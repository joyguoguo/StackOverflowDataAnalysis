<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stack Overflow Java Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            color-scheme: light;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f6f8;
            color: #1c1c1c;
        }
        .container {
            max-width: 1100px;
            margin: 0 auto;
        }
        header {
            text-align: center;
            margin-bottom: 24px;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 32px;
        }
        .stat-card {
            background: white;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        .stat-card .label {
            display: block;
            font-size: 0.9rem;
            color: #6b7280;
        }
        .stat-card .value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #111827;
        }
        .panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .panel-header {
            display: flex;
            justify-content: space-between;
            gap: 16px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 12px;
        }
        .panel-header h2 {
            margin: 0;
        }
        select, input[type="number"], input[type="date"], button {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            font-size: 0.95rem;
        }
        button {
            background: #2563eb;
            border: none;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background: #1d4ed8;
        }
        .boxplot-tooltip {
            position: absolute;
            pointer-events: none;
            background: rgba(17,24,39,0.9);
            color: #f9fafb;
            padding: 8px 10px;
            border-radius: 6px;
            font-size: 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.25);
            z-index: 20;
            max-width: 260px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
<div class="container">
    <header>
        <h1>Stack Overflow Java Q&amp;A 分析面板</h1>
        <p>基于本地离线数据集的趋势、共现、多线程痛点与可解性洞察</p>
    </header>

    <section class="stats" id="metaSection">
        <div class="stat-card">
            <span class="label">线程数</span>
            <span class="value" id="threadCount">-</span>
        </div>
        <div class="stat-card">
            <span class="label">回答数</span>
            <span class="value" id="answerCount">-</span>
        </div>
        <div class="stat-card">
            <span class="label">评论数</span>
            <span class="value" id="commentCount">-</span>
        </div>
        <div class="stat-card">
            <span class="label">数据区间</span>
            <span class="value" id="dataRange">-</span>
        </div>
    </section>

    <section class="panel">
        <div class="panel-header">
            <div>
                <h2>Topic Trends</h2>
                <p>显示帖子数量前 N 的标签在等时长时间窗口内的趋势</p>
            </div>
            <div>
                <label for="trendTopN">Top N 标签：</label>
                <input id="trendTopN" type="number" min="3" max="20" value="8" style="width: 60px;">
                <label for="metricSelect" style="margin-left: 15px;">指标：</label>
                <select id="metricSelect">
                    <option value="QUESTIONS">发帖量</option>
                    <option value="ANSWERS">回答数</option>
                    <option value="SCORE">得分</option>
                    <option value="ENGAGEMENT">浏览量</option>
                </select>
                <button id="refreshTrends" style="margin-left: 10px;">刷新</button>
            </div>
        </div>
        <canvas id="topicTrendChart"></canvas>
    </section>

    <section class="panel">
        <div class="panel-header">
            <div>
                <h2>Topic Co-occurrence话题共现</h2>
                <p>力导向图展示话题共现关系：节点代表话题，边代表共现对，边的粗细代表共现频率</p>
            </div>
            <div>
                <label for="cooccurrenceSelect">Top N:</label>
                <input id="cooccurrenceSelect" type="number" min="3" max="50" value="10">
                <label for="filterCoreTopics" style="margin-left: 15px;">
                    <input type="checkbox" id="filterCoreTopics"> 只显示核心话题
                </label>
                <button id="refreshPairs" style="margin-left: 10px;">刷新</button>
            </div>
        </div>
        <div id="forceGraphContainer" style="width: 100%; height: 800px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff; overflow: visible; margin-bottom: 20px;"></div>
        <canvas id="cooccurrenceChart" style="max-height: 400px;"></canvas>
    </section>

    <section class="panel">
        <div class="panel-header">
            <div>
                <h2>Multithreading Common Pitfalls</h2>
                <p>Identify and categorize multithreading-related issues based on tags, titles, body text, and code snippets</p>
            </div>
            <div>
                <label for="pitfallSelect">Top N Categories:</label>
                <input id="pitfallSelect" type="number" min="1" max="9" value="5" title="Number of top categories to display (1-9)">
                <button id="refreshPitfalls">Refresh</button>
            </div>
        </div>
        <canvas id="pitfallChart" style="max-height: 500px;"></canvas>
    </section>

    <section class="panel">
        <div class="panel-header">
            <div>
                <h2>可解性特征对比</h2>
                <p>比较容易解决 vs 难以解决问题在多个特征上的差异</p>
            </div>
            <div class="date-range">
                <label for="fromDate">From</label>
                <input type="date" id="fromDate">
                <label for="toDate">To</label>
                <input type="date" id="toDate">
                <button id="refreshSolvability">应用</button>
    </div>
    </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">分组柱状图（百分比和比例数据）</h3>
            <canvas id="solvabilityBarChart"></canvas>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">箱形图（连续数据分布）</h3>
            <canvas id="solvabilityBoxChart" style="max-height: 400px;"></canvas>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">标签频率对比（前10个标签，排除java）</h3>
            <canvas id="tagFrequencyChart"></canvas>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">问题评论频率对比</h3>
            <canvas id="commentFrequencyChart"></canvas>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">代码片段比率分布</h3>
            <canvas id="codeSnippetRatioChart"></canvas>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">标签数分布</h3>
            <canvas id="tagCountChart"></canvas>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">问题长度分布</h3>
            <canvas id="questionLengthChart"></canvas>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">提问者声誉分布 (log10变换)</h3>
            <canvas id="reputationChart"></canvas>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">提问者声誉分布箱线图 (log10变换)</h3>
            <div id="reputationBoxPlotContainer" style="position: relative; width: 100%; height: 400px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff;"></div>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">标题词数分布箱线图</h3>
            <div id="titleWordsBoxPlotContainer" style="position: relative; width: 100%; height: 400px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff;"></div>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">代码片段占比分布箱线图</h3>
            <div id="codeRatioBoxPlotContainer" style="position: relative; width: 100%; height: 400px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff;"></div>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">浏览量分布箱线图</h3>
            <div id="viewCountBoxPlotContainer" style="position: relative; width: 100%; height: 400px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff;"></div>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">提问者声誉分布小提琴图 (log10变换)</h3>
            <div id="reputationViolinContainer" style="position: relative; width: 100%; height: 400px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff;"></div>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">标题词数分布小提琴图</h3>
            <div id="titleWordsViolinContainer" style="position: relative; width: 100%; height: 400px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff;"></div>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">代码片段占比分布小提琴图</h3>
            <div id="codeRatioViolinContainer" style="position: relative; width: 100%; height: 400px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff;"></div>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">浏览量分布小提琴图</h3>
            <div id="viewCountViolinContainer" style="position: relative; width: 100%; height: 400px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff;"></div>
        </div>
        <div>
            <h3 style="margin-bottom: 12px;">评论数量分布</h3>
            <canvas id="commentCountChart"></canvas>
        </div>
    </section>
</div>

<script>
    const charts = {};

    document.addEventListener('DOMContentLoaded', () => {
        loadMetadata();
        initTopicTrendChart();
        initCooccurrenceChart();
        initPitfallChart();
        initSolvabilityChart();
    });

    async function fetchJson(url) {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`请求失败：${response.status}`);
        }
        return response.json();
    }

    async function loadMetadata() {
        const payload = await fetchJson('/api/metadata/status');
        const meta = payload.data;
        document.getElementById('threadCount').innerText = meta.threadCount;
        document.getElementById('answerCount').innerText = meta.answerCount;
        document.getElementById('commentCount').innerText = meta.commentCount;
        document.getElementById('dataRange').innerText = `${meta.earliestQuestion ?? '-'} ~ ${meta.latestQuestion ?? '-'}`;
    }

    function initTopicTrendChart() {
        const ctx = document.getElementById('topicTrendChart').getContext('2d');
        charts.topicTrends = new Chart(ctx, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                responsive: true,
                interaction: { mode: 'index', intersect: false },
                plugins: { legend: { position: 'bottom' } }
            }
        });
        document.getElementById('metricSelect').addEventListener('change', loadTopicTrends);
        document.getElementById('refreshTrends').addEventListener('click', loadTopicTrends);
        loadTopicTrends();
    }

    async function loadTopicTrends() {
        const metric = document.getElementById('metricSelect').value;
        const topN = document.getElementById('trendTopN').value;
        const payload = await fetchJson(`/api/topic-trends?metric=${metric}&topN=${topN}`);
        const data = payload.data;
        const labels = [...new Set(data.series.flatMap(series => series.points.map(p => p.bucket)))].sort();
        const colorPalette = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#7E57C2', '#26A69A'];
        const datasets = data.series.map((series, index) => ({
            label: series.topic,
            data: labels.map(label => {
                const point = series.points.find(p => p.bucket === label);
                return point ? point.value : 0;
            }),
            borderColor: colorPalette[index % colorPalette.length],
            tension: 0.3,
            fill: false
        }));
        charts.topicTrends.data.labels = labels;
        charts.topicTrends.data.datasets = datasets;
        charts.topicTrends.update();
    }

    let forceGraphSimulation = null;

    function initCooccurrenceChart() {
        // 初始化柱状图
        const ctx = document.getElementById('cooccurrenceChart').getContext('2d');
        charts.cooccurrence = new Chart(ctx, {
            type: 'bar',
            data: { labels: [], datasets: [{ label: '共现次数', data: [], backgroundColor: '#36A2EB' }] },
            options: { 
                responsive: true, 
                maintainAspectRatio: true,
                plugins: { 
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return '共现次数: ' + context.parsed.y;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '共现频率'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '话题对'
                        }
                    }
                }
            }
        });
        
        document.getElementById('refreshPairs').addEventListener('click', loadCooccurrence);
        document.getElementById('cooccurrenceSelect').addEventListener('change', loadCooccurrence);
        document.getElementById('filterCoreTopics').addEventListener('change', loadCooccurrence);
        loadCooccurrence();
    }

    async function loadCooccurrence() {
        const topN = document.getElementById('cooccurrenceSelect').value;
        const filterCoreTopics = document.getElementById('filterCoreTopics').checked;
        const url = `/api/cooccurrence?topN=${topN}&filterCoreTopics=${filterCoreTopics}`;
        const payload = await fetchJson(url);
        
        // 渲染力导向图
        renderForceDirectedGraph(payload.data.pairs);
        
        // 更新柱状图
        const labels = payload.data.pairs.map(pair => pair.topic_pair.join(' & '));
        const data = payload.data.pairs.map(pair => pair.frequency);
        charts.cooccurrence.data.labels = labels;
        charts.cooccurrence.data.datasets[0].data = data;
        charts.cooccurrence.update();
    }

    function renderForceDirectedGraph(pairs) {
        const container = document.getElementById('forceGraphContainer');
        container.innerHTML = '';
        
        if (!pairs || pairs.length === 0) {
            container.innerHTML = '<p style="text-align: center; padding: 50px; color: #6b7280;">暂无数据</p>';
            return;
        }

        // 停止之前的模拟（如果存在）
        if (forceGraphSimulation) {
            forceGraphSimulation.stop();
        }

        const width = container.clientWidth;
        const height = 800;  // 增加高度，避免节点跑到外面

        // 收集所有唯一的节点（话题）
        const nodeMap = new Map();
        pairs.forEach(pair => {
            pair.topic_pair.forEach(topic => {
                if (!nodeMap.has(topic)) {
                    nodeMap.set(topic, { id: topic, name: topic });
                }
            });
        });

        const nodes = Array.from(nodeMap.values());
        const nodeByIdMap = new Map(nodes.map(n => [n.id, n]));

        // 创建链接（边）数组，使用节点 ID 字符串（d3.forceLink 会自动转换为节点对象）
        const links = pairs.map(pair => ({
            source: pair.topic_pair[0],  // 使用 ID 字符串，d3.forceLink().id() 会转换为节点对象
            target: pair.topic_pair[1],
            frequency: pair.frequency
        }));

        // 计算频率范围，用于设置边的粗细
        const frequencies = links.map(l => l.frequency);
        const minFreq = Math.min(...frequencies);
        const maxFreq = Math.max(...frequencies);
        const freqRange = maxFreq - minFreq;

        // 创建 SVG，使用更大的尺寸并允许溢出
        const svg = d3.select(container)
            .append('svg')
            .attr('width', width)
            .attr('height', height)
            .style('overflow', 'visible');
        
        // 添加定义，用于文本背景
        const defs = svg.append('defs');
        
        // 添加文本背景的过滤器（用于更好的可读性）
        const filter = defs.append('filter')
            .attr('id', 'text-background')
            .attr('x', '-50%')
            .attr('y', '-50%')
            .attr('width', '200%')
            .attr('height', '200%');
        
        filter.append('feFlood')
            .attr('flood-color', 'white')
            .attr('flood-opacity', '0.8')
            .attr('result', 'bg');
        
        filter.append('feComposite')
            .attr('in', 'bg')
            .attr('in2', 'SourceAlpha')
            .attr('operator', 'in');

        // 创建力导向图模拟
        // 注意：distance 函数中的参数是 link，频率越高，距离越近
        // 同时减弱斥力、增加软性边界约束，避免节点飞出视野
        forceGraphSimulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(links)
                .id(d => d.id)
                .distance(d => {
                    // 频率越高，距离越近（但保持最小距离）
                    return Math.max(40, 220 - (d.frequency / maxFreq) * 140);
                })
                .strength(0.4))
            .force('charge', d3.forceManyBody()
                .strength(-45)          // 斥力绝对值调小，避免节点飞得太远
                .distanceMax(260))      // 超过该距离斥力变弱，有利于整体收拢
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(14));  // 稍微加大碰撞半径，减少重叠

        // 绘制链接（边）
        const link = svg.append('g')
            .selectAll('line')
            .data(links)
            .enter().append('line')
            .attr('stroke', '#999')
            .attr('stroke-opacity', 0.6)
            .attr('stroke-width', d => {
                // 边的粗细映射到频率：最小2px，最大10px
                const thickness = 2 + (d.frequency - minFreq) / freqRange * 8;
                return Math.max(2, Math.min(10, thickness));
            });

        // 绘制节点
        const node = svg.append('g')
            .selectAll('circle')
            .data(nodes)
            .enter().append('circle')
            .attr('r', 12)
            .attr('fill', '#2563eb')
            .attr('stroke', '#fff')
            .attr('stroke-width', 2)
            .call(drag(forceGraphSimulation));

        // 添加标签
        const label = svg.append('g')
            .selectAll('text')
            .data(nodes)
            .enter().append('text')
            .text(d => d.name)
            .attr('font-size', '12px')
            .attr('dx', 15)
            .attr('dy', 4)
            .attr('fill', '#1c1c1c')
            .style('pointer-events', 'none');

        // 添加悬停提示
        node.append('title')
            .text(d => d.name);

        // 在链接上添加悬停提示
        link.append('title')
            .text(d => {
                // d3.forceLink 会将 source/target 转换为节点对象
                const sourceName = typeof d.source === 'object' ? d.source.name : d.source;
                const targetName = typeof d.target === 'object' ? d.target.name : d.target;
                return `${sourceName} & ${targetName}: ${d.frequency} 次共现`;
            });
        
        // 在边的中间位置添加频率标签
        const linkLabel = svg.append('g')
            .selectAll('text')
            .data(links)
            .enter().append('text')
            .text(d => d.frequency)
            .attr('font-size', '10px')
            .attr('font-weight', 'bold')
            .attr('fill', '#000000')         // 黑色字体
            .attr('stroke', 'white')         // <--- 添加白色描边
            .attr('stroke-width', 2.5)       // <--- 设置描边宽度（增加对比度）
            .attr('paint-order', 'stroke')   // <--- 确保先绘制描边，再绘制填充
            .attr('text-anchor', 'middle')
            .style('pointer-events', 'none');       

        // 更新位置函数，增加边界约束，防止节点“出画”
        function ticked() {
            const margin = 30;

            function clampX(x) {
                return Math.max(margin, Math.min(width - margin, x));
            }

            function clampY(y) {
                return Math.max(margin, Math.min(height - margin, y));
            }

            link
                .attr('x1', d => clampX(d.source.x))
                .attr('y1', d => clampY(d.source.y))
                .attr('x2', d => clampX(d.target.x))
                .attr('y2', d => clampY(d.target.y));

            node
                .attr('cx', d => {
                    d.x = clampX(d.x);
                    return d.x;
                })
                .attr('cy', d => {
                    d.y = clampY(d.y);
                    return d.y;
                });

            label
                .attr('x', d => d.x)
                .attr('y', d => d.y);
            
            // 更新边的标签位置（在边的中点）
            linkLabel
                .attr('x', d => (clampX(d.source.x) + clampX(d.target.x)) / 2)
                .attr('y', d => (clampY(d.source.y) + clampY(d.target.y)) / 2);
        }

        // 启动模拟
        forceGraphSimulation.on('tick', ticked);

        // 拖拽函数
        function drag(simulation) {
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }

            return d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended);
        }
    }

    // 绘制通用箱线图（使用 D3），并带有更合理的纵轴缩放和悬浮信息
    function renderBoxPlot(containerId, boxData, yLabel, titleText) {
        const container = document.getElementById(containerId);
        container.innerHTML = '';

        if (!boxData || !boxData.solvable || !boxData.hard) {
            container.innerHTML = '<p style="text-align: center; padding: 40px; color: #6b7280;">暂无数据</p>';
            return;
        }

        const data = [
            { label: '易解决', stats: boxData.solvable },
            { label: '难解决', stats: boxData.hard }
        ];

        const margin = { top: 20, right: 20, bottom: 40, left: 60 };
        const width = container.clientWidth - margin.left - margin.right;
        const height = 360 - margin.top - margin.bottom;

        const allCoreValues = [
            ...data.flatMap(d => [d.stats.q1, d.stats.median, d.stats.q3])
        ];
        const globalQ1 = Math.min(...data.map(d => d.stats.q1));
        const globalQ3 = Math.max(...data.map(d => d.stats.q3));
        const iqrGlobal = globalQ3 - globalQ1;

        let yMin, yMax;
        if (iqrGlobal > 0) {
            // 以 IQR 为主进行缩放，减少极端值对坐标轴的“拉伸”
            const lower = globalQ1 - 0.5 * iqrGlobal;
            const upper = globalQ3 + 1.5 * iqrGlobal;
            const minVal = Math.min(...data.map(d => d.stats.min));
            const maxVal = Math.max(...data.map(d => d.stats.max));
            yMin = Math.max(minVal, lower);
            yMax = Math.min(maxVal, upper);
        } else {
            // 当 IQR 很小或为 0 时，退化为简单 min/max + padding
            const rawMin = Math.min(...data.map(d => d.stats.min));
            const rawMax = Math.max(...data.map(d => d.stats.max));
            const pad = (rawMax - rawMin) * 0.1 || 10;
            yMin = rawMin - pad;
            yMax = rawMax + pad;
        }

        if (!Number.isFinite(yMin) || !Number.isFinite(yMax)) {
            yMin = 0;
            yMax = 1;
        }

        const svg = d3.select(container)
            .append('svg')
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom)
            .append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);

        const x = d3.scaleBand()
            .domain(data.map(d => d.label))
            .range([0, width])
            .paddingInner(0.4)
            .paddingOuter(0.2);

        const y = d3.scaleLinear()
            .domain([yMin, yMax])
            .range([height, 0]);

        // 轴
        svg.append('g')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(x));

        svg.append('g')
            .call(d3.axisLeft(y));
        
        // 添加Y轴标题
        svg.append('text')
            .attr('transform', 'rotate(-90)')
            .attr('y', 0 - margin.left)
            .attr('x', 0 - (height / 2))
            .attr('dy', '1em')
            .style('text-anchor', 'middle')
            .style('font-size', '12px')
            .text(yLabel || '');
        
        // 添加X轴标题
        svg.append('text')
            .attr('transform', `translate(${width / 2}, ${height + margin.bottom - 5})`)
            .style('text-anchor', 'middle')
            .style('font-size', '12px')
            .text('问题类型');

        const boxWidth = x.bandwidth();

        // 绘制箱线图
        data.forEach(d => {
            const cx = x(d.label) + boxWidth / 2;
            const { min, q1, median, q3, max, outliers } = d.stats;
            
            // 计算IQR和异常值边界
            const iqr = q3 - q1;
            const lowerBound = q1 - 1.5*iqr;
            const upperBound = q3 + 1.5*iqr;
            
            // 计算非异常值的最小值和最大值（用于绘制须线）
            // 下须：延伸到所有非异常值中的最小值
            // 如果min是异常值，则延伸到lowerBound；否则延伸到min
            const outlierSet = new Set((outliers || []).map(v => Math.round(v * 100) / 100));
            const isMinOutlier = outlierSet.has(Math.round(min * 100) / 100);
            const lowerWhisker = isMinOutlier ? Math.max(lowerBound, 0) : min;
            
            // 上须：延伸到所有非异常值中的最大值
            // 如果max是异常值，则延伸到upperBound；否则延伸到max
            const isMaxOutlier = outlierSet.has(Math.round(max * 100) / 100);
            const upperWhisker = isMaxOutlier ? Math.min(upperBound, max) : max;
            
            // 确保lowerWhisker <= q1 和 upperWhisker >= q3
            const finalLowerWhisker = Math.min(lowerWhisker, q1);
            const finalUpperWhisker = Math.max(upperWhisker, q3);
            
            // 绘制箱体 (Q1到Q3) - 先绘制箱体，这样其他元素会在上面
            const boxHeight = Math.max(1, y(q1) - y(q3));
            svg.append('rect')
                .attr('x', x(d.label))
                .attr('y', y(q3))
                .attr('width', boxWidth)
                .attr('height', boxHeight)
                .attr('fill', d.label === '易解决' ? 'rgba(75, 192, 192, 0.4)' : 'rgba(233, 30, 99, 0.4)')
                .attr('stroke', d.label === '易解决' ? '#4BC0C0' : '#E91E63')
                .attr('stroke-width', 1.5);
            
            // 绘制中位数线（横穿箱体）
            svg.append('line')
                .attr('x1', x(d.label))
                .attr('x2', x(d.label) + boxWidth)
                .attr('y1', y(median))
                .attr('y2', y(median))
                .attr('stroke', '#111827')
                .attr('stroke-width', 2);
            
            // 绘制下须（从Q1到finalLowerWhisker）
            svg.append('line')
                .attr('x1', cx)
                .attr('x2', cx)
                .attr('y1', y(q1))
                .attr('y2', y(finalLowerWhisker))
                .attr('stroke', '#374151')
                .attr('stroke-width', 1.5);
            
            // 绘制上须（从Q3到finalUpperWhisker）
            svg.append('line')
                .attr('x1', cx)
                .attr('x2', cx)
                .attr('y1', y(q3))
                .attr('y2', y(finalUpperWhisker))
                .attr('stroke', '#374151')
                .attr('stroke-width', 1.5);
            
            // 绘制下须端点（横线）
            svg.append('line')
                .attr('x1', cx - boxWidth * 0.2)
                .attr('x2', cx + boxWidth * 0.2)
                .attr('y1', y(finalLowerWhisker))
                .attr('y2', y(finalLowerWhisker))
                .attr('stroke', '#374151')
                .attr('stroke-width', 1.5);
            
            // 绘制上须端点（横线）
            svg.append('line')
                .attr('x1', cx - boxWidth * 0.2)
                .attr('x2', cx + boxWidth * 0.2)
                .attr('y1', y(finalUpperWhisker))
                .attr('y2', y(finalUpperWhisker))
                .attr('stroke', '#374151')
                .attr('stroke-width', 1.5);
            
            // 绘制异常值点
            (outliers || []).forEach(v => {
                svg.append('circle')
                    .attr('cx', cx)
                    .attr('cy', y(v))
                    .attr('r', 4)
                    .attr('fill', d.label === '易解决' ? '#4BC0C0' : '#E91E63')
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 1.5)
                    .attr('opacity', 0.8)
                    .append('title')
                    .text(`异常值: ${v.toFixed(0)}`);
            });

            // 为箱体添加悬浮提示，展示完整统计信息
            const sampleCount = d.stats.sample_count ?? 0;
            const outlierList = outliers || [];
            const outlierCount = outlierList.length;
            const outlierFreqMap = {};
            outlierList.forEach(v => {
                const key = v.toFixed(2);
                outlierFreqMap[key] = (outlierFreqMap[key] || 0) + 1;
            });
            const sortedOutliers = Object.entries(outlierFreqMap)
                .sort((a, b) => parseFloat(b[0]) - parseFloat(a[0]))
                .slice(0, 5);

            const tooltipBox = svg.append('rect')
                .attr('x', x(d.label))
                .attr('y', y(q3))
                .attr('width', boxWidth)
                .attr('height', boxHeight)
                .attr('fill', 'transparent')
                .style('cursor', 'pointer');

            let tooltipDiv = null;
            tooltipBox
                .on('mouseover', (event) => {
                    if (!tooltipDiv) {
                        tooltipDiv = d3.select(container)
                            .append('div')
                            .attr('class', 'boxplot-tooltip');
                    }
                    const detailsLines = sortedOutliers.map(
                        ([val, cnt]) => `${val} (${cnt} 次)`
                    );
                    const html = `
                        <div><strong>${d.label}</strong></div>
                        <div>样本数：${sampleCount}</div>
                        <div>最小值：${min.toFixed(2)}</div>
                        <div>Q1：${q1.toFixed(2)}</div>
                        <div>中位数：${median.toFixed(2)}</div>
                        <div>Q3：${q3.toFixed(2)}</div>
                        <div>最大值：${max.toFixed(2)}</div>
                        <div>异常值数量：${outlierCount}</div>
                        ${detailsLines.length ? `<div>部分异常值：<br>${detailsLines.join('<br>')}</div>` : ''}
                    `;
                    tooltipDiv.html(html)
                        .style('display', 'block');
                })
                .on('mousemove', (event) => {
                    if (!tooltipDiv) return;
                    const rect = container.getBoundingClientRect();
                    const offsetX = event.clientX - rect.left;
                    const offsetY = event.clientY - rect.top;
                    tooltipDiv
                        .style('left', `${offsetX + 12}px`)
                        .style('top', `${offsetY + 12}px`);
                })
                .on('mouseout', () => {
                    if (tooltipDiv) {
                        tooltipDiv.remove();
                        tooltipDiv = null;
                    }
                });
        });

        // 添加标题
        svg.append('text')
            .attr('x', width / 2)
            .attr('y', -6)
            .attr('text-anchor', 'middle')
            .attr('fill', '#111827')
            .attr('font-size', '14px')
            .text(titleText || '');
    }

    let sunburstData = null;

    // 通用小提琴图绘制：上下对称，左侧为易解决，右侧为难解决，并在内部叠加对比箱线
    // statsData 对应后端的 BoxPlotData，用于在 tooltip 中补充整体统计信息
    function renderViolinPlot(containerId, distributionData, statsData, xLabel, titleText) {
        const container = document.getElementById(containerId);
        container.innerHTML = '';

        if (!distributionData || !distributionData.bins || distributionData.bins.length === 0) {
            container.innerHTML = '<p style="text-align: center; padding: 40px; color: #6b7280;">暂无数据</p>';
            return;
        }

        const bins = distributionData.bins;
        const solvableFreq = distributionData.solvable_frequencies || [];
        const hardFreq = distributionData.hard_frequencies || [];

        const margin = { top: 24, right: 24, bottom: 40, left: 80 };
        const width = container.clientWidth - margin.left - margin.right;
        const height = 360 - margin.top - margin.bottom;

        const maxFreq = Math.max(
            1,
            ...solvableFreq,
            ...hardFreq
        );

        const svg = d3.select(container)
            .append('svg')
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom)
            .append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);

        const y = d3.scaleBand()
            .domain(bins)
            .range([height, 0])
            .padding(0.15);

        const x = d3.scaleLinear()
            .domain([-maxFreq, maxFreq])
            .range([0, width]);

        svg.append('g')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(x).ticks(5).tickFormat(d => Math.abs(d)));

        svg.append('g')
            .call(d3.axisLeft(y));

        svg.append('text')
            .attr('x', width / 2)
            .attr('y', -6)
            .attr('text-anchor', 'middle')
            .attr('fill', '#111827')
            .attr('font-size', '14px')
            .text(titleText || '');

        svg.append('text')
            .attr('x', width / 2)
            .attr('y', height + margin.bottom - 6)
            .attr('text-anchor', 'middle')
            .attr('font-size', '12px')
            .text(xLabel || '频率 (%)');

        const centerX = x(0);
        svg.append('line')
            .attr('x1', centerX)
            .attr('x2', centerX)
            .attr('y1', 0)
            .attr('y2', height)
            .attr('stroke', '#9ca3af')
            .attr('stroke-width', 1)
            .attr('stroke-dasharray', '4,4');

        function buildHalfViolin(freqArray, side) {
            const points = [];
            bins.forEach((bin, idx) => {
                const f = freqArray[idx] || 0;
                const yCenter = y(bin) + y.bandwidth() / 2;
                const offset = x(side === 'left' ? -f : f);
                points.push([offset, yCenter]);
            });

            // 注意：不能使用 [[...]] 这种字面量，否则会被 Thymeleaf 解析为内联表达式
            const result = [];
            const firstY = y(bins[0]) + y.bandwidth() / 2;
            const lastY = y(bins[bins.length - 1]) + y.bandwidth() / 2;

            result.push([centerX, firstY]);
            points.forEach(p => result.push(p));
            result.push([centerX, lastY]);

            return result;
        }

        // 通过频率分布近似计算对应组在各分位点上的 y 位置（用于在小提琴内部画箱线）
        function buildBoxPositions(freqArray) {
            const total = freqArray.reduce((acc, v) => acc + (v || 0), 0);
            if (total <= 0) {
                return null;
            }

            // 计算最小/最大（第一个和最后一个有频率的区间）
            let minBinIndex = null;
            let maxBinIndex = null;
            freqArray.forEach((v, idx) => {
                if ((v || 0) > 0) {
                    if (minBinIndex === null) {
                        minBinIndex = idx;
                    }
                    maxBinIndex = idx;
                }
            });
            if (minBinIndex === null || maxBinIndex === null) {
                return null;
            }

            function findQuantileY(q) {
                const target = q * total;
                let cum = 0;
                for (let i = 0; i < freqArray.length; i++) {
                    cum += (freqArray[i] || 0);
                    if (cum >= target) {
                        const bin = bins[i];
                        return y(bin) + y.bandwidth() / 2;
                    }
                }
                const lastBin = bins[bins.length - 1];
                return y(lastBin) + y.bandwidth() / 2;
            }

            const minBin = bins[minBinIndex];
            const maxBin = bins[maxBinIndex];

            return {
                minY: y(minBin) + y.bandwidth() / 2,
                q1Y: findQuantileY(0.25),
                medianY: findQuantileY(0.5),
                q3Y: findQuantileY(0.75),
                maxY: y(maxBin) + y.bandwidth() / 2
            };
        }

        const solvablePath = d3.path();
        const leftPoints = buildHalfViolin(solvableFreq, 'left');
        leftPoints.forEach((p, i) => {
            if (i === 0) solvablePath.moveTo(p[0], p[1]);
            else solvablePath.lineTo(p[0], p[1]);
        });

        const hardPath = d3.path();
        const rightPoints = buildHalfViolin(hardFreq, 'right');
        rightPoints.forEach((p, i) => {
            if (i === 0) hardPath.moveTo(p[0], p[1]);
            else hardPath.lineTo(p[0], p[1]);
        });

        svg.append('path')
            .attr('d', solvablePath.toString())
            .attr('fill', 'rgba(75, 192, 192, 0.45)')
            .attr('stroke', '#4BC0C0')
            .attr('stroke-width', 1.5);

        svg.append('path')
            .attr('d', hardPath.toString())
            .attr('fill', 'rgba(233, 30, 99, 0.45)')
            .attr('stroke', '#E91E63')
            .attr('stroke-width', 1.5);

        // 在小提琴内部叠加对比箱线（左右各一套）
        const solvBoxPos = buildBoxPositions(solvableFreq);
        const hardBoxPos = buildBoxPositions(hardFreq);
        const violinFullWidth = x(maxFreq) - x(-maxFreq);
        const boxHalfWidth = Math.max(4, violinFullWidth * 0.025);
        // 让两类箱线紧靠轴线，对称分布：只做一个很小的左右偏移
        const boxOffset = boxHalfWidth * 1.4;

        if (solvBoxPos) {
            const boxX = centerX - boxOffset;
            const boxRectY = Math.min(solvBoxPos.q1Y, solvBoxPos.q3Y);
            const boxRectH = Math.max(1, Math.abs(solvBoxPos.q1Y - solvBoxPos.q3Y));

            // 竖线（须）
            svg.append('line')
                .attr('x1', boxX)
                .attr('x2', boxX)
                .attr('y1', solvBoxPos.minY)
                .attr('y2', solvBoxPos.maxY)
                .attr('stroke', '#0f766e')
                .attr('stroke-width', 1.2);

            // 箱体
            svg.append('rect')
                .attr('x', boxX - boxHalfWidth)
                .attr('y', boxRectY)
                .attr('width', boxHalfWidth * 2)
                .attr('height', boxRectH)
                .attr('fill', 'rgba(16, 185, 129, 0.8)')
                .attr('stroke', '#064e3b')
                .attr('stroke-width', 1.2);

            // 中位数线
            svg.append('line')
                .attr('x1', boxX - boxHalfWidth)
                .attr('x2', boxX + boxHalfWidth)
                .attr('y1', solvBoxPos.medianY)
                .attr('y2', solvBoxPos.medianY)
                .attr('stroke', '#022c22')
                .attr('stroke-width', 1.6);
        }

        if (hardBoxPos) {
            const boxX = centerX + boxOffset;
            const boxRectY = Math.min(hardBoxPos.q1Y, hardBoxPos.q3Y);
            const boxRectH = Math.max(1, Math.abs(hardBoxPos.q1Y - hardBoxPos.q3Y));

            svg.append('line')
                .attr('x1', boxX)
                .attr('x2', boxX)
                .attr('y1', hardBoxPos.minY)
                .attr('y2', hardBoxPos.maxY)
                .attr('stroke', '#9f1239')
                .attr('stroke-width', 1.2);

            svg.append('rect')
                .attr('x', boxX - boxHalfWidth)
                .attr('y', boxRectY)
                .attr('width', boxHalfWidth * 2)
                .attr('height', boxRectH)
                .attr('fill', 'rgba(244, 63, 94, 0.8)')
                .attr('stroke', '#881337')
                .attr('stroke-width', 1.2);

            svg.append('line')
                .attr('x1', boxX - boxHalfWidth)
                .attr('x2', boxX + boxHalfWidth)
                .attr('y1', hardBoxPos.medianY)
                .attr('y2', hardBoxPos.medianY)
                .attr('stroke', '#450a0a')
                .attr('stroke-width', 1.6);
        }

        const legend = svg.append('g')
            .attr('transform', `translate(${width - 140}, 0)`);
        legend.append('rect')
            .attr('x', 0)
            .attr('y', 0)
            .attr('width', 12)
            .attr('height', 12)
            .attr('fill', 'rgba(75, 192, 192, 0.8)');
        legend.append('text')
            .attr('x', 18)
            .attr('y', 10)
            .attr('font-size', '12px')
            .text('易解决');
        legend.append('rect')
            .attr('x', 0)
            .attr('y', 18)
            .attr('width', 12)
            .attr('height', 12)
            .attr('fill', 'rgba(233, 30, 99, 0.8)');
        legend.append('text')
            .attr('x', 18)
            .attr('y', 28)
            .attr('font-size', '12px')
            .text('难解决');

        bins.forEach((bin, idx) => {
            const bandTop = y(bin);
            const rectBand = svg.append('rect')
                .attr('x', x(-maxFreq))
                .attr('y', bandTop)
                .attr('width', x(maxFreq) - x(-maxFreq))
                .attr('height', y.bandwidth())
                .attr('fill', 'transparent');

            let tooltipDiv = null;
            rectBand
                .on('mouseover', (event) => {
                    if (!tooltipDiv) {
                        tooltipDiv = d3.select(container)
                            .append('div')
                            .attr('class', 'boxplot-tooltip');
                    }
                    const s = solvableFreq[idx] || 0;
                    const h = hardFreq[idx] || 0;
                    let html = `
                        <div><strong>区间：${bin}</strong></div>
                        <div>易解决频率：${s.toFixed(2)} %</div>
                        <div>难解决频率：${h.toFixed(2)} %</div>
                    `;

                    // 如果提供了整体箱线统计，则在同一个 tooltip 中附加总体信息
                    if (statsData && statsData.solvable && statsData.hard) {
                        const sStats = statsData.solvable;
                        const hStats = statsData.hard;
                        html += `
                            <hr style="border:none; border-top:1px solid rgba(156,163,175,0.6); margin:6px 0;" />
                            <div><strong>易解决整体统计</strong></div>
                            <div>样本数：${sStats.sample_count ?? 0}</div>
                            <div>最小值：${sStats.min.toFixed(2)}</div>
                            <div>Q1：${sStats.q1.toFixed(2)}</div>
                            <div>中位数：${sStats.median.toFixed(2)}</div>
                            <div>Q3：${sStats.q3.toFixed(2)}</div>
                            <div>最大值：${sStats.max.toFixed(2)}</div>
                            <div style="margin-top:4px;"><strong>难解决整体统计</strong></div>
                            <div>样本数：${hStats.sample_count ?? 0}</div>
                            <div>最小值：${hStats.min.toFixed(2)}</div>
                            <div>Q1：${hStats.q1.toFixed(2)}</div>
                            <div>中位数：${hStats.median.toFixed(2)}</div>
                            <div>Q3：${hStats.q3.toFixed(2)}</div>
                            <div>最大值：${hStats.max.toFixed(2)}</div>
                        `;
                    }

                    tooltipDiv.html(html)
                        .style('display', 'block');
                })
                .on('mousemove', (event) => {
                    if (!tooltipDiv) return;
                    const rect = container.getBoundingClientRect();
                    const offsetX = event.clientX - rect.left;
                    const offsetY = event.clientY - rect.top;
                    tooltipDiv
                        .style('left', `${offsetX + 12}px`)
                        .style('top', `${offsetY + 12}px`);
                })
                .on('mouseout', () => {
                    if (tooltipDiv) {
                        tooltipDiv.remove();
                        tooltipDiv = null;
                    }
                });
        });
    }

    function initPitfallChart() {
        const ctx = document.getElementById('pitfallChart').getContext('2d');
        charts.pitfall = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [{
                    label: 'Number of Questions',
                    data: [],
                    backgroundColor: '#FF9F40'
                }]
            },
            options: {
                indexAxis: 'y',
                responsive: true,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return 'Count: ' + context.parsed.x;
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        beginAtZero: true,
                        title: { display: true, text: 'Question Count' }
                    },
                    y: {
                        title: { display: true, text: 'Pitfall Category' }
                    }
                }
            }
        });

        document.getElementById('refreshPitfalls').addEventListener('click', loadPitfalls);
        document.getElementById('pitfallSelect').addEventListener('change', loadPitfalls);
        loadPitfalls();
    }

    async function loadPitfalls() {
        let topN = parseInt(document.getElementById('pitfallSelect').value || '5', 10);
        if (Number.isNaN(topN)) {
            topN = 5;
        }
        topN = Math.max(1, Math.min(9, topN));
        document.getElementById('pitfallSelect').value = topN;

        const payload = await fetchJson(`/api/multithreading/pitfalls?topN=${topN}`);
        const pitfalls = payload.data.pitfalls || [];

        const labels = pitfalls.map(p => `${p.code}: ${p.label}`);
        const data = pitfalls.map(p => p.count);

        charts.pitfall.data.labels = labels;
        charts.pitfall.data.datasets[0].data = data;
        charts.pitfall.update();
    }

    function renderSunburstChart(data) {
        const container = document.getElementById('sunburstContainer');
        container.innerHTML = '';
        
        if (!data || !data.categories || data.categories.length === 0) {
            container.innerHTML = '<p style="text-align: center; padding: 50px; color: #6b7280;">No data available</p>';
            return;
        }

        const width = container.clientWidth;
        const height = 600;
        const radius = Math.min(width, height) / 2 - 10;

        // Create SVG
        const svg = d3.select(container)
            .append('svg')
            .attr('width', width)
            .attr('height', height)
            .append('g')
            .attr('transform', `translate(${width / 2},${height / 2})`);

        // Color scheme for categories
        const categoryColors = {
            'Synchronization Issues': '#FF6384',
            'Memory Consistency': '#36A2EB',
            'Concurrent Data Structures': '#FFCE56',
            'Thread Pool & Executors': '#4BC0C0',
            'Performance Issues': '#9966FF',
            'Others': '#FF9F40'
        };

        // Build hierarchical data structure
        // Ensure inner ring value equals sum of outer ring values
        const root = {
            name: 'Multithreading Pitfalls',
            children: data.categories.map(category => {
                // Calculate actual sum from pitfalls
                const actualTotal = category.pitfalls.reduce((sum, p) => sum + p.count, 0);
                return {
                    name: category.category,
                    value: actualTotal, // Use actual sum instead of totalCount to ensure consistency
                    children: category.pitfalls.map(pitfall => ({
                        name: pitfall.label,
                        value: pitfall.count,
                        category: category.category
                    }))
                };
            })
        };

        // Create partition layout
        const partition = d3.partition()
            .size([2 * Math.PI, radius]);

        const rootNode = d3.hierarchy(root)
            .sum(d => d.value)
            .sort((a, b) => b.value - a.value);

        partition(rootNode);

        // Color function
        const color = d3.scaleOrdinal()
            .domain(Object.keys(categoryColors))
            .range(Object.values(categoryColors));

        // Create arcs
        const arc = d3.arc()
            .startAngle(d => d.x0)
            .endAngle(d => d.x1)
            .innerRadius(d => d.y0)
            .outerRadius(d => d.y1);

        // Draw arcs
        const arcs = svg.selectAll('path')
            .data(rootNode.descendants())
            .enter()
            .append('path')
            .attr('d', arc)
            .attr('fill', d => {
                if (d.depth === 0) return '#f0f0f0';
                if (d.depth === 1) return color(d.data.name) || '#999';
                return d3.color(color(d.data.category) || '#999').brighter(0.5);
            })
            .attr('stroke', '#fff')
            .attr('stroke-width', 2)
            .style('cursor', 'pointer')
            .on('mouseover', function(event, d) {
                d3.select(this)
                    .attr('opacity', 0.8)
                    .attr('stroke-width', 3);
                
                // Show tooltip
                const tooltip = d3.select('body').append('div')
                    .attr('class', 'tooltip')
                    .style('opacity', 0)
                    .style('position', 'absolute')
                    .style('background', 'rgba(0, 0, 0, 0.8)')
                    .style('color', 'white')
                    .style('padding', '8px')
                    .style('border-radius', '4px')
                    .style('pointer-events', 'none')
                    .style('font-size', '12px');
                
                let label, count;
                if (d.depth === 1) {
                    // Category level
                    label = d.data.name;
                    count = d.value;
                } else {
                    // Pitfall level
                    label = `${d.data.category} - ${d.data.name}`;
                    count = d.value;
                }
                tooltip.html(`${label}<br/>Count: ${count}`)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px')
                    .transition()
                    .duration(200)
                    .style('opacity', 1);
            })
            .on('mousemove', function(event) {
                d3.select('.tooltip')
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            })
            .on('mouseout', function() {
                d3.select(this)
                    .attr('opacity', 1)
                    .attr('stroke-width', 2);
                d3.select('.tooltip').remove();
            });

        // Add labels for categories (inner ring) with better positioning
        svg.selectAll('text.category')
            .data(rootNode.children || [])
            .enter()
            .append('text')
            .attr('class', 'category')
            .attr('transform', d => {
                const angle = (d.x0 + d.x1) / 2;
                const radius = (d.y0 + d.y1) / 2;
                const x = Math.cos(angle - Math.PI / 2) * radius;
                const y = Math.sin(angle - Math.PI / 2) * radius;
                const rotation = angle * 180 / Math.PI;
                return `translate(${x},${y}) rotate(${rotation < 90 || rotation > 270 ? rotation : rotation + 180})`;
            })
            .attr('dy', '0.35em')
            .attr('text-anchor', 'middle')
            .attr('font-size', '13px')
            .attr('font-weight', 'bold')
            .attr('fill', '#333')
            .attr('stroke', '#fff')
            .attr('stroke-width', '0.3px')
            .attr('paint-order', 'stroke')
            .text(d => d.data.name)
            .style('pointer-events', 'none');

        // Add labels for pitfalls (outer ring) - only if space allows
        svg.selectAll('text.pitfall')
            .data(rootNode.descendants().filter(d => d.depth === 2 && d.value > 0))
            .enter()
            .append('text')
            .attr('class', 'pitfall')
            .attr('transform', d => {
                const x = ((d.x0 + d.x1) / 2) * 180 / Math.PI;
                const y = -(d.y0 + d.y1) / 2;
                return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
            })
            .attr('dy', '0.35em')
            .attr('text-anchor', d => (d.x0 + d.x1) / 2 < Math.PI ? 'start' : 'end')
            .attr('font-size', '10px')
            .attr('fill', '#666')
            .text(d => {
                // Only show label if arc is large enough
                const angle = (d.x1 - d.x0) * 180 / Math.PI;
                return angle > 10 ? d.data.name : '';
            })
            .style('pointer-events', 'none');
    }

    function initSolvabilityChart() {
        // 初始化分组柱状图
        const barCtx = document.getElementById('solvabilityBarChart').getContext('2d');
        charts.solvabilityBar = new Chart(barCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [
                    { 
                        label: '易解决', 
                        data: [], 
                        backgroundColor: 'rgba(75, 192, 192, 0.7)',
                        borderColor: '#4BC0C0',
                        borderWidth: 1
                    },
                    { 
                        label: '难解决', 
                        data: [], 
                        backgroundColor: 'rgba(233, 30, 99, 0.7)',
                        borderColor: '#E91E63',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.parsed.y;
                                const unit = context.dataset.unit || '';
                                return context.dataset.label + ': ' + value.toFixed(2) + ' ' + unit;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '值'
                        }
                    }
                }
            }
        });
        
        // 初始化箱形图（使用折线图模拟，显示平均值）
        const boxCtx = document.getElementById('solvabilityBoxChart').getContext('2d');
        charts.solvabilityBox = new Chart(boxCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [
                    { 
                        label: '易解决（平均值）', 
                        data: [], 
                        backgroundColor: 'rgba(75, 192, 192, 0.5)',
                        borderColor: '#4BC0C0',
                        borderWidth: 2
                    },
                    { 
                        label: '难解决（平均值）', 
                        data: [], 
                        backgroundColor: 'rgba(233, 30, 99, 0.5)',
                        borderColor: '#E91E63',
                        borderWidth: 2
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.parsed.y;
                                const unit = context.dataset.unit || '';
                                return context.dataset.label + ': ' + value.toFixed(2) + ' ' + unit;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '值'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '特征'
                        }
                    }
                }
            }
        });
        
        // 初始化标签频率折线图
        const tagFreqCtx = document.getElementById('tagFrequencyChart').getContext('2d');
        charts.tagFrequency = new Chart(tagFreqCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: '易解决',
                        data: [],
                        borderColor: '#4BC0C0',
                        backgroundColor: 'rgba(75, 192, 192, 0.1)',
                        tension: 0.3,
                        fill: false
                    },
                    {
                        label: '难解决',
                        data: [],
                        borderColor: '#E91E63',
                        backgroundColor: 'rgba(233, 30, 99, 0.1)',
                        tension: 0.3,
                        fill: false
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + context.parsed.y + ' 次';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '频次'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '标签'
                        }
                    }
                }
            }
        });
        
        // 初始化评论频率折线图
        const commentFreqCtx = document.getElementById('commentFrequencyChart').getContext('2d');
        charts.commentFrequency = new Chart(commentFreqCtx, {
            type: 'line',
            data: {
                labels: ['有评论', '无评论'],
                datasets: [
                    {
                        label: '易解决',
                        data: [0, 0],
                        borderColor: '#4BC0C0',
                        backgroundColor: 'rgba(75, 192, 192, 0.1)',
                        tension: 0.3,
                        fill: false
                    },
                    {
                        label: '难解决',
                        data: [0, 0],
                        borderColor: '#E91E63',
                        backgroundColor: 'rgba(233, 30, 99, 0.1)',
                        tension: 0.3,
                        fill: false
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + context.parsed.y + ' 个问题';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '问题数量'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '评论状态'
                        }
                    }
                }
            }
        });
        
        // 初始化代码片段比率分布图
        const codeSnippetRatioCtx = document.getElementById('codeSnippetRatioChart').getContext('2d');
        charts.codeSnippetRatio = new Chart(codeSnippetRatioCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [
                    {
                        label: '易解决',
                        data: [],
                        backgroundColor: 'rgba(75, 192, 192, 0.7)',
                        borderColor: '#4BC0C0',
                        borderWidth: 1
                    },
                    {
                        label: '难解决',
                        data: [],
                        backgroundColor: 'rgba(233, 30, 99, 0.7)',
                        borderColor: '#E91E63',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '%';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '频率 (%)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '代码片段比率'
                        }
                    }
                }
            }
        });
        
        // 初始化标签数分布图
        const tagCountCtx = document.getElementById('tagCountChart').getContext('2d');
        charts.tagCount = new Chart(tagCountCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [
                    {
                        label: '易解决',
                        data: [],
                        backgroundColor: 'rgba(75, 192, 192, 0.7)',
                        borderColor: '#4BC0C0',
                        borderWidth: 1
                    },
                    {
                        label: '难解决',
                        data: [],
                        backgroundColor: 'rgba(233, 30, 99, 0.7)',
                        borderColor: '#E91E63',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '%';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '频率 (%)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '标签数'
                        }
                    }
                }
            }
        });
        
        // 初始化问题长度分布图
        const questionLengthCtx = document.getElementById('questionLengthChart').getContext('2d');
        charts.questionLength = new Chart(questionLengthCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [
                    {
                        label: '易解决',
                        data: [],
                        backgroundColor: 'rgba(75, 192, 192, 0.7)',
                        borderColor: '#4BC0C0',
                        borderWidth: 1
                    },
                    {
                        label: '难解决',
                        data: [],
                        backgroundColor: 'rgba(233, 30, 99, 0.7)',
                        borderColor: '#E91E63',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '%';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '频率 (%)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '问题长度（字符）'
                        }
                    }
                }
            }
        });
        
        // 初始化声誉分布图
        const reputationCtx = document.getElementById('reputationChart').getContext('2d');
        charts.reputation = new Chart(reputationCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [
                    {
                        label: '易解决',
                        data: [],
                        backgroundColor: 'rgba(75, 192, 192, 0.7)',
                        borderColor: '#4BC0C0',
                        borderWidth: 1
                    },
                    {
                        label: '难解决',
                        data: [],
                        backgroundColor: 'rgba(233, 30, 99, 0.7)',
                        borderColor: '#E91E63',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '%';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '频率 (%)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '提问者声誉 (log₁₀)'
                        }
                    }
                }
            }
        });
        
        // 初始化评论数量分布图
        const commentCountCtx = document.getElementById('commentCountChart').getContext('2d');
        charts.commentCount = new Chart(commentCountCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [
                    {
                        label: '易解决',
                        data: [],
                        backgroundColor: 'rgba(75, 192, 192, 0.7)',
                        borderColor: '#4BC0C0',
                        borderWidth: 1
                    },
                    {
                        label: '难解决',
                        data: [],
                        backgroundColor: 'rgba(233, 30, 99, 0.7)',
                        borderColor: '#E91E63',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '%';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '频率 (%)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '评论数量'
                        }
                    }
                }
            }
        });
        
        document.getElementById('refreshSolvability').addEventListener('click', loadSolvability);
        loadSolvability();
    }

    async function loadSolvability() {
        const from = document.getElementById('fromDate').value;
        const to = document.getElementById('toDate').value;
        const params = new URLSearchParams();
        if (from) params.append('from', from);
        if (to) params.append('to', to);
        const query = params.toString();
        const payload = await fetchJson(query ? `/api/solvability/contrast?${query}` : '/api/solvability/contrast');
        
        if (!payload.data || !payload.data.comparison_data) {
            console.error('Invalid data format');
            return;
        }
        
        const features = payload.data.comparison_data;
        
        // 分离百分比特征和连续值特征
        const percentageFeatures = features.filter(f => f.unit === 'Percentage');
        const continuousFeatures = features.filter(f => f.unit !== 'Percentage');
        
        // 更新分组柱状图（百分比数据）
        if (percentageFeatures.length > 0) {
            const barLabels = percentageFeatures.map(f => f.feature_name);
            const solvableBarData = percentageFeatures.map(f => f.solvable_group);
            const hardBarData = percentageFeatures.map(f => f.hard_group);
            
            charts.solvabilityBar.data.labels = barLabels;
            charts.solvabilityBar.data.datasets[0].data = solvableBarData;
            charts.solvabilityBar.data.datasets[0].unit = 'Percentage';
            charts.solvabilityBar.data.datasets[1].data = hardBarData;
            charts.solvabilityBar.data.datasets[1].unit = 'Percentage';
            charts.solvabilityBar.update();
        } else {
            charts.solvabilityBar.data.labels = [];
            charts.solvabilityBar.data.datasets[0].data = [];
            charts.solvabilityBar.data.datasets[1].data = [];
            charts.solvabilityBar.update();
        }
        
        // 更新箱形图（连续数据，这里显示平均值）
        if (continuousFeatures && continuousFeatures.length > 0) {
            const boxLabels = continuousFeatures.map(f => f.feature_name);
            const solvableBoxData = continuousFeatures.map(f => f.solvable_group);
            const hardBoxData = continuousFeatures.map(f => f.hard_group);
            const unit = continuousFeatures[0]?.unit || '';
            
            charts.solvabilityBox.data.labels = boxLabels;
            charts.solvabilityBox.data.datasets[0].data = solvableBoxData;
            charts.solvabilityBox.data.datasets[0].unit = unit;
            charts.solvabilityBox.data.datasets[1].data = hardBoxData;
            charts.solvabilityBox.data.datasets[1].unit = unit;
            charts.solvabilityBox.update();
            console.log('箱形图数据已更新:', { boxLabels, solvableBoxData, hardBoxData });
        } else {
            charts.solvabilityBox.data.labels = [];
            charts.solvabilityBox.data.datasets[0].data = [];
            charts.solvabilityBox.data.datasets[1].data = [];
            charts.solvabilityBox.update();
            console.log('箱形图：无连续数据特征');
        }

        // 更新声誉箱线图（D3 绘制）
        if (payload.data.reputation_boxplot_data) {
            renderBoxPlot('reputationBoxPlotContainer', payload.data.reputation_boxplot_data, '声誉 (log₁₀)', '提问者声誉分布箱线图 (log₁₀变换)');
        } else {
            renderBoxPlot('reputationBoxPlotContainer', null, '声誉 (log₁₀)', '提问者声誉分布箱线图 (log₁₀变换)');
        }
        // 更新标题词数箱线图
        if (payload.data.title_words_boxplot_data) {
            renderBoxPlot('titleWordsBoxPlotContainer', payload.data.title_words_boxplot_data, '词数', '标题词数分布箱线图');
        } else {
            renderBoxPlot('titleWordsBoxPlotContainer', null, '词数', '标题词数分布箱线图');
        }
        // 更新代码占比箱线图
        if (payload.data.code_ratio_boxplot_data) {
            renderBoxPlot('codeRatioBoxPlotContainer', payload.data.code_ratio_boxplot_data, '代码占比', '代码片段占比分布箱线图');
        } else {
            renderBoxPlot('codeRatioBoxPlotContainer', null, '代码占比', '代码片段占比分布箱线图');
        }
        // 更新浏览量箱线图
        if (payload.data.view_count_boxplot_data) {
            renderBoxPlot('viewCountBoxPlotContainer', payload.data.view_count_boxplot_data, '浏览量', '浏览量分布箱线图');
        } else {
            renderBoxPlot('viewCountBoxPlotContainer', null, '浏览量', '浏览量分布箱线图');
        }

        // 更新小提琴图：声誉、标题词数、代码占比、浏览量（附带整体箱线统计）
        if (payload.data.reputation_distribution) {
            renderViolinPlot(
                'reputationViolinContainer',
                payload.data.reputation_distribution,
                payload.data.reputation_boxplot_data,
                '频率 (%)',
                '提问者声誉分布小提琴图 (log₁₀变换)'
            );
        } else {
            renderViolinPlot('reputationViolinContainer', null, null, '频率 (%)', '提问者声誉分布小提琴图 (log₁₀变换)');
        }
        if (payload.data.title_words_distribution) {
            renderViolinPlot(
                'titleWordsViolinContainer',
                payload.data.title_words_distribution,
                payload.data.title_words_boxplot_data,
                '频率 (%)',
                '标题词数分布小提琴图'
            );
        } else {
            renderViolinPlot('titleWordsViolinContainer', null, null, '频率 (%)', '标题词数分布小提琴图');
        }
        if (payload.data.code_snippet_ratio_distribution) {
            renderViolinPlot(
                'codeRatioViolinContainer',
                payload.data.code_snippet_ratio_distribution,
                payload.data.code_ratio_boxplot_data,
                '频率 (%)',
                '代码片段占比分布小提琴图'
            );
        } else {
            renderViolinPlot('codeRatioViolinContainer', null, null, '频率 (%)', '代码片段占比分布小提琴图');
        }
        if (payload.data.view_count_distribution) {
            renderViolinPlot(
                'viewCountViolinContainer',
                payload.data.view_count_distribution,
                payload.data.view_count_boxplot_data,
                '频率 (%)',
                '浏览量分布小提琴图'
            );
        } else {
            renderViolinPlot('viewCountViolinContainer', null, null, '频率 (%)', '浏览量分布小提琴图');
        }
        
        // 更新标签频率折线图
        if (payload.data.tag_frequency_data && payload.data.tag_frequency_data.length > 0) {
            const tagData = payload.data.tag_frequency_data;
            const tagLabels = tagData.map(t => t.tag_name);
            const solvableTagCounts = tagData.map(t => t.solvable_count);
            const hardTagCounts = tagData.map(t => t.hard_count);
            
            charts.tagFrequency.data.labels = tagLabels;
            charts.tagFrequency.data.datasets[0].data = solvableTagCounts;
            charts.tagFrequency.data.datasets[1].data = hardTagCounts;
            charts.tagFrequency.update();
        } else {
            charts.tagFrequency.data.labels = [];
            charts.tagFrequency.data.datasets[0].data = [];
            charts.tagFrequency.data.datasets[1].data = [];
            charts.tagFrequency.update();
        }
        
        // 更新评论频率折线图
        if (payload.data.comment_frequency_data) {
            const commentData = payload.data.comment_frequency_data;
            const solvableWithComments = commentData.solvable_with_comments;
            const solvableWithoutComments = commentData.solvable_total - solvableWithComments;
            const hardWithComments = commentData.hard_with_comments;
            const hardWithoutComments = commentData.hard_total - hardWithComments;
            
            charts.commentFrequency.data.datasets[0].data = [solvableWithComments, solvableWithoutComments];
            charts.commentFrequency.data.datasets[1].data = [hardWithComments, hardWithoutComments];
            charts.commentFrequency.update();
        } else {
            charts.commentFrequency.data.datasets[0].data = [0, 0];
            charts.commentFrequency.data.datasets[1].data = [0, 0];
            charts.commentFrequency.update();
        }
        
        // 更新代码片段比率分布图
        if (payload.data.code_snippet_ratio_distribution) {
            const ratioData = payload.data.code_snippet_ratio_distribution;
            charts.codeSnippetRatio.data.labels = ratioData.bins;
            charts.codeSnippetRatio.data.datasets[0].data = ratioData.solvable_frequencies;
            charts.codeSnippetRatio.data.datasets[1].data = ratioData.hard_frequencies;
            charts.codeSnippetRatio.update();
        }
        
        // 更新标签数分布图
        if (payload.data.tag_count_distribution) {
            const tagCountData = payload.data.tag_count_distribution;
            charts.tagCount.data.labels = tagCountData.bins;
            charts.tagCount.data.datasets[0].data = tagCountData.solvable_frequencies;
            charts.tagCount.data.datasets[1].data = tagCountData.hard_frequencies;
            charts.tagCount.update();
        }
        
        // 更新问题长度分布图
        if (payload.data.question_length_distribution) {
            const lengthData = payload.data.question_length_distribution;
            charts.questionLength.data.labels = lengthData.bins;
            charts.questionLength.data.datasets[0].data = lengthData.solvable_frequencies;
            charts.questionLength.data.datasets[1].data = lengthData.hard_frequencies;
            charts.questionLength.update();
        }
        
        // 更新声誉分布图
        if (payload.data.reputation_distribution) {
            const reputationData = payload.data.reputation_distribution;
            charts.reputation.data.labels = reputationData.bins;
            charts.reputation.data.datasets[0].data = reputationData.solvable_frequencies;
            charts.reputation.data.datasets[1].data = reputationData.hard_frequencies;
            charts.reputation.update();
        }
        
        // 更新评论数量分布图
        if (payload.data.comment_count_distribution) {
            const commentCountData = payload.data.comment_count_distribution;
            charts.commentCount.data.labels = commentCountData.bins;
            charts.commentCount.data.datasets[0].data = commentCountData.solvable_frequencies;
            charts.commentCount.data.datasets[1].data = commentCountData.hard_frequencies;
            charts.commentCount.update();
        }
    }
</script>
</body>
</html>