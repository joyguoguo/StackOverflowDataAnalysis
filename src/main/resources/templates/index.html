<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stack Overflow Java Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            color-scheme: light;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f6f8;
            color: #1c1c1c;
        }
        .container {
            max-width: 1100px;
            margin: 0 auto;
        }
        header {
            text-align: center;
            margin-bottom: 24px;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 32px;
        }
        .stat-card {
            background: white;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        .stat-card .label {
            display: block;
            font-size: 0.9rem;
            color: #6b7280;
        }
        .stat-card .value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #111827;
        }
        .panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .panel-header {
            display: flex;
            justify-content: space-between;
            gap: 16px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 12px;
        }
        .panel-header h2 {
            margin: 0;
        }
        select, input[type="number"], input[type="date"], button {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            font-size: 0.95rem;
        }
        button {
            background: #2563eb;
            border: none;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background: #1d4ed8;
        }
    </style>
</head>
<body>
<div class="container">
    <header>
        <h1>Stack Overflow Java Q&amp;A 分析面板</h1>
        <p>基于本地离线数据集的趋势、共现、多线程痛点与可解性洞察</p>
    </header>

    <section class="stats" id="metaSection">
        <div class="stat-card">
            <span class="label">线程数</span>
            <span class="value" id="threadCount">-</span>
        </div>
        <div class="stat-card">
            <span class="label">回答数</span>
            <span class="value" id="answerCount">-</span>
        </div>
        <div class="stat-card">
            <span class="label">评论数</span>
            <span class="value" id="commentCount">-</span>
        </div>
        <div class="stat-card">
            <span class="label">数据区间</span>
            <span class="value" id="dataRange">-</span>
        </div>
    </section>

    <section class="panel">
        <div class="panel-header">
            <div>
                <h2>Topic Trends</h2>
                <p>显示帖子数量前 N 的标签在等时长时间窗口内的趋势</p>
            </div>
            <div>
                <label for="trendTopN">Top N 标签：</label>
                <input id="trendTopN" type="number" min="3" max="20" value="8" style="width: 60px;">
                <label for="metricSelect" style="margin-left: 15px;">指标：</label>
                <select id="metricSelect">
                    <option value="QUESTIONS">发帖量</option>
                    <option value="ANSWERS">回答数</option>
                    <option value="SCORE">得分</option>
                    <option value="ENGAGEMENT">浏览量</option>
                </select>
                <button id="refreshTrends" style="margin-left: 10px;">刷新</button>
            </div>
        </div>
        <canvas id="topicTrendChart"></canvas>
    </section>

    <section class="panel">
        <div class="panel-header">
            <div>
                <h2>Topic Co-occurrence话题共现</h2>
                <p>力导向图展示话题共现关系：节点代表话题，边代表共现对，边的粗细代表共现频率</p>
            </div>
            <div>
                <label for="cooccurrenceSelect">Top N:</label>
                <input id="cooccurrenceSelect" type="number" min="3" max="50" value="10">
                <label for="filterCoreTopics" style="margin-left: 15px;">
                    <input type="checkbox" id="filterCoreTopics"> 只显示核心话题
                </label>
                <button id="refreshPairs" style="margin-left: 10px;">刷新</button>
            </div>
        </div>
        <div id="forceGraphContainer" style="width: 100%; height: 800px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff; overflow: visible; margin-bottom: 20px;"></div>
        <canvas id="cooccurrenceChart" style="max-height: 400px;"></canvas>
    </section>

    <section class="panel">
        <div class="panel-header">
            <div>
                <h2>Multithreading Common Pitfalls</h2>
                <p>Identify and categorize multithreading-related issues based on tags, titles, body text, and code snippets</p>
            </div>
            <div>
                <label for="pitfallSelect">Top N Categories:</label>
                <input id="pitfallSelect" type="number" min="1" max="10" value="5" title="Number of top categories to display (1-10)">
                <button id="refreshPitfalls">Refresh</button>
            </div>
        </div>
        <div id="sunburstContainer" style="width: 100%; height: 600px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff;"></div>
    </section>

    <section class="panel">
        <div class="panel-header">
            <div>
                <h2>可解性特征对比</h2>
                <p>比较容易解决 vs 难以解决问题在多个特征上的差异</p>
            </div>
            <div class="date-range">
                <label for="fromDate">From</label>
                <input type="date" id="fromDate">
                <label for="toDate">To</label>
                <input type="date" id="toDate">
                <button id="refreshSolvability">应用</button>
    </div>
    </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">分组柱状图（百分比和比例数据）</h3>
            <canvas id="solvabilityBarChart"></canvas>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">箱形图（连续数据分布）</h3>
            <canvas id="solvabilityBoxChart" style="max-height: 400px;"></canvas>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">标签频率对比（前10个标签，排除java）</h3>
            <canvas id="tagFrequencyChart"></canvas>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">问题评论频率对比</h3>
            <canvas id="commentFrequencyChart"></canvas>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">代码片段比率分布</h3>
            <canvas id="codeSnippetRatioChart"></canvas>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">标签数分布</h3>
            <canvas id="tagCountChart"></canvas>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">问题长度分布</h3>
            <canvas id="questionLengthChart"></canvas>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">提问者声誉分布 (log10变换)</h3>
            <canvas id="reputationChart"></canvas>
        </div>
        <div style="margin-bottom: 24px;">
            <h3 style="margin-bottom: 12px;">提问者声誉分布箱线图 (log10变换)</h3>
            <div id="reputationBoxPlotContainer" style="width: 100%; height: 400px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff;"></div>
        </div>
        <div>
            <h3 style="margin-bottom: 12px;">评论数量分布</h3>
            <canvas id="commentCountChart"></canvas>
        </div>
    </section>
</div>

<script>
    const charts = {};

    document.addEventListener('DOMContentLoaded', () => {
        loadMetadata();
        initTopicTrendChart();
        initCooccurrenceChart();
        initPitfallChart();
        initSolvabilityChart();
    });

    async function fetchJson(url) {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`请求失败：${response.status}`);
        }
        return response.json();
    }

    async function loadMetadata() {
        const payload = await fetchJson('/api/metadata/status');
        const meta = payload.data;
        document.getElementById('threadCount').innerText = meta.threadCount;
        document.getElementById('answerCount').innerText = meta.answerCount;
        document.getElementById('commentCount').innerText = meta.commentCount;
        document.getElementById('dataRange').innerText = `${meta.earliestQuestion ?? '-'} ~ ${meta.latestQuestion ?? '-'}`;
    }

    function initTopicTrendChart() {
        const ctx = document.getElementById('topicTrendChart').getContext('2d');
        charts.topicTrends = new Chart(ctx, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                responsive: true,
                interaction: { mode: 'index', intersect: false },
                plugins: { legend: { position: 'bottom' } }
            }
        });
        document.getElementById('metricSelect').addEventListener('change', loadTopicTrends);
        document.getElementById('refreshTrends').addEventListener('click', loadTopicTrends);
        loadTopicTrends();
    }

    async function loadTopicTrends() {
        const metric = document.getElementById('metricSelect').value;
        const topN = document.getElementById('trendTopN').value;
        const payload = await fetchJson(`/api/topic-trends?metric=${metric}&topN=${topN}`);
        const data = payload.data;
        const labels = [...new Set(data.series.flatMap(series => series.points.map(p => p.bucket)))].sort();
        const colorPalette = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#7E57C2', '#26A69A'];
        const datasets = data.series.map((series, index) => ({
            label: series.topic,
            data: labels.map(label => {
                const point = series.points.find(p => p.bucket === label);
                return point ? point.value : 0;
            }),
            borderColor: colorPalette[index % colorPalette.length],
            tension: 0.3,
            fill: false
        }));
        charts.topicTrends.data.labels = labels;
        charts.topicTrends.data.datasets = datasets;
        charts.topicTrends.update();
    }

    let forceGraphSimulation = null;

    function initCooccurrenceChart() {
        // 初始化柱状图
        const ctx = document.getElementById('cooccurrenceChart').getContext('2d');
        charts.cooccurrence = new Chart(ctx, {
            type: 'bar',
            data: { labels: [], datasets: [{ label: '共现次数', data: [], backgroundColor: '#36A2EB' }] },
            options: { 
                responsive: true, 
                maintainAspectRatio: true,
                plugins: { 
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return '共现次数: ' + context.parsed.y;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '共现频率'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '话题对'
                        }
                    }
                }
            }
        });
        
        document.getElementById('refreshPairs').addEventListener('click', loadCooccurrence);
        document.getElementById('cooccurrenceSelect').addEventListener('change', loadCooccurrence);
        document.getElementById('filterCoreTopics').addEventListener('change', loadCooccurrence);
        loadCooccurrence();
    }

    async function loadCooccurrence() {
        const topN = document.getElementById('cooccurrenceSelect').value;
        const filterCoreTopics = document.getElementById('filterCoreTopics').checked;
        const url = `/api/cooccurrence?topN=${topN}&filterCoreTopics=${filterCoreTopics}`;
        const payload = await fetchJson(url);
        
        // 渲染力导向图
        renderForceDirectedGraph(payload.data.pairs);
        
        // 更新柱状图
        const labels = payload.data.pairs.map(pair => pair.topic_pair.join(' & '));
        const data = payload.data.pairs.map(pair => pair.frequency);
        charts.cooccurrence.data.labels = labels;
        charts.cooccurrence.data.datasets[0].data = data;
        charts.cooccurrence.update();
    }

    function renderForceDirectedGraph(pairs) {
        const container = document.getElementById('forceGraphContainer');
        container.innerHTML = '';
        
        if (!pairs || pairs.length === 0) {
            container.innerHTML = '<p style="text-align: center; padding: 50px; color: #6b7280;">暂无数据</p>';
            return;
        }

        // 停止之前的模拟（如果存在）
        if (forceGraphSimulation) {
            forceGraphSimulation.stop();
        }

        const width = container.clientWidth;
        const height = 800;  // 增加高度，避免节点跑到外面

        // 收集所有唯一的节点（话题）
        const nodeMap = new Map();
        pairs.forEach(pair => {
            pair.topic_pair.forEach(topic => {
                if (!nodeMap.has(topic)) {
                    nodeMap.set(topic, { id: topic, name: topic });
                }
            });
        });

        const nodes = Array.from(nodeMap.values());
        const nodeByIdMap = new Map(nodes.map(n => [n.id, n]));

        // 创建链接（边）数组，使用节点 ID 字符串（d3.forceLink 会自动转换为节点对象）
        const links = pairs.map(pair => ({
            source: pair.topic_pair[0],  // 使用 ID 字符串，d3.forceLink().id() 会转换为节点对象
            target: pair.topic_pair[1],
            frequency: pair.frequency
        }));

        // 计算频率范围，用于设置边的粗细
        const frequencies = links.map(l => l.frequency);
        const minFreq = Math.min(...frequencies);
        const maxFreq = Math.max(...frequencies);
        const freqRange = maxFreq - minFreq;

        // 创建 SVG，使用更大的尺寸并允许溢出
        const svg = d3.select(container)
            .append('svg')
            .attr('width', width)
            .attr('height', height)
            .style('overflow', 'visible');
        
        // 添加定义，用于文本背景
        const defs = svg.append('defs');
        
        // 添加文本背景的过滤器（用于更好的可读性）
        const filter = defs.append('filter')
            .attr('id', 'text-background')
            .attr('x', '-50%')
            .attr('y', '-50%')
            .attr('width', '200%')
            .attr('height', '200%');
        
        filter.append('feFlood')
            .attr('flood-color', 'white')
            .attr('flood-opacity', '0.8')
            .attr('result', 'bg');
        
        filter.append('feComposite')
            .attr('in', 'bg')
            .attr('in2', 'SourceAlpha')
            .attr('operator', 'in');

        // 创建力导向图模拟
        // 注意：distance 函数中的参数是 link，频率越高，距离越近
        forceGraphSimulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(links)
                .id(d => d.id)
                .distance(d => {
                    // 频率越高，距离越近（但保持最小距离）
                    return Math.max(10, 200 - (d.frequency / maxFreq) * 120);
                }))
            .force('charge', d3.forceManyBody().strength(-100))  // 增加排斥力，让节点分布更均匀
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(10));  // 增加碰撞半径，避免节点重叠

        // 绘制链接（边）
        const link = svg.append('g')
            .selectAll('line')
            .data(links)
            .enter().append('line')
            .attr('stroke', '#999')
            .attr('stroke-opacity', 0.6)
            .attr('stroke-width', d => {
                // 边的粗细映射到频率：最小2px，最大10px
                const thickness = 2 + (d.frequency - minFreq) / freqRange * 8;
                return Math.max(2, Math.min(10, thickness));
            });

        // 绘制节点
        const node = svg.append('g')
            .selectAll('circle')
            .data(nodes)
            .enter().append('circle')
            .attr('r', 12)
            .attr('fill', '#2563eb')
            .attr('stroke', '#fff')
            .attr('stroke-width', 2)
            .call(drag(forceGraphSimulation));

        // 添加标签
        const label = svg.append('g')
            .selectAll('text')
            .data(nodes)
            .enter().append('text')
            .text(d => d.name)
            .attr('font-size', '12px')
            .attr('dx', 15)
            .attr('dy', 4)
            .attr('fill', '#1c1c1c')
            .style('pointer-events', 'none');

        // 添加悬停提示
        node.append('title')
            .text(d => d.name);

        // 在链接上添加悬停提示
        link.append('title')
            .text(d => {
                // d3.forceLink 会将 source/target 转换为节点对象
                const sourceName = typeof d.source === 'object' ? d.source.name : d.source;
                const targetName = typeof d.target === 'object' ? d.target.name : d.target;
                return `${sourceName} & ${targetName}: ${d.frequency} 次共现`;
            });
        
        // 在边的中间位置添加频率标签
        const linkLabel = svg.append('g')
            .selectAll('text')
            .data(links)
            .enter().append('text')
            .text(d => d.frequency)
            .attr('font-size', '10px')
            .attr('font-weight', 'bold')
            .attr('fill', '#000000')         // 黑色字体
            .attr('stroke', 'white')         // <--- 添加白色描边
            .attr('stroke-width', 2.5)       // <--- 设置描边宽度（增加对比度）
            .attr('paint-order', 'stroke')   // <--- 确保先绘制描边，再绘制填充
            .attr('text-anchor', 'middle')
            .style('pointer-events', 'none');       

        // 更新位置函数
        function ticked() {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            node
                .attr('cx', d => d.x)
                .attr('cy', d => d.y);

            label
                .attr('x', d => d.x)
                .attr('y', d => d.y);
            
            // 更新边的标签位置（在边的中点）
            linkLabel
                .attr('x', d => (d.source.x + d.target.x) / 2)
                .attr('y', d => (d.source.y + d.target.y) / 2);
        }

        // 启动模拟
        forceGraphSimulation.on('tick', ticked);

        // 拖拽函数
        function drag(simulation) {
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }

            return d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended);
        }
    }

    // 绘制声誉箱线图（使用 D3）
    function renderReputationBoxPlot(boxData) {
        const container = document.getElementById('reputationBoxPlotContainer');
        container.innerHTML = '';

        if (!boxData || !boxData.solvable || !boxData.hard) {
            container.innerHTML = '<p style="text-align: center; padding: 40px; color: #6b7280;">暂无数据</p>';
            return;
        }

        const data = [
            { label: '易解决', stats: boxData.solvable },
            { label: '难解决', stats: boxData.hard }
        ];

        const margin = { top: 20, right: 20, bottom: 40, left: 60 };
        const width = container.clientWidth - margin.left - margin.right;
        const height = 360 - margin.top - margin.bottom;

        const allValues = [
            ...data.flatMap(d => [d.stats.min, d.stats.q1, d.stats.median, d.stats.q3, d.stats.max]),
            ...data.flatMap(d => d.stats.outliers || [])
        ];
        const yMin = Math.min(...allValues);
        const yMax = Math.max(...allValues);
        const yPadding = (yMax - yMin) * 0.05 || 10;

        const svg = d3.select(container)
            .append('svg')
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom)
            .append('g')
            .attr('transform', `translate(${margin.left},${margin.top})`);

        const x = d3.scaleBand()
            .domain(data.map(d => d.label))
            .range([0, width])
            .paddingInner(0.4)
            .paddingOuter(0.2);

        const y = d3.scaleLinear()
            .domain([yMin - yPadding, yMax + yPadding])
            .range([height, 0]);

        // 轴
        svg.append('g')
            .attr('transform', `translate(0,${height})`)
            .call(d3.axisBottom(x));

        svg.append('g')
            .call(d3.axisLeft(y));
        
        // 添加Y轴标题
        svg.append('text')
            .attr('transform', 'rotate(-90)')
            .attr('y', 0 - margin.left)
            .attr('x', 0 - (height / 2))
            .attr('dy', '1em')
            .style('text-anchor', 'middle')
            .style('font-size', '12px')
            .text('声誉 (log₁₀ Reputation)');
        
        // 添加X轴标题
        svg.append('text')
            .attr('transform', `translate(${width / 2}, ${height + margin.bottom - 5})`)
            .style('text-anchor', 'middle')
            .style('font-size', '12px')
            .text('问题类型');

        const boxWidth = x.bandwidth();

        // 绘制箱线图
        data.forEach(d => {
            const cx = x(d.label) + boxWidth / 2;
            const { min, q1, median, q3, max, outliers } = d.stats;
            
            // 计算IQR和异常值边界
            const iqr = q3 - q1;
            const lowerBound = q1 - 1.5 * iqr;
            const upperBound = q3 + 1.5 * iqr;
            
            // 计算非异常值的最小值和最大值（用于绘制须线）
            // 下须：延伸到所有非异常值中的最小值
            // 如果min是异常值，则延伸到lowerBound；否则延伸到min
            const outlierSet = new Set((outliers || []).map(v => Math.round(v * 100) / 100));
            const isMinOutlier = outlierSet.has(Math.round(min * 100) / 100);
            const lowerWhisker = isMinOutlier ? Math.max(lowerBound, 0) : min;
            
            // 上须：延伸到所有非异常值中的最大值
            // 如果max是异常值，则延伸到upperBound；否则延伸到max
            const isMaxOutlier = outlierSet.has(Math.round(max * 100) / 100);
            const upperWhisker = isMaxOutlier ? Math.min(upperBound, max) : max;
            
            // 确保lowerWhisker <= q1 和 upperWhisker >= q3
            const finalLowerWhisker = Math.min(lowerWhisker, q1);
            const finalUpperWhisker = Math.max(upperWhisker, q3);
            
            // 绘制箱体 (Q1到Q3) - 先绘制箱体，这样其他元素会在上面
            const boxHeight = Math.max(1, y(q1) - y(q3));
            svg.append('rect')
                .attr('x', x(d.label))
                .attr('y', y(q3))
                .attr('width', boxWidth)
                .attr('height', boxHeight)
                .attr('fill', d.label === '易解决' ? 'rgba(75, 192, 192, 0.4)' : 'rgba(233, 30, 99, 0.4)')
                .attr('stroke', d.label === '易解决' ? '#4BC0C0' : '#E91E63')
                .attr('stroke-width', 1.5);
            
            // 绘制中位数线（横穿箱体）
            svg.append('line')
                .attr('x1', x(d.label))
                .attr('x2', x(d.label) + boxWidth)
                .attr('y1', y(median))
                .attr('y2', y(median))
                .attr('stroke', '#111827')
                .attr('stroke-width', 2);
            
            // 绘制下须（从Q1到finalLowerWhisker）
            svg.append('line')
                .attr('x1', cx)
                .attr('x2', cx)
                .attr('y1', y(q1))
                .attr('y2', y(finalLowerWhisker))
                .attr('stroke', '#374151')
                .attr('stroke-width', 1.5);
            
            // 绘制上须（从Q3到finalUpperWhisker）
            svg.append('line')
                .attr('x1', cx)
                .attr('x2', cx)
                .attr('y1', y(q3))
                .attr('y2', y(finalUpperWhisker))
                .attr('stroke', '#374151')
                .attr('stroke-width', 1.5);
            
            // 绘制下须端点（横线）
            svg.append('line')
                .attr('x1', cx - boxWidth * 0.2)
                .attr('x2', cx + boxWidth * 0.2)
                .attr('y1', y(finalLowerWhisker))
                .attr('y2', y(finalLowerWhisker))
                .attr('stroke', '#374151')
                .attr('stroke-width', 1.5);
            
            // 绘制上须端点（横线）
            svg.append('line')
                .attr('x1', cx - boxWidth * 0.2)
                .attr('x2', cx + boxWidth * 0.2)
                .attr('y1', y(finalUpperWhisker))
                .attr('y2', y(finalUpperWhisker))
                .attr('stroke', '#374151')
                .attr('stroke-width', 1.5);
            
            // 绘制异常值点
            (outliers || []).forEach(v => {
                svg.append('circle')
                    .attr('cx', cx)
                    .attr('cy', y(v))
                    .attr('r', 4)
                    .attr('fill', d.label === '易解决' ? '#4BC0C0' : '#E91E63')
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 1.5)
                    .attr('opacity', 0.8)
                    .append('title')
                    .text(`异常值: ${v.toFixed(0)}`);
            });
        });

        // 添加标题
        svg.append('text')
            .attr('x', width / 2)
            .attr('y', -6)
            .attr('text-anchor', 'middle')
            .attr('fill', '#111827')
            .attr('font-size', '14px')
            .text('提问者声誉分布箱线图 (log₁₀变换)');
    }

    let sunburstData = null;

    function initPitfallChart() {
        document.getElementById('refreshPitfalls').addEventListener('click', loadPitfalls);
        document.getElementById('pitfallSelect').addEventListener('change', loadPitfalls);
        loadPitfalls();
    }

    async function loadPitfalls() {
        const topN = document.getElementById('pitfallSelect').value;
        const payload = await fetchJson(`/api/multithreading/pitfalls?topN=${topN}`);
        sunburstData = payload.data;
        renderSunburstChart(sunburstData);
    }

    function renderSunburstChart(data) {
        const container = document.getElementById('sunburstContainer');
        container.innerHTML = '';
        
        if (!data || !data.categories || data.categories.length === 0) {
            container.innerHTML = '<p style="text-align: center; padding: 50px; color: #6b7280;">No data available</p>';
            return;
        }

        const width = container.clientWidth;
        const height = 600;
        const radius = Math.min(width, height) / 2 - 10;

        // Create SVG
        const svg = d3.select(container)
            .append('svg')
            .attr('width', width)
            .attr('height', height)
            .append('g')
            .attr('transform', `translate(${width / 2},${height / 2})`);

        // Color scheme for categories
        const categoryColors = {
            'Synchronization Issues': '#FF6384',
            'Memory Consistency': '#36A2EB',
            'Concurrent Data Structures': '#FFCE56',
            'Thread Pool & Executors': '#4BC0C0',
            'Performance Issues': '#9966FF',
            'Others': '#FF9F40'
        };

        // Build hierarchical data structure
        // Ensure inner ring value equals sum of outer ring values
        const root = {
            name: 'Multithreading Pitfalls',
            children: data.categories.map(category => {
                // Calculate actual sum from pitfalls
                const actualTotal = category.pitfalls.reduce((sum, p) => sum + p.count, 0);
                return {
                    name: category.category,
                    value: actualTotal, // Use actual sum instead of totalCount to ensure consistency
                    children: category.pitfalls.map(pitfall => ({
                        name: pitfall.label,
                        value: pitfall.count,
                        category: category.category
                    }))
                };
            })
        };

        // Create partition layout
        const partition = d3.partition()
            .size([2 * Math.PI, radius]);

        const rootNode = d3.hierarchy(root)
            .sum(d => d.value)
            .sort((a, b) => b.value - a.value);

        partition(rootNode);

        // Color function
        const color = d3.scaleOrdinal()
            .domain(Object.keys(categoryColors))
            .range(Object.values(categoryColors));

        // Create arcs
        const arc = d3.arc()
            .startAngle(d => d.x0)
            .endAngle(d => d.x1)
            .innerRadius(d => d.y0)
            .outerRadius(d => d.y1);

        // Draw arcs
        const arcs = svg.selectAll('path')
            .data(rootNode.descendants())
            .enter()
            .append('path')
            .attr('d', arc)
            .attr('fill', d => {
                if (d.depth === 0) return '#f0f0f0';
                if (d.depth === 1) return color(d.data.name) || '#999';
                return d3.color(color(d.data.category) || '#999').brighter(0.5);
            })
            .attr('stroke', '#fff')
            .attr('stroke-width', 2)
            .style('cursor', 'pointer')
            .on('mouseover', function(event, d) {
                d3.select(this)
                    .attr('opacity', 0.8)
                    .attr('stroke-width', 3);
                
                // Show tooltip
                const tooltip = d3.select('body').append('div')
                    .attr('class', 'tooltip')
                    .style('opacity', 0)
                    .style('position', 'absolute')
                    .style('background', 'rgba(0, 0, 0, 0.8)')
                    .style('color', 'white')
                    .style('padding', '8px')
                    .style('border-radius', '4px')
                    .style('pointer-events', 'none')
                    .style('font-size', '12px');
                
                let label, count;
                if (d.depth === 1) {
                    // Category level
                    label = d.data.name;
                    count = d.value;
                } else {
                    // Pitfall level
                    label = `${d.data.category} - ${d.data.name}`;
                    count = d.value;
                }
                tooltip.html(`${label}<br/>Count: ${count}`)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px')
                    .transition()
                    .duration(200)
                    .style('opacity', 1);
            })
            .on('mousemove', function(event) {
                d3.select('.tooltip')
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            })
            .on('mouseout', function() {
                d3.select(this)
                    .attr('opacity', 1)
                    .attr('stroke-width', 2);
                d3.select('.tooltip').remove();
            });

        // Add labels for categories (inner ring) with better positioning
        svg.selectAll('text.category')
            .data(rootNode.children || [])
            .enter()
            .append('text')
            .attr('class', 'category')
            .attr('transform', d => {
                const angle = (d.x0 + d.x1) / 2;
                const radius = (d.y0 + d.y1) / 2;
                const x = Math.cos(angle - Math.PI / 2) * radius;
                const y = Math.sin(angle - Math.PI / 2) * radius;
                const rotation = angle * 180 / Math.PI;
                return `translate(${x},${y}) rotate(${rotation < 90 || rotation > 270 ? rotation : rotation + 180})`;
            })
            .attr('dy', '0.35em')
            .attr('text-anchor', 'middle')
            .attr('font-size', '13px')
            .attr('font-weight', 'bold')
            .attr('fill', '#333')
            .attr('stroke', '#fff')
            .attr('stroke-width', '0.3px')
            .attr('paint-order', 'stroke')
            .text(d => d.data.name)
            .style('pointer-events', 'none');

        // Add labels for pitfalls (outer ring) - only if space allows
        svg.selectAll('text.pitfall')
            .data(rootNode.descendants().filter(d => d.depth === 2 && d.value > 0))
            .enter()
            .append('text')
            .attr('class', 'pitfall')
            .attr('transform', d => {
                const x = ((d.x0 + d.x1) / 2) * 180 / Math.PI;
                const y = -(d.y0 + d.y1) / 2;
                return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
            })
            .attr('dy', '0.35em')
            .attr('text-anchor', d => (d.x0 + d.x1) / 2 < Math.PI ? 'start' : 'end')
            .attr('font-size', '10px')
            .attr('fill', '#666')
            .text(d => {
                // Only show label if arc is large enough
                const angle = (d.x1 - d.x0) * 180 / Math.PI;
                return angle > 10 ? d.data.name : '';
            })
            .style('pointer-events', 'none');
    }

    function initSolvabilityChart() {
        // 初始化分组柱状图
        const barCtx = document.getElementById('solvabilityBarChart').getContext('2d');
        charts.solvabilityBar = new Chart(barCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [
                    { 
                        label: '易解决', 
                        data: [], 
                        backgroundColor: 'rgba(75, 192, 192, 0.7)',
                        borderColor: '#4BC0C0',
                        borderWidth: 1
                    },
                    { 
                        label: '难解决', 
                        data: [], 
                        backgroundColor: 'rgba(233, 30, 99, 0.7)',
                        borderColor: '#E91E63',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.parsed.y;
                                const unit = context.dataset.unit || '';
                                return context.dataset.label + ': ' + value.toFixed(2) + ' ' + unit;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '值'
                        }
                    }
                }
            }
        });
        
        // 初始化箱形图（使用折线图模拟，显示平均值）
        const boxCtx = document.getElementById('solvabilityBoxChart').getContext('2d');
        charts.solvabilityBox = new Chart(boxCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [
                    { 
                        label: '易解决（平均值）', 
                        data: [], 
                        backgroundColor: 'rgba(75, 192, 192, 0.5)',
                        borderColor: '#4BC0C0',
                        borderWidth: 2
                    },
                    { 
                        label: '难解决（平均值）', 
                        data: [], 
                        backgroundColor: 'rgba(233, 30, 99, 0.5)',
                        borderColor: '#E91E63',
                        borderWidth: 2
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const value = context.parsed.y;
                                const unit = context.dataset.unit || '';
                                return context.dataset.label + ': ' + value.toFixed(2) + ' ' + unit;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '值'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '特征'
                        }
                    }
                }
            }
        });
        
        // 初始化标签频率折线图
        const tagFreqCtx = document.getElementById('tagFrequencyChart').getContext('2d');
        charts.tagFrequency = new Chart(tagFreqCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: '易解决',
                        data: [],
                        borderColor: '#4BC0C0',
                        backgroundColor: 'rgba(75, 192, 192, 0.1)',
                        tension: 0.3,
                        fill: false
                    },
                    {
                        label: '难解决',
                        data: [],
                        borderColor: '#E91E63',
                        backgroundColor: 'rgba(233, 30, 99, 0.1)',
                        tension: 0.3,
                        fill: false
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + context.parsed.y + ' 次';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '频次'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '标签'
                        }
                    }
                }
            }
        });
        
        // 初始化评论频率折线图
        const commentFreqCtx = document.getElementById('commentFrequencyChart').getContext('2d');
        charts.commentFrequency = new Chart(commentFreqCtx, {
            type: 'line',
            data: {
                labels: ['有评论', '无评论'],
                datasets: [
                    {
                        label: '易解决',
                        data: [0, 0],
                        borderColor: '#4BC0C0',
                        backgroundColor: 'rgba(75, 192, 192, 0.1)',
                        tension: 0.3,
                        fill: false
                    },
                    {
                        label: '难解决',
                        data: [0, 0],
                        borderColor: '#E91E63',
                        backgroundColor: 'rgba(233, 30, 99, 0.1)',
                        tension: 0.3,
                        fill: false
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + context.parsed.y + ' 个问题';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '问题数量'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '评论状态'
                        }
                    }
                }
            }
        });
        
        // 初始化代码片段比率分布图
        const codeSnippetRatioCtx = document.getElementById('codeSnippetRatioChart').getContext('2d');
        charts.codeSnippetRatio = new Chart(codeSnippetRatioCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [
                    {
                        label: '易解决',
                        data: [],
                        backgroundColor: 'rgba(75, 192, 192, 0.7)',
                        borderColor: '#4BC0C0',
                        borderWidth: 1
                    },
                    {
                        label: '难解决',
                        data: [],
                        backgroundColor: 'rgba(233, 30, 99, 0.7)',
                        borderColor: '#E91E63',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '%';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '频率 (%)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '代码片段比率'
                        }
                    }
                }
            }
        });
        
        // 初始化标签数分布图
        const tagCountCtx = document.getElementById('tagCountChart').getContext('2d');
        charts.tagCount = new Chart(tagCountCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [
                    {
                        label: '易解决',
                        data: [],
                        backgroundColor: 'rgba(75, 192, 192, 0.7)',
                        borderColor: '#4BC0C0',
                        borderWidth: 1
                    },
                    {
                        label: '难解决',
                        data: [],
                        backgroundColor: 'rgba(233, 30, 99, 0.7)',
                        borderColor: '#E91E63',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '%';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '频率 (%)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '标签数'
                        }
                    }
                }
            }
        });
        
        // 初始化问题长度分布图
        const questionLengthCtx = document.getElementById('questionLengthChart').getContext('2d');
        charts.questionLength = new Chart(questionLengthCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [
                    {
                        label: '易解决',
                        data: [],
                        backgroundColor: 'rgba(75, 192, 192, 0.7)',
                        borderColor: '#4BC0C0',
                        borderWidth: 1
                    },
                    {
                        label: '难解决',
                        data: [],
                        backgroundColor: 'rgba(233, 30, 99, 0.7)',
                        borderColor: '#E91E63',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '%';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '频率 (%)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '问题长度（字符）'
                        }
                    }
                }
            }
        });
        
        // 初始化声誉分布图
        const reputationCtx = document.getElementById('reputationChart').getContext('2d');
        charts.reputation = new Chart(reputationCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [
                    {
                        label: '易解决',
                        data: [],
                        backgroundColor: 'rgba(75, 192, 192, 0.7)',
                        borderColor: '#4BC0C0',
                        borderWidth: 1
                    },
                    {
                        label: '难解决',
                        data: [],
                        backgroundColor: 'rgba(233, 30, 99, 0.7)',
                        borderColor: '#E91E63',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '%';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '频率 (%)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '提问者声誉 (log₁₀)'
                        }
                    }
                }
            }
        });
        
        // 初始化评论数量分布图
        const commentCountCtx = document.getElementById('commentCountChart').getContext('2d');
        charts.commentCount = new Chart(commentCountCtx, {
            type: 'bar',
            data: {
                labels: [],
                datasets: [
                    {
                        label: '易解决',
                        data: [],
                        backgroundColor: 'rgba(75, 192, 192, 0.7)',
                        borderColor: '#4BC0C0',
                        borderWidth: 1
                    },
                    {
                        label: '难解决',
                        data: [],
                        backgroundColor: 'rgba(233, 30, 99, 0.7)',
                        borderColor: '#E91E63',
                        borderWidth: 1
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { position: 'top' },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + '%';
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '频率 (%)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '评论数量'
                        }
                    }
                }
            }
        });
        
        document.getElementById('refreshSolvability').addEventListener('click', loadSolvability);
        loadSolvability();
    }

    async function loadSolvability() {
        const from = document.getElementById('fromDate').value;
        const to = document.getElementById('toDate').value;
        const params = new URLSearchParams();
        if (from) params.append('from', from);
        if (to) params.append('to', to);
        const query = params.toString();
        const payload = await fetchJson(query ? `/api/solvability/contrast?${query}` : '/api/solvability/contrast');
        
        if (!payload.data || !payload.data.comparison_data) {
            console.error('Invalid data format');
            return;
        }
        
        const features = payload.data.comparison_data;
        
        // 分离百分比特征和连续值特征
        const percentageFeatures = features.filter(f => f.unit === 'Percentage');
        const continuousFeatures = features.filter(f => f.unit !== 'Percentage');
        
        // 更新分组柱状图（百分比数据）
        if (percentageFeatures.length > 0) {
            const barLabels = percentageFeatures.map(f => f.feature_name);
            const solvableBarData = percentageFeatures.map(f => f.solvable_group);
            const hardBarData = percentageFeatures.map(f => f.hard_group);
            
            charts.solvabilityBar.data.labels = barLabels;
            charts.solvabilityBar.data.datasets[0].data = solvableBarData;
            charts.solvabilityBar.data.datasets[0].unit = 'Percentage';
            charts.solvabilityBar.data.datasets[1].data = hardBarData;
            charts.solvabilityBar.data.datasets[1].unit = 'Percentage';
            charts.solvabilityBar.update();
        } else {
            charts.solvabilityBar.data.labels = [];
            charts.solvabilityBar.data.datasets[0].data = [];
            charts.solvabilityBar.data.datasets[1].data = [];
            charts.solvabilityBar.update();
        }
        
        // 更新箱形图（连续数据，这里显示平均值）
        if (continuousFeatures && continuousFeatures.length > 0) {
            const boxLabels = continuousFeatures.map(f => f.feature_name);
            const solvableBoxData = continuousFeatures.map(f => f.solvable_group);
            const hardBoxData = continuousFeatures.map(f => f.hard_group);
            const unit = continuousFeatures[0]?.unit || '';
            
            charts.solvabilityBox.data.labels = boxLabels;
            charts.solvabilityBox.data.datasets[0].data = solvableBoxData;
            charts.solvabilityBox.data.datasets[0].unit = unit;
            charts.solvabilityBox.data.datasets[1].data = hardBoxData;
            charts.solvabilityBox.data.datasets[1].unit = unit;
            charts.solvabilityBox.update();
            console.log('箱形图数据已更新:', { boxLabels, solvableBoxData, hardBoxData });
        } else {
            charts.solvabilityBox.data.labels = [];
            charts.solvabilityBox.data.datasets[0].data = [];
            charts.solvabilityBox.data.datasets[1].data = [];
            charts.solvabilityBox.update();
            console.log('箱形图：无连续数据特征');
        }

        // 更新声誉箱线图（D3 绘制）
        if (payload.data.reputation_boxplot_data) {
            renderReputationBoxPlot(payload.data.reputation_boxplot_data);
        } else {
            renderReputationBoxPlot(null);
        }
        
        // 更新标签频率折线图
        if (payload.data.tag_frequency_data && payload.data.tag_frequency_data.length > 0) {
            const tagData = payload.data.tag_frequency_data;
            const tagLabels = tagData.map(t => t.tag_name);
            const solvableTagCounts = tagData.map(t => t.solvable_count);
            const hardTagCounts = tagData.map(t => t.hard_count);
            
            charts.tagFrequency.data.labels = tagLabels;
            charts.tagFrequency.data.datasets[0].data = solvableTagCounts;
            charts.tagFrequency.data.datasets[1].data = hardTagCounts;
            charts.tagFrequency.update();
        } else {
            charts.tagFrequency.data.labels = [];
            charts.tagFrequency.data.datasets[0].data = [];
            charts.tagFrequency.data.datasets[1].data = [];
            charts.tagFrequency.update();
        }
        
        // 更新评论频率折线图
        if (payload.data.comment_frequency_data) {
            const commentData = payload.data.comment_frequency_data;
            const solvableWithComments = commentData.solvable_with_comments;
            const solvableWithoutComments = commentData.solvable_total - solvableWithComments;
            const hardWithComments = commentData.hard_with_comments;
            const hardWithoutComments = commentData.hard_total - hardWithComments;
            
            charts.commentFrequency.data.datasets[0].data = [solvableWithComments, solvableWithoutComments];
            charts.commentFrequency.data.datasets[1].data = [hardWithComments, hardWithoutComments];
            charts.commentFrequency.update();
        } else {
            charts.commentFrequency.data.datasets[0].data = [0, 0];
            charts.commentFrequency.data.datasets[1].data = [0, 0];
            charts.commentFrequency.update();
        }
        
        // 更新代码片段比率分布图
        if (payload.data.code_snippet_ratio_distribution) {
            const ratioData = payload.data.code_snippet_ratio_distribution;
            charts.codeSnippetRatio.data.labels = ratioData.bins;
            charts.codeSnippetRatio.data.datasets[0].data = ratioData.solvable_frequencies;
            charts.codeSnippetRatio.data.datasets[1].data = ratioData.hard_frequencies;
            charts.codeSnippetRatio.update();
        }
        
        // 更新标签数分布图
        if (payload.data.tag_count_distribution) {
            const tagCountData = payload.data.tag_count_distribution;
            charts.tagCount.data.labels = tagCountData.bins;
            charts.tagCount.data.datasets[0].data = tagCountData.solvable_frequencies;
            charts.tagCount.data.datasets[1].data = tagCountData.hard_frequencies;
            charts.tagCount.update();
        }
        
        // 更新问题长度分布图
        if (payload.data.question_length_distribution) {
            const lengthData = payload.data.question_length_distribution;
            charts.questionLength.data.labels = lengthData.bins;
            charts.questionLength.data.datasets[0].data = lengthData.solvable_frequencies;
            charts.questionLength.data.datasets[1].data = lengthData.hard_frequencies;
            charts.questionLength.update();
        }
        
        // 更新声誉分布图
        if (payload.data.reputation_distribution) {
            const reputationData = payload.data.reputation_distribution;
            charts.reputation.data.labels = reputationData.bins;
            charts.reputation.data.datasets[0].data = reputationData.solvable_frequencies;
            charts.reputation.data.datasets[1].data = reputationData.hard_frequencies;
            charts.reputation.update();
        }
        
        // 更新评论数量分布图
        if (payload.data.comment_count_distribution) {
            const commentCountData = payload.data.comment_count_distribution;
            charts.commentCount.data.labels = commentCountData.bins;
            charts.commentCount.data.datasets[0].data = commentCountData.solvable_frequencies;
            charts.commentCount.data.datasets[1].data = commentCountData.hard_frequencies;
            charts.commentCount.update();
        }
    }
</script>
</body>
</html>