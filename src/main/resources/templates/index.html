<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org" lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stack Overflow Java Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            color-scheme: light;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f6f8;
            color: #1c1c1c;
        }
        .container {
            max-width: 1100px;
            margin: 0 auto;
        }
        header {
            text-align: center;
            margin-bottom: 24px;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 32px;
        }
        .stat-card {
            background: white;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        .stat-card .label {
            display: block;
            font-size: 0.9rem;
            color: #6b7280;
        }
        .stat-card .value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #111827;
        }
        .panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 24px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .panel-header {
            display: flex;
            justify-content: space-between;
            gap: 16px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 12px;
        }
        .panel-header h2 {
            margin: 0;
        }
        select, input[type="number"], input[type="date"], button {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            font-size: 0.95rem;
        }
        button {
            background: #2563eb;
            border: none;
            color: white;
            cursor: pointer;
        }
        button:hover {
            background: #1d4ed8;
        }
    </style>
</head>
<body>
<div class="container">
    <header>
        <h1>Stack Overflow Java Q&amp;A 分析面板</h1>
        <p>基于本地离线数据集的趋势、共现、多线程痛点与可解性洞察</p>
    </header>

    <section class="stats" id="metaSection">
        <div class="stat-card">
            <span class="label">线程数</span>
            <span class="value" id="threadCount">-</span>
        </div>
        <div class="stat-card">
            <span class="label">回答数</span>
            <span class="value" id="answerCount">-</span>
        </div>
        <div class="stat-card">
            <span class="label">评论数</span>
            <span class="value" id="commentCount">-</span>
        </div>
        <div class="stat-card">
            <span class="label">数据区间</span>
            <span class="value" id="dataRange">-</span>
        </div>
    </section>

    <section class="panel">
        <div class="panel-header">
            <div>
                <h2>Topic Trends</h2>
                <p>显示帖子数量前 N 的标签在等时长时间窗口内的趋势</p>
            </div>
            <div>
                <label for="trendTopN">Top N 标签：</label>
                <input id="trendTopN" type="number" min="3" max="20" value="8" style="width: 60px;">
                <label for="metricSelect" style="margin-left: 15px;">指标：</label>
                <select id="metricSelect">
                    <option value="QUESTIONS">发帖量</option>
                    <option value="ANSWERS">回答数</option>
                    <option value="SCORE">得分</option>
                    <option value="ENGAGEMENT">浏览量</option>
                </select>
                <button id="refreshTrends" style="margin-left: 10px;">刷新</button>
            </div>
        </div>
        <canvas id="topicTrendChart"></canvas>
    </section>

    <section class="panel">
        <div class="panel-header">
            <div>
                <h2>Topic Co-occurrence话题共现</h2>
                <p>力导向图展示话题共现关系：节点代表话题，边代表共现对，边的粗细代表共现频率</p>
            </div>
            <div>
                <label for="cooccurrenceSelect">Top N:</label>
                <input id="cooccurrenceSelect" type="number" min="3" max="50" value="10">
                <label for="filterCoreTopics" style="margin-left: 15px;">
                    <input type="checkbox" id="filterCoreTopics"> 只显示核心话题
                </label>
                <button id="refreshPairs" style="margin-left: 10px;">刷新</button>
            </div>
        </div>
        <div id="forceGraphContainer" style="width: 100%; height: 800px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff; overflow: visible; margin-bottom: 20px;"></div>
        <canvas id="cooccurrenceChart" style="max-height: 400px;"></canvas>
    </section>

    <section class="panel">
        <div class="panel-header">
            <div>
                <h2>Multithreading Common Pitfalls</h2>
                <p>Identify and categorize multithreading-related issues based on tags, titles, body text, and code snippets</p>
            </div>
            <div>
                <label for="pitfallSelect">Top N Categories:</label>
                <input id="pitfallSelect" type="number" min="1" max="10" value="5" title="Number of top categories to display (1-10)">
                <button id="refreshPitfalls">Refresh</button>
            </div>
        </div>
        <div id="sunburstContainer" style="width: 100%; height: 600px; border: 1px solid #e5e7eb; border-radius: 8px; background: #fff;"></div>
    </section>

    <section class="panel">
        <div class="panel-header">
            <div>
                <h2>可解性特征对比</h2>
                <p>比较容易解决 vs 难以解决问题在多个特征上的差异</p>
            </div>
            <div class="date-range">
                <label for="fromDate">From</label>
                <input type="date" id="fromDate">
                <label for="toDate">To</label>
                <input type="date" id="toDate">
                <button id="refreshSolvability">应用</button>
    </div>
    </div>
        <canvas id="solvabilityChart"></canvas>
    </section>
</div>

<script>
    const charts = {};

    document.addEventListener('DOMContentLoaded', () => {
        loadMetadata();
        initTopicTrendChart();
        initCooccurrenceChart();
        initPitfallChart();
        initSolvabilityChart();
    });

    async function fetchJson(url) {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`请求失败：${response.status}`);
        }
        return response.json();
    }

    async function loadMetadata() {
        const payload = await fetchJson('/api/metadata/status');
        const meta = payload.data;
        document.getElementById('threadCount').innerText = meta.threadCount;
        document.getElementById('answerCount').innerText = meta.answerCount;
        document.getElementById('commentCount').innerText = meta.commentCount;
        document.getElementById('dataRange').innerText = `${meta.earliestQuestion ?? '-'} ~ ${meta.latestQuestion ?? '-'}`;
    }

    function initTopicTrendChart() {
        const ctx = document.getElementById('topicTrendChart').getContext('2d');
        charts.topicTrends = new Chart(ctx, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                responsive: true,
                interaction: { mode: 'index', intersect: false },
                plugins: { legend: { position: 'bottom' } }
            }
        });
        document.getElementById('metricSelect').addEventListener('change', loadTopicTrends);
        document.getElementById('refreshTrends').addEventListener('click', loadTopicTrends);
        loadTopicTrends();
    }

    async function loadTopicTrends() {
        const metric = document.getElementById('metricSelect').value;
        const topN = document.getElementById('trendTopN').value;
        const payload = await fetchJson(`/api/topic-trends?metric=${metric}&topN=${topN}`);
        const data = payload.data;
        const labels = [...new Set(data.series.flatMap(series => series.points.map(p => p.bucket)))].sort();
        const colorPalette = ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#7E57C2', '#26A69A'];
        const datasets = data.series.map((series, index) => ({
            label: series.topic,
            data: labels.map(label => {
                const point = series.points.find(p => p.bucket === label);
                return point ? point.value : 0;
            }),
            borderColor: colorPalette[index % colorPalette.length],
            tension: 0.3,
            fill: false
        }));
        charts.topicTrends.data.labels = labels;
        charts.topicTrends.data.datasets = datasets;
        charts.topicTrends.update();
    }

    let forceGraphSimulation = null;

    function initCooccurrenceChart() {
        // 初始化柱状图
        const ctx = document.getElementById('cooccurrenceChart').getContext('2d');
        charts.cooccurrence = new Chart(ctx, {
            type: 'bar',
            data: { labels: [], datasets: [{ label: '共现次数', data: [], backgroundColor: '#36A2EB' }] },
            options: { 
                responsive: true, 
                maintainAspectRatio: true,
                plugins: { 
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return '共现次数: ' + context.parsed.y;
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: '共现频率'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: '话题对'
                        }
                    }
                }
            }
        });
        
        document.getElementById('refreshPairs').addEventListener('click', loadCooccurrence);
        document.getElementById('cooccurrenceSelect').addEventListener('change', loadCooccurrence);
        document.getElementById('filterCoreTopics').addEventListener('change', loadCooccurrence);
        loadCooccurrence();
    }

    async function loadCooccurrence() {
        const topN = document.getElementById('cooccurrenceSelect').value;
        const filterCoreTopics = document.getElementById('filterCoreTopics').checked;
        const url = `/api/cooccurrence?topN=${topN}&filterCoreTopics=${filterCoreTopics}`;
        const payload = await fetchJson(url);
        
        // 渲染力导向图
        renderForceDirectedGraph(payload.data.pairs);
        
        // 更新柱状图
        const labels = payload.data.pairs.map(pair => pair.topic_pair.join(' & '));
        const data = payload.data.pairs.map(pair => pair.frequency);
        charts.cooccurrence.data.labels = labels;
        charts.cooccurrence.data.datasets[0].data = data;
        charts.cooccurrence.update();
    }

    function renderForceDirectedGraph(pairs) {
        const container = document.getElementById('forceGraphContainer');
        container.innerHTML = '';
        
        if (!pairs || pairs.length === 0) {
            container.innerHTML = '<p style="text-align: center; padding: 50px; color: #6b7280;">暂无数据</p>';
            return;
        }

        // 停止之前的模拟（如果存在）
        if (forceGraphSimulation) {
            forceGraphSimulation.stop();
        }

        const width = container.clientWidth;
        const height = 800;  // 增加高度，避免节点跑到外面

        // 收集所有唯一的节点（话题）
        const nodeMap = new Map();
        pairs.forEach(pair => {
            pair.topic_pair.forEach(topic => {
                if (!nodeMap.has(topic)) {
                    nodeMap.set(topic, { id: topic, name: topic });
                }
            });
        });

        const nodes = Array.from(nodeMap.values());
        const nodeByIdMap = new Map(nodes.map(n => [n.id, n]));

        // 创建链接（边）数组，使用节点 ID 字符串（d3.forceLink 会自动转换为节点对象）
        const links = pairs.map(pair => ({
            source: pair.topic_pair[0],  // 使用 ID 字符串，d3.forceLink().id() 会转换为节点对象
            target: pair.topic_pair[1],
            frequency: pair.frequency
        }));

        // 计算频率范围，用于设置边的粗细
        const frequencies = links.map(l => l.frequency);
        const minFreq = Math.min(...frequencies);
        const maxFreq = Math.max(...frequencies);
        const freqRange = maxFreq - minFreq;

        // 创建 SVG，使用更大的尺寸并允许溢出
        const svg = d3.select(container)
            .append('svg')
            .attr('width', width)
            .attr('height', height)
            .style('overflow', 'visible');
        
        // 添加定义，用于文本背景
        const defs = svg.append('defs');
        
        // 添加文本背景的过滤器（用于更好的可读性）
        const filter = defs.append('filter')
            .attr('id', 'text-background')
            .attr('x', '-50%')
            .attr('y', '-50%')
            .attr('width', '200%')
            .attr('height', '200%');
        
        filter.append('feFlood')
            .attr('flood-color', 'white')
            .attr('flood-opacity', '0.8')
            .attr('result', 'bg');
        
        filter.append('feComposite')
            .attr('in', 'bg')
            .attr('in2', 'SourceAlpha')
            .attr('operator', 'in');

        // 创建力导向图模拟
        // 注意：distance 函数中的参数是 link，频率越高，距离越近
        forceGraphSimulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(links)
                .id(d => d.id)
                .distance(d => {
                    // 频率越高，距离越近（但保持最小距离）
                    return Math.max(20, 200 - (d.frequency / maxFreq) * 120);
                }))
            .force('charge', d3.forceManyBody().strength(-100))  // 增加排斥力，让节点分布更均匀
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(10));  // 增加碰撞半径，避免节点重叠

        // 绘制链接（边）
        const link = svg.append('g')
            .selectAll('line')
            .data(links)
            .enter().append('line')
            .attr('stroke', '#999')
            .attr('stroke-opacity', 0.6)
            .attr('stroke-width', d => {
                // 边的粗细映射到频率：最小2px，最大10px
                const thickness = 2 + (d.frequency - minFreq) / freqRange * 8;
                return Math.max(2, Math.min(10, thickness));
            });

        // 绘制节点
        const node = svg.append('g')
            .selectAll('circle')
            .data(nodes)
            .enter().append('circle')
            .attr('r', 12)
            .attr('fill', '#2563eb')
            .attr('stroke', '#fff')
            .attr('stroke-width', 2)
            .call(drag(forceGraphSimulation));

        // 添加标签
        const label = svg.append('g')
            .selectAll('text')
            .data(nodes)
            .enter().append('text')
            .text(d => d.name)
            .attr('font-size', '12px')
            .attr('dx', 15)
            .attr('dy', 4)
            .attr('fill', '#1c1c1c')
            .style('pointer-events', 'none');

        // 添加悬停提示
        node.append('title')
            .text(d => d.name);

        // 在链接上添加悬停提示
        link.append('title')
            .text(d => {
                // d3.forceLink 会将 source/target 转换为节点对象
                const sourceName = typeof d.source === 'object' ? d.source.name : d.source;
                const targetName = typeof d.target === 'object' ? d.target.name : d.target;
                return `${sourceName} & ${targetName}: ${d.frequency} 次共现`;
            });
        
        // 在边的中间位置添加频率标签
        const linkLabel = svg.append('g')
            .selectAll('text')
            .data(links)
            .enter().append('text')
            .text(d => d.frequency)
            .attr('font-size', '10px')
            .attr('font-weight', 'bold')
            .attr('fill', '#374151')  // 深灰色
            .attr('text-anchor', 'middle')
            .style('pointer-events', 'none')
            .style('filter', 'url(#text-background)');  // 添加背景以提高可读性

        // 更新位置函数
        function ticked() {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            node
                .attr('cx', d => d.x)
                .attr('cy', d => d.y);

            label
                .attr('x', d => d.x)
                .attr('y', d => d.y);
            
            // 更新边的标签位置（在边的中点）
            linkLabel
                .attr('x', d => (d.source.x + d.target.x) / 2)
                .attr('y', d => (d.source.y + d.target.y) / 2);
        }

        // 启动模拟
        forceGraphSimulation.on('tick', ticked);

        // 拖拽函数
        function drag(simulation) {
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }

            return d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended);
        }
    }

    let sunburstData = null;

    function initPitfallChart() {
        document.getElementById('refreshPitfalls').addEventListener('click', loadPitfalls);
        document.getElementById('pitfallSelect').addEventListener('change', loadPitfalls);
        loadPitfalls();
    }

    async function loadPitfalls() {
        const topN = document.getElementById('pitfallSelect').value;
        const payload = await fetchJson(`/api/multithreading/pitfalls?topN=${topN}`);
        sunburstData = payload.data;
        renderSunburstChart(sunburstData);
    }

    function renderSunburstChart(data) {
        const container = document.getElementById('sunburstContainer');
        container.innerHTML = '';
        
        if (!data || !data.categories || data.categories.length === 0) {
            container.innerHTML = '<p style="text-align: center; padding: 50px; color: #6b7280;">No data available</p>';
            return;
        }

        const width = container.clientWidth;
        const height = 600;
        const radius = Math.min(width, height) / 2 - 10;

        // Create SVG
        const svg = d3.select(container)
            .append('svg')
            .attr('width', width)
            .attr('height', height)
            .append('g')
            .attr('transform', `translate(${width / 2},${height / 2})`);

        // Color scheme for categories
        const categoryColors = {
            'Synchronization Issues': '#FF6384',
            'Memory Consistency': '#36A2EB',
            'Concurrent Data Structures': '#FFCE56',
            'Thread Pool & Executors': '#4BC0C0',
            'Performance Issues': '#9966FF',
            'Others': '#FF9F40'
        };

        // Build hierarchical data structure
        // Ensure inner ring value equals sum of outer ring values
        const root = {
            name: 'Multithreading Pitfalls',
            children: data.categories.map(category => {
                // Calculate actual sum from pitfalls
                const actualTotal = category.pitfalls.reduce((sum, p) => sum + p.count, 0);
                return {
                    name: category.category,
                    value: actualTotal, // Use actual sum instead of totalCount to ensure consistency
                    children: category.pitfalls.map(pitfall => ({
                        name: pitfall.label,
                        value: pitfall.count,
                        category: category.category
                    }))
                };
            })
        };

        // Create partition layout
        const partition = d3.partition()
            .size([2 * Math.PI, radius]);

        const rootNode = d3.hierarchy(root)
            .sum(d => d.value)
            .sort((a, b) => b.value - a.value);

        partition(rootNode);

        // Color function
        const color = d3.scaleOrdinal()
            .domain(Object.keys(categoryColors))
            .range(Object.values(categoryColors));

        // Create arcs
        const arc = d3.arc()
            .startAngle(d => d.x0)
            .endAngle(d => d.x1)
            .innerRadius(d => d.y0)
            .outerRadius(d => d.y1);

        // Draw arcs
        const arcs = svg.selectAll('path')
            .data(rootNode.descendants())
            .enter()
            .append('path')
            .attr('d', arc)
            .attr('fill', d => {
                if (d.depth === 0) return '#f0f0f0';
                if (d.depth === 1) return color(d.data.name) || '#999';
                return d3.color(color(d.data.category) || '#999').brighter(0.5);
            })
            .attr('stroke', '#fff')
            .attr('stroke-width', 2)
            .style('cursor', 'pointer')
            .on('mouseover', function(event, d) {
                d3.select(this)
                    .attr('opacity', 0.8)
                    .attr('stroke-width', 3);
                
                // Show tooltip
                const tooltip = d3.select('body').append('div')
                    .attr('class', 'tooltip')
                    .style('opacity', 0)
                    .style('position', 'absolute')
                    .style('background', 'rgba(0, 0, 0, 0.8)')
                    .style('color', 'white')
                    .style('padding', '8px')
                    .style('border-radius', '4px')
                    .style('pointer-events', 'none')
                    .style('font-size', '12px');
                
                let label, count;
                if (d.depth === 1) {
                    // Category level
                    label = d.data.name;
                    count = d.value;
                } else {
                    // Pitfall level
                    label = `${d.data.category} - ${d.data.name}`;
                    count = d.value;
                }
                tooltip.html(`${label}<br/>Count: ${count}`)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px')
                    .transition()
                    .duration(200)
                    .style('opacity', 1);
            })
            .on('mousemove', function(event) {
                d3.select('.tooltip')
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            })
            .on('mouseout', function() {
                d3.select(this)
                    .attr('opacity', 1)
                    .attr('stroke-width', 2);
                d3.select('.tooltip').remove();
            });

        // Add labels for categories (inner ring) with better positioning
        svg.selectAll('text.category')
            .data(rootNode.children || [])
            .enter()
            .append('text')
            .attr('class', 'category')
            .attr('transform', d => {
                const angle = (d.x0 + d.x1) / 2;
                const radius = (d.y0 + d.y1) / 2;
                const x = Math.cos(angle - Math.PI / 2) * radius;
                const y = Math.sin(angle - Math.PI / 2) * radius;
                const rotation = angle * 180 / Math.PI;
                return `translate(${x},${y}) rotate(${rotation < 90 || rotation > 270 ? rotation : rotation + 180})`;
            })
            .attr('dy', '0.35em')
            .attr('text-anchor', 'middle')
            .attr('font-size', '13px')
            .attr('font-weight', 'bold')
            .attr('fill', '#333')
            .attr('stroke', '#fff')
            .attr('stroke-width', '0.3px')
            .attr('paint-order', 'stroke')
            .text(d => d.data.name)
            .style('pointer-events', 'none');

        // Add labels for pitfalls (outer ring) - only if space allows
        svg.selectAll('text.pitfall')
            .data(rootNode.descendants().filter(d => d.depth === 2 && d.value > 0))
            .enter()
            .append('text')
            .attr('class', 'pitfall')
            .attr('transform', d => {
                const x = ((d.x0 + d.x1) / 2) * 180 / Math.PI;
                const y = -(d.y0 + d.y1) / 2;
                return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
            })
            .attr('dy', '0.35em')
            .attr('text-anchor', d => (d.x0 + d.x1) / 2 < Math.PI ? 'start' : 'end')
            .attr('font-size', '10px')
            .attr('fill', '#666')
            .text(d => {
                // Only show label if arc is large enough
                const angle = (d.x1 - d.x0) * 180 / Math.PI;
                return angle > 10 ? d.data.name : '';
            })
            .style('pointer-events', 'none');
    }

    function initSolvabilityChart() {
        const ctx = document.getElementById('solvabilityChart').getContext('2d');
        charts.solvability = new Chart(ctx, {
            type: 'radar',
            data: {
                labels: [],
                datasets: [
                    { label: '易解决', data: [], borderColor: '#4BC0C0', backgroundColor: 'rgba(75,192,192,0.2)' },
                    { label: '难解决', data: [], borderColor: '#E91E63', backgroundColor: 'rgba(233,30,99,0.2)' }
                ]
            },
            options: { responsive: true }
        });
        document.getElementById('refreshSolvability').addEventListener('click', loadSolvability);
        loadSolvability();
    }

    async function loadSolvability() {
        const from = document.getElementById('fromDate').value;
        const to = document.getElementById('toDate').value;
        const params = new URLSearchParams();
        if (from) params.append('from', from);
        if (to) params.append('to', to);
        const query = params.toString();
        const payload = await fetchJson(query ? `/api/solvability/contrast?${query}` : '/api/solvability/contrast');
        const labels = payload.data.features.map(feature => feature.name);
        const solvable = payload.data.features.map(feature => feature.solvable.average);
        const hard = payload.data.features.map(feature => feature.hard.average);
        charts.solvability.data.labels = labels;
        charts.solvability.data.datasets[0].data = solvable;
        charts.solvability.data.datasets[1].data = hard;
        charts.solvability.update();
    }
</script>
</body>
</html>