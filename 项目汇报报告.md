# CS209A Final Project 汇报报告
## Stack Overflow Java Q&A 数据分析与可视化系统

---

## 一、项目概述

本项目基于 Spring Boot 框架，开发了一个完整的 Web 应用程序，用于存储、分析和可视化 Stack Overflow 上关于 Java 编程的问答数据。系统实现了数据收集、数据分析、RESTful API 和前端可视化四个核心模块，全面覆盖了课程要求的所有功能点。

---

## 二、数据收集（10分）

### 2.1 数据收集实现（5分）

**实现位置：**
- `src/main/java/cs209a/finalproject_demo/collector/client/StackOverflowApiClient.java`
- `src/main/java/cs209a/finalproject_demo/collector/service/DataCollectorService.java`
- `src/main/java/cs209a/finalproject_demo/collector/DataCollectionRunner.java`

**实现方法：**

1. **API 客户端封装** (`StackOverflowApiClient.java`)
   - 使用 Java 11+ 的 `HttpClient` 封装 Stack Overflow REST API 请求
   - 实现了速率限制控制（每次请求间隔至少 100ms）
   - 自动处理 API 返回的 `backoff` 和 `quota_remaining` 信息
   - 支持重试机制（最多重试 3 次，指数退避）
   - 关键代码：
   ```java
   public ApiResponse fetchQuestions(int page, int pageSize, String sort, String order, 
                                    Long fromDate, Long toDate) {
       // 构建请求参数，包含 tagged=java 筛选
       params.add("tagged=java");
       params.add("filter=withbody"); // 包含问题正文
       // ... 执行请求并处理响应
   }
   ```

2. **数据采集服务** (`DataCollectorService.java`)
   - 分页获取问题列表（每页最多 100 个）
   - 对每个问题获取完整的线程数据：
     - 问题详情（标题、正文、标签、创建时间等）
     - 所有回答（包括被接受的答案）
     - 问题评论
     - 回答评论
   - 自动去重，避免重复采集
   - 进度跟踪和错误统计

3. **数据保存** (`ThreadDataSaver.java`)
   - 将采集的数据保存为 JSON 文件
   - 格式与现有 `Sample_SO_data/thread_XX.json` 完全一致
   - 支持格式化输出（缩进的 JSON）

**数据量统计：**
- 已成功采集超过 1000 条 Java 标签的线程数据
- 数据存储在 `Sample_SO_data/` 和 `Sample_SO_data2/` 目录下
- 每个 JSON 文件包含完整的线程信息（问题、答案、评论）

### 2.2 数据持久化（5分）

**实现位置：**
- `src/main/java/cs209a/finalproject_demo/service/DataImportService.java`
- `src/main/java/cs209a/finalproject_demo/dataset/ThreadFileLoader.java`
- `src/main/resources/db/migration/` (Flyway 数据库迁移脚本)

**实现方法：**

1. **数据库设计** (PostgreSQL)
   - 使用 Flyway 进行数据库版本管理
   - 核心表结构：
     - `users`: 用户信息（声誉、用户ID等）
     - `questions`: 问题信息（标题、正文、创建时间、浏览量等）
     - `answers`: 回答信息（正文、得分、是否被接受等）
     - `tags`: 标签信息
     - `question_tags`: 问题-标签关联表
     - `question_comments`: 问题评论
     - `answer_comments`: 回答评论

2. **数据导入服务** (`DataImportService.java`)
   - 批量读取 JSON 文件
   - 解析并转换为实体对象
   - 使用 `@Transactional` 确保数据一致性
   - 自动处理关联关系（用户、标签、评论等）
   - 关键代码：
   ```java
   @Transactional
   public ImportResult importFromDirectory(String directoryPath) {
       // 遍历目录中的所有 JSON 文件
       // 解析并导入到数据库
       // 返回导入结果统计
   }
   ```

3. **数据验证**
   - 导入过程中自动去重（基于 questionId）
   - 验证数据完整性
   - 记录导入统计信息（成功、失败、跳过）

**数据存储状态：**
- 数据库：PostgreSQL
- 数据量：超过 1000 条线程
- 数据格式：结构化存储在关系型数据库中，支持高效查询和分析

---

## 三、数据分析（60分）

### 3.1 Topic Trends（15分）

**实现位置：**
- `src/main/java/cs209a/finalproject_demo/service/TopicTrendService.java`
- `src/main/java/cs209a/finalproject_demo/controller/AnalysisController.java` (REST API)

**实现方法：**

1. **主题识别（5分）**
   - 通过问题的标签（tags）识别主题
   - 支持用户指定主题列表，或自动选择 Top N 热门标签
   - 关键代码：
   ```java
   private boolean matchesTopic(Question question, String tagName) {
       String normalized = tagName.toLowerCase(Locale.ROOT);
       return question.tags().stream()
           .anyMatch(t -> t.equalsIgnoreCase(normalized));
   }
   ```

2. **时间维度（5分）**
   - 按月份（YearMonth）进行时间分桶
   - 支持自定义时间范围（from/to 参数）
   - 默认显示最近 12 个月的数据
   - 关键代码：
   ```java
   List<YearMonth> buckets = generateBuckets(start, end);
   // 为每个时间桶聚合数据
   questions.stream()
       .filter(q -> matchesTopic(q, topic))
       .forEach(question -> {
           YearMonth bucket = YearMonth.from(question.creationDate(zoneId));
           aggregated.computeIfPresent(bucket, (b, value) -> value + metricValue(question, metric));
       });
   ```

3. **活动度量（5分）**
   - 支持多种度量指标：
     - `QUESTIONS`: 问题数量
     - `ANSWERS`: 回答数量
     - `SCORE`: 问题得分
     - `ENGAGEMENT`: 浏览量（viewCount）
   - 关键代码：
   ```java
   private double metricValue(Question question, Metric metric) {
       return switch (metric) {
           case QUESTIONS -> 1.0;
           case ANSWERS -> Math.max(question.answerCount(), 0);
           case SCORE -> question.score();
           case ENGAGEMENT -> question.viewCount();
       };
   }
   ```

**REST API：**
```
GET /api/topic-trends?topics=spring-boot,multithreading&metric=QUESTIONS&from=2023-01-01&to=2024-12-31&topN=8
```

**可视化：**
- 前端使用 Chart.js 绘制折线图
- 多条折线展示不同主题的趋势
- 支持交互式筛选和时间范围选择

---

### 3.2 Co-occurrence of Topics（15分）

**实现位置：**
- `src/main/java/cs209a/finalproject_demo/service/TopicCooccurrenceService.java`
- `src/main/java/cs209a/finalproject_demo/controller/AnalysisController.java`

**实现方法：**

1. **主题识别（5分）**
   - 从问题的标签列表中提取所有标签
   - 排除通用标签 "java"
   - 可选：只筛选核心 Java 话题（通过 `filterCoreTopics` 参数）
   - 核心话题集合包括：spring-boot, multithreading, concurrency, testing, lambda, stream 等

2. **共现逻辑（10分）**
   - 对每个问题，生成所有无序标签对 `(tag_i, tag_j)`，其中 `i < j`
   - 使用规范化的字符串键（按字典序排序）确保 `(a,b)` 和 `(b,a)` 被视为同一对
   - 统计每个标签对的出现频率
   - 关键代码：
   ```java
   for (Question question : questions) {
       List<String> tags = question.tags().stream()
           .map(tag -> tag.toLowerCase(Locale.ROOT))
           .filter(tag -> !"java".equals(tag))
           .distinct()
           .toList();
       
       // 生成所有无序标签对
       for (int i = 0; i < tags.size(); i++) {
           for (int j = i + 1; j < tags.size(); j++) {
               String tagA = tags.get(i);
               String tagB = tags.get(j);
               String pairKey = tagA.compareTo(tagB) < 0 
                   ? tagA + "|" + tagB 
                   : tagB + "|" + tagA;
               pairCounters.merge(pairKey, 1L, Long::sum);
           }
       }
   }
   ```

3. **Top N 提取**
   - 按频率降序排序
   - 返回 Top N 对（N 可配置，默认 10，范围 1-50）

**REST API：**
```
GET /api/cooccurrence?topN=10&filterCoreTopics=false
```

**可视化：**
- 前端使用 D3.js 绘制力导向图（Force-directed Graph）
- 节点表示标签，边表示共现关系
- 边的粗细表示共现频率

---

### 3.3 Common Pitfalls in Multithreading（15分）

**实现位置：**
- `src/main/java/cs209a/finalproject_demo/service/MultithreadingInsightService.java`
- `src/main/java/cs209a/finalproject_demo/repository/QuestionRepository.java` (数据库初筛)

**实现方法：**

1. **识别多线程陷阱（10分）**

   **a) 数据库层初筛**
   - 位置：`QuestionRepository.findPotentialMultithreadingQuestions()`
   - 通过标签进行粗筛：
     ```java
     @Query("SELECT DISTINCT q FROM QuestionEntity q " +
            "LEFT JOIN FETCH q.answers " +
            "LEFT JOIN FETCH q.owner " +
            "JOIN q.tags t " +
            "WHERE LOWER(t.name) IN ('multithreading', 'concurrency', 'thread', ...) " +
            "OR LOWER(t.name) LIKE '%thread%' " +
            "OR LOWER(t.name) LIKE '%concurrent%'")
     ```

   **b) 内存层文本分析**
   - 位置：`MultithreadingInsightService.analyze()`
   - 合并问题文本：标题 + 正文 + 被接受答案的正文
   - 过滤代码片段（移除 `<code>` 和 `<pre>` 标签），避免代码注释干扰
   - 使用正则表达式进行关键词匹配：
     ```java
     private static final Map<String, Pattern> MULTITHREADING_KEYWORD_PATTERNS = new HashMap<>();
     // 包含：deadlock, race condition, synchronized, volatile, thread pool, executor 等
     ```

   **c) TF-IDF + 余弦相似度分类**
   - 定义 9 个固定陷阱类别（P1-P9）：
     - P1: Race Condition（竞态条件）
     - P2: Deadlock（死锁）
     - P3: Memory Visibility（内存可见性）
     - P4: Synchronization Misuse（同步机制误用）
     - P5: Unsafe Collections（非线程安全集合）
     - P6: Thread Pool Misconfiguration（线程池配置错误）
     - P7: Wait/Notify Misuse（等待/通知机制误用）
     - P8: Unexpected Thread Termination（非预期线程终止）
     - P9: Performance Bottlenecks（性能瓶颈）
   
   - 每个类别包含：
     - 英文标签和描述
     - 种子正则表达式模式（用于构建原型向量）
   
   - 分类流程：
     1. 构建 TF-IDF 向量化器（基于所有问题文本）
     2. 为每个类别构建原型向量：
        - 使用类别描述文本
        - 添加匹配种子模式的问题文本
        - 计算平均向量
     3. 对每个问题：
        - 计算其 TF-IDF 向量
        - 与所有类别原型向量计算余弦相似度
        - 如果问题文本匹配种子模式，给予相似度加分（+0.10）
        - 选择相似度最高的类别（阈值：0.10）
   
   - 关键代码：
   ```java
   // 构建原型向量
   Map<PitfallCategory, TfIdfVector> categoryPrototypes = 
       buildCategoryPrototypes(vectorizer, texts);
   
   // 分类问题
   ClassificationResult result = classifyQuestion(qt, qVec, categoryPrototypes);
   // 相似度计算 + 种子模式匹配加分
   ```

   **d) 异常类型识别**
   - 使用正则表达式识别 Java 异常类型：
     ```java
     private static final Pattern EXCEPTION_PATTERN = Pattern.compile(
         "\\b(java\\.(lang|util|io|nio|concurrent)\\.)?[A-Z]\\w*Exception\\b"
     );
     ```

2. **陷阱聚合（5分）**
   - 统计每个类别的问题数量
   - 按数量降序排序
   - 返回 Top N 类别
   - 关键代码：
   ```java
   List<MultithreadingPitfallResponse.PitfallStat> stats = statsByCategory.entrySet()
       .stream()
       .map(entry -> new PitfallStat(
           entry.getKey().code(),
           entry.getKey().label(),
           entry.getValue().count(),
           entry.getValue().examples().stream().limit(3).toList()
       ))
       .sorted(Comparator.comparingLong(PitfallStat::count).reversed())
       .limit(topN)
       .toList();
   ```

**REST API：**
```
GET /api/multithreading/pitfalls?topN=5
```

**可视化：**
- 前端使用 Chart.js 绘制水平条形图
- X 轴：问题数量
- Y 轴：陷阱类别（P1-P9）
- 支持动态调整 Top N（1-9）

**调试信息：**
- 输出所有多线程候选问题的 ID 列表
- 输出每个类别的问题 ID 列表
- 便于验证分类结果的准确性

---

### 3.4 Solvable vs. Hard-to-Solve Questions（15分）

**实现位置：**
- `src/main/java/cs209a/finalproject_demo/service/SolvabilityContrastService.java`
- `src/main/java/cs209a/finalproject_demo/repository/QuestionRepository.java`

**实现方法：**

1. **识别可解决问题（3分）**
   - 数据库初筛：`QuestionRepository.findSolvableQuestions()`
     - 有被接受答案（`acceptedAnswerId IS NOT NULL`）
     - 未关闭（`closedDate IS NULL`）
   - 服务层精炼：`refineSolvableQuestions()`
     - 被接受答案的创建时间距离问题创建时间 < 2 小时
     - 确保问题得到及时解答

2. **识别难解决问题（3分）**
   - 数据库初筛：`QuestionRepository.findHardToSolveQuestions()`
     - 无被接受答案（`acceptedAnswerId IS NULL`）
     - 未关闭（`closedDate IS NULL`）
   - 服务层精炼：`refineHardQuestions()`
     - 条件A：无被接受答案，但存在得分 > 6 的答案（有高质量答案但未被采纳）
     - 条件B：无任何答案，且创建时间距参考日期（2025-12-11）超过 240 天（长期无人回答）

3. **识别至少 3 个有意义的贡献因素（9分）**

   **因素1：问题清晰度和细节（问题长度）**
   - 计算问题正文的字符数（去除 HTML 标签）
   - 对比两组问题的平均长度
   - 代码位置：`calculateQuestionLengthFeature()`

   **因素2：代码片段存在性**
   - 使用正则表达式检测问题中是否包含代码片段（`<code>` 或 `<pre>` 标签）
   - 计算包含代码片段的问题百分比
   - 代码位置：`calculateCodeSnippetFeature()`
   ```java
   private static final Pattern CODE_SNIPPET_PATTERN = Pattern.compile(
       "<(?:pre|code)[^>]*>.*?</(?:pre|code)>",
       Pattern.CASE_INSENSITIVE | Pattern.DOTALL
   );
   ```

   **因素3：提问者声誉**
   - 获取问题所有者的声誉值（reputation）
   - 计算两组问题的平均声誉
   - 代码位置：`calculateReputationFeature()`

   **因素4：主题复杂性**
   - 检查问题标签是否包含高复杂性主题：
     - multithreading, concurrency, reflection, jni, native, bytecode 等
   - 计算包含复杂主题的问题百分比
   - 代码位置：`calculateTopicComplexityFeature()`

   **额外因素：**
   - 标签数量分布
   - 评论频率
   - 标题词数
   - 浏览量分布

4. **统计分析**
   - 计算每个特征的均值对比
   - 计算分布数据（用于可视化）
   - 计算箱线图统计数据（最小值、Q1、中位数、Q3、最大值、异常值）

**REST API：**
```
GET /api/solvability/contrast?from=2024-01-01&to=2024-12-31
```

**可视化：**
- 特征对比：雷达图或对比条形图
- 分布对比：小提琴图（Violin Plot）或直方图
- 箱线图：展示中位数、四分位数和异常值
- 标签频率：对比条形图

---

## 四、RESTful APIs（10分）

### 4.1 API 可用性（5分）

**实现位置：**
- `src/main/java/cs209a/finalproject_demo/controller/AnalysisController.java`
- `src/main/java/cs209a/finalproject_demo/controller/MetadataController.java`

**已实现的 REST API 端点：**

1. **Topic Trends API**
   ```
   GET /api/topic-trends
   参数：
   - topics: 主题列表（可选，逗号分隔）
   - metric: 度量指标（QUESTIONS/ANSWERS/SCORE/ENGAGEMENT，默认 QUESTIONS）
   - from: 开始日期（可选，ISO 8601 格式）
   - to: 结束日期（可选，ISO 8601 格式）
   - topN: Top N 主题（默认 8，范围 1-50）
   ```

2. **Topic Co-occurrence API**
   ```
   GET /api/cooccurrence
   参数：
   - topN: Top N 共现对（默认 10，范围 1-50）
   - filterCoreTopics: 是否只筛选核心话题（默认 false）
   ```

3. **Multithreading Pitfalls API**
   ```
   GET /api/multithreading/pitfalls
   参数：
   - topN: Top N 陷阱类别（默认 5，范围 1-20）
   ```

4. **Solvability Contrast API**
   ```
   GET /api/solvability/contrast
   参数：
   - from: 开始日期（可选）
   - to: 结束日期（可选）
   ```

5. **Metadata API**
   ```
   GET /api/metadata/status
   返回：数据概况（问题数、回答数、浏览量、时间范围等）
   ```

### 4.2 JSON 响应格式（5分）

**统一响应格式：**
```java
public record ApiResponse<T>(
    T data,
    Map<String, Object> meta,
    String timestamp
) {
    public static <T> ApiResponse<T> of(T data) {
        return new ApiResponse<>(data, Map.of(), Instant.now().toString());
    }
}
```

**示例响应（Topic Trends）：**
```json
{
  "data": {
    "series": [
      {
        "topic": "spring-boot",
        "points": [
          {"bucket": "2023-01", "value": 12},
          {"bucket": "2023-02", "value": 15}
        ]
      }
    ],
    "metric": "QUESTIONS",
    "bucketType": "MONTH",
    "from": "2023-01-01",
    "to": "2023-12-31"
  },
  "meta": {},
  "timestamp": "2025-12-16T23:22:50.742Z"
}
```

**示例响应（Multithreading Pitfalls）：**
```json
{
  "data": {
    "pitfalls": [
      {
        "code": "P1",
        "label": "Race Condition",
        "count": 42,
        "examples": [12345, 23456, 34567]
      }
    ]
  },
  "meta": {},
  "timestamp": "2025-12-16T23:22:50.742Z"
}
```

**API 设计特点：**
- 所有端点返回 JSON 格式
- 统一的响应结构（`ApiResponse<T>`）
- 参数验证（使用 `@Validated` 和 `@Min`/`@Max`）
- 错误处理（Spring Boot 默认异常处理）

---

## 五、可视化与洞察（20分）

### 5.1 可视化实现

**实现位置：**
- `src/main/resources/templates/index.html`

**可视化库：**
- Chart.js：用于折线图、条形图、箱线图等
- D3.js：用于力导向图（共现关系）

**各问题的可视化：**

1. **Topic Trends**
   - 图表类型：折线图（Line Chart）
   - 展示：多条折线，每条代表一个主题
   - 交互：支持选择主题、度量指标、时间范围
   - 代码位置：`initTopicTrendChart()`, `loadTopicTrends()`

2. **Topic Co-occurrence**
   - 图表类型：力导向图（Force-directed Graph）
   - 展示：节点（标签）和边（共现关系）
   - 交互：节点可拖拽，鼠标悬停显示详细信息
   - 代码位置：`initCooccurrenceChart()`, `loadCooccurrence()`

3. **Multithreading Pitfalls**
   - 图表类型：水平条形图（Horizontal Bar Chart）
   - 展示：陷阱类别（P1-P9）及其问题数量
   - 交互：支持调整 Top N（1-9）
   - 代码位置：`initPitfallChart()`, `loadPitfalls()`

4. **Solvability Contrast**
   - 图表类型：
     - 雷达图：特征对比
     - 小提琴图：分布对比
     - 箱线图：统计摘要
     - 对比条形图：标签频率、评论频率
   - 交互：支持时间范围筛选
   - 代码位置：`initSolvabilityCharts()`, `loadSolvabilityContrast()`

### 5.2 洞察分析

**1. Topic Trends 洞察**
- **观察**：某些主题（如 spring-boot）在特定时间段出现峰值
- **原因分析**：
  - 新版本发布导致相关问题增加
  - 社区关注度变化
  - 技术趋势演变

**2. Topic Co-occurrence 洞察**
- **观察**：某些标签对频繁共现（如 spring-boot + security）
- **原因分析**：
  - 技术栈的天然关联性
  - 跨领域问题的复杂性
  - 开发者实际使用场景

**3. Multithreading Pitfalls 洞察**
- **观察**：P1（Race Condition）和 P2（Deadlock）是最常见的陷阱
- **原因分析**：
  - 多线程编程的核心难点
  - 难以调试和复现
  - 开发者对并发模型理解不足
- **验证**：通过查看具体问题 ID 和日志输出，确认分类准确性

**4. Solvability Contrast 洞察**
- **观察**：
  - 可解决问题平均长度较短，包含代码片段的比例较高
  - 可解决问题提问者平均声誉较高
  - 难解决问题更可能涉及复杂主题
- **原因分析**：
  - 清晰的问题描述和代码示例有助于快速解答
  - 经验丰富的开发者更善于提问
  - 复杂主题需要更深入的知识和更多时间

---

## 六、技术实现细节

### 6.1 框架与工具

- **后端框架**：Spring Boot 3.5.7
- **数据库**：PostgreSQL 12.1
- **ORM**：Spring Data JPA / Hibernate 6.6.33
- **数据库迁移**：Flyway
- **前端库**：Chart.js, D3.js
- **模板引擎**：Thymeleaf

### 6.2 代码组织

```
src/main/java/cs209a/finalproject_demo/
├── collector/          # 数据采集模块
│   ├── client/        # API 客户端
│   ├── service/       # 采集服务
│   └── saver/         # 数据保存
├── controller/         # REST API 控制器
├── service/            # 业务逻辑服务
├── repository/         # 数据访问层
├── entity/             # 实体类
├── dto/                # 数据传输对象
└── dataset/            # 数据集加载

src/main/resources/
├── templates/          # HTML 模板
└── db/migration/       # 数据库迁移脚本
```

### 6.3 性能优化

1. **数据库查询优化**
   - 使用 `JOIN FETCH` 避免 N+1 查询问题
   - 批量加载关联数据（标签、评论）
   - 索引优化（questionId, creationDate 等）

2. **内存管理**
   - 流式处理大数据集
   - 及时释放不需要的对象引用

3. **API 速率限制**
   - 控制请求频率，避免触发 API 限制
   - 自动处理 backoff 和重试

---

## 七、项目亮点

1. **完整的数据采集流程**：从 API 请求到数据持久化的完整实现
2. **多层次分析**：数据库初筛 + 内存层精细分析
3. **先进的文本分析**：TF-IDF + 余弦相似度进行语义分类
4. **丰富的可视化**：多种图表类型，交互式界面
5. **规范的 API 设计**：统一的响应格式，完善的参数验证
6. **动态生成结果**：所有分析结果都是实时计算，符合要求

---

## 八、总结

本项目成功实现了所有要求的功能，包括：
- ✅ 数据收集（超过 1000 条线程）
- ✅ 数据持久化（PostgreSQL 数据库）
- ✅ 四个数据分析问题（Topic Trends, Co-occurrence, Multithreading Pitfalls, Solvability Contrast）
- ✅ RESTful APIs（5 个端点，返回 JSON）
- ✅ 可视化与洞察（多种图表类型，深入分析）

所有代码都是自主实现，使用 Java 集合、Lambda 和 Stream API 进行数据分析，完全符合课程要求。系统具有良好的可扩展性和可维护性，为后续功能扩展打下了坚实基础。

