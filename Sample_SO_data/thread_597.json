{
  "question" : {
    "question_id" : 79785900,
    "title" : "Spring Security configuration always redirecting to Login page",
    "body" : "<p>I recently upgraded Java, Springboot, Sprint Security, and Tomcat to versions 21, 3.5.6, 6.5.5, and 10, respectively, from versions 8, 2.7.5, 5.3.23, and 9, respectively, and I am updating my security configuration as a result.</p>\n<p>In my local environment, the app runs without issue after making my changes. However, when running the app in a deployment, I can reach the Login page but every endpoint redirects to a nonexistent login endpoint <a href=\"http://localhost:8080/custom-context/login\" rel=\"nofollow noreferrer\">http://localhost:8080/custom-context/login</a> and I cannot login. My login page is <a href=\"http://localhost:8080/Login\" rel=\"nofollow noreferrer\">http://localhost:8080/Login</a>. I have discerned that the issue stems from the authorization and authentication for my endpoints, but have not been able to figure out where exactly the issue is nor how to resolve it.</p>\n<p>My thoughts are that the issue is multifaceted and lies in different areas of the authentication and authorization process, both in how I've configured Spring Security and my custom filters.</p>\n<p>I have attempted to modify my configuration with several suggestions from the current Springboot and Spring Security documentations, particularly relating to how to setup the SecurityConfig class. Below is my current SecurityConfig class.</p>\n<pre><code>@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    @Bean(name=&quot;customUserDetailsService&quot;)\n    public AccessController userDetailsService() {return new AccessController();}\n\n    @Bean\n    public BCryptPasswordEncoder customPasswordEncoder() {return new BCryptPasswordEncoder();}\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http.cors(cors -&gt; cors.configurationSource(corsConfigurationSource()))\n            .csrf(AbstractHttpConfigurer::disable).authorizeHttpRequests(auth -&gt; auth\n                .requestMatchers(&quot;/access/token&quot;, &quot;/access/login&quot;, &quot;/access/license&quot;\n                    &quot;/access/refreshToken&quot;, &quot;/licensing/**&quot;, &quot;/ui/saveChecksumLogs&quot;,\n                    &quot;/ws-message/**&quot;, &quot;/swagger-ui/**&quot;, &quot;/v3/**&quot;, &quot;/ui/disabledProfileUpdatedStatus&quot;,\n                    &quot;/ui/profileUpdatedStatus&quot;, &quot;/ui/test&quot;).permitAll()\n                .anyRequest().authenticated()\n        ).sessionManagement(httpSecuritySessionManagementConfigurer -&gt;\n        httpSecuritySessionManagementConfigurer.sessionCreationPolicy(SessionCreationPolicy.STATELESS));\n\n        http.with(new CustomAuthenticationManager(), customAuthenticationManager -&gt; {});\n        http.addFilterBefore(customAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);\n        http.addFilterBefore(new CustomAuthorizationFilter(), UsernamePasswordAuthenticationFilter.class);\n        http.addFilterAfter(new DomainAuthorizationFilter(), BasicAuthenticationFilter.class);\n        http.addFilterAfter(new RoleAuthorizationFilter(), BasicAuthenticationFilter.class);\n\n        return http.build();\n    }\n\n    @Bean\n    public CorsConfigurationSource corsConfigurationSource() {\n        CorsConfiguration config = new CorsConfiguration();\n        config.setAllowedMethods(List.of(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;, &quot;PATCH&quot;));\n        config.setAllowedOriginPatterns(List.of(&quot;http://*:8080&quot;, &quot;http://*:3000&quot;, &quot;https://*:443&quot;, &quot;https://*:8443&quot;));\n        config.setAllowCredentials(true);\n        config.setAllowedHeaders(List.of(&quot;*&quot;));\n        config.setExposedHeaders(List.of(&quot;*&quot;));\n        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        source.registerCorsConfiguration(&quot;/**&quot;, config);\n        return source;\n    }\n\n    class CustomAuthenticationManager extends AbstractHttpConfigurer&lt;CustomAuthenticationManager, HttpSecurity&gt; {\n        @Autowired\n        UserDetailsService service;\n\n        @Override\n        public void configure(HttpSecurity http) throws Exception {\n            DaoAuthenticationProvider provider = new DaoAuthenticationProvider(service);\n            provider.setPasswordEncoder(customPasswordEncoder());\n            CustomAuthenticationFilter auth = new CustomAuthenticationFilter(new ProviderManager(provider));\n            auth.setFilterProcessesUrl(&quot;/access/login&quot;);\n            http.addFilter(auth);\n        }\n    }\n\n    public CustomAuthenticationFilter customAuthenticationFilter() {\n        DaoAuthenticationProvider provider = new DaoAuthenticationProvider(userDetailsService());\n        provider.setPasswordEncoder(customPasswordEncoder());\n        CustomAuthenticationFilter auth = new CustomAuthenticationFilter(new ProviderManager(provider));\n        auth.setfilterProcessesUrl(&quot;/access/login&quot;);\n        return auth;\n    }\n}\n</code></pre>\n<p>Next is my CustomAuthenticationFilter class.</p>\n<pre><code>public class CustomAuthenticationFilter extends UsernamePasswordAuthenticationFilter {\n    private final AuthenticationManager authenticationManager;\n    private LicenseHelper licenseHelper;\n    private DomainHelper domainHelper;\n    private UIController uiController;\n    public CustomAuthenticationFilter(AuthenticationManager authenticationManager) {\n        this.authenticationManager = authenticationManager;\n    }\n\n    @Override\n    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response)\n            throws AuthenticationException {\n\n        if (licenseHelper == null) { // This class type can't use injection, so do a lazy set\n            ServletContext servletContext = request.getServletContext();\n            WebApplicationContext webApplicationContext = WebApplicationContextUtils\n                    .getWebApplicationContext(servletContext);\n            assert webApplicationContext != null;\n            licenseHelper = webApplicationContext.getBean(LicenseHelper.class);\n        }\n\n        if (domainHelper == null) { // This class type can't use injection, so do a lazy set\n            ServletContext servletContext = request.getServletContext();\n            WebApplicationContext webApplicationContext = WebApplicationContextUtils\n                    .getWebApplicationContext(servletContext);\n            assert webApplicationContext != null;\n            domainHelper = webApplicationContext.getBean(DomainHelper.class);\n        }\n\n        String username = request.getParameter(&quot;username&quot;);\n        String password = request.getParameter(&quot;password&quot;);\n        String decodedUser;\n        String decodedPass;\n        try {\n            decodedUser = URLDecoder.decode(username, StandardCharsets.UTF_8.name());\n            decodedPass = URLDecoder.decode(password, StandardCharsets.UTF_8.name());\n        } catch (UnsupportedEncodingException ex) {\n            throw new BadCredentialsException(ex.getMessage(), ex);\n        }\n\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(decodedUser,\n                decodedPass);\n        return authenticationManager.authenticate(authenticationToken);\n\n    }\n\n    @Override\n    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain,\n            Authentication authResult) throws IOException, ServletException {\n        User user = (User) authResult.getPrincipal();\n        // TODO Save token string elsewhere\n        TokenHelper tokenHelper = new TokenHelper(user, request);\n        String access_token = tokenHelper.createAccessToken();\n        String refresh_token = tokenHelper.createRefreshToken();\n\n        // User has logged in, check if they're enabled before granting access\n        boolean isEnabled = false;\n        for (GrantedAuthority auth : user.getAuthorities()) {\n            String authority = auth.getAuthority();\n            String userEnabled = authority.substring(USER_ENABLED_SUBSTRING.length());\n            if (userEnabled.equals(&quot;true&quot;) || userEnabled.equals(&quot;TRUE&quot;)) {\n                isEnabled = true;\n                break;\n            }\n        }\n\n        // If admin then allow the login\n        if (!licenseHelper.validLicenseInstalled() &amp;&amp; !domainHelper.isRegisteredAdmin(user.getUsername())) {\n            response.setStatus(FORBIDDEN.value());\n            response.setContentType(APPLICATION_JSON_VALUE);\n            response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\n            OperationStatusModel result = new OperationStatusModel(&quot;Login&quot;);\n            result.setResult(RequestOperationResult.ERROR.name());\n            result.setErrorDescription(&quot;A valid license is not installed&quot;);\n            new ObjectMapper().writeValue(response.getOutputStream(), result);\n            logger.error(&quot;A valid license is not installed, prevent login&quot;);\n            return;\n        }\n\n        if (!isEnabled) {\n            response.setStatus(FORBIDDEN.value());\n            response.setContentType(APPLICATION_JSON_VALUE);\n            response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\n            OperationStatusModel result = new OperationStatusModel(&quot;Login&quot;);\n            result.setResult(RequestOperationResult.ERROR.name());\n            result.setErrorDescription(&quot;Could not login, user is not enabled&quot;);\n            new ObjectMapper().writeValue(response.getOutputStream(), result);\n            logger.error(&quot;User is not enabled, cannot login&quot;);\n            return;\n        }\n\n        logger.info(&quot;Login Success!&quot;);\n        Map&lt;String, String&gt; tokens = new HashMap&lt;&gt;();\n        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\n\n        tokens.put(&quot;access_token&quot;, access_token);\n        tokens.put(&quot;refresh_token&quot;, refresh_token);\n        response.setContentType(APPLICATION_JSON_VALUE);\n        new ObjectMapper().writeValue(response.getOutputStream(), tokens);\n\n    }\n\n    @Override\n    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,\n            AuthenticationException failed) throws IOException, ServletException {\n\n        response.setStatus(FORBIDDEN.value());\n        response.setContentType(APPLICATION_JSON_VALUE);\n        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);\n        OperationStatusModel result = new OperationStatusModel(&quot;Login&quot;);\n        result.setResult(RequestOperationResult.ERROR.name());\n        result.setErrorDescription(&quot;Could not login, incorrect username or password&quot;);\n        new ObjectMapper().writeValue(response.getOutputStream(), result);\n        logger.error(&quot;Unsuccessful Login attempt&quot;);\n    }\n}\n</code></pre>\n<p>Next is my CustomAuthorizationFilter class.</p>\n<pre><code>public class CustomAuthorizationFilter extends OncePerRequestFilter {\n\n    @Override\n    public void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n            throws ServletException, IOException {\n        if (request.getServletPath().equals(&quot;/access/login&quot;) ||\n                request.getServletPath().equals(&quot;/access/refreshToken&quot;) ||\n                request.getServletPath().equals(&quot;/access/license&quot;) ||\n                request.getServletPath().equals(&quot;/ui/test&quot;)) {\n            filterChain.doFilter(request, response);\n        } else {\n            String authorizationHeader = request.getHeader(AUTHORIZATION);\n            if (authorizationHeader != null &amp;&amp; authorizationHeader.startsWith(&quot;Bearer &quot;)) {\n                try {\n                    String token = authorizationHeader.substring(&quot;Bearer &quot;.length());\n                    Algorithm algorithm = Algorithm.HMAC256(TokenHelper.secret);\n                    JWTVerifier verifier = JWT.require(algorithm).build();\n                    DecodedJWT decodedJWT = verifier.verify(token);\n                    String username = decodedJWT.getSubject();\n                    String[] roles = decodedJWT.getClaim(&quot;roles&quot;).asArray(String.class);\n\n                    Collection&lt;SimpleGrantedAuthority&gt; authorities = new ArrayList&lt;&gt;();\n                    stream(roles).forEach(role -&gt; {\n                        authorities.add(new SimpleGrantedAuthority(role));\n                    });\n                    UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(\n                            username, null, authorities);\n                    SecurityContextHolder.getContext().setAuthentication(authenticationToken);\n                    filterChain.doFilter(request, response);\n                } catch (Exception e) {\n                    logger.error(&quot;ERROR Authenticating : &quot; + e.getMessage());\n\n                    response.setStatus(FORBIDDEN.value());\n                    response.setContentType(APPLICATION_JSON_VALUE);\n\n                    OperationStatusModel error = new OperationStatusModel(request.getMethod());\n                    error.setResult(RequestOperationResult.ERROR.name());\n                    error.setErrorDescription(e.getMessage());\n                    new ObjectMapper().writeValue(response.getOutputStream(), error);\n                }\n            } else {\n                filterChain.doFilter(request, response);\n            }\n        }\n    }\n}\n</code></pre>\n<p>And last my AccessController class showing the UserDetailsService implementation. The TokenHelper class generates the JWT with the needed authorities.</p>\n<pre><code>@Tag(name = &quot;access&quot;, description = &quot;Endpoints for logging in and verifying access of the user&quot;)\n@RestController(&quot;customUserDetailsService&quot;)\n@RequestMapping(&quot;/access&quot;)\n@CrossOrigin(origins = &quot;*&quot;, allowedHeaders = &quot;*&quot;) // added to let react reach the service correctly\npublic class AccessController implements UserDetailsService {\n    private static final Logger log = LogManager.getLogger(AccessController.class);\n\n    @Autowired\n    UserRepository user_repo;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        OperationStatusModel result = new OperationStatusModel(&quot;RequestLogin&quot;);\n        CustomUser user = user_repo.findByUsername(username);\n        if (user == null) {\n            log.error(&quot;User not found: &quot; + username);\n            result.setErrorDescription(&quot;The Name fields cannot be null or empty.&quot;);\n            result.setResult(RequestOperationResult.ERROR.name());\n            throw new UsernameNotFoundException(&quot;User not found in the database&quot;);\n        } else {\n            log.info(&quot;User found in database: &quot; + username + &quot; and domainId: &quot; + user.getDomain().getDomainId());\n\n        }\n        TokenHelper tokenHelper = new TokenHelper(user, null);\n\n        Collection&lt;GrantedAuthority&gt; authorities = tokenHelper.generateAuthorities();\n\n        return new org.springframework.security.core.userdetails.User(user.getUsername(), user.getPassword(),\n                authorities);\n    }\n}\n</code></pre>\n<p>One such attempt to correct the issue involved using the below code in the SecurityConfig and replacing the CustomAuthenticationManager implementation with a more Spring Security styled approach. Again, this did not work and I still got redirections.</p>\n<pre><code>@Bean\npublic AuthenticationManager authManager(UserDetailsService userService, PasswordEncoder passEncoder) {\n    DaoAuthenticationProvider daoProvider = new DaoAuthenticationProvider(userDetailsService);\n    daoProvider.setPasswordEncoder(passEncoder);\n    return new ProviderManager(daoProvider);\n}\n</code></pre>\n<p>I then tried to add this AuthenticationManager as a parameter for my CustomAuthenticationFilter, but that did not work.</p>\n<pre><code>http.addFilterBefore(new CustomAuthenticationFilter(authManager(userDetailsService(), customPasswordEncoder())), UsernamePasswordAuthenticationFilter.class);\n</code></pre>\n<p>I also tried to specify the Login page URL, but that did not work. This was in between disabling the CSRF and request matchers definitions. I can reach the page without issue in my browser, but any attempt to login will cause the redirections to occur.</p>\n<pre><code>.formLogin(form -&gt; form.loginPage(&quot;/Login&quot;).permitAll())\n</code></pre>\n<p>Lastly, I tried looking through my project logging and the Tomcat server logging, but could not find anything that would point me to where the issue might be. I can post those if needed.</p>\n<p>I apologize if anything seems to be confusing. I will correct anything that is incorrect to provide more clarity.</p>\n<p>Catalina Log</p>\n<pre><code>09-Oct-2025 11:42:40.573 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server version name:   Apache Tomcat/10.1.46\n09-Oct-2025 11:42:40.589 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server built:          Sep 8 2025 14:26:21 UTC\n09-Oct-2025 11:42:40.591 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Server version number: 10.1.46.0\n09-Oct-2025 11:42:40.597 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Name:               Windows 11\n09-Oct-2025 11:42:40.597 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log OS Version:            10.0\n09-Oct-2025 11:42:40.599 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Architecture:          amd64\n09-Oct-2025 11:42:40.599 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Java Home:             C:\\Program Files\\Java\\jdk-21\n09-Oct-2025 11:42:40.599 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Version:           21.0.8+12-LTS-250\n09-Oct-2025 11:42:40.599 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log JVM Vendor:            Oracle Corporation\n09-Oct-2025 11:42:40.606 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_BASE:         C:\\Program Files\\Apache Software Foundation\\Tomcat 10.1\n09-Oct-2025 11:42:40.606 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log CATALINA_HOME:         C:\\Program Files\\Apache Software Foundation\\Tomcat 10.1\n09-Oct-2025 11:42:40.647 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.util.logging.config.file=C:\\Program Files\\Apache Software Foundation\\Tomcat 10.1\\conf\\logging.properties\n09-Oct-2025 11:42:40.649 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager\n09-Oct-2025 11:42:40.649 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djdk.tls.ephemeralDHKeySize=2048\n09-Oct-2025 11:42:40.649 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.protocol.handler.pkgs=org.apache.catalina.webresources\n09-Oct-2025 11:42:40.650 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dsun.io.useCanonCaches=false\n09-Oct-2025 11:42:40.650 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.lang=ALL-UNNAMED\n09-Oct-2025 11:42:40.650 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.lang.reflect=ALL-UNNAMED\n09-Oct-2025 11:42:40.650 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.io=ALL-UNNAMED\n09-Oct-2025 11:42:40.650 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.util=ALL-UNNAMED\n09-Oct-2025 11:42:40.652 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.base/java.util.concurrent=ALL-UNNAMED\n09-Oct-2025 11:42:40.652 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED\n09-Oct-2025 11:42:40.652 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dcatalina.base=C:\\Program Files\\Apache Software Foundation\\Tomcat 10.1\n09-Oct-2025 11:42:40.654 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Dcatalina.home=C:\\Program Files\\Apache Software Foundation\\Tomcat 10.1\n09-Oct-2025 11:42:40.657 INFO [main] org.apache.catalina.startup.VersionLoggerListener.log Command line argument: -Djava.io.tmpdir=C:\\Program Files\\Apache Software Foundation\\Tomcat 10.1\\temp\n09-Oct-2025 11:42:40.672 INFO [main] org.apache.catalina.core.AprLifecycleListener.lifecycleEvent The Apache Tomcat Native library which allows using OpenSSL was not found on the java.library.path: [C:\\Program Files\\Java\\jdk-21\\bin;C:\\WINDOWS\\Sun\\Java\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\Program Files\\Common Files\\Oracle\\Java\\javapath;C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\java8path;C:\\Program Files (x86)\\Common Files\\Oracle\\Java\\javapath;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;C:\\Users\\Patrick\\AppData\\Local\\Programs\\Python\\Python37-32\\Scripts\\;C:\\Users\\Patrick\\AppData\\Local\\Programs\\Python\\Python37-32\\;C:\\Users\\Patrick\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Program Files\\Java\\jre-1.8\\bin;;.]\n09-Oct-2025 11:42:41.936 INFO [main] org.apache.coyote.AbstractProtocol.init Initializing ProtocolHandler [&quot;http-nio-8080&quot;]\n09-Oct-2025 11:42:42.077 INFO [main] org.apache.catalina.startup.Catalina.load Server initialization in [2050] milliseconds\n09-Oct-2025 11:42:42.316 INFO [main] org.apache.catalina.core.StandardService.startInternal Starting service [Catalina]\n09-Oct-2025 11:42:42.318 INFO [main] org.apache.catalina.core.StandardEngine.startInternal Starting Servlet engine: [Apache Tomcat/10.1.46]\n09-Oct-2025 11:42:42.393 INFO [main] org.apache.catalina.startup.HostConfig.deployWAR Deploying web application archive [C:\\Program Files\\Apache Software Foundation\\Tomcat 10.1\\webapps\\custom-context.war]\n09-Oct-2025 11:43:05.081 INFO [main] org.apache.jasper.servlet.TldScanner.scanJars At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.\n09-Oct-2025 11:44:09.744 INFO [main] org.apache.catalina.startup.HostConfig.deployWAR Deployment of web application archive [C:\\Program Files\\Apache Software Foundation\\Tomcat 10.1\\webapps\\custom-context.war] has finished in [87,349] ms\n09-Oct-2025 11:44:09.784 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [C:\\Program Files\\Apache Software Foundation\\Tomcat 10.1\\webapps\\host-manager]\n09-Oct-2025 11:44:10.242 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [C:\\Program Files\\Apache Software Foundation\\Tomcat 10.1\\webapps\\host-manager] has finished in [490] ms\n09-Oct-2025 11:44:10.244 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [C:\\Program Files\\Apache Software Foundation\\Tomcat 10.1\\webapps\\manager]\n09-Oct-2025 11:44:10.528 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [C:\\Program Files\\Apache Software Foundation\\Tomcat 10.1\\webapps\\manager] has finished in [282] ms\n09-Oct-2025 11:44:10.528 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deploying web application directory [C:\\Program Files\\Apache Software Foundation\\Tomcat 10.1\\webapps\\ROOT]\n09-Oct-2025 11:44:10.628 INFO [main] org.apache.catalina.startup.HostConfig.deployDirectory Deployment of web application directory [C:\\Program Files\\Apache Software Foundation\\Tomcat 10.1\\webapps\\ROOT] has finished in [100] ms\n09-Oct-2025 11:44:10.643 INFO [main] org.apache.coyote.AbstractProtocol.start Starting ProtocolHandler [&quot;http-nio-8080&quot;]\n09-Oct-2025 11:44:10.701 INFO [main] org.apache.catalina.startup.Catalina.start Server startup in [88608] milliseconds\n09-Oct-2025 11:45:42.930 INFO [Thread-2] org.apache.coyote.AbstractProtocol.pause Pausing ProtocolHandler [&quot;http-nio-8080&quot;]\n09-Oct-2025 11:45:42.960 INFO [Thread-2] org.apache.catalina.core.StandardService.stopInternal Stopping service [Catalina]\n09-Oct-2025 11:45:43.298 WARNING [Thread-2] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [custom-context] appears to have started a thread named [Log4j2-TF-4-Scheduled-2] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:\n java.base/jdk.internal.misc.Unsafe.park(Native Method)\n java.base/java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:269)\n java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:1763)\n java.base/java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:1182)\n java.base/java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:899)\n java.base/java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1070)\n java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)\n java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)\n java.base/java.lang.Thread.run(Thread.java:1583)\n09-Oct-2025 11:45:43.300 WARNING [Thread-2] org.apache.catalina.loader.WebappClassLoaderBase.clearReferencesThreads The web application [custom-context] appears to have started a thread named [mysql-cj-abandoned-connection-cleanup] but has failed to stop it. This is very likely to create a memory leak. Stack trace of thread:\n java.base/jdk.internal.misc.Unsafe.park(Native Method)\n java.base/java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:269)\n java.base/java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:1852)\n java.base/java.lang.ref.ReferenceQueue.await(ReferenceQueue.java:71)\n java.base/java.lang.ref.ReferenceQueue.remove0(ReferenceQueue.java:143)\n java.base/java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:218)\n com.mysql.cj.jdbc.AbandonedConnectionCleanupThread.run(AbandonedConnectionCleanupThread.java:84)\n java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)\n java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)\n java.base/java.lang.Thread.run(Thread.java:1583)\n09-Oct-2025 11:45:43.331 INFO [Thread-2] org.apache.coyote.AbstractProtocol.stop Stopping ProtocolHandler [&quot;http-nio-8080&quot;]\n09-Oct-2025 11:45:43.378 INFO [Thread-2] org.apache.coyote.AbstractProtocol.destroy Destroying ProtocolHandler [&quot;http-nio-8080&quot;]\n</code></pre>\n",
    "tags" : [ "java", "spring-boot", "spring-security" ],
    "owner" : {
      "account_id" : 36162863,
      "reputation" : 9,
      "user_id" : 27596981,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d963531d48d1c0774cc98fed79160018?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Patrick Hughes",
      "link" : "https://stackoverflow.com/users/27596981/patrick-hughes"
    },
    "is_answered" : false,
    "view_count" : 116,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1760126112,
    "creation_date" : 1759963068,
    "link" : "https://stackoverflow.com/questions/79785900/spring-security-configuration-always-redirecting-to-login-page",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140787183,
    "post_id" : 79785900,
    "body" : "Can you try going smaller steps? e.g., (a) update to Java 17, (b) update Spring Boot, Spring Security, and Tomcat, (c) update to Java 21. That way, you can at least eliminate one of the suspects.",
    "score" : 0,
    "owner" : {
      "account_id" : 1888781,
      "reputation" : 2498,
      "user_id" : 1707427,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/4d1a2608ee35e2df7d2400a02e62bb20?s=256&d=identicon&r=PG",
      "display_name" : "S&#246;ren",
      "link" : "https://stackoverflow.com/users/1707427/s%c3%b6ren"
    },
    "creation_date" : 1760042189,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140786611,
    "post_id" : 79785900,
    "body" : "It works locally. The application.yml you run locally is not going to be the same as the one used for production software or you have values being injected from outside that will be different. The most logical place for a difference in behavior to occur is right there and you have something to search for, that mysterious &#39;custom-context&#39; that suddenly appears in the url. You&#39;re spinning your wheels looking at code. Besides that, the first order of business is to activate debug logging for spring security.",
    "score" : 2,
    "owner" : {
      "account_id" : 187094,
      "reputation" : 5301,
      "user_id" : 424903,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/8oHZF.png?s=256",
      "display_name" : "Gimby",
      "link" : "https://stackoverflow.com/users/424903/gimby"
    },
    "creation_date" : 1760022271,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}