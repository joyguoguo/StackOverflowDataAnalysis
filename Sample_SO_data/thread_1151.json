{
  "question" : {
    "question_id" : 79737860,
    "title" : "Why does adding a value to Float.MAX_VALUE not reach infinity?",
    "body" : "<p>According to the standard, overflow in java is handled using a special value called infinity, but here the sum is 3.4028235E38. Why is this the case?</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class FloatingPointTest {\n    public static void main(String[] args) {\n        float a = Float.MAX_VALUE;\n        float b = 1_000_000_000f; // Note the 'f' to ensure it's a float literal\n        float sum = a + b;\n\n        System.out.println(&quot;Float.MAX_VALUE: &quot; + a);\n        System.out.println(&quot;Large number: &quot; + b);\n        System.out.println(&quot;Sum: &quot; + sum);\n        System.out.println(&quot;Is sum equal to Float.POSITIVE_INFINITY? &quot; + (sum == Float.POSITIVE_INFINITY));\n    }\n}\n</code></pre>\n",
    "tags" : [ "java", "floating-point" ],
    "owner" : {
      "account_id" : 30213850,
      "reputation" : 43,
      "user_id" : 23855347,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/ACg8ocJ6ee7cd_YxUtdiKeprN7A7Zdkq8StvxYhRhqQcptNoQw=k-s256",
      "display_name" : "saul goodman",
      "link" : "https://stackoverflow.com/users/23855347/saul-goodman"
    },
    "is_answered" : true,
    "view_count" : 325,
    "answer_count" : 2,
    "score" : 4,
    "last_activity_date" : 1755623073,
    "creation_date" : 1755437530,
    "link" : "https://stackoverflow.com/questions/79737860/why-does-adding-a-value-to-float-max-value-not-reach-infinity",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79738744,
    "question_id" : 79737860,
    "body" : "<h2>Summary</h2>\n<p>An arithmetic result is rounded before it is tested for overflow. If the rounded result is representable, there is no overflow.</p>\n<h2>Details</h2>\n<p>For rounding, Java uses IEEE 754’s round-to-nearest, ties-to-even method (per <em>The Java Virtual Machine Specification</em>, <em>JAVA SE 18 Edition</em> 2022-02-23, clause <a href=\"https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-2.html#jvms-2.8\" rel=\"nofollow noreferrer\"><em>2.8 Floating-Point Arithmetic</em></a>, page 20).</p>\n<p>Rounding in IEEE-754 behaves as if the range were unbounded (per IEEE 754-2019 draft D2.47, clause 4.3, first paragraph, page 18). That is, the rounding is performed as if there were no bound on the exponent, and then a check for overflow is performed. For illustration, suppose we had a two-digit decimal format that had finite numbers up to, but not including, 100. So 99 is representable but 100 is out of bounds. Consider adding 99 and .23. The exact result would be 99.23. This is above 99, but we do not declare overflow yet. First, we round 99.23 to two digits. The result is 99. This is within the finite range, so it does not overflow.</p>\n<p>In the binary32 format that Java uses for <code>Float</code>, <code>Float.MAX_VALUE</code> is 2<sup>128</sup>−2<sup>104</sup>. If the exponent were not bounded, the next greater representable value would be 2<sup>128</sup>. When we add 10<sup>9</sup> to <code>Float.MAX_VALUE</code>, the exact result would be 2<sup>128</sup>−2<sup>104</sup>+10<sup>9</sup>. When we round, this is nearer to 2<sup>128</sup>−2<sup>104</sup> than it is to 2<sup>128</sup>. So it is rounded to 2<sup>128</sup>−2<sup>104</sup>, and there is no overflow.</p>\n<h2>Discussion</h2>\n<p>The rule that we round before we test for overflow makes sense: There is no reason for rounding to change at the edge of the finite range or to produce an infinity when the ordinary result of rounding would be finite. If we changed the rules to make any result outside the finite range an overflow, then floating-point arithmetic would behave differently near the edge of the range than it does inside the finite range.</p>\n<p>If you added 2<sup>103</sup> to <code>Float.MAX_VALUE</code>, the exact result, 2<sup>128</sup>−2<sup>104</sup>+2<sup>103</sup> would be exactly halfway between 2<sup>128</sup>−2<sup>104</sup> and 2<sup>128</sup>. The rule for tied results is to round to the choice with the even low digit in its significand. The low digit of 2<sup>128</sup>−2<sup>104</sup> is 1, and the low digit of 2<sup>128</sup> is 0, so the result would be 2<sup>128</sup>. That is out of the finite range, so an overflow would be declared.</p>\n",
    "score" : 5,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 113187,
      "reputation" : 233163,
      "user_id" : 298225,
      "user_type" : "registered",
      "accept_rate" : 100,
      "profile_image" : "https://www.gravatar.com/avatar/ef102f4ee36e58d09e0b27cd5393a1d8?s=256&d=identicon&r=PG",
      "display_name" : "Eric Postpischil",
      "link" : "https://stackoverflow.com/users/298225/eric-postpischil"
    },
    "creation_date" : 1755521560,
    "last_activity_date" : 1755623073,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79739532,
    "question_id" : 79737860,
    "body" : "<p>In Java, Float.MAX_VALUE is the largest finite representable float value (≈ 3.4028235e38).</p>\n<p>But when you add a small value to it (like +1 or even +1000), it doesn’t change at all, because that extra value is too small compared to Float.MAX_VALUE — it’s lost due to limited precision of floating-point representation (IEEE 754).</p>\n<p>Infinity is only reached when the result of an operation exceeds the largest representable float.</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class FloatMaxValue {\n    public static void main(String[] args) {\n        float max = Float.MAX_VALUE;\n        \n        System.out.println(&quot;Float.MAX_VALUE = &quot; + max);\n\n        float result1 = max + 1;\n        System.out.println(&quot;Float.MAX_VALUE + 1 = &quot; + result1);\n\n        float result2 = max * 2;\n        System.out.println(&quot;Float.MAX_VALUE * 2 = &quot; + result2);\n\n        float result3 = max + 1e30f; \n        System.out.println(&quot;Float.MAX_VALUE + 1e30f = &quot; + result3);\n\n        float result4 = max * 1.1f;  \n        System.out.println(&quot;Float.MAX_VALUE * 1.1f = &quot; + result4);\n    }\n}\n</code></pre>\n<p>Ans<br />\nFloat.MAX_VALUE = 3.4028235E38</p>\n<p>Float.MAX_VALUE + 1 = 3.4028235E38   // No change</p>\n<p>Float.MAX_VALUE * 2 = Infinity       // Overflows to Infinity</p>\n<p>Float.MAX_VALUE + 1e30f = 3.4028235E38  // Still no change</p>\n<p>Float.MAX_VALUE * 1.1f = Infinity    // Overflows to Infinity</p>\n<p>Float.MAX_VALUE + 1 → stays the same, because 1 is tiny compared to 1e38, so it cannot affect the float’s mantissa.</p>\n<p>Only multiplying by a big enough number (e.g., *2, *1.1) makes it overflow, resulting in Infinity.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 29461042,
      "reputation" : 1,
      "user_id" : 22575824,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/72a21b1c9059df860a2097c8ee71763f?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Mohd Aamir",
      "link" : "https://stackoverflow.com/users/22575824/mohd-aamir"
    },
    "creation_date" : 1755585886,
    "last_activity_date" : 1755585886,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140675843,
    "post_id" : 79737860,
    "body" : "Related: <a href=\"https://stackoverflow.com/questions/79312867\">Floating Point: Distance between MAX and INF</a>.",
    "score" : 0,
    "owner" : {
      "account_id" : 4865492,
      "reputation" : 49215,
      "user_id" : 3923896,
      "user_type" : "registered",
      "accept_rate" : 69,
      "profile_image" : "https://i.sstatic.net/AcZuX.png?s=256",
      "display_name" : "Steve Summit",
      "link" : "https://stackoverflow.com/users/3923896/steve-summit"
    },
    "creation_date" : 1755596807,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140673885,
    "post_id" : 79737860,
    "body" : "maybe be interesting to check the documentation of <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/Math.html#ulp(float)\" rel=\"nofollow noreferrer\"><code>Math.ulp()</code></a> --- or just add <code>2e31f</code> to <code>Float.MAX_VALUE</code> instead of <code>1e9f</code>",
    "score" : 1,
    "owner" : {
      "account_id" : 31180,
      "reputation" : 29752,
      "user_id" : 85421,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/kKvXH.gif?s=256",
      "display_name" : "user85421",
      "link" : "https://stackoverflow.com/users/85421/user85421"
    },
    "creation_date" : 1755529074,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140671477,
    "post_id" : 79737860,
    "body" : "Try doing the addition by hand using the <a href=\"https://cs.stackexchange.com/a/91523\">IEEE 754 addition algorithm</a>.",
    "score" : 1,
    "owner" : {
      "account_id" : 6651855,
      "reputation" : 292025,
      "user_id" : 5133585,
      "user_type" : "registered",
      "accept_rate" : 96,
      "profile_image" : "https://i.sstatic.net/dfqcw.png?s=256",
      "display_name" : "Sweeper",
      "link" : "https://stackoverflow.com/users/5133585/sweeper"
    },
    "creation_date" : 1755439102,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140671449,
    "post_id" : 79737860,
    "body" : "For the same reason than <code>1 + 1e-30 == 1</code>: <code>b</code> is so small compared to <code>a</code> that it gets rounded away.",
    "score" : 8,
    "owner" : {
      "account_id" : 2347076,
      "reputation" : 20510,
      "user_id" : 2057033,
      "user_type" : "registered",
      "accept_rate" : 88,
      "profile_image" : "https://www.gravatar.com/avatar/868c67cd2d96685d2ec0a8bd472a2f69?s=256&d=identicon&r=PG",
      "display_name" : "Blackhole",
      "link" : "https://stackoverflow.com/users/2057033/blackhole"
    },
    "creation_date" : 1755438070,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79738744" : [ {
      "comment_id" : 140676052,
      "post_id" : 79738744,
      "body" : "It&#39;s well known that computing properly-rounded results typically requires the use of one or more <a href=\"https://en.wikipedia.org/wiki/Guard_digit\" rel=\"nofollow noreferrer\">guard digits</a> for intermediate results.  Your statements <i>rounding in IEEE-754 behaves as if the range were unbounded</i> and <i>we round before we test for overflow</i> make me realize: To get this right (but get it right easily and generally), an implementation just needs the equivalent of guard digits on intermediate exponents, too.",
      "score" : 0,
      "owner" : {
        "account_id" : 4865492,
        "reputation" : 49215,
        "user_id" : 3923896,
        "user_type" : "registered",
        "accept_rate" : 69,
        "profile_image" : "https://i.sstatic.net/AcZuX.png?s=256",
        "display_name" : "Steve Summit",
        "link" : "https://stackoverflow.com/users/3923896/steve-summit"
      },
      "creation_date" : 1755602323,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79739532" : [ {
      "comment_id" : 140679236,
      "post_id" : 79739532,
      "body" : "precise statement should be:  a )  Adding very small numbers has no effect due to limited precision,  b )  Adding sufficiently large numbers (like ~1e31) or multiplying by factors &gt; 1 can push it into Infinity.",
      "score" : 0,
      "owner" : {
        "account_id" : 29461042,
        "reputation" : 1,
        "user_id" : 22575824,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/72a21b1c9059df860a2097c8ee71763f?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Mohd Aamir",
        "link" : "https://stackoverflow.com/users/22575824/mohd-aamir"
      },
      "creation_date" : 1755697039,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140679233,
      "post_id" : 79739532,
      "body" : "You’re right — thanks for pointing that out . I should clarify:  1.Infinity happens not just when you “exceed Float.MAX_VALUE” but when the computed value is beyond the largest representable finite float. That means some additions can indeed push it over the edge (not just multiplications).  2. For example, Float.MAX_VALUE + 1f won’t change (precision loss), but Float.MAX_VALUE + 1.01412048e31f does overflow to Infinity because that number is large enough to affect the exponent.",
      "score" : 0,
      "owner" : {
        "account_id" : 29461042,
        "reputation" : 1,
        "user_id" : 22575824,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/72a21b1c9059df860a2097c8ee71763f?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Mohd Aamir",
        "link" : "https://stackoverflow.com/users/22575824/mohd-aamir"
      },
      "creation_date" : 1755696993,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140675840,
      "post_id" : 79739532,
      "body" : "You&#39;ve got a couple of misleading statements. <i>Infinity is only reached when the result of an operation exceeds the largest representable float.</i> No, it&#39;s when the value exceeds the largest representable float, and then some. <i>Only multiplying by a big enough number makes it overflow</i> No, there are numbers you can add.  The smallest is 1.01412048e+31.  See the answer at <a href=\"https://stackoverflow.com/questions/79312867\">this question</a>.",
      "score" : 0,
      "owner" : {
        "account_id" : 4865492,
        "reputation" : 49215,
        "user_id" : 3923896,
        "user_type" : "registered",
        "accept_rate" : 69,
        "profile_image" : "https://i.sstatic.net/AcZuX.png?s=256",
        "display_name" : "Steve Summit",
        "link" : "https://stackoverflow.com/users/3923896/steve-summit"
      },
      "creation_date" : 1755596702,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}