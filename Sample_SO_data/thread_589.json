{
  "question" : {
    "question_id" : 79791032,
    "title" : "CompletableFutures, join() and get() vs thread interruption",
    "body" : "<p>In my code (Java 17) I am used to handle exceptions from combined <code>CompletableFuture</code>s with <code>get()</code> like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>try {\n    CompletableFuture.allOf(someFuture, someOtherFuture).get();\n} catch (InterruptedException | ExecutionException ex) {\n    Thread.currentThread().interrupt();\n    if (ex.getCause() instanceof CustomException customException) {\n        throw customException;\n    }\n    throw new CustomException(CustomErrorCodeEnum.UNEXPECTED_ERROR,\n                              ex.getCause().getMessage());\n}\n</code></pre>\n<p>The part that I have a question about is the <code>Thread.currentThread().interrupt()</code>. I think this approach of mine is valid, since when the <code>InterruptedException</code> is thrown, the interrupted flag needs to be set on my thread.</p>\n<p>But now I am wondering if I can use <code>join()</code> – which does not throw <code>InterruptedException</code> – instead of <code>get()</code> without swallowing the interrupt (thus losing the information about the interrupt). I would like to use it like this (for example):</p>\n<pre><code>try {\n    CompletableFuture.allOf(someFuture, someOtherFuture).join();\n} catch (CompletionException | CancellationException ex) {\n    if (ex.getCause() instanceof CustomException customException) {\n        throw customException;\n    }\n    throw new CustomException(CustomErrorCodeEnum.UNEXPECTED_ERROR,\n                              ex.getCause().getMessage());\n}\n</code></pre>\n<p>I have read the implementation of <code>join()</code> and <code>get()</code> methods and it seems to me, that in the <code>join()</code> method is the <code>Thread.currentThread().interrupt()</code> already called so one does not lose the information about the interrupt, but I am not 100% sure, so my question is: is it safe to use the <code>join()</code> variant? Won't I lose some information?</p>\n",
    "tags" : [ "java", "completable-future", "java-17", "java-threads" ],
    "owner" : {
      "account_id" : 30972277,
      "reputation" : 11,
      "user_id" : 23787449,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/7dad22697a8edea3311a7d07985b97ed?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "thevasssa",
      "link" : "https://stackoverflow.com/users/23787449/thevasssa"
    },
    "is_answered" : true,
    "view_count" : 106,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1760542764,
    "creation_date" : 1760522958,
    "link" : "https://stackoverflow.com/questions/79791032/completablefutures-join-and-get-vs-thread-interruption",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79791355,
    "question_id" : 79791032,
    "body" : "<p>The API is.. dubiously designed here.</p>\n<p>Thinking about it in the abstract, there is no meaningful difference between <code>join()</code> and <code>get()</code>. They both wait, and as they are primarily about 'wait for another thread to finish a job', and the JDK spec clearly specifies that the core operations that all such operations are built on top of are guaranteed interruptable (namely, <code>Thread.sleep</code>, <code>obj.wait</code>, that sort of thing), then so are both <code>join()</code> and <code>get()</code>.</p>\n<p>Hence, both operations do essentially the same thing and can run into the same extraneous situation (a thread interrupt), and yet, they handle it differently which is bad API design.</p>\n<p>But, reading the javadoc in more detail, the docs explain it. Note that <code>get()</code> is inherited from <code>Future</code> whereas <code>join()</code> is not.</p>\n<p>The docs show the OpenJDK team at odds with themselves: The API design of <code>Future</code>'s <code>get()</code> leans into checked exceptions: It can throw both <code>ExecutionException</code> and <code>InterruptedException</code> (both checked). In contrast, <code>CompletableFuture</code> has a <code>getNow</code> method which has replaced ExecutionException with CompletionException which is a runtime exception, and the javadoc explicitly spell out that they rewrap all the checked stuff into unchecked stuff 'for convenience'. ^1</p>\n<p>However, delving into the code, there is a large difference after all. One should not rely on as the javadoc do not guarantee this difference:</p>\n<p><code>get()</code> calls the underlying job infrastructure with the 'mayInterruptIfYouWant' set to 'true' whereas <code>join</code>()<code>sets it to false. For example, if the flag is up at the moment you invoke</code>get()<code>, then get() will return __immediately__ by clearing the flag and throwing </code>InterruptedException<code>(that's correct behaviour; raising the flag / keeping it raised _and also_ throwing that exception is not right), whereas</code>join()` will just wait and ignore the fact that the flag is up. Once the future value is calculated, it returns normally and doesn't mess with the flag in any way (which means it will remain raised).</p>\n<p>That means in practice <code>join()</code> is less likely to end by throwing <code>InterruptedException</code> than <code>get()</code> would be. Instead, <code>join()</code> would finish normally, except.. the interrupted flag of your thread is up. Which means any call at any time to anything that waits is either guaranteed to (such as with <code>Thread.sleep</code> or <code>obj.wait()</code> which internally almost all 'wait for stuff' methods will end up invoking), or highly likely to (blocking reads/writes to I/O channels such as files or notwork ports) abort instantly with an exception and a lowering of that flag. That's a bad state to leave things in.</p>\n<p>Armed with that information, we can describe the behaviour of the old code which is broken, and the new code which is broken in a different way. The right answer then, is neither of your 2 snippets.</p>\n<h2>Your old code</h2>\n<p>If interrupted, stops nearly instantly, raises the flag, <strong>and</strong> exits via exception. This is not what you want. In the end, an interrupt means what you want it to mean: It cannot occur unless you explicitly write code that interrupts, which means a <code>catch (InterruptedEx)</code> block should do.. whatever you want to happen when you wrote <code>foo.interrupt()</code> in that other source file. But when trying to generalize, that <em>almost always</em> means that you want to <strong>either</strong> throw an exception and keep the flag lowered, <strong>or</strong> you want to log some stuff or do some cleanup but not take responsibility for the interrupt and just keep going, leaving the actual dealing with it to other code, in which case you swallow the exception and keep on going. <strong>do not do both</strong>. And you're doing both, here. That's why it's probably broken.</p>\n<p>Any thread whose interrupt flag is up is essentially unstable: The next call to <code>Thread.sleep()</code> / <code>obj.wait()</code> exits INSTANTLY, clearing the flag and throwing <code>InterruptedException</code>. And lots of code ends up invoking one of those when needing to wait. Any blocking I/O ops (such as reading from or writing to a file or network port, which also means any interaction with any database, microservices, you name it) <em>usually</em> also instantly exit with an exception and a lowering of the flag, on essentially all architectures: <code>InputStream.read()</code> isn't specced to throw InterruptedException solely so that a hypothetical OS that has uninterruptable I/O still can host a JVM, it'd a shame if that'd be the only reason a JVM cannot be ported to such an OS.</p>\n<p>Hence, you shouldn't raise that flag 'just in case' or out of an abundance of caution: it actually makes your code more fragile, not less so. Unless, of course, you <em>want</em> this thread to explode within moments after finishing your code block, which you should want only if you haven't actually processed the interruption yet. That is <strong>not true</strong> for your first snippet: You <em>have</em> handled it, by throwing an exception. Hence, do not raise the flag.</p>\n<h2>Your new code</h2>\n<p>If interrupted, <em>does not respond to that at all</em> and just keeps waiting.</p>\n<p>When your new code returns, the flag will still be up, which means that thread will likely explode soon after (about half of the JVM core libraries, if invoked, will result in an exception in one way or another), but it returns 'normally' (not with an exception.</p>\n<p>Both are bad.</p>\n<p>The correct code is likely:</p>\n<pre><code>try {\n    CompletableFuture.allOf(someFuture, someOtherFuture).get();\n} catch (InterruptedException | ExecutionException ex) {\n    if (ex.getCause() instanceof CustomException customException) {\n        throw customException;\n    }\n    throw new CustomException(CustomErrorCodeEnum.UNEXPECTED_ERROR,\n                              ex.getCause().getMessage());\n}\n</code></pre>\n<p>i.e. the same thing you had but without the reraising of the flag.</p>\n<p>We've improved things <em>and</em> made your code shorter, that's a win-win!</p>\n<h2>A note about interruptions</h2>\n<p>They do not happen unless you want it to.</p>\n<p>Specifically, an interrupt flag being up / an <code>InterruptedException</code> being thrown <strong>cannot possibly occur</strong> unless <em>you</em> wrote code to make them happen. You must invoke <code>interrupt()</code> on a <code>Thread</code> instance, or invoke an API that does this, and the APIs that do so are very explicit about it. For example, <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/concurrent/Future.html#cancel(boolean)\" rel=\"nofollow noreferrer\"><code>someFuture.cancel(true)</code></a> will interrupt a thread - that boolean parameter is literally called <code>mayInterruptIfRunning</code> for a good reason.</p>\n<p>'interrupting' a JVM <em>is a very different thing and does not result in <code>InterruptedException</code>!</em>. For example, if you have a JVM running and you hit CTRL+C in its terminal window or use your OS activity monitor / task manager equivalent to 'kill' the JVM, then one of two things happen:</p>\n<ul>\n<li>You use a hard-kill option. The JVM. just. dies. Nothing is run, no shutdown hooks, no finalizers, no interruptedexceptions.</li>\n<li>You use a soft-kill option, such as CTRL+C. The JVM just dies in the sense that no Interruptedexceptions are thrown either and no finalization is run, but, any shutdown hooks <em>are</em> executed and can even stop the shutdown if they want to.</li>\n</ul>\n<p>So, there are only 3 options:</p>\n<ol>\n<li><p>You wrote <code>t.interrupt()</code> or <code>future.cancel(true)</code> or similar somewhere. In that case, you wrote that for a reason, and probably not &quot;a cat walked over my keyboard and I liked the look of it&quot;. What was that reason? Whatever it was, put <em>that</em> in your catch block. There is no general answer to 'how do I deal with an InterruptedException' because there is no general answer to &quot;why did you write <code>t.interrupt()</code>; what did you want to happen?&quot;. <code>t.interrupt()</code> is a signal: Do (something I want) but not here, in another thread. t.interrupt starts the process. You write the (something I want) in the <code>catch (InterruptedException)</code> block at the side of the thing you interrupted.</p>\n</li>\n<li><p>You did not write that anywhere. In that case the interrupt cannot possibly occur, there's no reason to worry about it, and your current code that throws a'UNEXPECTED_ERROR&quot; is as good as anything; it's a defensive code: Code that cannot possibly run unless your understanding of your own system is broken (i.e. you have bugs). In that case you <strong>want</strong> an exception with loads of detail to bubble all the way up. That's vastly superior than a bug causing your code to silently do nothing or ignore the error.</p>\n</li>\n<li><p>You are writing a library; there is some other programmer that will use your stuff and thus, while you never wrote <code>t.interrupt()</code>, that programmer that uses your library might. This is the most complicated case. The best thing to do is to explicitly document (and then test!) what your library does when interrupts occur. In this case you would presumably expand upon CustomException to have a <code>CustomErrorCodeEnum</code> that reflects interruption. Or, much simpler, you document: You can interrupt the waiting for the completion of some futures; if you do that, it is dealt with the same way as if the calculation of the future value code throws something. You could instead document: &quot;if you interrupt it, my library will attempt to stop waiting ASAP, will return some arbitrarily value, will not throw any exception, but will keep the flag raised&quot;. You can document that and test it, but that's unlikely to be behaviour that a user of your library wants.</p>\n</li>\n</ol>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107186,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1760542764,
    "last_activity_date" : 1760542764,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140797442,
    "post_id" : 79791032,
    "body" : "<i>since when the InterruptedException is thrown, the interrupted flag needs to be set on my thread.</i> - this is commonly said, but not correct. Interrupt means whatever you think it means. As in: they do not occur unless <i>you</i> write somewhere in <i>your</i> code <code>.interrupt()</code>. When you wrote that code, what did you think should happen? Put that in your catch block. Note that you&#39;re also raising that flag if ExecutionEx happens which is very bad.",
    "score" : 0,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107186,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1760540044,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140796821,
    "post_id" : 79791032,
    "body" : "All well-behaving methods either respond to interruption or retain the interruption state. Since <code>join()</code> can not be interrupted, it falls into the second category. So you don’t need to do anything yourself. But when you handle <code>CompletionException</code> and <code>CancellationException</code> with the same code you can’t use <code>ex.getCause().getMessage()</code> unconditionally. There is no guaranty that a <code>CancellationException</code> has a cause. Likewise, the first code snippet’s exception handler is questionable. You should not call <code>Thread.currentThread().interrupt()</code> when catching an <code>ExecutionException</code>.",
    "score" : 3,
    "owner" : {
      "account_id" : 3211603,
      "reputation" : 300981,
      "user_id" : 2711488,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
      "display_name" : "Holger",
      "link" : "https://stackoverflow.com/users/2711488/holger"
    },
    "creation_date" : 1760524066,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}