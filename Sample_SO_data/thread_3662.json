{
  "question" : {
    "question_id" : 79533309,
    "title" : "JPA @Version and optimistic locking problem",
    "body" : "<p>Could someone please explain how to get <strong>Optimistic Locking</strong> in JPA to work? My initial idea was, that once I'm passing an entity with Version number other than it is stored in the database the commit is rejected and OptimisticLockException is thrown.\nMy Database in the backend is Oracle 21C</p>\n<p>as shown in the code below I'm explicitly setting fixed version number for each HTTP PUT(update) request. But every request is successful.\nThe <code>updateDateTime</code> property is correctly managed by JPA and it is updated with every request. The same for <code>version</code> property. Its value is being incremented on every commit.</p>\n<p>Here is my test entity, with property annotated with @Version:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Entity\n@Table(name = &quot;docs&quot;, uniqueConstraints = @UniqueConstraint(columnNames = &quot;doc_id&quot;))\npublic class Doc {\n\n    @Id\n    @Column(name = &quot;doc_id&quot;)\n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;doc_generator&quot;)\n    @SequenceGenerator(name = &quot;doc_generator&quot;, sequenceName = &quot;doc_seq&quot;, allocationSize = 1)\n    private Long id;\n\n    @Column(name = &quot;param_1&quot;, nullable = false)\n    private String param1;\n\n    @Column(name=&quot;param_2&quot;)\n    private String param2;\n\n    @CreationTimestamp\n    @Column(name = &quot;created&quot;, nullable = false, updatable = false)\n    private LocalDateTime createDateTime;\n\n    @UpdateTimestamp\n    @Column(name = &quot;updated&quot;, nullable = false, updatable = true)\n    private LocalDateTime updateDateTime;\n\n    @Version\n    @Column(name = &quot;version&quot;)\n    private Integer version;\n\n    // ...\n}\n</code></pre>\n<p>simple repository:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public interface DocRepository extends JpaRepository&lt;Doc, Long&gt; {\n\n    @Query(value = &quot;SELECT d FROM Doc d WHERE d.id = ?1&quot;)\n    @Lock(LockModeType.OPTIMISTIC)\n    Optional&lt;Doc&gt; findByIdWithLock(Long id);\n}\n</code></pre>\n<p>a service:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Service\npublic class DocService {\n\n    private final DocRepository docRepository;\n    private final EntityManager entityManager;\n    private final DocMapper docMapper;\n\n    public DocService(DocRepository docRepository, EntityManager entityManager, DocMapper docMapper) {\n        this.docRepository = docRepository;\n        this.entityManager = entityManager;\n        this.docMapper = docMapper;\n    }\n\n    public DocDto save(DocDto dto) {\n        var entity = docMapper.toEntity(dto);\n        var saved = docRepository.save(entity);\n        return docMapper.toDto(saved);\n    }\n\n    @Transactional\n    public DocDto update(Long id, DocDto dto) {\n        var updated = docRepository.findByIdWithLock(id)\n                .map(entity -&gt; docMapper.updateWith(entity, dto))\n                .orElseThrow(() -&gt; new EntityNotFoundException(&quot;Document not found&quot;));\n        var saved = docRepository.save(updated);\n        return docMapper.toDto(saved);\n    }\n\n    @Transactional\n    public List&lt;DocDto&gt; findAll() {\n        return docRepository.findAll().stream()\n                .map(docMapper::toDto)\n                .collect(Collectors.toList());\n    }\n\n    public void delete(Long id) {\n        var saved = docRepository.findById(id)\n                .orElseThrow(() -&gt; new EntityNotFoundException(&quot;Document not found&quot;));\n        docRepository.delete(saved);\n    }\n\n    public Long getCount() {\n        return docRepository.count();\n    }\n\n}\n</code></pre>\n<p>controller:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@RestController\n@RequestMapping(path = &quot;/api/doc&quot;)\npublic class DocController {\n\n    private final DocService docService;\n\n    public DocController(DocService docService) {\n        this.docService = docService;\n    }\n\n    @PostMapping(path = {&quot;&quot;, &quot;/&quot;})\n    public ResponseEntity&lt;DocDto&gt; save(@RequestBody DocDto dto) {\n        var response = docService.save(dto);\n        return ResponseEntity.ok(response);\n    }\n\n    @GetMapping(path = {&quot;&quot;, &quot;/&quot;})\n    public ResponseEntity&lt;List&lt;DocDto&gt;&gt; findAll() {\n        var response = docService.findAll();\n        return ResponseEntity.ok(response);\n    }\n\n    @PutMapping(path = &quot;/{id}&quot;)\n    public ResponseEntity&lt;DocDto&gt; update(@PathVariable(value = &quot;id&quot;) Long id, @RequestBody DocDto dto) {\n        var response = docService.update(id, dto);\n        return ResponseEntity.ok(response);\n    }\n\n    @DeleteMapping(path = &quot;/{id}&quot;)\n    public ResponseEntity&lt;Void&gt; delete(@PathVariable(value = &quot;id&quot;) Long id) {\n        docService.delete(id);\n        return ResponseEntity.noContent().build();\n    }\n\n    @ExceptionHandler(value = {EntityNotFoundException.class})\n    @ResponseStatus(HttpStatus.NOT_FOUND)\n    public ResponseEntity&lt;ErrorResponse&gt; handleException(EntityNotFoundException exc) {\n        // ...\n    }\n}\n</code></pre>\n<p>and DTO / Entity mapper:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Component\npublic class DocMapper {\n\n    public Doc toEntity(DocDto dto) {\n        var entity = new Doc()\n                .setParam1(dto.getParam1())\n                .setParam2(dto.getParam2());\n        return entity;\n    }\n\n    public Doc  updateWith(Doc entity, DocDto dto) {\n        entity.setParam1(dto.getParam1())\n              .setParam2(dto.getParam2())\n              .setVersion(1);\n        return entity;\n    }\n\n    public DocDto toDto(Doc entity) {\n        var dto = new DocDto()\n                .setId(entity.getId())\n                .setParam1(entity.getParam1())\n                .setParam2(entity.getParam2())\n                .setVersion(entity.getVersion());\n        return dto;\n    }\n}\n</code></pre>\n",
    "tags" : [ "java", "database", "spring-boot", "jpa", "spring-data-jpa" ],
    "owner" : {
      "account_id" : 11016405,
      "reputation" : 55,
      "user_id" : 8092128,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/ccdd8a04bddd2352ce93b6a024aa8a68?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Witek",
      "link" : "https://stackoverflow.com/users/8092128/witek"
    },
    "is_answered" : false,
    "view_count" : 66,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1742988482,
    "creation_date" : 1742897139,
    "link" : "https://stackoverflow.com/questions/79533309/jpa-version-and-optimistic-locking-problem",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140265535,
    "post_id" : 79533309,
    "body" : "Why are you using findByIdWithLock when you are trying to use optimistic locking? It doesn&#39;t do what you may think it does: &#39;Locking&#39; when using optimistic locking just requests a version bump, but doesn&#39;t specify when it is done. Remove it and it should work the way you are expecting; I believe this is causing Hibernate to eventually increment the existing value in the DB - not the one you are giving it - when it needs to flush with the DB.  I&#39;d say it is a bug, but I still wouldn&#39;t try to use these together anyway.",
    "score" : 0,
    "owner" : {
      "account_id" : 231721,
      "reputation" : 21335,
      "user_id" : 496099,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/efa7510cf47d7bd79e80486246e7e39e?s=256&d=identicon&r=PG",
      "display_name" : "Chris",
      "link" : "https://stackoverflow.com/users/496099/chris"
    },
    "creation_date" : 1742993005,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140260251,
    "post_id" : 79533309,
    "body" : "Try to log SQL updates. You can enable them by adding <code>logging.level.org.hibernate.SQL: DEBUG</code> to application.yaml.",
    "score" : 0,
    "owner" : {
      "account_id" : 4497436,
      "reputation" : 20786,
      "user_id" : 3656904,
      "user_type" : "registered",
      "accept_rate" : 67,
      "profile_image" : "https://www.gravatar.com/avatar/8bdbd1f89f8907e8e8b15ab88c084c65?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "talex",
      "link" : "https://stackoverflow.com/users/3656904/talex"
    },
    "creation_date" : 1742898002,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}