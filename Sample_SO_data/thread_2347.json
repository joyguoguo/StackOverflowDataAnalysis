{
  "question" : {
    "question_id" : 79627049,
    "title" : "Unsolvable Stack Overflow Error in Java Spring Boot",
    "body" : "<p>I have this issue where, upon sending ANY request from my frontend web app (Next.js) to my backend application in Spring Boot, I get a Stack Overflow Error, and not only that, but my application becomes completely useless and always throws this error, no matter what, until computer restart. So if this error is triggered, which I have not found the source of but only some possible causes, then basically my entire ide (IntelliJ) is screwed, even if I rebuild the application from source, or invalidate caches, or clean with maven, nothing works except a clean Windows restart to solve the issue. I have also observed this issue to happen in Linux as well via an active ec2 instance I have running.</p>\n<p>Here is what the error looks like in the terminal, it returns an error 500 InternalServerError:</p>\n<pre><code>May 17 20:14:16 ip-IP.us-east-2.compute.internal java[2209]: 2025-05-17T20:14:16.996Z ERROR 2209 --- [nio-8080-exec-7] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Filter execution threw an exception] with root cause\nMay 17 20:14:16 ip-IP.us-east-2.compute.internal java[2209]: java.lang.StackOverflowError: null\nMay 17 20:14:17 ip-IP.us-east-2.compute.internal java[2209]: at org.springframework.core.BridgeMethodResolver.findBridgedMethod(BridgeMethodResolver.java:71) ~[spring-core-6.2.3.jar!/:6.2.3]\nMay 17 20:14:17 ip-IP.us-east-2.compute.internal java[2209]: at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:356) ~[spring-aop-6.2.3.jar!/:6.2.3]\nMay 17 20:14:17 ip-IP.us-east-2.compute.internal java[2209]: at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:216) ~[spring-aop-6.2.3.jar!/:6.2.3]\nMay 17 20:14:17 ip-IP.us-east-2.compute.internal java[2209]: at jdk.proxy2/jdk.proxy2.$Proxy167.authenticate(Unknown Source) ~[na:na]\nMay 17 20:14:17 ip-IP.us-east-2.compute.internal java[2209]: at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103) ~[na:na]\nMay 17 20:14:17 ip-IP.us-east-2.compute.internal java[2209]: at java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na]\nMay 17 20:14:17 ip-IP.us-east-2.compute.internal java[2209]: at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:359) ~[spring-aop-6.2.3.jar!/:6.2.3]\nMay 17 20:14:17 ip-IP.us-east-2.compute.internal java[2209]: at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:216) ~[spring-aop-6.2.3.jar!/:6.2.3]\nMay 17 20:14:17 ip-IP.us-east-2.compute.internal java[2209]: at jdk.proxy2/jdk.proxy2.$Proxy167.authenticate(Unknown Source) ~[na:na]\nMay 17 20:14:17 ip-IP.us-east-2.compute.internal java[2209]: at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103) ~[na:na]\nMay 17 20:14:17 ip-IP.us-east-2.compute.internal java[2209]: at java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na]\nMay 17 20:14:17 ip-IP.us-east-2.compute.internal java[2209]: at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:359) ~[spring-aop-6.2.3.jar!/:6.2.3]\nMay 17 20:14:17 ip-IP.us-east-2.compute.internal java[2209]: at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:216) ~[spring-aop-6.2.3.jar!/:6.2.3]\nMay 17 20:14:17 ip-IP.us-east-2.compute.internal java[2209]: at jdk.proxy2/jdk.proxy2.$Proxy167.authenticate(Unknown Source) ~[na:na]\n</code></pre>\n<p>aaaaand repeat for about a thousand more lines.</p>\n<p>The issue is triggered specifically when sending API requests to the backend, I THINK to the authentication endpoint, in particular at /api/v1/login. This results in an error 500, and sometimes it just hangs the response to the frontend, other times it will actually throw the InternalServerError with 500.</p>\n<p>This error doesn't occur all the time, only sometimes, but it is much more common when messing with certain code, like trying to configure and adjust the authentication cookies to send from my backend to my frontend upon login. I notice that the error occurs most frequently when trying to fix these cookies / httpServletResponse related bugs that form in my code.</p>\n<p>When I get the SOE error, it is usually triggered (I believe) by my login endpoint, and in dev, once triggered, it remains for ALL endpoints in the server, regardless of the arguments. Even endpoints that do not EXIST (I haven't written controllers for them) return the same SOE error when requested to, when they should usually return &quot;No static resource&quot;. This is true for all types of requests as well, including ones that require a Jwt and ones that don't.</p>\n<p>Here is a fragment of the code I use in my authenticate() service method taking arguments @RequestBody request (a normal java dto class, basically), and HttpServletResponse. The following code is what I use to assign cookies to the response that will be going back to the requestor frontend to verify the user with a JWT cookie. Typically, the issue is most likely to be caused by something to do with this cookies code, and rerunning, and I'm not sure why.</p>\n<pre><code>        // Create and configure cookie for access token\n        Cookie jwtCookie = new Cookie(&quot;auth-token&quot;, accessToken);\n        jwtCookie.setHttpOnly(true);\n        System.out.println(&quot;SECURE COOKIES: &quot; + useSecureCookies);\n        jwtCookie.setSecure(useSecureCookies); // Change to true in production\n        jwtCookie.setPath(&quot;/&quot;);\n        // Set domain conditionally\n        if (Objects.equals(frontendUrl, &quot;mydomain.com&quot;)) {\n            jwtCookie.setDomain(&quot;.mydomain.com&quot;);\n            System.out.println(&quot;TO DOMAIN: &quot; + jwtCookie.getDomain());\n        }\n\n        // Add cookie to response\n//        String cookieValue = String.format(&quot;jwt=%s; Path=/; Max-Age=3600; HttpOnly; Secure; SameSite=None&quot;, accessToken);\n//        response.addHeader(&quot;Set-Cookie&quot;, cookieValue);\n        // THIS is the actual thing that adds cookies to the frontend client\n        response.addCookie(jwtCookie);\n\n        // Create and configure cookie for refresh token as well\n        Cookie refreshCookie = new Cookie(&quot;refresh-token&quot;, refreshToken);\n        refreshCookie.setHttpOnly(true);\n        refreshCookie.setSecure(useSecureCookies); // Change to true in production\n        refreshCookie.setPath(&quot;/&quot;);\n        if (Objects.equals(frontendUrl, &quot;mydomain.com&quot;)) {\n            refreshCookie.setDomain(&quot;.mydomain.com&quot;);\n            System.out.println(&quot;TO DOMAIN: &quot; + jwtCookie.getDomain());\n        }\n\n        // Conditionally set age based on if user entered &quot;rememberMe&quot; or not\n        if (request.getRememberMe()) {\n            refreshCookie.setMaxAge((int) Duration.ofDays(30).toSeconds());\n            System.out.println(&quot;REMEMBERME: &quot; + request.getRememberMe());\n            System.out.println(&quot;MAXAGE: 30 DAYS&quot;);\n        }\n        else {\n            refreshCookie.setMaxAge(-1);\n            System.out.println(&quot;REMEMBERME: &quot; + request.getRememberMe());\n            System.out.println(&quot;MAXAGE: UNTIL END OF SESSION&quot;);\n        }\n\n        // Add refresh cookie to response\n//        String refreshValue = String.format(&quot;refresh=%s; Path=/auth; Max-Age=2592000; HttpOnly; Secure; SameSite=None&quot;, refreshToken);\n//        response.addHeader(&quot;Set-Cookie&quot;, refreshValue); // 30 days\n        // THIS is the actual thing that adds cookies to the frontend client\n        response.addCookie(refreshCookie)\n</code></pre>\n<p>Here also is the code of the controller that calls this service method</p>\n<pre><code>    @PostMapping(&quot;/login&quot;)\n    public ResponseEntity&lt;?&gt; login(\n            @RequestBody LoginRequest loginRequest,\n            HttpServletResponse response\n    ) {\n        try {\n            return loginService.authenticate(loginRequest, response);\n        } catch (RuntimeException e) {\n            e.printStackTrace();\n            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(e.getMessage());\n        } catch (Exception e) {\n            e.printStackTrace();\n            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(&quot;Unexpected error&quot;);\n        }\n    }\n</code></pre>\n<p>The HttpStatus.INTERNAL_SERVER_ERROR is never returned, by the way. Even if the ISE 500 is thrown from the SOE, that line is never returned to the API request, only the huge chunk of text from the SOE directly.</p>\n<p>When I make the login request in dev, I get the above error ALWAYS, however when I do it in prod, something about the build jar is different I guess and it is able to return me the more predictable correct response code (still an error, but fixable):</p>\n<pre><code>May 17 20:25:31 ip-IP.us-east-2.compute.internal java[2209]: Verifying credentials\nMay 17 20:25:31 ip-IP.us-east-2.compute.internal java[2209]: SECURE COOKIES: true\nMay 17 20:25:31 ip-IP.us-east-2.compute.internal java[2209]: TO DOMAIN: .mydomain.com\nMay 17 20:25:31 ip-IP.us-east-2.compute.internal java[2209]: java.lang.IllegalArgumentException: An invalid domain [.mydomain.com] was specified for this cookie\nMay 17 20:25:31 ip-IP.us-east-2.compute.internal java[2209]: at org.apache.tomcat.util.http.Rfc6265CookieProcessor.validateDomain(Rfc6265CookieProcessor.java:253)\nMay 17 20:25:31 ip-IP.us-east-2.compute.internal java[2209]: at org.apache.tomcat.util.http.Rfc6265CookieProcessor.generateHeader(Rfc6265CookieProcessor.java:147)\nMay 17 20:25:31 ip-IP.us-east-2.compute.internal java[2209]: at org.apache.catalina.connector.Response.generateCookieString(Response.java:881)\nMay 17 20:25:31 ip-IP.us-east-2.compute.internal java[2209]: at org.apache.catalina.connector.Response.addCookie(Response.java:837)\n</code></pre>\n<p>Interestingly, I noticed that in production, the SOE bug can still occur, but usually goes away after a little bit or a few requests, while in IntelliJ on my dev setup it sticks around and will be there EVERY time I run the program, regardless of whether I change things or invalidate caches or restart IntelliJ. And just to clarify, this issue does not affect the startup of the program at all. It always works perfectly fine as long as nothing else is wrong, in both dev and prod. It is only any request made to the application that causes the error 500 and huge response code.</p>\n<p>The ONLY fix I have found to work is by restarting Windows. And yes, I can confirm that the code is the exact same from restart to restart, but the build and startup of the jar and request all go smoothly after a restart, at least until the error is triggered again. Then, like I said, it will sort of fix itself in prod after a bit but in dev I'm just screwed permanently every time I start the app until I restart my computer.</p>\n<p>Some things I should note about my project, is that I'm using keycloak as an authentication provider with a Direct Access Grant to user accounts, and because of its jwt structuring I'm using a custom JwtAuthenticationConverter:</p>\n<pre><code>@Component\npublic class JwtAuthenticationConverter implements Converter&lt;Jwt, AbstractAuthenticationToken&gt; {\n\n    private final JwtGrantedAuthoritiesConverter jwtGrantedAuthoritiesConverter =\n            new JwtGrantedAuthoritiesConverter();\n\n\n    // These annotations pull data from the yml file\n    @Value(&quot;${jwt.auth.converter.resource-id}&quot;)\n    private String resourceId;\n    @Value(&quot;${jwt.auth.converter.principal-attribute}&quot;)\n    private String principalAttribute = &quot;resource-id&quot;;\n\n    @Override\n    public AbstractAuthenticationToken convert(@NonNull Jwt jwt) {\n        Collection&lt;GrantedAuthority&gt; authorities = Stream.concat(\n                        jwtGrantedAuthoritiesConverter.convert(jwt).stream(),\n                        extractResourceRoles(jwt).stream()\n                )\n                .collect(Collectors.toSet());\n\n\n        return new JwtAuthenticationToken(jwt, authorities, getPrincipalClaimName(jwt));\n    }\n\n    private String getPrincipalClaimName(Jwt jwt) {\n        String claimName = JwtClaimNames.SUB;\n        if (principalAttribute != null) {\n            claimName = principalAttribute;\n        }\n        return jwt.getClaim(claimName);\n    }\n\n    private Collection&lt;? extends GrantedAuthority&gt; extractResourceRoles(Jwt jwt) {\n        Map&lt;String, Object&gt; resourceAccess = jwt.getClaim(&quot;resource_access&quot;);\n\n        if (resourceAccess == null || !resourceAccess.containsKey(resourceId)) {\n            return Set.of();\n        }\n\n        Map&lt;String, Object&gt; resource = (Map&lt;String, Object&gt;) resourceAccess.get(resourceId);\n\n        if (resource == null || resource.get(&quot;roles&quot;) == null) {\n            return Set.of();\n        }\n\n        Collection&lt;String&gt; resourceRoles;\n        try {\n            resourceRoles = (Collection&lt;String&gt;) resource.get(&quot;roles&quot;);\n        } catch (ClassCastException e) {\n            return Set.of(); // roles field is wrong type somehow\n        }\n\n        return resourceRoles.stream()\n                .map(role -&gt; new SimpleGrantedAuthority(&quot;ROLE_&quot; + role))\n                .collect(Collectors.toSet());\n    }\n}\n</code></pre>\n<p>and additionally I am using a created annotation @CurrentUser which takes type Jwt from all frontend api requests I add it to with the &quot;credentials: include&quot; directive:</p>\n<pre><code>// @CurrentUser class\n@Target(ElementType.PARAMETER)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface CurrentUser {\n}\n\n// Argument resolver in separate class file\n@Component\npublic class CurrentUserArgumentResolver implements HandlerMethodArgumentResolver {\n\n    @Override\n    public boolean supportsParameter(MethodParameter parameter) {\n        return parameter.hasParameterAnnotation(CurrentUser.class) &amp;&amp; parameter.getParameterType().equals(Jwt.class);\n    }\n\n    @Override\n    public Object resolveArgument(MethodParameter parameter,\n                                  ModelAndViewContainer mavContainer,\n                                  NativeWebRequest webRequest,\n                                  WebDataBinderFactory binderFactory) throws Exception {\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        if (authentication != null &amp;&amp; authentication.getPrincipal() instanceof Jwt jwt) {\n            return jwt;\n        }\n        return null;\n    }\n}\n</code></pre>\n<p>I should note I haven't been able to positively identify any one cause of this problem, only that it occurs typically around the /login endpoint. And Spring Boot, keycloak, postgres, docker all function perfectly normally and fine in the absence of this error, I have been working on this project for some time now and I don't think it is caused directly by any one of those.</p>\n<p>I've tried fixing the issue first by just asking ChatGPT 4o / o4-mini-high / 4.5, didn't help, moved on to Gemini 2.5 pro and Gemini definitely knew how to debug better, but even after venturing into the java Spring dependency source code, it couldn't be helped, and nothing seemed to fix the issue.</p>\n<p>This is my first Stack Overflow question, so let me know if I need to change anything or if more info is needed. Sorry for the long read.</p>\n",
    "tags" : [ "java", "spring-boot", "next.js", "jwt", "stack-overflow" ],
    "owner" : {
      "account_id" : 19701752,
      "reputation" : 11,
      "user_id" : 14424342,
      "user_type" : "registered",
      "profile_image" : "https://lh5.googleusercontent.com/-KMVmrG0SWA0/AAAAAAAAAAI/AAAAAAAAAAA/AMZuucn5eTkhnAqbbUG2-u7_yXMU3xoZ0A/s128-rj/s128-rj/s256-rj/photo.jpg",
      "display_name" : "Sleepless",
      "link" : "https://stackoverflow.com/users/14424342/sleepless"
    },
    "is_answered" : false,
    "view_count" : 221,
    "answer_count" : 1,
    "score" : 1,
    "last_activity_date" : 1747539091,
    "creation_date" : 1747523133,
    "link" : "https://stackoverflow.com/questions/79627049/unsolvable-stack-overflow-error-in-java-spring-boot",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79627137,
    "question_id" : 79627049,
    "body" : "<p>Honestly, I don’t believe your StackOverflowError is caused by cookies—especially since it happens sporadically and is “fixed” by a reboot. It’s far more likely that the JVM simply doesn’t have enough stack space. I’d start by increasing the thread stack size with the <code>-Xss</code> option, or even try a different <code>JVM distribution</code>.</p>\n<p>It’s also possible that you have excessively deep call chains—either through recursion or deeply nested method calls—that exhaust the stack. I recommend reviewing your code for any <code>deep recursion</code> or <code>long chains of method invocations</code> and refactoring them (for example, converting recursive algorithms to iterative ones) to prevent the error.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 30382589,
      "reputation" : 23,
      "user_id" : 23283324,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/uo1o9.jpg?s=256",
      "display_name" : "l_______",
      "link" : "https://stackoverflow.com/users/23283324/l"
    },
    "creation_date" : 1747539091,
    "last_activity_date" : 1747539091,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140437702,
    "post_id" : 79627049,
    "body" : "@Sleepless, I already linked two better ways to avoid the usage of public clients and to protect against XSS in my 1st comment. The 2nd (with Cloud Gateway) might be easier to scale and observe (Actuator makes it so easy to collect metrics, logs, and traces).",
    "score" : 0,
    "owner" : {
      "account_id" : 308139,
      "reputation" : 13879,
      "user_id" : 619830,
      "user_type" : "registered",
      "accept_rate" : 75,
      "profile_image" : "https://www.gravatar.com/avatar/f4d00b0a82e9307b1d68b29867fee4e5?s=256&d=identicon&r=PG",
      "display_name" : "ch4mp",
      "link" : "https://stackoverflow.com/users/619830/ch4mp"
    },
    "creation_date" : 1747610215,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140437666,
    "post_id" : 79627049,
    "body" : "@ch4mp that&#39;s absolutely what I&#39;m doing (or trying to do). If I&#39;m being honest, I&#39;m not a programmer by trade, but I&#39;m actually a business student who has learned some web dev over the last 5 months to work on a project idea with a friend, so much of this is new to me. There are still lots of holes in my understanding - auth has been especially complicated - so I redirect most of my &#39;theory&#39; and conventions questions to chatgpt, but I don&#39;t always get the best answer. If there is a better way to do this, like with session, I can try that as well.",
    "score" : 0,
    "owner" : {
      "account_id" : 19701752,
      "reputation" : 11,
      "user_id" : 14424342,
      "user_type" : "registered",
      "profile_image" : "https://lh5.googleusercontent.com/-KMVmrG0SWA0/AAAAAAAAAAI/AAAAAAAAAAA/AMZuucn5eTkhnAqbbUG2-u7_yXMU3xoZ0A/s128-rj/s128-rj/s256-rj/photo.jpg",
      "display_name" : "Sleepless",
      "link" : "https://stackoverflow.com/users/14424342/sleepless"
    },
    "creation_date" : 1747607979,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140437378,
    "post_id" : 79627049,
    "body" : "@gaurav-pingale, he probably does this to hide tokens from the JavaScript code and its dependencies (to prevent XSS attacks). Tokens, like any other kind of credentials, shouldn&#39;t be accessible to the code running on remote devices. Using HttpOnly cookies achieves this purpose, but tokens still transit on the network. Using server memory (session) is more efficient and safer.",
    "score" : 0,
    "owner" : {
      "account_id" : 308139,
      "reputation" : 13879,
      "user_id" : 619830,
      "user_type" : "registered",
      "accept_rate" : 75,
      "profile_image" : "https://www.gravatar.com/avatar/f4d00b0a82e9307b1d68b29867fee4e5?s=256&d=identicon&r=PG",
      "display_name" : "ch4mp",
      "link" : "https://stackoverflow.com/users/619830/ch4mp"
    },
    "creation_date" : 1747595316,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140436359,
    "post_id" : 79627049,
    "body" : "Maybe a bit off-topic, but why are you adding cookies to the response? You should just return the tokens in JSON response and manage tokens on front-end",
    "score" : 0,
    "owner" : {
      "account_id" : 8881618,
      "reputation" : 454,
      "user_id" : 6631495,
      "user_type" : "registered",
      "profile_image" : "https://lh5.googleusercontent.com/-lQPN4VYEU38/AAAAAAAAAAI/AAAAAAAAAnA/VT8B2rX84q0/s128-rj/s256-rj/photo.jpg",
      "display_name" : "Gaurav Pingale",
      "link" : "https://stackoverflow.com/users/6631495/gaurav-pingale"
    },
    "creation_date" : 1747551853,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140436353,
    "post_id" : 79627049,
    "body" : "Welcome to Stack Overflow. I hope your error is not literally unsolvable. If it were, posting it here could not help. Which I hope it does.",
    "score" : 1,
    "owner" : {
      "account_id" : 7612423,
      "reputation" : 87400,
      "user_id" : 5772882,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/8283c64511fa80afed5259d10850168f?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Anonymous",
      "link" : "https://stackoverflow.com/users/5772882/anonymous"
    },
    "creation_date" : 1747551487,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140436108,
    "post_id" : 79627049,
    "body" : "You shouldn&#39;t send tokens to the front end. Instead, use the OAuth2 BFF pattern either with the <a href=\"https://next-auth.js.org/\" rel=\"nofollow noreferrer\">NextAuth.js</a> lib or <a href=\"https://www.baeldung.com/spring-cloud-gateway-bff-oauth2\" rel=\"nofollow noreferrer\">with a Spring Cloud Gateway instance</a>.",
    "score" : 0,
    "owner" : {
      "account_id" : 308139,
      "reputation" : 13879,
      "user_id" : 619830,
      "user_type" : "registered",
      "accept_rate" : 75,
      "profile_image" : "https://www.gravatar.com/avatar/f4d00b0a82e9307b1d68b29867fee4e5?s=256&d=identicon&r=PG",
      "display_name" : "ch4mp",
      "link" : "https://stackoverflow.com/users/619830/ch4mp"
    },
    "creation_date" : 1747533450,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79627137" : [ {
      "comment_id" : 140437661,
      "post_id" : 79627137,
      "body" : "Thanks for responding. I can try increasing stack size, it just seems like a strange thing to need since I still feel like my project is relatively small in overall size, and I have been having this issue which seems to be most likely caused by the authentication processes I am running.  I also don&#39;t think I have a single recursive call in the entire project, but I will have to check to confirm. I think my deepest method nesting is probably 3-4 calls deep from the initial controller call, but it could be much deeper.",
      "score" : 0,
      "owner" : {
        "account_id" : 19701752,
        "reputation" : 11,
        "user_id" : 14424342,
        "user_type" : "registered",
        "profile_image" : "https://lh5.googleusercontent.com/-KMVmrG0SWA0/AAAAAAAAAAI/AAAAAAAAAAA/AMZuucn5eTkhnAqbbUG2-u7_yXMU3xoZ0A/s128-rj/s128-rj/s256-rj/photo.jpg",
        "display_name" : "Sleepless",
        "link" : "https://stackoverflow.com/users/14424342/sleepless"
      },
      "creation_date" : 1747607595,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}