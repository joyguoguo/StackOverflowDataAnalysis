{
  "question" : {
    "question_id" : 79542332,
    "title" : "Problem at moving pacman&#39;s ghost randomly",
    "body" : "<p>I'm building a Pac-Man clone for a school project, and I need some help with the ghost movement logic.</p>\n<p>In my game, I have a state system:</p>\n<p>state = 3 is the initial state, where the ghost exits the ghost room.</p>\n<p>Once it leaves, it transitions to state = 0, where it's supposed to move randomly.</p>\n<p>The problem is that when the ghost changes from state 3 to state 0, it either:\ndoesn't move at all, moves just a little,or even worse — it goes through the walls.</p>\n<p>I'm not sure if it's a logic issue, or if my direction handling is off.\nHere’s the code I'm using (most variable names and comments are in Italian because it’s my first language).</p>\n<pre><code>public class FantasmaRosso extends JPanel implements ActionListener { //Fantasma rosso, tende a rimanere sempre sulla coda di Pac-Man. Segue direttamente Pac-Man\nprivate int blinkyX;          // Posizione sull'asse X\nprivate int blinkyY;          // Posizione sull'asse Y\nprivate int celleBlinkyX;\nprivate int celleBlinkyY;\nprivate final int velocita;   // Velocità del fantasma\nprivate int stato; // Stato del fantasma\nprivate int mangiato; //Chi ha eventualmente mangiato chi\nprivate int direzioneFantasma;\nprivate boolean rifallo;\nprivate BufferedImage immagineBlinkyVersoAlto; //La classe BufferedImage la usiamo per caricare e gestire lo sprite del fantasma nel suo oggetto immagine Blinky\nprivate BufferedImage immagineBlinkyVersoBasso;\nprivate BufferedImage immagineBlinkyVersoDestra;\nprivate BufferedImage immagineBlinkyVersoSinistra;\nprivate Timer timer;\n\nprivate int pacManX; //X del Pacman\nprivate int pacManY;  //Y del Pacman\nprivate int cellePacManX;\nprivate int cellePacManY;\nprivate int vitePacman = 3;\nprivate int precedentiVitePacman;\n\nprivate final int[][] mappaMatrice;\nprivate final int dimensioneCella;\nprivate double distanzaCelle;\n\npublic FantasmaRosso(int dimensioneCella, int pacManX, int pacManY, int[][] mappaMatrice, int vitePacman) {\n    //VALORI DELLA FINESTRA\n    this.mappaMatrice = mappaMatrice;\n    this.dimensioneCella = dimensioneCella;\n\n    //VALORI DEL PACMAN\n    this.pacManX = pacManX;\n    this.pacManY = pacManY;\n\n    //VALORI DEL FANTASMA\n    this.blinkyX = 9*dimensioneCella;\n    this.blinkyY = 8*dimensioneCella;\n    this.velocita = 5;\n    this.stato = 3;\n\n    setBounds(blinkyX, blinkyY, dimensioneCella, dimensioneCella); //posizioniamo e dimensioniamo il componente (= il fantasma) all'interno del contenitore (= mappaMatrice)\n\n    this.caricaImmagine();\n\n    timer = new Timer(16, this); //Crea un timer che aggiorna ogni 20 millisecondi la posizione dello sprite del fantasma invocando il metodo actionPerformed() definito in questa classe. this richiama il metodo actionPerformed() overridato in questa classe: il metodo actionPerformed appartiene all'interfaccia ActionListener, che va quindi implementata in questa classe\n    timer.start(); //avviamo il timer\n\n    repaint(); //ridisegna il fantasma\n}\n\n@Override\npublic void actionPerformed(ActionEvent e){\n    celleBlinkyX = blinkyX/dimensioneCella;\n    celleBlinkyY = blinkyY/dimensioneCella;\n    cellePacManX = pacManX/dimensioneCella;\n    cellePacManY = pacManY/dimensioneCella;\n\n    if(stato == 3){\n        if((blinkyX &gt;= 10*dimensioneCella )&amp;&amp; (blinkyY &lt;= 5*dimensioneCella)){\n            stato = 0;\n        }\n    }\n    /*\n    if(stato == 0){\n\n        distanzaCelle = Math.sqrt( Math.pow(celleX - cellePacManX, 2) + Math.pow(celleY - cellePacManY, 2) ); //Facciamo il teorema di pitagora in modo da considerare se il fantasma dista 5 celle dal pacman verticalmente, orizzontalmente e diagonalmente\n\n        if(distanzaCelle &lt;= 5 ){ //se il fantasma dista 5 celle dal pacman (orizzontalmente, verticalmente o diagonalmente)\n            stato = 1; //passo allo stato di caccia\n        }\n    }\n     */\n\n    this.movimentoFantasma();\n\n    /*\n    if((x == 9*dimensioneCella) &amp;&amp; (y == 8*dimensioneCella)){\n        stato = 3;\n    }\n    if(chiHaMangiatoChi() == 1){\n        stato = 4;\n    }\n    */\n\n    repaint();\n}\n\npublic void caricaImmagine(){\n    try {\n        immagineBlinkyVersoAlto = ImageIO.read(new File(&quot;Resources/ghost/blinky.png&quot;));//Utilizziamo il metodo read() della classe ImageIO per ottenere e caricare l'immagine del fantasma nell'attributo immagineBlinky. Il pathname usato è relativo.\n        immagineBlinkyVersoBasso = ImageIO.read(new File(&quot;Resources/ghost/blinky.png&quot;));\n        immagineBlinkyVersoDestra = ImageIO.read(new File(&quot;Resources/ghost/blinky.png&quot;));\n        immagineBlinkyVersoSinistra = ImageIO.read(new File(&quot;Resources/ghost/blinky.png&quot;));\n    } catch (IOException e) { //In caso si verifica un errore (come l'inesistenza del file o un problema di lettura), l'eccezione IOException generata viene catturata da questo catch.\n        e.printStackTrace(); //Stampa la cronologia dei passaggi fatti per arrivare a questa eccezione.\n    }\n}\n\npublic void movimentoFantasma() {\n    switch(stato) {\n        //Modalità Casuale: Blinky si muove a caso nella mappa\n        case 0 -&gt; {\n\n\n            direzioneFantasma = (int)(Math.random() * 4);\n\n            switch (direzioneFantasma) {\n                case 0 -&gt; {\n                    if(mappaMatrice[blinkyY / dimensioneCella][(blinkyX /dimensioneCella) + 1] == 0 || mappaMatrice[blinkyY / dimensioneCella][(blinkyX /dimensioneCella) + 1] == 3){\n                        this.muoviVersoDestra(dimensioneCella);\n                    }\n                }\n                case 1 -&gt; {\n                    if(mappaMatrice[blinkyY / dimensioneCella][(blinkyX /dimensioneCella) - 1] == 0 || mappaMatrice[blinkyY / dimensioneCella][(blinkyX /dimensioneCella) - 1] == 3){\n                        this.muoviVersoSinistra(dimensioneCella);\n                    }\n                }\n                case 2 -&gt; {\n                    if(mappaMatrice[(blinkyY / dimensioneCella) - 1][blinkyX /dimensioneCella] == 0 || mappaMatrice[(blinkyY / dimensioneCella) - 1][blinkyX /dimensioneCella] == 3){\n                        this.muoviVersoAlto(dimensioneCella);\n                    }\n                }\n                case 3 -&gt; {\n                    if(mappaMatrice[(blinkyY / dimensioneCella) + 1][blinkyX /dimensioneCella] == 0 || mappaMatrice[(blinkyY / dimensioneCella) + 1][blinkyX /dimensioneCella] == 3){\n                        this.muoviVersoBasso(dimensioneCella);\n                    }\n                }\n            }\n        }\n        //Modalità Caccia (Chase): Normale comportamento di Blinky, il quale segue e attacca Pac-Man\n        case 1 -&gt; {\n            if ((pacManX &gt; blinkyX &amp;&amp; mappaMatrice[blinkyY / dimensioneCella][(blinkyX / dimensioneCella) + 1] == 0)) { //Se il pacman è a destra del fantasma e la cella alla destra del fantasma è vuota (ha valore zero)\n                direzioneFantasma = 0;\n                this.muoviVersoDestra(dimensioneCella);\n            }\n            else if (pacManX &lt; blinkyX &amp;&amp; (mappaMatrice[blinkyY / dimensioneCella][(blinkyX / dimensioneCella) - 1] == 0)) {  //Se il pacman è a sinistra del fantasma e la cella alla sinistra del fantasma è vuota (ha valore zero)   //per confrontare la posizione del fantasma nella matrice devi dividere la x e la y del fantasma per 50 perché ogni cella della matrice equivale a 50*50 pixel. dopo di chè aggiungi o sottrai 1 alla x o y per muovere il fantasma rosso\n                direzioneFantasma = 1;\n                this.muoviVersoSinistra(dimensioneCella);\n            }\n            else if (pacManY &lt; blinkyY &amp;&amp; (mappaMatrice[(blinkyY / dimensioneCella) - 1][blinkyX / dimensioneCella] == 0)) { //Se il pacman è più alto del fantasma e la cella sopra il fantasma è vuota (ha valore zero)\n                direzioneFantasma = 2;\n                this.muoviVersoAlto(dimensioneCella);\n            }\n            else if (pacManY &gt; blinkyY &amp;&amp; (mappaMatrice[(blinkyY / dimensioneCella) + 1][blinkyX / dimensioneCella] == 0)) { //Se il pacman è più alto del fantasma e la cella sotto il fantasma è vuota (ha valore zero)\n                direzioneFantasma = 3;\n                this.muoviVersoBasso(dimensioneCella);\n            }\n\n            this.chiHaMangiatoChi();\n        }\n        //Modalità Iniziale: Il fantasma deve uscire dalla stanza dei fantasmi\n        case 3 -&gt; {\n            if(blinkyX &lt; 10*dimensioneCella){\n                direzioneFantasma = 0;\n                this.muoviVersoDestra(dimensioneCella);\n            }else if(blinkyY &gt; 5*dimensioneCella){\n                direzioneFantasma = 1;\n                this.muoviVersoAlto(dimensioneCella);\n            }\n        }\n        //Modalità Ritorna nella stanza dei fantasmi\n        case 4 -&gt; {\n            direzioneFantasma = 0;\n            blinkyX = 9*dimensioneCella;\n            blinkyY = 8*dimensioneCella;\n        }\n\n    }\n\n    setBounds(blinkyX, blinkyY, dimensioneCella, dimensioneCella); //Aggiorno la posizione dell'immagine del fantasma alla sua posizione attuale4\n}\n\npublic void muoviVersoDestra(int dimensioneCella){\n    blinkyX += velocita; //Muovi a destra\n}\npublic void muoviVersoSinistra(int dimensioneCella){\n    blinkyX -= velocita; // Muovi a sinistra\n\n}\npublic void muoviVersoAlto(int dimensioneCella){\n    blinkyY -= velocita; //Muovi verso l'alto\n}\npublic void muoviVersoBasso(int dimensioneCella){\n    blinkyY += velocita; //Muovi verso il basso\n}\n\n//Metodo usato quando Blinky mangia il fantasma rosso\npublic int chiHaMangiatoChi(){\n    mangiato = 0;\n    if((blinkyX /dimensioneCella == pacManX/dimensioneCella) || (blinkyY /dimensioneCella == pacManY/dimensioneCella)){\n        mangiato = 1;\n    }\n    return mangiato;\n}\n\n// Metodo per disegnare il fantasma rosso\n@Override\npublic void paintComponent(Graphics g) { //Usiamo l'oggetto g per impostare l'immagine come sfondo del jPanel MappaGioco\n    super.paintComponent(g); //stiamo chiamando il metodo paintComponents della superclasse JComponent, la quale è la superclasse di JPanel\n    if(direzioneFantasma == 0){\n        g.drawImage(immagineBlinkyVersoDestra, 0, 0, this); //Il metodo drawImage() disegna lo sprite di blinky.\n                                                                        // L'oggetto 'this' (che rappresenta questo JPanel) viene utilizzato come ImageObserver.\n                                                                        // Questo è possibile perché JPanel  implementa implicitamente l'interfaccia ImageObserver.\n                                                                        // In questo modo, il JPanel stesso è in grado di ricevere notifiche sullo stato di caricamento\n                                                                        // dell'immagine e di ridisegnarsi quando l'immagine è pronta per essere visualizzata.\n\n    } else if(direzioneFantasma == 1){\n        g.drawImage(immagineBlinkyVersoSinistra, 0, 0, this);\n    } else if(direzioneFantasma == 2){\n        g.drawImage(immagineBlinkyVersoAlto, 0, 0, this);\n    } else if(direzioneFantasma == 3){\n        g.drawImage(immagineBlinkyVersoBasso, 0, 0, this);\n    }\n}\n\n// Metodi get per ottenere le posizioni del fantasma\npublic int getX() {\n    return blinkyX;\n}\npublic int getY() {\n    return blinkyY;\n}\n\n//Metodi get e set per ottenere e modificare lo stato del fantasma\npublic int getStato(){\n    return stato;\n}\npublic void setStato(int stato) {\n    this.stato = stato;\n}\n\n//Metodi get e set per vedere chi ha mangiato chi\npublic int getMangiato(){\n    return mangiato;\n}\npublic void setMangiato(int mangiato){\n    this.mangiato = mangiato;\n}\n</code></pre>\n<p>}</p>\n<p>This is the stracture of the matrix I'm using in my code:</p>\n<pre><code>mappaMatrice = new int[][]{\n            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},\n            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},\n            {1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1},\n            {1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1},\n            {1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1},\n            {1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1},\n            {1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 2, 2, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1},\n            {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1},\n            {1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1},\n            {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1},\n            {1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1},\n            {1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1},\n            {1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1},\n            {1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1},\n            {1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1},\n            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},\n            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n    };\n</code></pre>\n<p>I’d appreciate any tips on how to properly handle:\nghost movement only on valid paths (not walls), and switching behavior only when it’s at an intersection or corner.</p>\n<p>sorry for the italian parts of the code and for the extensive code.</p>\n<p>Thank you to anyone who can answer me.</p>\n",
    "tags" : [ "java", "logic" ],
    "owner" : {
      "account_id" : 41051210,
      "reputation" : 9,
      "user_id" : 30095927,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/9f57df9d1a501fc6f3fa543a86e4b8ac?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Davide Ricci",
      "link" : "https://stackoverflow.com/users/30095927/davide-ricci"
    },
    "is_answered" : false,
    "view_count" : 52,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1743192560,
    "creation_date" : 1743192560,
    "link" : "https://stackoverflow.com/questions/79542332/problem-at-moving-pacmans-ghost-randomly",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ ],
  "answer_comments" : { }
}