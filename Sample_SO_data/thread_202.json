{
  "question" : {
    "question_id" : 79826579,
    "title" : "Is there a Database First approach in Java like Entity Framework in C#?",
    "body" : "<p>I’m used to working with a <strong>Database First</strong> approach in C#. I design my database schema (often with MySQL Workbench) and do a forward engineering, then generate my C# models using Entity Framework’s. This way, I get classes matching my tables automatically and can use LINQ to manipulate data without writing all the objects manually.</p>\n<p>I’m looking for something similar in Java a tool or framework that can generate Java classes from an existing database and let me easily work with data through an ORM.</p>\n<p>Does Hibernate or JPA support this? What’s the best way to do “Database First” in Java?</p>\n<p>Thanks for your help!</p>\n",
    "tags" : [ "java", "database", "entity-framework", "database-first" ],
    "owner" : {
      "account_id" : 38175820,
      "reputation" : 11,
      "user_id" : 28636783,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/9640c86bbe4fbc51fb4b9a6a2922bcc8?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "alex_pythooon",
      "link" : "https://stackoverflow.com/users/28636783/alex-pythooon"
    },
    "is_answered" : true,
    "view_count" : 78,
    "answer_count" : 4,
    "score" : 0,
    "last_activity_date" : 1763748355,
    "creation_date" : 1763734058,
    "link" : "https://stackoverflow.com/questions/79826579/is-there-a-database-first-approach-in-java-like-entity-framework-in-c",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79826619,
    "question_id" : 79826579,
    "body" : "<p>It's a bit odd to talk about, in bold no less, <strong>Database first</strong> when you're then asking for what comes across as &quot;I find SQL scary and confusing please give me an ORM&quot;. I'm sure that's not what you're intending, of course. But that's essentially what you're asking for.</p>\n<p>As a general rule, java programmers who are comfortable and familiar with their DB engine will:</p>\n<ul>\n<li><p>Lock down the DB engine in use (i.e. they do not write java projects that are db engine agnostic; they know that while thats certainly a nice bonus, in practice the difference between db engine implementations is vast, <em>especially</em> if you take performance into account (writing the fastest combination of SQL queries and java code to make some tricky job run well when the db engine is, say, Postgres, is different vs, say, MS SQL, hence, there's really no point <em>if</em> your project gets to a place where you need to worry about such things. And many projects do get there).</p>\n</li>\n<li><p>Use JDBI or JOOQ; this lets you interact with the database with the best tool for that particular job (namely: The DB engine's own SQL), whilst still being relatively nice to use from java, which JDBC isn't (and wasn't intended to be). These aren't ORMs. They are libraries to 'do SQL' from java in as nice a way as possible.</p>\n</li>\n<li><p>In general, they keep data migration in mind. There's no real point generating <code>CREATE TABLE</code> statements from java if one considers that some day you're going to change the structure of your data. But there's also no point using some GUI tool to click your tables together, and then have some tool generate java code (or C# code) that creates 'model classes' that mirror those table definitions. Because what if you need to migrate? It's possible you can shut down the server, <code>psql</code> your way into your db engine, run all the various <code>ALTER TABLE</code> statements you want to run, then push a new release of your application that has the new models and structures. But usually you can't just easily take the server down for a few hours while you do all that, and you need a lot more than this.</p>\n</li>\n<li><p>They don't ORMise their view of the data. ORMs, and your question, all make an assumption about how to interact with DBs that is unwritten, but very much there: That the right way to think about databases is to think about their tables as the only relevant model available. This is simply incorrect. ORMs, or even simply the act of making a java class that mirrors a table, imply that you think <code>SELECT * FROM myTable</code> is the essential interaction model. But that's rarely the best approach. For example, this is the 'SQL scares me' / 'server-first' / 'all calculations must exist on server no matter how trivial' way to do things, which does not strike me as compatible with the term 'Database first':</p>\n</li>\n</ul>\n<pre class=\"lang-java prettyprint-override\"><code>class RestaurantGuest {\n  String name;\n  int age;\n}\n\nvar today = LocalDate.now();\nvar guests = new ArrayList&lt;RestaurantGuest&gt;();\n\ndbAbstraction.query(&quot;SELECT birthDay, name FROM onlineReservations&quot;).each(row -&gt; {\n  guests.add(new RestaurantGuest(row.getString(&quot;name&quot;), \n  ChronoUnit.YEARS.between(row.getLocalDate(&quot;birthDay&quot;), today)));\n});\n</code></pre>\n<p>This would be the 'database first' way:</p>\n<pre class=\"lang-java prettyprint-override\"><code>class RestaurantGuest {\n  String name;\n  int age;\n}\n\nvar guests = dbAbstraction.query(\n  &quot;SELECT name, EXTRACT YEAR FROM AGE(birthDay, NOW()) AS age FROM onlineReservations&quot;)\n  .map(RestaurantGuest::new)\n  .toList();\n</code></pre>\n<p>'AGE' is a postgres builtin; in various other SQL flavours this would probably involve something like <code>DATEDIFF(year, birthDay, NOW())</code>.</p>\n<p>Note how the existence of a <code>class OnlineReservations</code>, written either by you or by some automatic 'make java classes that mirror my tables' tool, would just be a pointless distraction here. It tries to entice you into the equivalent of doing <code>SELECT *</code> on <code>onlineReservations</code> when that's not actually the right way to approach this problem. It gets worse: Once you've gone down that path, if later on somebody wants to, say, just get an idea of how many children there are, you're tempted to query the entire table and then 'do that math' java-side. But you should obviously be doing that db-side, at least, if you adhere to a 'Database first' principle.</p>\n<p>DB tables aren't OO. Java and C# are. Trying to treat a database as a 'bunch of objects' is therefore a very leaky abstraction that has loads of friction. It starts out right from the bat with something as simple as equality. Let's say you have a class <code>OnlineReservation</code>, representing 1 row of the <code>onlineReservations</code> table. If I have 2 instances of this class with identical data, <em>other than</em> the <code>unid</code> column for this table (let's say, like most DB designs, all rows have a UUID primary key field named 'unid' which holds no intrinsic meaning, it's just the row's id), are they 'equal'?</p>\n<p>They appear to represent the same reservation, so yes. On the other hand, they model a row, and they do not represent the same row, so, no.</p>\n<p>There is no proper answer to this question. That's what I mean when I say 'friction'. Trying to smash this square peg into this round hole runs into a few fundamental problems that you are perenially working around because a clean solution is inherently impossible.</p>\n<p>TL;DR:</p>\n<ul>\n<li>You're looking for JDBI and JOOQ.</li>\n<li>You do not <strong>want</strong> to have java classes that mirror your tables in the first place.</li>\n<li>Start thinking about how to tackle dd migration.</li>\n<li>You need to readjust your thinking, and consider the basic unit of interaction between code and DB <strong>a query</strong> and not <strong>a bunch of objects</strong>. That query can then be <em>mapped</em> to whatever object you want, and you should be making a custom class for each and every query you write.</li>\n<li>Sometimes it's nice to just have a general fire-and-forget CRUD tool, but those are very simple apps (where you basically just slap a light frontend on top of a db model where that frontend just lets you view and edit each row in each table). If that's all you're looking for - <strong>every</strong> DB library under the sun can do that, you can pick whatever looks good. That's not the difficult part. Yes, ORM is probably 'the best', but, optimising for simple cases is not a sensible principle.</li>\n</ul>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107186,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1763736080,
    "last_activity_date" : 1763736080,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79826591,
    "question_id" : 79826579,
    "body" : "<p>You can use <strong>Hibernate Tools</strong> to <strong>reverse engineer</strong> your existing database schema. This automatically generates <strong>Java Entity classes</strong> (POJOs) with JPA annotations, which is functionally equivalent to how Entity Framework generates C# models. Once generated, you manage data using <strong>JPA</strong> and query it with <strong>JPQL</strong> or <strong>Spring Data JPA</strong>.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 44705115,
      "reputation" : 46,
      "user_id" : 31892340,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/261WeowM.png?s=256",
      "display_name" : "Ankit kumar",
      "link" : "https://stackoverflow.com/users/31892340/ankit-kumar"
    },
    "creation_date" : 1763735075,
    "last_activity_date" : 1763735075,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79826632,
    "question_id" : 79826579,
    "body" : "<p>You might want to try MyBatis Generator (MBG). It can automatically generate the following from the database tables: Java POJO classes, Mapper interfaces, and Mapper XML files.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 26698569,
      "reputation" : 4070,
      "user_id" : 20306007,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/98bbc403493aee3681b71dae7abef66e?s=256&d=identicon&r=PG",
      "display_name" : "life888888",
      "link" : "https://stackoverflow.com/users/20306007/life888888"
    },
    "creation_date" : 1763736590,
    "last_activity_date" : 1763736590,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79826832,
    "question_id" : 79826579,
    "body" : "<p>Thank you Ankit kumar, I did not know you could do that this way with Hibernate.</p>\n<p>Thank you life888888, I haven't heard of MyBatis Generator, I'll have a look!</p>\n<p>zwitserloot, thanks for your detailed answer. I appreciate the time you took to write it, and I want to clarify my perspective because I think my original question may have given the wrong impression.</p>\n<p>I definitely do not find SQL or databases scary. My background is in Business Data Processing studies, where we were very data-oriented. We often worked in C#, using ER diagrams, forward engineering, and WPF projects. We generated models from the database, but we never treated those generated classes as the application itself. With MVVM and layered designs, we always separated business logic, view models, domain behavior, and everything else.</p>\n<p>Later, in my professional work with Java, I mostly used Code First approaches with Quarkus, Spring Boot, and Hibernate. So I have experience on both sides, Code First and Database First.</p>\n<p>Recently, I talked with an old classmate who builds ERP modules. His company still uses a Database First approach because it helps them design clean data models from the start, which works well for modular ERP systems. That made me think about the advantages and disadvantages I have seen myself. Code First usually lets you move faster at the beginning, but I often ended up refactoring a lot when the data structure evolved. Database First is slower at the start, but since I think visually, working with ER diagrams makes it easier for me to design something stable and maintainable.</p>\n<p>For personal projects, I want to try combining both ideas. I would design the schema first, maybe generate simple models, and then build a proper hexagonal architecture. Domain objects would stay independent from the persistence layer. For example, a User domain object may have behaviors that are not stored in the database and that are unrelated to table fields.</p>\n<p>My question was not about treating database tables as domain objects. I agree with you on that. I was only asking whether Java has something similar to what I used in C#. I have already done Database First there, but never in Java.</p>\n<p>Both philosophies have their pros and cons.</p>\n<p>By the way, just to be sure before answering you, I tested MySQL Workbench to check that when you modify tables with forward engineering, it doesn’t erase the existing tables and keeps everything. It works. I liked that approach because it really lets you visualize your database (yes, I know UML is not often apprieciated in the working world, but I still like it maybe that’s my old student side showing XD).</p>\n<p>About database engine migration, I might have misunderstood your point. From my experience, switching from MySQL to PostgreSQL is a major change no matter which approach you use. And version upgrades depend heavily on the system’s architecture, not just the ORM.</p>\n<p>Thanks again for your answer and your perspective. And if I misunderstood anything you wrote or you want to add something, feel free to let me know.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 38175820,
      "reputation" : 11,
      "user_id" : 28636783,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/9640c86bbe4fbc51fb4b9a6a2922bcc8?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "alex_pythooon",
      "link" : "https://stackoverflow.com/users/28636783/alex-pythooon"
    },
    "creation_date" : 1763748355,
    "last_activity_date" : 1763748355,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}