{
  "question" : {
    "question_id" : 79610438,
    "title" : "Philips TV APIv6 Pairing: HTTP 200 OK on /pair/grant with Digest Auth, but JSON body returns &quot;INVALID_PIN&quot; (Both Custom App &amp; Python Script)",
    "body" : "<p>I'm attempting to implement the pairing process for a Philips Android/Linux OS TV (model 43PUS8309/62, API version 6) in my Android (Java/Kotlin with OkHttp) application. The TV uses a JointSpace-like API on port 1926 (HTTPS).</p>\n<p>The pairing process, as understood from online resources and a Python script <a href=\"https://github.com/suborb/philips_android_tv\" rel=\"nofollow noreferrer\">(<code>philips_android_tv-master/philips.py</code>)</a>, involves these main steps:</p>\n<ol>\n<li><p><strong>POST to <code>/6/pair/request</code></strong>:</p>\n<ul>\n<li>Payload: <code>{&quot;scope&quot;: [&quot;read&quot;, &quot;write&quot;, &quot;control&quot;], &quot;device&quot;: {&quot;device_name&quot;: &quot;...&quot;, &quot;device_os&quot;: &quot;...&quot;, &quot;app_id&quot;: &quot;...&quot;, &quot;app_name&quot;: &quot;...&quot;, &quot;type&quot;: &quot;native&quot;, &quot;id&quot;: &quot;CLIENT_GENERATED_ID&quot;}}</code></li>\n<li>TV responds with 200 OK and a JSON body containing <code>auth_key</code> and <code>timestamp</code>. A PIN appears on the TV screen.</li>\n</ul>\n</li>\n<li><p><strong>User enters the PIN.</strong></p>\n</li>\n<li><p><strong>POST to <code>/6/pair/grant</code></strong>:</p>\n<ul>\n<li><strong>HTTP Authentication:</strong> This request requires HTTP Digest Authentication.\n<ul>\n<li>Username: The <code>CLIENT_GENERATED_ID</code> from step 1.</li>\n<li>Password: The <code>auth_key</code> received from step 1.</li>\n</ul>\n</li>\n<li><strong>JSON Payload:</strong>\n<pre class=\"lang-json prettyprint-override\"><code>{\n    &quot;auth&quot;: {\n        &quot;pin&quot;: &quot;USER_ENTERED_PIN&quot;,\n        &quot;auth_timestamp&quot;: TIMESTAMP_FROM_STEP_1, // Sent as a number\n        &quot;auth_signature&quot;: &quot;CALCULATED_HMAC_SIGNATURE&quot;,\n        &quot;auth_AppId&quot;: &quot;1&quot; // Or 1 as number\n    },\n    &quot;device&quot;: { /* Same device object as in /pair/request */ }\n}\n</code></pre>\n</li>\n<li><strong>HMAC Signature (<code>auth_signature</code>):</strong> Calculated as <code>Base64.encode(UTF8_bytes( HexString( HMAC_SHA1(decoded_secret_key, UTF8_bytes(timestamp_string + pin_string)) ) ))</code>. The <code>secret_key</code> is a known fixed Base64 string.</li>\n</ul>\n</li>\n</ol>\n<p><strong>The Problem:</strong></p>\n<p>Both my Android application and Python script exhibit the same behavior:</p>\n<ol>\n<li>The <code>/pair/request</code> call is successful, and <code>auth_key</code> / <code>timestamp</code> are received.</li>\n<li>The first attempt to POST to <code>/6/pair/grant</code> (without an <code>Authorization</code> header in my app, or handled by <code>requests</code> library in Python) correctly receives a <strong>401 Unauthorized</strong> from the TV.</li>\n<li>The <code>WWW-Authenticate</code> header is: <code>Digest realm=&quot;XTV&quot;, nonce=&quot;SOME_NONCE&quot;, qop=&quot;auth&quot;</code> (no <code>opaque</code> parameter).</li>\n<li>Both my app and the Python script then correctly calculate the HTTP Digest <code>Authorization</code> header using the client-generated <code>device_id</code> as username and the TV's <code>auth_key</code> as password.</li>\n<li>The second POST request to <code>/6/pair/grant</code> (with the same JSON payload but now including the <code>Authorization: Digest ...</code> header) receives a <strong>200 OK</strong> HTTP status code from the TV.</li>\n<li><strong>Crucially, the JSON body of this 200 OK response is: <code>{&quot;error_id&quot;: &quot;INVALID_PIN&quot;, &quot;error_text&quot;: &quot;Invalid authentication parameters&quot;}</code> for BOTH my application AND the Python script.</strong></li>\n</ol>\n<p><strong>What I've Verified:</strong></p>\n<ul>\n<li><strong>HTTP Digest Authentication is Working:</strong> Receiving 200 OK on the second <code>/pair/grant</code> attempt indicates the TV accepts the Digest credentials.</li>\n<li><strong>HMAC Signature Calculation Seems Correct:</strong>\n<ul>\n<li>I've meticulously compared the HMAC-SHA1 -&gt; Hex String -&gt; UTF-8 Bytes -&gt; Base64 String output between my Java code and the Python script using identical <code>timestamp</code>, <code>pin</code>, and <code>secret_key</code> inputs. The final Base64 <code>auth_signature</code> strings are <strong>identical</strong>.</li>\n<li>Python example (timestamp=&quot;2527&quot;, pin=&quot;8763&quot;): <code>auth_signature=&quot;ZTkwMWE4MTQyNDhmMzdkZDAzNWRjMjY1YzFmM2VlZWViM2JlYTgyNA==&quot;</code></li>\n<li>My Java code with same inputs produces the same Base64 string.</li>\n</ul>\n</li>\n<li><strong>JSON Payload Structure:</strong>\n<ul>\n<li><code>auth_timestamp</code> is sent as a numeric value (Long in Java, int in Python) in the JSON.</li>\n<li><code>auth_AppId</code> is sent as numeric <code>1</code>.</li>\n<li>The <code>device</code> object in the payload for <code>/pair/grant</code> uses the same <code>id</code> (the client-generated one) as in <code>/pair/request</code>.</li>\n<li>I've tried mimicking the <code>device_name</code>, <code>app_name</code>, and <code>app_id</code> from the official Philips TV Remote app logs in my <code>device</code> JSON object for both <code>/pair/request</code> and <code>/pair/grant</code>. This did not change the &quot;INVALID_PIN&quot; outcome.</li>\n</ul>\n</li>\n<li><strong>Initial <code>/system</code> Call:</strong> My app now also makes an initial (unauthenticated) GET request to <code>http://&lt;TV_IP&gt;:1925/system</code> before starting the pairing sequence on port 1926, similar to what the official Philips app does. This also did not change the &quot;INVALID_PIN&quot; outcome for <code>/pair/grant</code>.</li>\n</ul>\n<p><strong>Python Script Snippet (Corrected and Logging):</strong></p>\n<pre class=\"lang-py prettyprint-override\"><code>from __future__ import print_function, unicode_literals\nfrom base64 import b64encode, b64decode\nfrom datetime import datetime\nimport json\nimport sys\nimport requests\nimport random\nimport string\nfrom Crypto.Hash import SHA, HMAC # For HMAC-SHA1\nimport argparse\nfrom requests.auth import HTTPDigestAuth\n\n# Disable SSL warnings (optional, can be used in test environments)\ntry:\n    import urllib3\n    requests.packages.urllib3.disable_warnings()\nexcept ImportError:\n    pass\n\n\n# Fixed secret key used by the TV to create HMAC signature (in Base64 format)\n# We will use the Base64 decoded version of this key.\nSECRET_KEY_BASE64 = &quot;ZmVay1EQVFOaZhwQ4Kv81ypLAZNczV9sG4KkseXWn1NEk6cXmPKO/MCa9sryslvLCFMnNe4Z4CPXzToowvhHvA==&quot;\nDECODED_SECRET_KEY_BYTES = b64decode(SECRET_KEY_BASE64)\n\ndef create_device_id():\n    &quot;&quot;&quot;Generates a random 16-character device ID.&quot;&quot;&quot;\n    return ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits + string.ascii_lowercase) for _ in range(16))\n\ndef create_signature(secret_key_bytes, message_to_sign_bytes):\n    &quot;&quot;&quot;\n    Creates an HMAC-SHA1 signature with the given message and secret key,\n    converts the result to hex, converts this hex string to bytes, and encodes it with Base64.\n    &quot;&quot;&quot;\n    print(f&quot;\\n--- Signature Creation Details (Python) ---&quot;)\n    print(f&quot;[PYTHON] Secret Key Used (byte representation, first 10 bytes): {list(secret_key_bytes[:10])}...&quot;)\n    print(f&quot;[PYTHON] Message to Sign (as string): {message_to_sign_bytes.decode('utf-8')}&quot;)\n    print(f&quot;[PYTHON] Message to Sign (byte representation): {list(message_to_sign_bytes)}&quot;)\n\n    # Create HMAC-SHA1 object\n    hmac_obj = HMAC.new(secret_key_bytes, message_to_sign_bytes, SHA)\n    \n    # Get HMAC result as a hexadecimal string\n    hex_digest_string = hmac_obj.hexdigest()\n    print(f&quot;[PYTHON] HMAC Result (Hex String): {hex_digest_string}&quot;)\n\n    # Convert hex string to UTF-8 bytes (for Base64 encoding)\n    hex_digest_bytes_for_b64 = hex_digest_string.encode('utf-8')\n    print(f&quot;[PYTHON] Hex String Bytes Prepared for Base64 (representation): {list(hex_digest_bytes_for_b64)}&quot;)\n\n    # Encode UTF-8 bytes with Base64\n    signature_base64_bytes = b64encode(hex_digest_bytes_for_b64)\n    \n    # Convert Base64 bytes to string\n    final_signature_string = signature_base64_bytes.decode('utf-8')\n    print(f&quot;[PYTHON] Final Signature (Base64 String): {final_signature_string}&quot;)\n    print(f&quot;--- Signature Creation Details Ended ---\\n&quot;)\n    return final_signature_string\n\ndef get_device_spec_json(app_id_val, device_id_val):\n    &quot;&quot;&quot;Creates a JSON object containing device information for pairing requests.&quot;&quot;&quot;\n    device_spec =  {\n        &quot;device_name&quot;: &quot;Python Test Script&quot;, # Any name you want\n        &quot;device_os&quot;: &quot;Python&quot;,\n        &quot;app_name&quot;: &quot;PyPhilipsTest&quot;,\n        &quot;type&quot;: &quot;native&quot;,\n        &quot;app_id&quot;: app_id_val, # app_id passed as parameter\n        &quot;id&quot;: device_id_val   # device_id passed as parameter\n    }\n    return device_spec\n\ndef pair_with_tv(tv_ip_address, app_id_val=&quot;com.example.pythontest&quot;, simulate_pin=None):\n    &quot;&quot;&quot;\n    Manages the pairing process with a Philips TV.\n    If simulate_pin is provided, it uses that value instead of asking for a PIN from the user.\n    &quot;&quot;&quot;\n    generated_device_id = create_device_id()\n    print(f&quot;TV IP Address: {tv_ip_address}&quot;)\n    print(f&quot;Device ID Generated by the Application (Will be Username): {generated_device_id}&quot;)\n    print(f&quot;App ID Used: {app_id_val}&quot;)\n\n    # --- Step 1: /pair/request ---\n    pair_request_payload = {\n        'scope': [&quot;read&quot;, &quot;write&quot;, &quot;control&quot;],\n        'device': get_device_spec_json(app_id_val, generated_device_id)\n    }\n    request_url = f&quot;https://{tv_ip_address}:1926/6/pair/request&quot;\n    \n    print(f&quot;\\n1. Sending Pairing Request ({request_url})...&quot;)\n    print(f&quot;Payload Sent (pair/request): {json.dumps(pair_request_payload)}&quot;)\n    \n    try:\n        response_request = requests.post(request_url, json=pair_request_payload, verify=False, timeout=10)\n        response_request.raise_for_status() # Raise exception for HTTP errors\n        pair_request_data = response_request.json()\n    except requests.exceptions.RequestException as e:\n        print(f&quot;ERROR: /pair/request failed: {e}&quot;)\n        return\n    except json.JSONDecodeError:\n        print(f&quot;ERROR: /pair/request response is not JSON: {response_request.text}&quot;)\n        return\n\n    print(f&quot;Successful /pair/request response: {pair_request_data}&quot;)\n    \n    tv_auth_timestamp_str = str(pair_request_data.get(&quot;timestamp&quot;)) # Always take as string\n    tv_auth_key = pair_request_data.get(&quot;auth_key&quot;)\n    # auth_Timeout = pair_request_data.get(&quot;timeout&quot;) # Not used but can be retrieved\n\n    if not tv_auth_timestamp_str or not tv_auth_key:\n        print(&quot;ERROR: 'timestamp' or 'auth_key' missing in /pair/request response.&quot;)\n        return\n\n    print(f&quot;Timestamp Received from TV: {tv_auth_timestamp_str}&quot;)\n    print(f&quot;Auth Key Received from TV (This will be the password): {tv_auth_key}&quot;)\n\n    # --- Step 2: Get PIN from User ---\n    if simulate_pin:\n        entered_pin_str = str(simulate_pin)\n        print(f&quot;Simulated PIN used: {entered_pin_str}&quot;)\n    else:\n        entered_pin_str = input(&quot;Please enter the PIN code displayed on the TV screen: &quot;)\n    \n    # --- Step 3: /pair/grant ---\n    # Create the message to sign (timestamp + pin)\n    message_to_sign_bytes = (tv_auth_timestamp_str + entered_pin_str).encode('utf-8')\n    \n    # Generate the signature\n    calculated_signature = create_signature(DECODED_SECRET_KEY_BYTES, message_to_sign_bytes)\n\n    auth_payload_for_grant = {\n        &quot;pin&quot;: entered_pin_str,\n        &quot;auth_timestamp&quot;: int(tv_auth_timestamp_str), # TV may expect int, original Python script sent int\n        &quot;auth_signature&quot;: calculated_signature,\n        &quot;auth_AppId&quot;: &quot;1&quot; # Usually fixed\n    }\n    \n    grant_request_payload = {\n        'auth': auth_payload_for_grant,\n        'device': get_device_spec_json(app_id_val, generated_device_id) # Same device info as in request\n    }\n    \n    grant_url = f&quot;https://{tv_ip_address}:1926/6/pair/grant&quot;\n    print(f&quot;\\n2. Sending Pairing Grant Request ({grant_url})...&quot;)\n    print(f&quot;Payload Sent (pair/grant): {json.dumps(grant_request_payload)}&quot;)\n    \n    try:\n        # HTTPDigestAuth with username = generated_device_id, password = tv_auth_key\n        digest_auth = HTTPDigestAuth(generated_device_id, tv_auth_key)\n        response_grant = requests.post(grant_url, json=grant_request_payload, verify=False, auth=digest_auth, timeout=10)\n        \n        print(f&quot;/pair/grant response code: {response_grant.status_code}&quot;)\n        print(f&quot;/pair/grant response headers: {response_grant.headers}&quot;)\n        grant_response_data = response_grant.json()\n        print(f&quot;Successful /pair/grant response: {grant_response_data}&quot;)\n\n        if response_grant.status_code == 200 and grant_response_data.get(&quot;error_id&quot;) != &quot;INVALID_PIN&quot;: # Or check for &quot;SUCCESS&quot; if applicable\n            print(&quot;\\n********************************************&quot;)\n            print(&quot;PAIRING SUCCESSFUL!&quot;)\n            print(f&quot;Username for subsequent commands (Device ID): {generated_device_id}&quot;)\n            print(f&quot;Password for subsequent commands (Auth Key): {tv_auth_key}&quot;)\n            print(&quot;You can save this information in your Android application.&quot;)\n            print(&quot;********************************************&quot;)\n        else:\n            print(&quot;\\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;)\n            print(&quot;PAIRING SEEMS TO HAVE FAILED (Check TV response).&quot;)\n            print(f&quot;TV Response: {grant_response_data}&quot;)\n            print(&quot;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;)\n\n    except requests.exceptions.RequestException as e:\n        print(f&quot;ERROR: /pair/grant failed: {e}&quot;)\n        if hasattr(e, 'response') and e.response is not None:\n            print(f&quot;Server response (error): {e.response.text}&quot;)\n    except json.JSONDecodeError:\n        print(f&quot;ERROR: /pair/grant response is not JSON: {response_grant.text}&quot;)\n\n\ndef get_general_command(tv_ip_address, username, password, api_path):\n    &quot;&quot;&quot;Sends a GET request to the specified API path.&quot;&quot;&quot;\n    url = f&quot;https://{tv_ip_address}:1926/{api_path.strip('/')}&quot;\n    print(f&quot;\\nSending GET request: {url}&quot;)\n    try:\n        digest_auth = HTTPDigestAuth(username, password)\n        r = requests.get(url, verify=False, auth=digest_auth, timeout=10)\n        r.raise_for_status()\n        print(f&quot;Response Code: {r.status_code}&quot;)\n        print(f&quot;Response Headers: {r.headers}&quot;)\n        print(f&quot;Response Content (JSON): {r.json()}&quot;)\n    except requests.exceptions.RequestException as e:\n        print(f&quot;ERROR: GET request failed: {e}&quot;)\n        if hasattr(e, 'response') and e.response is not None:\n            print(f&quot;Server response (error): {e.response.text}&quot;)\n    except json.JSONDecodeError:\n        print(f&quot;ERROR: Response is not JSON: {r.text}&quot;)\n\n\ndef post_key_command(tv_ip_address, username, password, key_to_send):\n    &quot;&quot;&quot;Sends the specified key to the TV.&quot;&quot;&quot;\n    api_path = &quot;6/input/key&quot;\n    url = f&quot;https://{tv_ip_address}:1926/{api_path}&quot;\n    payload = {&quot;key&quot;: key_to_send}\n    print(f&quot;\\nSending POST request: {url} (Payload: {payload})&quot;)\n    try:\n        digest_auth = HTTPDigestAuth(username, password)\n        r = requests.post(url, json=payload, verify=False, auth=digest_auth, timeout=10)\n        r.raise_for_status()\n        print(f&quot;Response Code: {r.status_code}&quot;)\n        # Philips input/key usually returns empty 200 OK\n        if r.text:\n            print(f&quot;Response Content: {r.text}&quot;)\n        else:\n            print(&quot;Request successful (response body is empty).&quot;)\n    except requests.exceptions.RequestException as e:\n        print(f&quot;ERROR: POST request failed: {e}&quot;)\n        if hasattr(e, 'response') and e.response is not None:\n            print(f&quot;Server response (error): {e.response.text}&quot;)\n\nif __name__ == &quot;__main__&quot;:\n    parser = argparse.ArgumentParser(description='Philips TV Control and Pairing Script')\n    parser.add_argument(&quot;host&quot;, help=&quot;IP address of the TV&quot;)\n    \n    subparsers = parser.add_subparsers(dest=&quot;command&quot;, required=True, help='Command to execute')\n\n    # Pairing command\n    pair_parser = subparsers.add_parser(&quot;pair&quot;, help=&quot;Initiates the pairing process with the TV&quot;)\n    pair_parser.add_argument(&quot;--appid&quot;, default=&quot;com.example.pythontest&quot;, help=&quot;Application ID used for pairing&quot;)\n    pair_parser.add_argument(&quot;--pin&quot;, help=&quot;PIN displayed on the TV for simulation (optional)&quot;)\n\n    # GET commands\n    get_parser = subparsers.add_parser(&quot;get&quot;, help=&quot;Sends a GET request to retrieve information from the TV&quot;)\n    get_parser.add_argument(&quot;path&quot;, help=&quot;API path (e.g., 6/system or system)&quot;)\n    get_parser.add_argument(&quot;user&quot;, help=&quot;Username obtained after pairing (device_id)&quot;)\n    get_parser.add_argument(&quot;password&quot;, help=&quot;Password obtained after pairing (auth_key)&quot;)\n\n    # POST (key) commands\n    post_parser = subparsers.add_parser(&quot;postkey&quot;, help=&quot;Sends a key command to the TV&quot;)\n    post_parser.add_argument(&quot;key&quot;, help=&quot;Key to send (e.g., Standby, VolumeUp)&quot;)\n    post_parser.add_argument(&quot;user&quot;, help=&quot;Username obtained after pairing (device_id)&quot;)\n    post_parser.add_argument(&quot;password&quot;, help=&quot;Password obtained after pairing (auth_key)&quot;)\n    \n    args = parser.parse_args()\n\n    if args.command == &quot;pair&quot;:\n        pair_with_tv(args.host, args.appid, args.pin)\n    elif args.command == &quot;get&quot;:\n        get_general_command(args.host, args.user, args.password, args.path)\n    elif args.command == &quot;postkey&quot;:\n        post_key_command(args.host, args.user, args.password, args.key)\n    else:\n        print(f&quot;Unknown command: {args.command}&quot;)\n        parser.print_help()\n\n## What I've Tried:\n\nI'm attempting to replicate the pairing process for a Philips APIv6 TV, which involves a two-step pairing mechanism after initial device discovery via NSD.\n\n**1. Initial Pairing Request (`/6/pair/request`):**\n\n*   **Action:** I send a POST request to `https://&lt;TV_IP&gt;:1926/6/pair/request`.\n*   **Payload Sent:**\n    ```json\n    {\n        &quot;scope&quot;: [&quot;read&quot;, &quot;write&quot;, &quot;control&quot;],\n        &quot;device&quot;: {\n            &quot;device_name&quot;: &quot;Android device&quot;, // Tried my app name and Philips app name\n            &quot;device_os&quot;: &quot;Android &lt;OS_VERSION&gt;&quot;, // Dynamically set\n            &quot;app_id&quot;: &quot;com.tpvision.philipstvapp2&quot;, // Tried my package name and Philips app package name\n            &quot;app_name&quot;: &quot;Philips TV Remote&quot;,   // Tried my app name and Philips app name\n            &quot;type&quot;: &quot;native&quot;,\n            &quot;id&quot;: &quot;CLIENT_GENERATED_ID_1&quot; // e.g., &quot;IIDU47MyjCqdlYEL&quot;\n        }\n    }\n    ```\n*   **Expected Result:** A 200 OK response with a JSON body containing `auth_key` and `timestamp`, and a PIN appearing on the TV screen.\n*   **Actual Result:** This step is **successful**. I receive a 200 OK and the JSON body with `auth_key` (e.g., &quot;xut3hiaim0qy78f3&quot;) and `timestamp` (e.g., 5573). A PIN appears on the TV.\n\n**2. PIN Entry by User:**\n\n*   **Action:** The user enters the PIN displayed on the TV into my Android application. Let's assume the PIN is &quot;5213&quot; for this example, corresponding to the timestamp &quot;5573&quot;.\n\n**3. Pairing Grant Request (`/6/pair/grant`):**\n\n*   **HMAC Signature Calculation (`auth_signature`):**\n    *   I use the `receivedPhilipsTimestamp` (e.g., &quot;5573&quot;) and the `enteredPin` (e.g., &quot;5213&quot;).\n    *   The message `timestamp_string + pin_string` (e.g., &quot;55735213&quot;) is created.\n    *   This message is HMAC-SHA1 signed using a known, fixed `secret_key` (Base64 decoded).\n    *   The raw HMAC bytes are converted to a lowercase hexadecimal string.\n    *   This hex string is then UTF-8 encoded and Base64 encoded to produce the final `auth_signature`.\n    *   **Verification:** I have meticulously compared this process and its output (intermediate hex string and final Base64 string) with a reference Python script (`philips_android_tv-master/philips.py`) using the *exact same inputs*, and the generated `auth_signature` strings are **identical**.\n        *   Example from my Java logs (timestamp: 5573, PIN: 5213): `auth_signature=&quot;NTNjMzM1MjlmMmY0NDc1Y2FmNTYxYTdhZjFjMTg3NGRjYjUzM2RhZQ==&quot;` (matches Python for same inputs).\n\n*   **JSON Payload for `/pair/grant`:**\n    ```json\n    {\n        &quot;auth&quot;: {\n            &quot;pin&quot;: &quot;5213&quot;, // User-entered PIN\n            &quot;auth_timestamp&quot;: 5573, // Numeric timestamp from /pair/request\n            &quot;auth_signature&quot;: &quot;NTNjMzM1MjlmMmY0NDc1Y2FmNTYxYTdhZjFjMTg3NGRjYjUzM2RhZQ==&quot;, // Calculated signature\n            &quot;auth_AppId&quot;: 1 // Numeric 1\n        },\n        &quot;device&quot;: { // Same device object as in /pair/request, using CLIENT_GENERATED_ID_1\n            &quot;device_name&quot;: &quot;Android device&quot;,\n            &quot;device_os&quot;: &quot;Android &lt;OS_VERSION&gt;&quot;,\n            &quot;app_id&quot;: &quot;com.tpvision.philipstvapp2&quot;,\n            &quot;app_name&quot;: &quot;Philips TV Remote&quot;,\n            &quot;type&quot;: &quot;native&quot;,\n            &quot;id&quot;: &quot;IIDU47MyjCqdlYEL&quot;\n        }\n    }\n    ```\n\n*   **Attempt 1: Sending `/pair/grant` without Digest Auth:**\n    *   **Action:** POST the above JSON payload to `https://&lt;TV_IP&gt;:1926/6/pair/grant` without an `Authorization` header.\n    *   **Expected Result:** A 401 Unauthorized response with a `WWW-Authenticate: Digest ...` header.\n    *   **Actual Result:** This is **successful**. I receive a 401 with the header: `WWW-Authenticate: Digest realm=&quot;XTV&quot;, nonce=&quot;SOME_NEW_NONCE&quot;, qop=&quot;auth&quot;`.\n\n*   **Attempt 2: Sending `/pair/grant` with Digest Auth:**\n    *   **Action:**\n        1.  Parse the `realm`, `nonce`, `qop` from the 401 challenge.\n        2.  Generate a client `cnonce` and set `nc` to &quot;00000001&quot;.\n        3.  Calculate the Digest `response` using:\n            *   Username: The `CLIENT_GENERATED_ID_1` (e.g., &quot;IIDU47MyjCqdlYEL&quot;).\n            *   Password: The `receivedPhilipsAuthKey` (e.g., &quot;xut3hiaim0qy78f3&quot;).\n            *   Other parameters from the challenge and request (method: &quot;POST&quot;, uri: &quot;/6/pair/grant&quot;).\n        4.  Construct the `Authorization: Digest ...` header.\n        5.  Resend the POST request to `https://&lt;TV_IP&gt;:1926/6/pair/grant` with the **same JSON payload** as Attempt 1, but now including the calculated `Authorization` header.\n    *   **Expected Result:** A 200 OK response with a JSON body indicating successful pairing (e.g., `{&quot;error_id&quot;: &quot;SUCCESS&quot;, &quot;error_text&quot;: &quot;Pairing completed&quot;}`), as seen in logs from the official Philips TV Remote app.\n    *   **Actual Result:** I receive a **200 OK HTTP status code**. However, the JSON body of this response is consistently:\n        ```json\n        {\n            &quot;error_id&quot;: &quot;INVALID_PIN&quot;,\n            &quot;error_text&quot;: &quot;Invalid authentication parameters&quot;\n        }\n        ```\n        This same &quot;INVALID_PIN&quot; in a 200 OK response body is also observed when running the corrected Python reference script (which now correctly uses `HTTPDigestAuth` for the `/pair/grant` call).\n\n**Summary of the Core Issue:**\n\nDespite successfully passing HTTP Digest Authentication for the `/6/pair/grant` endpoint (evidenced by the 200 OK status), the TV's application layer rejects the request with an &quot;INVALID_PIN&quot; error in the JSON response. This occurs even when the HMAC SHA1 signature in the payload appears to be correctly calculated and matches the output of a reference Python script for identical inputs. I've also tried to match the `device` information in the payload to what the official Philips app sends.\n\nI am looking for insights into why the TV might still return &quot;INVALID_PIN&quot; in this scenario or what other aspects of the Philips APIv6 pairing process I might be overlooking.\n</code></pre>\n",
    "tags" : [ "java", "android", "kotlin", "hmac", "smart-tv" ],
    "owner" : {
      "account_id" : 38228857,
      "reputation" : 31,
      "user_id" : 28665990,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/c58d9c8cc8d085397892a14fa04b7b57?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Artiquana",
      "link" : "https://stackoverflow.com/users/28665990/artiquana"
    },
    "is_answered" : false,
    "view_count" : 141,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1746618052,
    "creation_date" : 1746618052,
    "link" : "https://stackoverflow.com/questions/79610438/philips-tv-apiv6-pairing-http-200-ok-on-pair-grant-with-digest-auth-but-json",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ ],
  "answer_comments" : { }
}