{
  "question" : {
    "question_id" : 79647993,
    "title" : "Android onLocationChanged() callback not working when the screen is off",
    "body" : "<p>I'm relatively new to Android programming, and I was trying to create an app with a Foreground Service (I'm targeting API 31 or higher) which uses Location and Sensors. I've implemented both <code>SensorEventListener</code> and <code>LocationListener</code> and their respective interface methods <code>onSensorChanged()</code> and <code>onLocationChanged()</code>. They both work as intended when the App's Activities are in Foreground, but <code>onLocationChanged()</code> is not called when I turn the device's screen off.</p>\n<p>In my manifest, I request the following permissions:</p>\n<pre class=\"lang-xml prettyprint-override\"><code>...\n&lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE&quot;/&gt;\n&lt;uses-permission android:name=&quot;android.permission.FOREGROUND_SERVICE_LOCATION&quot;/&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&gt;\n&lt;uses-permission android:name=&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot;/&gt;\n&lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot;/&gt;\n&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;/&gt;\n...\n</code></pre>\n<p>and I've requested them dynamically in my main activity; I've declared my service with</p>\n<pre><code>&lt;service\n    ...\n    android:exported=&quot;false&quot;\n    android:foregroundServiceType=&quot;location&quot;&gt;\n&lt;/service&gt;\n</code></pre>\n<p>In my activity, I'm starting my Foreground Service with</p>\n<pre class=\"lang-java prettyprint-override\"><code>startForegroundService(i);\n</code></pre>\n<p>and in the service's onStartCommand() method, I'm using</p>\n<pre class=\"lang-java prettyprint-override\"><code>ServiceCompat.startForeground(this, notification_id, serviceNotification, FOREGROUND_SERVICE_TYPE_LOCATION);\n</code></pre>\n<p>The Service starts normally and the notification I've created is posted as intended; in service's onCreate() I've registered both the callback methods for sensors and location change</p>\n<pre class=\"lang-java prettyprint-override\"><code>SensorManager sm = (SensorManager) getSystemService(SENSOR_SERVICE);\nsm.registerListener(this, accelSensor, SensorManager.SENSOR_DELAY_UI);\nsm.registerListener(this, rotationVectorSensor, SensorManager.SENSOR_DELAY_UI);\n\n...\n\nLocationManager lm = (LocationManager) getSystemService(LOCATION_SERVICE);\nlm.requestLocationUpdates(LocationManager.GPS_PROVIDER, 50, 5.f, this);\n</code></pre>\n<p>I've noticed that if I used my app with the screen off but with something that kept the device working (for example a GPS Navigator on Android Auto) both the callback methods worked as intended, so I've also tried to use a WakeLock in my service's onStartCommand</p>\n<pre class=\"lang-java prettyprint-override\"><code>PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);\nwakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, &quot;myService::ServiceWakeLockTAG&quot;);\nwakeLock.acquire();\n\n...\n</code></pre>\n<p>which I later release in the service's onDestroy method</p>\n<pre class=\"lang-java prettyprint-override\"><code>...\n\nwakeLock.release();\n</code></pre>\n<p>After all of this, I've also &quot;whitelisted&quot; my app in the device settings, so it is not restricted by Android's battery saving options, but my problem still remains, and what I can see from the logs is that the onLocationChanged() is not called if the screen is off.</p>\n<p>Is there any way to ensure my app keeps working as intended even in this condition?</p>\n",
    "tags" : [ "java", "android", "xml", "gps", "wakelock" ],
    "owner" : {
      "account_id" : 42316605,
      "reputation" : 1,
      "user_id" : 30692481,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/fd0d49b5e35de7a2e0a4392f60cdebc7?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "loore",
      "link" : "https://stackoverflow.com/users/30692481/loore"
    },
    "is_answered" : false,
    "view_count" : 92,
    "answer_count" : 2,
    "score" : 0,
    "last_activity_date" : 1749968348,
    "creation_date" : 1748817100,
    "link" : "https://stackoverflow.com/questions/79647993/android-onlocationchanged-callback-not-working-when-the-screen-is-off",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79649988,
    "question_id" : 79647993,
    "body" : "<p>When the screen is off on Android (especially API 31+),the system goes into Doze Mode and enforces App Standby restrictions. This aggressively limits background processes, particularly GPS access, to save battery, even for Foreground Services with PARTIAL_WAKE_LOCK. Sensors (onSensorChanged()) are often left active since they consume less power and may not be as severely restricted.</p>\n<p>I advise you to try it:</p>\n<ul>\n<li><strong>Utilize Fused Location Provider API.</strong> This is Google's recommended API for location. This is the most reliable method. It combines GPS, Wi-Fi, and cellular data for optimal accuracy and battery usage in the background.</li>\n</ul>\n<pre class=\"lang-java prettyprint-override\"><code>// Add the dependency\nimplementation 'com.google.android.gms:play-services-location:21.0.1'\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import com.google.android.gms.location.FusedLocationProviderClient;\nimport com.google.android.gms.location.LocationCallback;\nimport com.google.android.gms.location.LocationRequest;\nimport com.google.android.gms.location.LocationResult;\nimport com.google.android.gms.location.LocationServices;\nimport android.location.Location; \nimport android.os.Looper; \nimport android.os.PowerManager;\n\npublic class YourLocationService extends Service {\n\n    private FusedLocationProviderClient fusedLocationClient;\n    private LocationCallback locationCallback;\n    private PowerManager.WakeLock wakeLock; // Assuming this is already declared\n\n    // ... other service fields and methods\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        // ... your existing onCreate() code for sensors\n\n        // 1. Initialize FusedLocationProviderClient\n        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this);\n\n        // 2. Create LocationRequest (configures update frequency and accuracy)\n        LocationRequest locationRequest = LocationRequest.create();\n        locationRequest.setInterval(5000);        \n        locationRequest.setFastestInterval(2000);\n        locationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY); \n\n        // 3. Create LocationCallback (where location data will be received)\n        locationCallback = new LocationCallback() {\n            @Override\n            public void onLocationResult(@NonNull LocationResult locationResult) {\n                if (locationResult == null) {\n                    return;\n                }\n                for (Location location : locationResult.getLocations()) {\n                    // You receive the new Location object here \n                    // Process or pass the location data, e.g., to your existing onLocationChanged()\n                }\n            }\n        };\n\n        // 4. Request location updates\n        try {\n            fusedLocationClient.requestLocationUpdates(locationRequest, locationCallback, Looper.getMainLooper());\n        } catch (SecurityException e) {\n            Log.e(&quot;YourService&quot;, &quot;Location permission not granted for FusedLocationProvider!&quot;, e);\n        }\n\n        // ... your existing code for acquiring WakeLock:\n      \n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        // 5. Crucially, remove location updates in onDestroy()\n        if (fusedLocationClient != null &amp;&amp; locationCallback != null) {\n            fusedLocationClient.removeLocationUpdates(locationCallback);\n        }\n\n        // ... your existing code for releasing WakeLock:\n \n    }\n\n    // ... other service methods\n}\n</code></pre>\n<ul>\n<li><strong>Add to your manifest:</strong></li>\n</ul>\n<pre class=\"lang-java prettyprint-override\"><code>&lt;uses-permission android:name=&quot;android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS&quot;/&gt;\n</code></pre>\n<ul>\n<li><strong>Add Battery Optimization Exemption Request in MainActivity.</strong> Add this code to your main activity to prompt the user to ignore battery optimizations.</li>\n</ul>\n<pre class=\"lang-java prettyprint-override\"><code>private void checkAndRequestBatteryOptimizationExemption() {\n    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) { \n        PowerManager powerManager = (PowerManager) getSystemService(POWER_SERVICE);\n        String packageName = getPackageName();\n\n        if (powerManager != null &amp;&amp; !powerManager.isIgnoringBatteryOptimizations(packageName)) {\n            Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);\n            intent.setData(Uri.parse(&quot;package:&quot; + packageName));\n            try {\n                startActivity(intent);\n            } catch (Exception e) {\n                // Handle exception if the intent cannot be started\n                Toast.makeText(this, &quot;Please manually disable battery optimization for this app in settings.&quot;, Toast.LENGTH_LONG).show();\n            }\n        }\n    }\n}\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 15045413,
      "reputation" : 313,
      "user_id" : 10858737,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/xVVGa7ai.jpg?s=256",
      "display_name" : "Elizabeth",
      "link" : "https://stackoverflow.com/users/10858737/elizabeth"
    },
    "creation_date" : 1748880814,
    "last_activity_date" : 1748880814,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79666347,
    "question_id" : 79647993,
    "body" : "<p>Starting from Android 10 (API 29) and even more strictly in Android 12+ (API 31), <code>LocationManager</code> becomes unreliable when the device enters Doze mode or the screen is turned off, even with a wake lock and a foreground service.</p>\n<p>The core issue is <code>LocationManager</code> is not guaranteed to deliver updates in idle/doze modes, even in a foreground service.</p>\n<p>Instead of <code>LocationManager</code>, switch to Google's Fused Location Provider, which is more reliable, battery-aware, and continues to deliver updates even with the screen off (assuming proper setup).</p>\n<p>1. Add the dependency:</p>\n<pre><code>implementation 'com.google.android.gms:play-services-location:21.0.1'\n</code></pre>\n<p>2. Replace <code>LocationManager</code> with FusedLocationProviderClient:<br />\nIn your foreground service:</p>\n<pre class=\"lang-java prettyprint-override\"><code>private FusedLocationProviderClient fusedLocationClient;\nprivate LocationCallback locationCallback;\n\n@Override\npublic void onCreate() {\n    super.onCreate();\n    fusedLocationClient = LocationServices.getFusedLocationProviderClient(this);\n\n    locationCallback = new LocationCallback() {\n        @Override\n        public void onLocationResult(LocationResult locationResult) {\n            for (Location location : locationResult.getLocations()) {\n                // Handle location update here\n                Log.d(&quot;LocationUpdate&quot;, location.toString());\n            }\n        }\n    };\n\n    LocationRequest locationRequest = LocationRequest.create()\n        .setInterval(10000) // 10 seconds\n        .setFastestInterval(5000)\n        .setPriority(Priority.PRIORITY_HIGH_ACCURACY);\n\n    fusedLocationClient.requestLocationUpdates(\n        locationRequest,\n        locationCallback,\n        Looper.getMainLooper()\n    );\n}\n</code></pre>\n<p>3. Keep your existing Foreground Service setup:<br />\nEnsure you are calling <code>startForeground()</code> correctly and targeting:</p>\n<pre class=\"lang-xml prettyprint-override\"><code>&lt;service\n    android:foregroundServiceType=&quot;location&quot;\n    android:exported=&quot;false&quot; /&gt;\n</code></pre>\n<p>4. Hold a WakeLock <em>(Optional but helps in edge case)</em>:</p>\n<pre class=\"lang-java prettyprint-override\"><code>PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);\nwakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, &quot;MyApp::LocationWakeLock&quot;);\nwakeLock.acquire();\n</code></pre>\n<p>5. Request location permissions dynamically, including background:</p>\n<pre><code>Manifest.permission.ACCESS_FINE_LOCATION\nManifest.permission.ACCESS_COARSE_LOCATION\nManifest.permission.ACCESS_BACKGROUND_LOCATION\nManifest.permission.FOREGROUND_SERVICE\n</code></pre>\n<p>6. Also, check battery optimizations:</p>\n<pre><code>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {\n    PowerManager pm = (PowerManager) getSystemService(POWER_SERVICE);\n    if (!pm.isIgnoringBatteryOptimizations(getPackageName())) {\n        Intent intent = new Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS);\n        intent.setData(Uri.parse(&quot;package:&quot; + getPackageName()));\n        startActivity(intent);\n    }\n}\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 19789106,
      "reputation" : 128,
      "user_id" : 14492452,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/fzUoN746.png?s=256",
      "display_name" : "Jeevandeep Saini",
      "link" : "https://stackoverflow.com/users/14492452/jeevandeep-saini"
    },
    "creation_date" : 1749968348,
    "last_activity_date" : 1749968348,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}