{
  "question" : {
    "question_id" : 79590535,
    "title" : "Measuring Logging performance",
    "body" : "<p>I am trying to measure logging performance in combination with in unit test. What I noticed is, the first block that gets executed gets some overhead get added. The code below is one case with <code>StringEscapeUtils.escapeJava</code> but I have also come across this behaviour in other tests. Has anyone come across this and know the reason?</p>\n<pre><code>import org.junit.jupiter.api.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nclass MyTests {\n    private static final Logger LOGGER = LoggerFactory.getLogger(MyTests.class);\n\n    protected String getSaltString(final int length) {\n        String SALTCHARS = &quot;ABCDEFGHIJKLMNOPQRSTUVWXY\\nZ1234567890&quot;;\n        StringBuilder salt = new StringBuilder();\n        Random rnd = new Random();\n        while (salt.length() &lt; length) { // length of the random string.\n            int index = (int) (rnd.nextFloat() * SALTCHARS.length());\n            salt.append(SALTCHARS.charAt(index));\n        }\n        String saltStr = salt.toString();\n        return saltStr;\n\n    }\n\n    private void dummy(final String str) {\n\n    }\n\n    @Test\n    public void testNewlineInString() {\n        long start = 0, end = 0;\n        final int Times = 1000;\n\n        LOGGER.info(&quot;starting..&quot;);\n\n        String [] strings = new String[Times];\n        for (int i = 0; i &lt; Times; ++i) {\n            strings[i] = getSaltString(100);\n        }\n\n        LOGGER.info(&quot;Generated strings..&quot;);\n\n        start = Instant.now().toEpochMilli();\n        for (int i = 0; i &lt; Times; ++i) {\n            LOGGER.info(&quot;Case 1: String Number: {} Name: {}&quot;, i + 1, strings[i]);\n//          dummy(strings[i]);\n        }\n        end = Instant.now().toEpochMilli();\n        final long durationNo_escapeJava = end - start;\n\n        start = Instant.now().toEpochMilli();\n        for (int i = 0; i &lt; Times; ++i) {\n            LOGGER.info(&quot;Case 2: String Number: {} Name: {}&quot;, i + 1, StringEscapeUtils.escapeJava(strings[i]));\n//          dummy(StringEscapeUtils.escapeJava(strings[i]));\n        }\n        end = Instant.now().toEpochMilli();\n        final long duration_escapeJava = end - start;\n\n        start = Instant.now().toEpochMilli();\n        for (int i = 0; i &lt; Times; ++i) {\n            LOGGER.info(&quot;Case 3: String Number: {} Name: {}&quot;, i + 1, strings[i]);\n//          dummy(strings[i]);\n        }\n        end = Instant.now().toEpochMilli();\n        final long durationNo_escapeJavaAgain = end - start;\n\n\n        LOGGER.info(&quot;durationNo_escapeJava: {} duration_escapeJava: {} durationNo_escapeJavaAgain: {}&quot;,\n                durationNo_escapeJava, duration_escapeJava, durationNo_escapeJavaAgain);\n\n    }\n}\n</code></pre>\n<p>The result consistently shows that the first block takes much more than 3rd block which is essentially same.</p>\n<p>for example:</p>\n<p>durationNo_escapeJava: 265 duration_escapeJava: 107 durationNo_escapeJavaAgain: 28</p>\n<p>I have tried using a function call, function <code>dummy</code> in the example above but it does not have this problem.</p>\n",
    "tags" : [ "java", "logging", "slf4j" ],
    "owner" : {
      "account_id" : 41589294,
      "reputation" : 5,
      "user_id" : 30360496,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/178cc1cf4e28280b839174665fb823cb?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "user30360496",
      "link" : "https://stackoverflow.com/users/30360496/user30360496"
    },
    "is_answered" : true,
    "view_count" : 60,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1745497931,
    "creation_date" : 1745496101,
    "link" : "https://stackoverflow.com/questions/79590535/measuring-logging-performance",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79590584,
    "question_id" : 79590535,
    "body" : "<p>What you're observing has to do with the JVM warm-up and the nature of a JIT compiler that optimizes code at runtime.</p>\n<p>There's a whole article about that topic on <a href=\"https://www.baeldung.com/java-jvm-warmup\" rel=\"nofollow noreferrer\">Baeldung.com</a></p>\n<p>I'd suggest you use the &quot;JMH - Java Microbenchmark Harness&quot; framework mentioned in the article for benchmarking your program.</p>\n",
    "score" : 1,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 28568877,
      "reputation" : 68,
      "user_id" : 21871376,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/176a8b578938d6f0d75d59c5e4951d66?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Hahzeeboo",
      "link" : "https://stackoverflow.com/users/21871376/hahzeeboo"
    },
    "creation_date" : 1745497455,
    "last_activity_date" : 1745497931,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140365348,
    "post_id" : 79590535,
    "body" : "Are you sure <code>Instant.now().toEpochMilli()</code> gives you the precesion you need for your test? Are you sure that you are not measuring JIT compiler invocations in between? Are you sure you know how to write performance tests in Java by having looked at <a href=\"https://github.com/openjdk/jmh\" rel=\"nofollow noreferrer\">jmh</a> first?",
    "score" : 1,
    "owner" : {
      "account_id" : 1580843,
      "reputation" : 13706,
      "user_id" : 1466267,
      "user_type" : "registered",
      "accept_rate" : 91,
      "profile_image" : "https://www.gravatar.com/avatar/c47d1f7544a8c4a1bb7a41d511f53604?s=256&d=identicon&r=PG",
      "display_name" : "SpaceTrucker",
      "link" : "https://stackoverflow.com/users/1466267/spacetrucker"
    },
    "creation_date" : 1745497692,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79590584" : [ {
      "comment_id" : 140371661,
      "post_id" : 79590584,
      "body" : "Not just JIT and warm up, but also the fact that Java loads classes on-demand (unless you count that under warm up).",
      "score" : 1,
      "owner" : {
        "account_id" : 213468,
        "reputation" : 110282,
        "user_id" : 466862,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/d873f397779db38cd510d9ee5416fd43?s=256&d=identicon&r=PG",
        "display_name" : "Mark Rotteveel",
        "link" : "https://stackoverflow.com/users/466862/mark-rotteveel"
      },
      "creation_date" : 1745668573,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}