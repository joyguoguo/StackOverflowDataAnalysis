{
  "question" : {
    "question_id" : 79594341,
    "title" : "ArrayList vs LinkedList in terms of cache locality",
    "body" : "<p>How does cache locality impact the performance of ArrayList compared to LinkedList in Java?</p>\n<p>I've often heard that ArrayList has an advantage in terms of cache locality, but I don't fully understand why. Since Java stores objects in memory as references, wouldn't accessing elements in either list require jumping to random locations in memory?</p>\n",
    "tags" : [ "java", "arraylist", "linked-list", "cache-locality" ],
    "owner" : {
      "account_id" : 29999041,
      "reputation" : 73,
      "user_id" : 22989572,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/ACg8ocI8MFnMQ5UFoxF7AR3soJArQ26CSzpUQwuATq6cJkZ2vw=k-s256",
      "display_name" : "Marat Tim",
      "link" : "https://stackoverflow.com/users/22989572/marat-tim"
    },
    "is_answered" : true,
    "view_count" : 368,
    "answer_count" : 3,
    "score" : 3,
    "last_activity_date" : 1745942426,
    "creation_date" : 1745697032,
    "link" : "https://stackoverflow.com/questions/79594341/arraylist-vs-linkedlist-in-terms-of-cache-locality",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79594564,
    "question_id" : 79594341,
    "body" : "<p>Hold on, let's first illustrate how java works, because without that knowledge you can't make heads or tails of these conflicting statements about 'everything is a link'.</p>\n<p>In java, <strong>every</strong> variable is fixed size and very small. This is highly convenient, because it allows making such grand, sweeping statements such as &quot;whenever you call a method, <em>every</em> parameter is copied to the method you are calling; that method can do whatever it wants with these copies, and the copies poof out of existence once that method has finished execution&quot;. After all, if you make that statement and a variable is 2 GB large, then passing it around will very very swiftly cause out of memory errors.</p>\n<p>But, how does that work? Surely <code>List&lt;String&gt; list = enumerateEveryWordInTheCollectedWorksOfShakespeare();</code> is not &quot;fixed, small size&quot;.</p>\n<p>That's where the second part kicks in: In java, you have primitives, which is this hardcoded list of types: <code>int</code>, <code>long</code>, <code>short</code>, <code>byte</code>, <code>double</code>, <code>float</code>, <code>char</code>, <code>boolean</code>. (That's been the list since forever, this list will never change, you cannot make your own primitives ^1) - each and every one of those is 'fixed, small size' (specifically, they are all 64 bits or less). And everything else is a <strong>reference</strong>. A pointer.</p>\n<p>When you write:</p>\n<pre><code>String x = &quot;hello&quot;;\n</code></pre>\n<p>Then it is incorrect to say &quot;x is hello&quot;. It's not. x is <strong>a reference</strong> to it.</p>\n<p>It's like &quot;Hello&quot; is a house (think about it: Strings can be arbitrarily long. They can be the entire collected works of shakespeare. Very much not 'fixed, small size'), and x is merely a page in an address book. It's an instruction that tells you how to get to the house. Given that page, if you wanna know if the house is red, you can do it - just.. go there, and look. All you need is the page. But you do need to spend the time, so to speak.</p>\n<h2><code>ArrayList</code></h2>\n<p>ArrayList is 'a list of links' in that exact sense: By definition, you can't have an arraylist of primitive values (you can have a <code>List&lt;Integer&gt;</code>; <code>Integer</code> is the boxed, i.e. 'reference' version of <code>int</code>. <code>List&lt;int&gt;</code> is not valid java), hence, it must be a list of references. That means an <code>ArrayList</code> <strong>is an address book</strong>. It's a list of addresses.</p>\n<p>The list is 'contiguous' - meaning, the address book is in one piece, and in the order you expect it to be. If you're on page 5 of the address book, and you're intrigued about <strong>the address</strong> on page 6, then I can guarantee you page 6 is extremely closeby. Simply.. flip the page, and there it is. <em>Guaranteed</em>.</p>\n<p>One downside of arraylists is that, like actual address books, they have a fixed size. So what happens when you fill up your address book? Well, the implementation of ArrayList will play some secret magic to make it appear as if the list doesn't actually have a 'whoops it is full' issue: It buys a new, larger address book, manually copies over each and every address in the old one, swiftly replaces your address book with this new one, and chucks the old one in the garbage, all just as part of its normal operations. Calling methods isn't so much 'doing' a thing to an object, it's asking the object to do it for you. ArrayList is an address book that is capable of understanding how to go out, buy a new larger one, copy itself into the new one, transfer its consciousness into the new one and then chuck its old self in the bin.</p>\n<h2><code>LinkedList</code></h2>\n<p>LinkedList is like an address book that you rip each page out of, and then just scatter them all across the room. You know where page 1 of the address book is. But that is all you know. Fortunately, each and every page lists the location where you hid the next page, as well as the previous page. So, if you want to, say, go to the house listed in your address book on page 5, because you want to know what colour it is painted, you find page 1, and it says &quot;You shoved page 2 behind the couch&quot;, you go find page 2, which says &quot;page 3 is on top of the refridgerator&quot;, you find page 3, which says &quot;page 4 is on the desk&quot;, and page 4 says &quot;page 5 is also on the desk&quot;, and then finally you can go over to that house.</p>\n<p>This is a ridiculously time consuming process. It does have one single advantage: You never need to buy a new address book <em>and copy the old full one over to it</em>. After all, with this scattered pages system, if you run out of pages, just scatter some more blank pages across the room and keep going. This isn't much of an advantage, but it is something, I guess.</p>\n<p>Now, if you so happen to create a linked list and immediately fill the first 500 pages of it, then the situation is likely that all 500 pages are still in a stack on your desk more or less sorted exactly. But because you can't be sure, even if this is the case, if you want to go to the house listed on page 250, you still have to go through each page in turn, whereas with the arraylist address book you can just go right to page 250 in one go.</p>\n<p>But LinkedList does not require that you fill it up neatly as you make it. If you fill it up over time, then you get the 'pages are all over the place' scenario.</p>\n<h2>... it gets worse!</h2>\n<p>Each 'page' of our linkedlist address book actually stores <strong>3</strong> things. Not one thing. It stores the location of the previous page, the location of the next page, and, of course, the address of the house. Each of those things is a 'fixed small thing' (a reference). But those 3 together - that's not how java works, that's too much.</p>\n<p>So in actual fact a LinkedList is more like 'each page of the address book is actually a tiny little address book with 3 pages in it, one explaining where the previous postit is, one where the next postit is, and one with the address of the house', and those mini-address books are all over the place, <em>as well as</em> a bunch of postits that explain where to find the mini address books.</p>\n<h2>and now back to how it works in java terms</h2>\n<p>A LinkedList consists of a reference to the first node and the last node. A node is a small object that consists of a reference to the next node, to the previous node, and to the object this entry in the list represents. To e.g. iterate through the first 10 items of a linked list and e.g. print them all, the JVM has to resolve the reference to the linked list, from there resolve the reference to the first node, from there resolve the reference to the object and print that, then resolve the reference to the next node, resolve the reference to the object and print that, resolve the reference to the next node, and so on.</p>\n<p>Each little node object is created as you add an object, and unless you so happen to all do that neatly all in one go, these node objects are scattered all over your heap. And of course, the actual objects that the list contains may or may not be scattered all over the heap, depends on when they were made.</p>\n<p>In contrast, with an <code>ArrayList</code>, you simply have a guaranteed consecutive series of references to the actual objects contained in the list. <em>Those objects may not be consecutive</em>, but at least the refs to them are.</p>\n<h2>So what does this mean?</h2>\n<p>It boils down to just 2 words, which are all you <strong>must</strong> know as a java programmer about linked lists.</p>\n<h1>LinkedList BAD.</h1>\n<p>That's it. That's all you really need to know about <code>java.util.LinkedList</code>. The number of cases where an LL is the correct answer is <strong>vanishingly</strong> small. ArrayList is often better, but certainly not always; however, <em>some</em> other collection variant will be better than LL in pretty much every imaginable use case.</p>\n<p>Various language agnostic takes on LL make claims that <em>might</em> apply to a LinkedList but they do not apply to <em>java</em>'s take on them. For example, 'the advantage of a linked list is that, given an object in the list, it is very fast to insert an object right after it'. <strong>This is false</strong> - given an entry in a linked list you can't &quot;get back&quot; to the linked list's node <strong>in java</strong>. In essence the one and only way to even begin to enjoy the benefits of LLs in java is to use the very rarely used <code>.listIterator()</code> method which indeed can do a quick insertion of a value in a way ArrayList cannot compete with. Without listIterator the only thing LL can do that AL cannot do, is 'fast add/remove both from start and from end.</p>\n<p>But if that's what you want, use <code>ArrayDeque</code> - much more efficient at the job of 'a list thing that lets you fast add/remove from either end'.</p>\n<h2>A note about the concept 'linked list'</h2>\n<p>Many of these rules do not apply to the <em>concept</em> of linked lists. You are free to take some class definition, add the fields <code>private SelfType prev, next;</code> and have an object <em>itself</em> track its previous and next element. This offers a few advantages. For example, given some object you can now cheaply insert an object right behind it or right in front of it. This concept also suffers less from 'the JVM is travelling all over the heap thus running into lots of delay due to cache page misses', <em>if</em> you are iterating over every object and actually need data from the object in addition to the link to the next object in the list.</p>\n<p>It also has downsides: Such a thing does not implement <code>java.util.List</code>, and an object can only ever be in one list. If this is what you're interested in, most of this answer does not apply.</p>\n<hr />\n<p>[1] Various aspects of valhalla and panama mean these statements are going to need a lot of caveats soon. As of JDK24, this is accurate. If you know what Project Valhalla and Panama are - yes, change is on the horizon.</p>\n",
    "score" : 9,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107186,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1745715702,
    "last_activity_date" : 1745942426,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79594368,
    "question_id" : 79594341,
    "body" : "<p>I am going to answer this in two ways: with a technical answer and with a cool and easy to follow example. I had to do some research before answering this and simplifying things always help me, so let's first introduce the cache terminology:</p>\n<p><strong>Cache:</strong> a cache is  like a special reading desk where the most frequently used books are placed. Instead of running deep into the shelves every time, the computer can grab the specific book from the desk.</p>\n<p>Now how does this relate to your question?</p>\n<p>The <strong>ArrayList</strong> stores data in a row in the reading desk. So when the computer reads one book, it already has the next one nearby, making reading super fast and efficient. Therefore, making sequential access faster.</p>\n<p>The <strong>LinkedList</strong> is like a scattered set of books where you have to follow notes leading to each next book. Every time the computer needs a new book, it has to walk through another shelf.</p>\n<p>Now you might want a more &quot;technical&quot; answer, so here it is:</p>\n<p><strong>In ArrayList:</strong></p>\n<p>Since all elements are on a single block, accessing one element automatically loads nearby elements into the cache. This obviously makes iteration much faster, as the CPU retrieves more elements on one go.</p>\n<p><strong>In LinkedList:</strong></p>\n<p>Since nodes are scattered across memory, accessing one node doesn’t guarantee the next one is nearby. Each node access involves a pointer dereference, leading to higher cache misses.</p>\n<p><strong>Please note:</strong> While ArrayList stores its references contiguously in memory, the actual objects they point to can be scattered throughout the heap. This means accessing the object itself may require additional lookups, potentially reducing cache efficiency. However, when iterating over an ArrayList, accessing sequential elements is still faster than LinkedList since those references are stored in order, leveraging cache locality. (this was pointed out by @David Conrad)</p>\n<p>To sum everything up: when iterating over a LinkedList, both the object reference and the next node reference need to be resolved, often causing more cache misses than an ArrayList, where the next element is simply the next position in memory.</p>\n<p>Here is an article that helped me: <a href=\"https://stackoverflow.com/questions/12065774/why-does-cache-locality-matter-for-array-performance\">Why does cache locality matter for array performance?</a>. This discussion on Stack Overflow is similar. It dives deeper into the advantages of cache locality in arrays over LinkedLists.</p>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 38890247,
      "reputation" : 156,
      "user_id" : 29003408,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/LhjH9Wyd.jpg?s=256",
      "display_name" : "Andrei Greblă",
      "link" : "https://stackoverflow.com/users/29003408/andrei-grebl%c4%83"
    },
    "creation_date" : 1745698558,
    "last_activity_date" : 1745865694,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79594359,
    "question_id" : 79594341,
    "body" : "<p>Yes, ArrayList stores references in a contiguous array, making sequential access faster for the CPU cache. LinkedList nodes are scattered in memory, causing more cache misses.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 41562200,
      "reputation" : 319,
      "user_id" : 30347057,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/1df3f0344c100f61055196bb8d14522f?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Alex",
      "link" : "https://stackoverflow.com/users/30347057/alex"
    },
    "creation_date" : 1745697701,
    "last_activity_date" : 1745697701,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140372642,
    "post_id" : 79594341,
    "body" : "You could also check this resource that I also showed in my answer to this question: <a href=\"https://stackoverflow.com/questions/12065774/why-does-cache-locality-matter-for-array-performance\" title=\"why does cache locality matter for array performance\">stackoverflow.com/questions/12065774/&hellip;</a> if you are interested to find more about the difference between the ArrayList and Linked List in terms of cache locality.",
    "score" : 0,
    "owner" : {
      "account_id" : 38890247,
      "reputation" : 156,
      "user_id" : 29003408,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/LhjH9Wyd.jpg?s=256",
      "display_name" : "Andrei Greblă",
      "link" : "https://stackoverflow.com/users/29003408/andrei-grebl%c4%83"
    },
    "creation_date" : 1745704141,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140372635,
    "post_id" : 79594341,
    "body" : "@MaratTim That&#39;s correct.",
    "score" : 0,
    "owner" : {
      "account_id" : 11942432,
      "reputation" : 1205,
      "user_id" : 9651461,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b4954f1c7eec82df28149fb85ea3652a?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Maks Verver",
      "link" : "https://stackoverflow.com/users/9651461/maks-verver"
    },
    "creation_date" : 1745703934,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140372612,
    "post_id" : 79594341,
    "body" : "Yeah, I think your on the right direction.  In simpler terms: when iterating over a LinkedList, both the object reference and the next node reference need to be resolved, often causing more cache misses than an ArrayList, where the next element is simply the next position in memory.",
    "score" : 1,
    "owner" : {
      "account_id" : 38890247,
      "reputation" : 156,
      "user_id" : 29003408,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/LhjH9Wyd.jpg?s=256",
      "display_name" : "Andrei Greblă",
      "link" : "https://stackoverflow.com/users/29003408/andrei-grebl%c4%83"
    },
    "creation_date" : 1745702979,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140372567,
    "post_id" : 79594341,
    "body" : "@MaksVerver I think I understood, since the LinkedList is a list of nodes in which the object itself is also stored by reference, then during the iteration we will access memory for both the object itself and the next node. And there will be the same in the array, but accessing the next &quot;node&quot; will be fast, since it is not a random place in memory. Did I understand correctly?",
    "score" : 2,
    "owner" : {
      "account_id" : 29999041,
      "reputation" : 73,
      "user_id" : 22989572,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/ACg8ocI8MFnMQ5UFoxF7AR3soJArQ26CSzpUQwuATq6cJkZ2vw=k-s256",
      "display_name" : "Marat Tim",
      "link" : "https://stackoverflow.com/users/22989572/marat-tim"
    },
    "creation_date" : 1745700598,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140372538,
    "post_id" : 79594341,
    "body" : "OP is actually correct that both ArrayList and LinkedList store references to heap-allocated objects, so compared to a language like C++ which stores elements in-place, there is an extra level of indirection in Java.  The difference between ArrayList and LinkedList is that the former stores those <i>references</i> in consecutive memory, while the latters stores them in separate heap allocated node objects. So iterating over a LinkedList requires 2 heap accesses per element, while ArrayList requires only 1. So yes, ArrayList is probably faster in most cases. But it&#39;s still slow compared to C++.",
    "score" : 3,
    "owner" : {
      "account_id" : 11942432,
      "reputation" : 1205,
      "user_id" : 9651461,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b4954f1c7eec82df28149fb85ea3652a?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Maks Verver",
      "link" : "https://stackoverflow.com/users/9651461/maks-verver"
    },
    "creation_date" : 1745698844,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140372493,
    "post_id" : 79594341,
    "body" : "@S&#246;ren I&#39;m not sure if this counts as proof, but here&#39;s what I could find <a href=\"https://stackoverflow.com/questions/51598148/do-arrays-in-java-store-data-or-pointers\" title=\"do arrays in java store data or pointers\">stackoverflow.com/questions/51598148/&hellip;</a>",
    "score" : 1,
    "owner" : {
      "account_id" : 29999041,
      "reputation" : 73,
      "user_id" : 22989572,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/ACg8ocI8MFnMQ5UFoxF7AR3soJArQ26CSzpUQwuATq6cJkZ2vw=k-s256",
      "display_name" : "Marat Tim",
      "link" : "https://stackoverflow.com/users/22989572/marat-tim"
    },
    "creation_date" : 1745697541,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140372485,
    "post_id" : 79594341,
    "body" : "&quot;In java, after all, any list is a list of links, that is, even after downloading several consecutive links, we will have to search for an object in a random place in memory for each link&quot; - citation needed.",
    "score" : 6,
    "owner" : {
      "account_id" : 1888781,
      "reputation" : 2498,
      "user_id" : 1707427,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/4d1a2608ee35e2df7d2400a02e62bb20?s=256&d=identicon&r=PG",
      "display_name" : "S&#246;ren",
      "link" : "https://stackoverflow.com/users/1707427/s%c3%b6ren"
    },
    "creation_date" : 1745697181,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79594564" : [ {
      "comment_id" : 140385171,
      "post_id" : 79594564,
      "body" : "@Sebastian That question is not really answerable. Let&#39;s say the list had a capacity of 100 and you add the 101st element to it. <code>add</code> will first allocate an array of 150 objects (which are pointers), so that&#39;s 150*X bytes all in one row where X is the size f a pointer (usually 64 bit): 1200 bytes. This is <i>somewhere</i> on the heap. Probably in an active page, but not the same page as the old array. Then 100 pointers are copied from old to new; this act does not need to deref the pointers so the locality of the objects is irrelevant. But this is making quite a few assumptions.",
      "score" : 1,
      "owner" : {
        "account_id" : 401843,
        "reputation" : 107186,
        "user_id" : 768644,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
        "display_name" : "rzwitserloot",
        "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
      },
      "creation_date" : 1746036133,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140385137,
      "post_id" : 79594564,
      "body" : "So in case of ArrayList resizing, does the CPU cache affect the performance?",
      "score" : 0,
      "owner" : {
        "account_id" : 34944043,
        "reputation" : 77,
        "user_id" : 26873512,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/FyIB0pKV.jpg?s=256",
        "display_name" : "Sebastian",
        "link" : "https://stackoverflow.com/users/26873512/sebastian"
      },
      "creation_date" : 1746035430,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140380905,
      "post_id" : 79594564,
      "body" : "@Holger Could be. Just in case that happens, I&#39;ve added 1 extra chapter at the end and cleared up the &#39;linkedlist bad&#39; section to make extra clear that&#39;s referring specifically to j.u.LinkedList and not the concept.",
      "score" : 1,
      "owner" : {
        "account_id" : 401843,
        "reputation" : 107186,
        "user_id" : 768644,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
        "display_name" : "rzwitserloot",
        "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
      },
      "creation_date" : 1745942470,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140380851,
      "post_id" : 79594564,
      "body" : "@rzwitserloot that’s reasonable, for sure. But still I know, sooner or later, readers will show up, confusing the specific class and the concept. It wasn’t meant to say that your answer was missing something in the context of this specific question.",
      "score" : 1,
      "owner" : {
        "account_id" : 3211603,
        "reputation" : 300981,
        "user_id" : 2711488,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
        "display_name" : "Holger",
        "link" : "https://stackoverflow.com/users/2711488/holger"
      },
      "creation_date" : 1745941655,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140380822,
      "post_id" : 79594564,
      "body" : "@Holger the title of this question specifically contains the word &quot;LinkedList&quot; which in context of tag &#39;java&#39; can really only mean one thing: <code>java.util.LinkedList</code>. Not the generalized concept of &#39;what happens if some class def has field <code>private Self prev, next;</code>?&#39; - hence why I didn&#39;t delve into this.",
      "score" : 0,
      "owner" : {
        "account_id" : 401843,
        "reputation" : 107186,
        "user_id" : 768644,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
        "display_name" : "rzwitserloot",
        "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
      },
      "creation_date" : 1745941237,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140380366,
      "post_id" : 79594564,
      "body" : "Another approach would be to expose the node objects of a general purpose list. Then, you could do things like cutting a list in the middle and cheaply append one half to another list (not a thing in the Collection API). In contrast, removing one half of a <code>java.util.LinkedList</code> and adding it to another implies abandoning all associated internal node objects and creating new ones for the target list. Which creates more load to the garbage collector and linked lists are less garbage collector friendly in general.",
      "score" : 1,
      "owner" : {
        "account_id" : 3211603,
        "reputation" : 300981,
        "user_id" : 2711488,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
        "display_name" : "Holger",
        "link" : "https://stackoverflow.com/users/2711488/holger"
      },
      "creation_date" : 1745934810,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140380360,
      "post_id" : 79594564,
      "body" : "It’s important to emphasize that “java&#39;s take on linked lists” refers to <code>java.util.LinkedList</code> which implements a general purpose <code>java.util.List</code>. There are other possibilities, even in Java. For example, application specific objects having a next/previous pointer, (like Instruction objects in ASM’s Tree API) which eliminates the indirection but also lacks the general purpose aspect of the Collection API (e.g. such objects can only be in one list at a time).",
      "score" : 1,
      "owner" : {
        "account_id" : 3211603,
        "reputation" : 300981,
        "user_id" : 2711488,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
        "display_name" : "Holger",
        "link" : "https://stackoverflow.com/users/2711488/holger"
      },
      "creation_date" : 1745934737,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140373182,
      "post_id" : 79594564,
      "body" : "I admire you for simply staying to make an answer so detailed and educative.",
      "score" : 3,
      "owner" : {
        "account_id" : 38890247,
        "reputation" : 156,
        "user_id" : 29003408,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/LhjH9Wyd.jpg?s=256",
        "display_name" : "Andrei Greblă",
        "link" : "https://stackoverflow.com/users/29003408/andrei-grebl%c4%83"
      },
      "creation_date" : 1745738100,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79594368" : [ {
      "comment_id" : 140377680,
      "post_id" : 79594368,
      "body" : "@DavidConrad, I mentioned you in my edit, as it was you that pointed this out. Here is what I added: &quot;Please note: While ArrayList stores its references contiguously in memory, the actual objects they point to can be scattered throughout the heap. This means accessing the object itself may require additional lookups, potentially reducing cache efficiency. However, when iterating over an ArrayList, accessing sequential elements is still faster than LinkedList since those references are stored in order, leveraging cache locality. (this was pointed out by David Conrad)&quot;",
      "score" : 1,
      "owner" : {
        "account_id" : 38890247,
        "reputation" : 156,
        "user_id" : 29003408,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/LhjH9Wyd.jpg?s=256",
        "display_name" : "Andrei Greblă",
        "link" : "https://stackoverflow.com/users/29003408/andrei-grebl%c4%83"
      },
      "creation_date" : 1745865813,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140377668,
      "post_id" : 79594368,
      "body" : "While ArrayList does store a block of data, that data is references (pointers) to the objects in the list, which are not stored in the ArrayList, but scattered across memory.",
      "score" : 0,
      "owner" : {
        "account_id" : 318670,
        "reputation" : 16467,
        "user_id" : 636009,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/IIQJV.jpg?s=256",
        "display_name" : "David Conrad",
        "link" : "https://stackoverflow.com/users/636009/david-conrad"
      },
      "creation_date" : 1745865330,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}