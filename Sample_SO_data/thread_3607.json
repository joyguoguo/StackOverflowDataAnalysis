{
  "question" : {
    "question_id" : 79536986,
    "title" : "Why does class extending raw type result in overload ambiguity?",
    "body" : "<p>Why is <code>method(new ExtendsRaw())</code> ambiguous in the code below?</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class Main {\n    private Main() {}\n\n    static class Generic&lt;T&gt; {}\n    @SuppressWarnings(&quot;rawtypes&quot;)\n    static class ExtendsRaw extends Generic {}\n\n    static void method(Generic&lt;String&gt; generic) {}\n    static void method(ExtendsRaw raw) {}\n\n    static void test() {\n        method(new Generic&lt;&gt;());\n        // Ambiguous method call error\n        method(new ExtendsRaw());\n    }\n}\n</code></pre>\n<p>In other cases, Java doesn't consider it ambiguous when the parameter type of one overload is a subtype of the other overload's parameter. For example:</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.util.List;\nimport java.util.ArrayList;\n\npublic class Main {\n    private Main() {}\n\n    static void method1(Object supertype) {}\n    static void method1(String subtype) {}\n\n    static void method2(List&lt;String&gt; supertype) {}\n    static void method2(ArrayList&lt;String&gt; subtype) {}\n\n    static void test() {\n        // These both work fine.\n        method1(new Object());\n        method1(&quot;string&quot;);\n\n        // These also both work fine.\n        method2(List.of());\n        method2(new ArrayList&lt;&gt;());\n    }\n}\n</code></pre>\n<p>What's the reason for this behavior?</p>\n",
    "tags" : [ "java", "generics", "overload-resolution", "raw-types" ],
    "owner" : {
      "account_id" : 6743408,
      "reputation" : 755,
      "user_id" : 5195839,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/0e46223f9edd52cfebf12b5483e81d2a?s=256&d=identicon&r=PG",
      "display_name" : "Tomer Aberbach",
      "link" : "https://stackoverflow.com/users/5195839/tomer-aberbach"
    },
    "is_answered" : true,
    "view_count" : 103,
    "answer_count" : 2,
    "score" : 4,
    "last_activity_date" : 1743301842,
    "creation_date" : 1743014064,
    "link" : "https://stackoverflow.com/questions/79536986/why-does-class-extending-raw-type-result-in-overload-ambiguity",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79543969,
    "question_id" : 79536986,
    "body" : "<p>TL;DR: <strong>Java's spec considers <code>ExtendsRaw</code> more specific than <code>Generic</code>, but not more specific than <code>Generic&lt;String&gt;</code>, so overload resolution is ambiguous.</strong></p>\n<hr />\n<p>I researched the Java spec and came across section <a href=\"https://docs.oracle.com/javase/specs/jls/se19/html/jls-15.html#jls-15.12.2.5\" rel=\"nofollow noreferrer\">15.12.2.5. Choosing the Most Specific Method</a>, which says:</p>\n<blockquote>\n<p>One applicable method m<sub>1</sub> is more specific than another applicable method m<sub>2</sub>, for an invocation with argument expressions e<sub>1</sub>, ..., e<sub>k</sub>, if any of the following are true:</p>\n</blockquote>\n<p>Neither method in my code snippet is generic, so the following bullet point applies:</p>\n<blockquote>\n<p>m<sub>2</sub> is not generic, and m<sub>1</sub> and m<sub>2</sub> are applicable by strict or loose invocation, and where m<sub>1</sub> has formal parameter types S<sub>1</sub>, ..., S<sub>n</sub> and m<sub>2</sub> has formal parameter types T<sub>1</sub>, ..., T<sub>n</sub>, the type S<sub>i</sub> is more specific than T<sub>i</sub> for argument e<sub>i</sub> for all i (1 ≤ i ≤ n, n = k).</p>\n</blockquote>\n<p>This means my code snippet should work if <code>new ExtendsRaw()</code> is &quot;more specific&quot; for <code>ExtendsRaw</code> than it is for <code>Generic&lt;String&gt;</code>.</p>\n<p>The spec then says:</p>\n<blockquote>\n<p>A type S is more specific than a type T for any expression if S &lt;: T (<a href=\"https://docs.oracle.com/javase/specs/jls/se19/html/jls-4.html#jls-4.10\" rel=\"nofollow noreferrer\">§4.10</a>).</p>\n</blockquote>\n<p>So the question becomes whether <code>ExtendsRaw</code> &lt;: <code>Generic&lt;String&gt;</code> is true. The linked section says:</p>\n<blockquote>\n<p>The subtype and supertype relations are binary relations on types.</p>\n<p>The supertypes of a type are obtained by reflexive and transitive closure over the direct supertype relation, written S &gt;<sub>1</sub> T, which is defined by rules given later in this section. We write S :&gt; T to indicate that the supertype relation holds between S and T.</p>\n<p>S is a proper supertype of T, written S &gt; T, if S :&gt; T and S ≠ T.</p>\n<p>The subtypes of a type T are all types U such that T is a supertype of U, and the null type. We write T &lt;: S to indicate that that the subtype relation holds between types T and S.</p>\n</blockquote>\n<p>The last part means that S :&gt; T (S is a proper supertype of T) implies T &lt;: S (T is a proper subtype of S).</p>\n<p>The following subsection, <a href=\"https://docs.oracle.com/javase/specs/jls/se19/html/jls-4.html#jls-4.10.2\" rel=\"nofollow noreferrer\">4.10.2</a> says:</p>\n<blockquote>\n<p>Given a non-generic class or interface C, the direct supertypes of the type of C are all of the following:</p>\n<ul>\n<li>The direct superclass type of C (<a href=\"https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.1.4\" rel=\"nofollow noreferrer\">§8.1.4</a>), if C is a class.</li>\n<li>The direct superinterface types of C (<a href=\"https://docs.oracle.com/javase/specs/jls/se19/html/jls-8.html#jls-8.1.5\" rel=\"nofollow noreferrer\">§8.1.5</a>, <a href=\"https://docs.oracle.com/javase/specs/jls/se19/html/jls-9.html#jls-9.1.3\" rel=\"nofollow noreferrer\">§9.1.3</a>).</li>\n<li>The type Object, if C is an interface with no direct superinterface types (<a href=\"https://docs.oracle.com/javase/specs/jls/se19/html/jls-9.html#jls-9.1.3\" rel=\"nofollow noreferrer\">§9.1.3</a>).</li>\n</ul>\n</blockquote>\n<p><code>ExtendsRaw</code> is a non-generic class so the first bullet point implies that <code>Generic</code> (the raw type) is one if its direct supertypes, which means <code>ExtendsRaw &lt;: Generic</code>.</p>\n<p>So <code>new ExtendsRaw()</code> is &quot;more specific&quot; for <code>ExtendsRaw</code> than it is for <code>Generic</code>. The following code compiles and confirms it:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class Main {\n    private Main() {}\n\n    static class Generic&lt;T&gt; {}\n    @SuppressWarnings(&quot;rawtypes&quot;)\n    static class ExtendsRaw extends Generic {}\n\n    static void method(Generic generic) {}\n    static void method(ExtendsRaw raw) {}\n\n    static void test() {\n        // This resolves to `method(Generic generic)`\n        method(new Generic());\n        // This resolves to `method(ExtendsRaw raw)`\n        method(new ExtendsRaw());\n    }\n}\n</code></pre>\n<p>None of the other bullet points establish that <code>ExtendsRaw</code> &lt;: <code>Generic&lt;String&gt;</code> is true, which is what we're trying to do.</p>\n<p>&lt;: is transitive (see above) so if we can prove <code>Generic</code> &lt;: <code>Generic&lt;String&gt;</code> is true, then that would prove <code>ExtendsRaw</code> &lt;: <code>Generic&lt;String&gt;</code> is true.</p>\n<p>Section <a href=\"https://docs.oracle.com/javase/specs/jls/se19/html/jls-4.html#jls-4.10.2\" rel=\"nofollow noreferrer\">4.10.2</a> continues and says:</p>\n<blockquote>\n<p>Given a generic class or interface C with type parameters F<sub>1</sub>,...,F<sub>n</sub> (n &gt; 0), the direct supertypes of the raw type C (<a href=\"https://docs.oracle.com/javase/specs/jls/se19/html/jls-4.html#jls-4.8\" rel=\"nofollow noreferrer\">§4.8</a>) are all of the following:</p>\n<ul>\n<li>The erasure (<a href=\"https://docs.oracle.com/javase/specs/jls/se19/html/jls-4.html#jls-4.6\" rel=\"nofollow noreferrer\">§4.6</a>) of the direct superclass type of C, if C is a class.</li>\n<li>The erasure of the direct superinterface types of C.</li>\n<li>The type Object, if C is an interface with no direct superinterface types.</li>\n</ul>\n</blockquote>\n<p><code>Generic&lt;T&gt;</code> is a generic class and <code>Generic</code> is its raw type so the first bullet point implies that <code>Generic</code> &lt;: |<code>Generic</code>| is true (<a href=\"https://docs.oracle.com/javase/specs/jls/se19/html/jls-4.html#jls-4.6\" rel=\"nofollow noreferrer\">|<code>Generic</code>| is the erasure of <code>Generic&lt;T&gt;</code></a>).</p>\n<p>None of the other bullet points help make progress, so as far as I can tell, there's nowhere to go from here. We cannot prove that <code>Generic&lt;String&gt;</code> is a direct supertype of |<code>Generic</code>|, which means we cannot prove <code>Generic&lt;String&gt;</code> is a proper supertype of <code>ExtendsRaw</code>.</p>\n<p><strong>That's why the overload resolution is ambiguous. The logic in the spec considers <code>ExtendsRaw</code> more specific than <code>Generic</code>, but not more specific than <code>Generic&lt;String&gt;</code>.</strong></p>\n<p>This is counterintuitive because <code>ExtendsRaw</code> is assignable to <code>Generic&lt;String&gt;</code>, but the overload resolution logic isn't based on assignability.</p>\n<hr />\n<p>Bonus: Why does the <code>List&lt;String&gt;</code> and <code>ArrayList&lt;String&gt;</code> scenario work?</p>\n<p>Section <a href=\"https://docs.oracle.com/javase/specs/jls/se19/html/jls-4.html#jls-4.10.2\" rel=\"nofollow noreferrer\">4.10.2</a> says:</p>\n<blockquote>\n<p>Given a generic class or interface C with type parameters F<sub>1</sub>,...,F<sub>n</sub> (n &gt; 0), the direct supertypes of the parameterized type C&lt;T<sub>1</sub>,...,T<sub>n</sub>&gt;, where each of T<sub>i</sub> (1 ≤ i ≤ n) is a type, are all of the following:</p>\n<ul>\n<li>The substitution [F<sub>1</sub>:=T<sub>1</sub>,...,F<sub>n</sub>:=T<sub>n</sub>] applied to the direct superclass type of C, if C is a class.</li>\n<li>The substitution [F<sub>1</sub>:=T<sub>1</sub>,...,F<sub>n</sub>:=T<sub>n</sub>] applied to the direct superinterface types of C.</li>\n<li>C&lt;S<sub>1</sub>,...,S<sub>n</sub>&gt;, where S<sub>i</sub> contains T<sub>i</sub> (1 ≤ i ≤ n) (§4.5.1).</li>\n<li>The type Object, if C is an interface with no direct superinterface types.</li>\n<li>The raw type C.</li>\n</ul>\n</blockquote>\n<p><code>ArrayList&lt;String&gt;</code> is a generic class with one type parameter: <code>String</code>. <code>List</code> is a direct superinterface of <code>ArrayList</code> so the second bullet point implies that <code>List&lt;String&gt;</code> is a direct supertype of <code>ArrayList&lt;String&gt;</code>.</p>\n<p>That means <code>ArrayList&lt;String&gt;</code> &lt;: <code>List&lt;String&gt;</code> is true, which means that <code>new ArrayList&lt;&gt;()</code> in my code snippet is more specific for <code>ArrayList&lt;String&gt;</code> than <code>List&lt;String&gt;</code>.</p>\n",
    "score" : 3,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 6743408,
      "reputation" : 755,
      "user_id" : 5195839,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/0e46223f9edd52cfebf12b5483e81d2a?s=256&d=identicon&r=PG",
      "display_name" : "Tomer Aberbach",
      "link" : "https://stackoverflow.com/users/5195839/tomer-aberbach"
    },
    "creation_date" : 1743286945,
    "last_activity_date" : 1743301842,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79537326,
    "question_id" : 79536986,
    "body" : "<p>The compiler needs to know which methods will be required and in your first case it cannot be known as both are generic. The workaround is to bind ExtendsRaw to Object class allowing the compiler to distunguish between &lt;T&gt; and Object.</p>\n<pre><code>public class Main {\n    private Main() {}\n\n    static class Generic&lt;T&gt; {}\n    static class ExtendsRaw extends Generic&lt;Object&gt; {}\n\n    static &lt;T&gt; void method(Generic&lt;T&gt; generic) {}\n    static void method(ExtendsRaw raw) {}\n\n    static void test() {\n      method(new Generic&lt;&gt;());\n      method(new ExtendsRaw());\n    }\n  }\n</code></pre>\n",
    "score" : -1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 11555562,
      "reputation" : 569,
      "user_id" : 8466853,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/cd7f72b426ce3c46739900b8ba014e26?s=256&d=identicon&r=PG",
      "display_name" : "Arno",
      "link" : "https://stackoverflow.com/users/8466853/arno"
    },
    "creation_date" : 1743025229,
    "last_activity_date" : 1743025229,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79537326" : [ {
      "comment_id" : 140267498,
      "post_id" : 79537326,
      "body" : "I&#39;m not sure I follow. Why does it matter that they are both generic?  The following works fine: <code>java public class Main {     private Main() {}      static void method(List&lt;String&gt; list) {}     static void method(ArrayList&lt;String&gt; arrayList) {}      static void test() {       method(List.of());       method(new ArrayList&lt;&gt;());     } } </code>  Plus, which generics you use doesn&#39;t affect &quot;which methods will be required&quot;?",
      "score" : 2,
      "owner" : {
        "account_id" : 6743408,
        "reputation" : 755,
        "user_id" : 5195839,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/0e46223f9edd52cfebf12b5483e81d2a?s=256&d=identicon&r=PG",
        "display_name" : "Tomer Aberbach",
        "link" : "https://stackoverflow.com/users/5195839/tomer-aberbach"
      },
      "creation_date" : 1743039157,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}