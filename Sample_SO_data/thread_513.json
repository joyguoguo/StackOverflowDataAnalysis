{
  "question" : {
    "question_id" : 79797746,
    "title" : "Failing to validate HTTP Message Signature for OpenAi",
    "body" : "<p>I've implemented a slim library for my use to parse a HTTP Message signature - <a href=\"https://datatracker.ietf.org/doc/html/rfc9421\" rel=\"nofollow noreferrer\">https://datatracker.ietf.org/doc/html/rfc9421</a>.</p>\n<p>For testing purpose, I've browsed to a website that prints the HTTP headers, and I picked the current public key from the Open Ai public key link: <a href=\"https://chatgpt.com/.well-known/http-message-signatures-directory\" rel=\"nofollow noreferrer\">https://chatgpt.com/.well-known/http-message-signatures-directory</a>.</p>\n<p>When I'm trying to validate the signature using my code, I'm getting invalid signature.</p>\n<p>What is wrong with the way I implemented the validation code, or the way I'm testing it?</p>\n<p>Here's a slimmer version of my code and a unit test to test it:</p>\n<pre><code>mport org.junit.Test;\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.KeyFactory;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Base64;\n\nimport static org.junit.Assert.assertTrue;\n\npublic class HttpSignatureTest {\n\n    @Test\n    public void openAiSignatureTest() throws Exception {\n\n        String signature = &quot;sig1=:5ByQL0qdxM/8+UnfVqyGfyl87abJ12BtJtk3zqfF5UckkfsLo5/a17kcOFc5zL3xHoLpvrNJhifQ86g9u/kdAw==:&quot;;\n        String jwkX = &quot;7F_3jDlxaquwh291MiACkcS3Opq88NksyHiakzS-Y1g&quot;; // OpenAi key\n        String host = &quot;manytools.org&quot;;\n\n        String signatureBase = &quot;&quot;&quot;\n                &quot;@authority&quot;: %s\n                &quot;@method&quot;: GET\n                &quot;signature-agent&quot;: https://chatgpt.com\n                &quot;@signature-params&quot;: (&quot;@authority&quot; &quot;@method&quot; &quot;signature-agent&quot;);created=1761218610;keyid=&quot;otMqcjr17mGyruktGvJU8oojQTSMHlVm7uO-lrcqbdg&quot;;expires=1761222210;nonce=&quot;qmwHb46yropxxtDUYBrymM-WzMIGg2oZiYswgyTOpHQduFtOHumCeRu-nMtCtf3wP2IocniC-uxaYHLZOpsXjg&quot;;tag=&quot;web-bot-auth&quot;;alg=&quot;ed25519&quot;\\\n                &quot;&quot;&quot;.formatted(host);\n\n        System.out.println(&quot;Signature Base: \\n&quot; + signatureBase);\n\n        // 4. Extract the signature bytes\n        String sigB64 = signature.substring(signature.indexOf(&quot;:&quot;) + 1, signature.lastIndexOf(&quot;:&quot;));\n        byte[] sigBytes = Base64.getDecoder().decode(sigB64);\n\n        // 5. Build the public key\n        PublicKey pub = createPublicKey(&quot;OKP&quot;, &quot;Ed25519&quot;, jwkX);\n\n        Signature verifier = Signature.getInstance(&quot;Ed25519&quot;);\n        verifier.initVerify(pub);\n        verifier.update(signatureBase.getBytes(StandardCharsets.UTF_8));\n        boolean valid = verifier.verify(sigBytes);\n\n        assertTrue(&quot;Signature should be valid&quot;, valid);\n    }\n    private static PublicKey createPublicKey(String kty, String alg, String x) throws Exception {\n\n        if (!&quot;OKP&quot;.equalsIgnoreCase(kty) || !&quot;Ed25519&quot;.equalsIgnoreCase(alg)) {\n            throw new IllegalArgumentException(&quot;Unsupported kty/alg combination: &quot; + kty + &quot;/&quot; + alg);\n        }\n\n        byte[] xBytes = Base64.getUrlDecoder().decode(x);\n        byte[] keyBytes;\n        if (xBytes.length == 32) {\n            // Wrap raw Ed25519 key in DER-encoded SubjectPublicKeyInfo\n            keyBytes = new byte[]{\n                    0x30, 0x2a, // SEQUENCE, length 42\n                    0x30, 0x05, // SEQUENCE, length 5\n                    0x06, 0x03, 0x2b, 0x65, 0x70, // OID 1.3.101.112 (Ed25519)\n                    0x03, 0x21, 0x00 // BIT STRING, length 33, unused bits 0\n            };\n            byte[] spki = new byte[keyBytes.length + xBytes.length];\n            System.arraycopy(keyBytes, 0, spki, 0, keyBytes.length);\n            System.arraycopy(xBytes, 0, spki, keyBytes.length, xBytes.length);\n            xBytes = spki;\n        }\n        KeyFactory kf = KeyFactory.getInstance(&quot;Ed25519&quot;);\n        X509EncodedKeySpec spec = new X509EncodedKeySpec(xBytes);\n        return kf.generatePublic(spec);\n    }\n}\n</code></pre>\n",
    "tags" : [ "java" ],
    "owner" : {
      "account_id" : 235021,
      "reputation" : 1896,
      "user_id" : 501560,
      "user_type" : "registered",
      "accept_rate" : 94,
      "profile_image" : "https://i.sstatic.net/wBhB0.jpg?s=256",
      "display_name" : "ofirbt",
      "link" : "https://stackoverflow.com/users/501560/ofirbt"
    },
    "is_answered" : false,
    "view_count" : 69,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1761720541,
    "creation_date" : 1761220312,
    "link" : "https://stackoverflow.com/questions/79797746/failing-to-validate-http-message-signature-for-openai",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79803500,
    "question_id" : 79797746,
    "body" : "<p>The problem was that I didn't handle the case where the value of the headers - for example - the Signature-Agent contained quotes.</p>\n<p>In that case - the value in the signature base also should contain quotes.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 235021,
      "reputation" : 1896,
      "user_id" : 501560,
      "user_type" : "registered",
      "accept_rate" : 94,
      "profile_image" : "https://i.sstatic.net/wBhB0.jpg?s=256",
      "display_name" : "ofirbt",
      "link" : "https://stackoverflow.com/users/501560/ofirbt"
    },
    "creation_date" : 1761720541,
    "last_activity_date" : 1761720541,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}