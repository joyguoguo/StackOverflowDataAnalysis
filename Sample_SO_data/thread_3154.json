{
  "question" : {
    "question_id" : 79568522,
    "title" : "How can I know if the clip&#39;s path is included in the normal strokePath or fillPath?",
    "body" : "<p>I use pdfbox 3.0.2 to get the clipping path and normal path in the PDF, but I am not sure whether the clipping path I get is linked to the normal path I get, or whether the clipping path is included in the normal path?Sometimes I get a lot of clips, but I'm not sure if this clip is what I need or if it's within the normal path.\nMy clipping path is obtained using the following method</p>\n<blockquote>\n<pre><code>@Override\npublic void endPath() throws IOException {}\n</code></pre>\n</blockquote>\n<p>My normal path is obtained using the following method</p>\n<blockquote>\n<pre><code>@Override\npublic void strokePath() {}\n@Override\npublic void fillPath(int i) {}\n</code></pre>\n</blockquote>\n<blockquote>\n<pre><code>@Override\npublic void endPath() throws IOException {\n    if (clipWindingRule != -1) {\n        linePath.setWindingRule(clipWindingRule); \n        Rectangle2D bounds = linePath.getBounds2D();\n        ClipPathInfo info = new ClipPathInfo();\n        Area currentClippingPath = getGraphicsState().getCurrentClippingPath();\n        if (clipWindingRule == PathIterator.WIND_EVEN_ODD) {\n            info.setRule(&quot;Even-Odd&quot;);\n        } else {\n            info.setRule(&quot;NonZero&quot;);\n        }\n\n        Matrix ctm = getGraphicsState().getCurrentTransformationMatrix();\n\n        PDRectangle cropBox = page.getCropBox();\n        float pageHeight = cropBox.getHeight();\n\n        double x = bounds.getX() * scale;\n        double y = (pageHeight - bounds.getY() - bounds.getHeight()) * scale;\n        double width = bounds.getWidth() * scale;\n        double height = bounds.getHeight() * scale;\n\n        Matrix matrix = new Matrix();\n        matrix.scale(1, -1);\n        matrix.translate(0, (float) -y);\n        matrix.scale(scale, scale);\n        Matrix multiply = matrix.multiply(ctm);\n\n        double[][] mCTMatrix = {\n            {multiply.getScaleX(), multiply.getShearY(), 0},\n            {multiply.getShearX(), multiply.getScaleY(), 0},\n            {multiply.getTranslateX(), multiply.getTranslateY(), 1},\n        };\n        info.setCtm(mCTMatrix);\n\n        info.setBoundary(new OfdBoxImpl(x, y, width, height));\n\n        AbbreviatedData data = new AbbreviatedData();\n        drawLine(linePath.getPathIterator(null), data, pageHeight * scale, true);\n        info.setData(data);\n        clipPathInfos.add(info);\n        clipWindingRule = -1;}linePath.reset();\n</code></pre>\n</blockquote>\n<pre><code>@Override\n    public void appendRectangle(Point2D p0, Point2D p1, Point2D p2, Point2D p3) {\n        linePath.moveTo((float) p0.getX(), (float) p0.getY());\n        linePath.lineTo((float) p1.getX(), (float) p1.getY());\n        linePath.lineTo((float) p2.getX(), (float) p2.getY());\n        linePath.lineTo((float) p3.getX(), (float) p3.getY());\n        linePath.closePath();\n    }\n\n\nprivate void drawLine(PathIterator iterator, AbbreviatedData data, float height, boolean isPath) throws IOException {\n        double[] coords = new double[6];\n        while (!iterator.isDone()) {\n            switch (iterator.currentSegment(coords)) {\n                case SEG_MOVETO:\n                    data.moveTo(coords[0] * scale, height - coords[1] * scale);\n                    break;\n                case SEG_LINETO:\n                    data.lineTo(coords[0] * scale, height - coords[1] * scale);\n                    break;\n                case SEG_CUBICTO:\n                    data.B(coords[0] * scale, height - coords[1] * scale,\n                        coords[2] * scale, height - coords[3] * scale,\n                        coords[4] * scale, height - coords[5] * scale);\n                    break;\n                case SEG_CLOSE:\n                    data.close();\n                    if (isPath) {\n                        closePath();\n                    }\n                    break;\n                default:\n                    break;\n            }\n            iterator.next();\n        }\n    }\n</code></pre>\n",
    "tags" : [ "java", "pdfbox" ],
    "owner" : {
      "account_id" : 21131086,
      "reputation" : 45,
      "user_id" : 15536335,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d6e65a42c48370f90430bb5785c6887b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Serendipity",
      "link" : "https://stackoverflow.com/users/15536335/serendipity"
    },
    "is_answered" : false,
    "view_count" : 50,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1744620706,
    "creation_date" : 1744364675,
    "link" : "https://stackoverflow.com/questions/79568522/how-can-i-know-if-the-clips-path-is-included-in-the-normal-strokepath-or-fillpa",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140332355,
    "post_id" : 79568522,
    "body" : "it doesn&#39;t make sense &quot;without matrix transformation&quot;. You need that because in your PDFs the transformations for clipping path and fill paths are different. To understand what PDFBox is doing, the easiest would probably be to get the source code, put some debug output in PageDrawer, build, run PDFDebugger and look what output you get. It&#39;s still unclear what your code is doing. Each edit brings up more unknown operations. What is &quot;AbbreviatedData&quot;? What type of class are you using? How are you calling it? Are you extending PageDrawer, PDFGraphicsStreamEngine or PDFStreamEngine?",
    "score" : 0,
    "owner" : {
      "account_id" : 255529,
      "reputation" : 19234,
      "user_id" : 535646,
      "user_type" : "registered",
      "accept_rate" : 40,
      "profile_image" : "https://i.sstatic.net/yGyps.jpg?s=256",
      "display_name" : "Tilman Hausherr",
      "link" : "https://stackoverflow.com/users/535646/tilman-hausherr"
    },
    "creation_date" : 1744625715,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140332045,
    "post_id" : 79568522,
    "body" : "I want to know the original path and clip path of the line in this document, without matrix transformation, and how can I determine whether the clip path is included in the original path?pdf:<a href=\"https://drive.google.com/file/d/1JXS7lGxN43tY-13SVDcNGW6IOeU78E51/view?usp=sharing\" rel=\"nofollow noreferrer\">drive.google.com/file/d/1JXS7lGxN43tY-13SVDcNGW6IOe&zwnj;&#8203;U78E51/&hellip;</a>",
    "score" : 0,
    "owner" : {
      "account_id" : 21131086,
      "reputation" : 45,
      "user_id" : 15536335,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d6e65a42c48370f90430bb5785c6887b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Serendipity",
      "link" : "https://stackoverflow.com/users/15536335/serendipity"
    },
    "creation_date" : 1744620658,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140331554,
    "post_id" : 79568522,
    "body" : "<code>drawLine()</code> is missing. And it would be helpful to share a PDF and explain what you were expecting and what you got instead.",
    "score" : 0,
    "owner" : {
      "account_id" : 255529,
      "reputation" : 19234,
      "user_id" : 535646,
      "user_type" : "registered",
      "accept_rate" : 40,
      "profile_image" : "https://i.sstatic.net/yGyps.jpg?s=256",
      "display_name" : "Tilman Hausherr",
      "link" : "https://stackoverflow.com/users/535646/tilman-hausherr"
    },
    "creation_date" : 1744612601,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140331147,
    "post_id" : 79568522,
    "body" : "I have overridden the <code>endPath()</code> method to obtain the clip path, but the <code>AbbreviatedData </code>obtained does not seem to be the original data of the PDF, but is processed. Is there any way to obtain the original path data?I posted the code above",
    "score" : 0,
    "owner" : {
      "account_id" : 21131086,
      "reputation" : 45,
      "user_id" : 15536335,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d6e65a42c48370f90430bb5785c6887b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Serendipity",
      "link" : "https://stackoverflow.com/users/15536335/serendipity"
    },
    "creation_date" : 1744593192,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140329676,
    "post_id" : 79568522,
    "body" : "Just as @Tilman said, any path painting command (stroking, filling, both,  neither) can be combined with a clipping command. You appear to use a class derived from the <code>PDFGraphicsStreamEngine</code>. You may have to override the <code>clip(int)</code> method.",
    "score" : 0,
    "owner" : {
      "account_id" : 1916831,
      "reputation" : 97003,
      "user_id" : 1729265,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/VMMeP.jpg?s=256",
      "display_name" : "mkl",
      "link" : "https://stackoverflow.com/users/1729265/mkl"
    },
    "creation_date" : 1744541364,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140324176,
    "post_id" : 79568522,
    "body" : "The operations you mention are used both for a clipping path or for a &quot;normal&quot; path. I think you&#39;ll have to write your own PageDrawer class. Look at the source code for setClip() and transferClip().",
    "score" : 0,
    "owner" : {
      "account_id" : 255529,
      "reputation" : 19234,
      "user_id" : 535646,
      "user_type" : "registered",
      "accept_rate" : 40,
      "profile_image" : "https://i.sstatic.net/yGyps.jpg?s=256",
      "display_name" : "Tilman Hausherr",
      "link" : "https://stackoverflow.com/users/535646/tilman-hausherr"
    },
    "creation_date" : 1744369452,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}