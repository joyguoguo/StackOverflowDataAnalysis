{
  "question" : {
    "question_id" : 79773713,
    "title" : "Spring STOMP Principal is null",
    "body" : "<p>I’m trying to implement authentication in a Spring Boot WebSocket (STOMP) application using a custom <code>ChannelInterceptor</code>.</p>\n<p>In my <code>AuthChannelInterceptor</code>, I validate a JWT token during the <code>CONNECT</code> command and set the authenticated user with:</p>\n<pre class=\"lang-java prettyprint-override\"><code>accessor.setUser(userInfo);\n</code></pre>\n<p>My <code>UserInfo</code> class <strong>already implements <code>java.security.Principal</code></strong>, so it should be usable as the authenticated user. Logging shows that the user is correctly set during the handshake:</p>\n<pre><code>User authenticated: com.inkorcloud.imlitejava.util.jwt.UserInfo@...\nCONNECT, session = ...\n</code></pre>\n<p>However, when I try to access the <code>Principal</code> in my <code>@MessageMapping</code> controller, it’s always <code>null</code>. For example:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@MessageMapping(&quot;/chat/send&quot;)\npublic void sendMessage(SimpMessageHeaderAccessor accessor,\n                        @Payload Message message,\n                        Principal principal) {\n    // accessor.getUser() is null here\n    // principal is also null\n    messageManager.sendMessage(message, (UserInfo) accessor.getUser());\n}\n</code></pre>\n<p>Here’s the relevant configuration:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Configuration\n@EnableWebSocketMessageBroker\npublic class STOMPConfig implements WebSocketMessageBrokerConfigurer {\n    private final AuthChannelInterceptor authChannelInterceptor;\n\n    @Autowired\n    public STOMPConfig(AuthChannelInterceptor authChannelInterceptor) {\n        this.authChannelInterceptor = authChannelInterceptor;\n    }\n\n    @Override\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\n        registry.addEndpoint(&quot;/ws-chat&quot;).setAllowedOrigins(&quot;*&quot;);\n    }\n\n    @Override\n    public void configureMessageBroker(MessageBrokerRegistry registry) {\n        registry.enableSimpleBroker(&quot;/topic&quot;);\n        registry.setApplicationDestinationPrefixes(&quot;/app&quot;);\n    }\n\n    @Override\n    public void configureClientInboundChannel(ChannelRegistration registration) {\n        registration.interceptors(authChannelInterceptor);\n    }\n}\n</code></pre>\n<p>And the interceptor:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Component\n@Slf4j\npublic class AuthChannelInterceptor implements ChannelInterceptor {\n    private final JWTManager jwtManager;\n\n    @Autowired\n    public AuthChannelInterceptor(JWTManager jwtManager) {\n        this.jwtManager = jwtManager;\n    }\n\n    @Override\n    public Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) {\n        StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);\n\n        if (StompCommand.CONNECT.equals(accessor.getCommand())) {\n            String token = accessor.getFirstNativeHeader(&quot;Authorization&quot;);\n            token = StrUtil.removeAllPrefix(token, &quot;Bearer &quot;);\n\n            if (!jwtManager.valiToken(token)) {\n                throw new PermissionDeniedException(&quot;Invalid token&quot;);\n            }\n\n            UserInfo userInfo = jwtManager.parseJWT(token);\n            if (userInfo != null) {\n                accessor.setUser(userInfo); // UserInfo implements Principal\n                log.debug(&quot;User authenticated: {}&quot;, accessor.getUser());\n            } else {\n                throw new PermissionDeniedException(&quot;Failed to extract user info&quot;);\n            }\n        }\n\n        return message;\n    }\n}\n</code></pre>\n<p><strong>Problem:</strong><br />\nEven though my <code>UserInfo</code> implements <code>Principal</code> and I set it in the <code>ChannelInterceptor</code>, the <code>Principal</code> is still <code>null</code> inside my <code>@MessageMapping</code> methods.</p>\n<p><strong>Question:</strong><br />\nWhat additional configuration is required to make the <code>Principal</code> (my <code>UserInfo</code>) available in <code>@MessageMapping</code> methods? Why isn’t Spring propagating the <code>Principal</code> I set in the <code>StompHeaderAccessor</code>?</p>\n<p>I tried creating a new message in the interceptor using <code>MessageBuilder</code> (with the original payload and the modified headers) and returning it, but still got <code>null</code>.</p>\n",
    "tags" : [ "java", "spring-boot", "spring-websocket", "stomp" ],
    "owner" : {
      "account_id" : 44070741,
      "reputation" : 1,
      "user_id" : 31561761,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/fdb5b4857a5c4bc689cc85cbb098b7f6?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "oiiaooiiao",
      "link" : "https://stackoverflow.com/users/31561761/oiiaooiiao"
    },
    "is_answered" : false,
    "view_count" : 45,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1758717264,
    "creation_date" : 1758717264,
    "link" : "https://stackoverflow.com/questions/79773713/spring-stomp-principal-is-null",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140758358,
    "post_id" : 79773713,
    "body" : "Alright, sorry, I made a stupid mistake. After I changed the accessor declaration to <code>MessageHeaderAccessor.getAccessor</code>, I also removed <code>accessor.setUser(userInfo);</code>. You were right—using <code>MessageHeaderAccessor.getAccessor</code> to get the accessor is useful, but changing the return statement to <code>MessageBuilder.createMessage(message.getPayload(), accessor.getMessageHeaders())</code> didn’t work. Thank you for helping me solve this problem; it had been bothering me all day. I even tried declaring a cache <code>Map</code> to separately store the <code>sessionId</code> and authentication information.",
    "score" : 0,
    "owner" : {
      "account_id" : 44070741,
      "reputation" : 1,
      "user_id" : 31561761,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/fdb5b4857a5c4bc689cc85cbb098b7f6?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "oiiaooiiao",
      "link" : "https://stackoverflow.com/users/31561761/oiiaooiiao"
    },
    "creation_date" : 1758768289,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140756882,
    "post_id" : 79773713,
    "body" : "Have you tried <code>var accessor = MessageHeaderAccessor.getAccessor(message, null)</code> instead of creating a new one (which would operate on a copy of the headers). Else instead of returning <code>message</code> do <code>return MessageBuilder.createMessage(message.getPayload(), accessor)</code> to get a new message with the modified headers from the accessor.",
    "score" : 1,
    "owner" : {
      "account_id" : 3192259,
      "reputation" : 126800,
      "user_id" : 2696260,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/qHEzx.png?s=256",
      "display_name" : "M. Deinum",
      "link" : "https://stackoverflow.com/users/2696260/m-deinum"
    },
    "creation_date" : 1758717469,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}