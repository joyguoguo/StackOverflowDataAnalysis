{
  "question" : {
    "question_id" : 79606146,
    "title" : "Apicurio Schema Registry 3.0.7 - producer failing in Confluent compatibility mode",
    "body" : "<p>I have Apicurio Schema Registry 3.0.7 installed on GKE. I'm trying to use this in Confluent Compatibility mode .. primarily because on production, my Kafka Producer is C++ client, and Apicurio serde is not supported for C++ client.</p>\n<p>Here is the Java code:</p>\n<pre><code>package com.versa.apicurio.confluent;\n\nimport com.versa.apicurio.confluent.Employee;\nimport com.versa.apicurio.confluent.DepartmentEnum;\nimport org.apache.kafka.clients.producer.*;\nimport org.apache.kafka.common.serialization.StringSerializer;\nimport io.confluent.kafka.serializers.KafkaAvroSerializer;\n\n\npublic class VersionBasedKafkaProducer {\n\n    private static final String REGISTRY_URL = &quot;https://apicurio-sr.vkp.versa-vani.com&quot;;\n    private static final String LETS_ENCRYPT_ROOT_URL = &quot;https://letsencrypt.org/certs/isrgrootx1.pem&quot;;\n    private static final String LETS_ENCRYPT_R11_URL = &quot;https://letsencrypt.org/certs/2024/r11.pem&quot;;\n    private static final String TRUSTSTORE_PASSWORD = &quot;changeit&quot;;\n    private static final String TRUSTSTORE_PATH = &quot;apicurio-truststore.jks&quot;;\n\n    /**\n     * Creates a custom truststore with Let's Encrypt certificates\n     * @return The path to the created truststore\n     */\n    private static String createCustomTruststore() throws Exception {\n        &lt;truncated&gt;\n    }\n    \n    /**\n     * Downloads an X.509 certificate from a URL\n     */\n    private static X509Certificate downloadCertificate(String certUrl) throws Exception {\n        &lt;truncated&gt;\n    }\n\n    /**\n     * Get the Access Token for authentication\n     */\n    public static String getAccessToken(String tokenUrl, String clientId, String clientSecret) throws Exception {\n        String params = &quot;grant_type=client_credentials&quot;\n            + &quot;&amp;client_id=&quot; + clientId\n            + &quot;&amp;client_secret=&quot; + clientSecret;\n        URL url = new URL(tokenUrl);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(&quot;POST&quot;);\n        conn.setDoOutput(true);\n        conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);\n        try (OutputStream os = conn.getOutputStream()) {\n            os.write(params.getBytes(StandardCharsets.UTF_8));\n        }\n        try (Scanner scanner = new Scanner(conn.getInputStream(), StandardCharsets.UTF_8.name())) {\n            String resp = scanner.useDelimiter(&quot;\\\\A&quot;).next();\n            return resp.split(&quot;\\&quot;access_token\\&quot;:\\&quot;&quot;)[1].split(&quot;\\&quot;&quot;)[0];\n        }\n    }\n    \n    apiv\n\n    /**\n * Verify schema exists and get information about it, returning the schema ID\n */\nprivate static int verifySchemaAndGetId(String token) throws Exception {\n    System.out.println(&quot;\\n=== Verifying schema in registry ===&quot;);\n    \n    // Subject name with RecordNameStrategy\n    String subject = &quot;com.versa.apicurio.confluent.Employee&quot;;\n    \n    // Check if the subject exists\n    String subjectsUrl = String.format(&quot;%s/apis/ccompat/v7/subjects&quot;, REGISTRY_URL);\n    System.out.println(&quot;Checking all subjects at: &quot; + subjectsUrl);\n    \n    URL url = new URL(subjectsUrl);\n    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n    conn.setRequestMethod(&quot;GET&quot;);\n    conn.setRequestProperty(&quot;Authorization&quot;, &quot;Bearer &quot; + token);\n    \n    int responseCode = conn.getResponseCode();\n    System.out.println(&quot;Response Code: &quot; + responseCode);\n    \n    boolean subjectExists = false;\n    \n    if (responseCode == 200) {\n        try (Scanner scanner = new Scanner(conn.getInputStream(), StandardCharsets.UTF_8.name())) {\n            String resp = scanner.useDelimiter(&quot;\\\\A&quot;).next();\n            System.out.println(&quot;All subjects: &quot; + resp);\n            \n            // Check if our subject is in the list\n            subjectExists = resp.contains(&quot;\\&quot;&quot; + subject + &quot;\\&quot;&quot;);\n            System.out.println(&quot;Subject '&quot; + subject + &quot;' exists: &quot; + subjectExists);\n        }\n    } else {\n        System.out.println(&quot;Failed to retrieve subjects list. Response code: &quot; + responseCode);\n        return -1;\n    }\n    \n    if (!subjectExists) {\n        System.out.println(&quot;Subject '&quot; + subject + &quot;' does not exist in the registry!&quot;);\n        return -1;\n    }\n    \n    // Get versions\n    String versionsUrl = String.format(&quot;%s/apis/ccompat/v7/subjects/%s/versions&quot;, REGISTRY_URL, subject);\n    System.out.println(&quot;Fetching versions at: &quot; + versionsUrl);\n    \n    URL versionsUrlObj = new URL(versionsUrl);\n    HttpURLConnection versionsConn = (HttpURLConnection) versionsUrlObj.openConnection();\n    versionsConn.setRequestMethod(&quot;GET&quot;);\n    versionsConn.setRequestProperty(&quot;Authorization&quot;, &quot;Bearer &quot; + token);\n    \n    int versionsResponseCode = versionsConn.getResponseCode();\n    String highestVersion = &quot;1&quot;;\n    \n    if (versionsResponseCode == 200) {\n        try (Scanner scanner = new Scanner(versionsConn.getInputStream(), StandardCharsets.UTF_8.name())) {\n            String resp = scanner.useDelimiter(&quot;\\\\A&quot;).next();\n            System.out.println(&quot;Available versions: &quot; + resp);\n            \n            if (resp.equals(&quot;[]&quot;) || resp.trim().isEmpty()) {\n                System.out.println(&quot;Warning: No versions found for this subject!&quot;);\n                return -1;\n            } else {\n                // Find the highest version number \n                Pattern pattern = Pattern.compile(&quot;\\\\d+&quot;);\n                Matcher matcher = pattern.matcher(resp);\n                int maxVersion = 0;\n                while (matcher.find()) {\n                    try {\n                        int version = Integer.parseInt(matcher.group());\n                        if (version &gt; maxVersion) {\n                            maxVersion = version;\n                            highestVersion = matcher.group();\n                        }\n                    } catch (NumberFormatException e) {\n                        // Skip if not a valid number\n                    }\n                }\n                System.out.println(&quot;Highest version found: &quot; + highestVersion);\n            }\n        }\n    } else {\n        System.out.println(&quot;Failed to list versions. Response code: &quot; + versionsResponseCode);\n        return -1;\n    }\n    \n    // Get the specific version\n    String versionUrl = String.format(&quot;%s/apis/ccompat/v7/subjects/%s/versions/%s&quot;, \n            REGISTRY_URL, subject, highestVersion);\n    System.out.println(&quot;Fetching schema at: &quot; + versionUrl);\n    \n    URL specificVersionUrl = new URL(versionUrl);\n    HttpURLConnection versionConn = (HttpURLConnection) specificVersionUrl.openConnection();\n    versionConn.setRequestMethod(&quot;GET&quot;);\n    versionConn.setRequestProperty(&quot;Authorization&quot;, &quot;Bearer &quot; + token);\n    \n    int versionResponseCode = versionConn.getResponseCode();\n    int schemaId = -1;\n    \n    if (versionResponseCode == 200) {\n        try (Scanner scanner = new Scanner(versionConn.getInputStream(), StandardCharsets.UTF_8.name())) {\n            String resp = scanner.useDelimiter(&quot;\\\\A&quot;).next();\n            System.out.println(&quot;Version &quot; + highestVersion + &quot; schema (raw): &quot; + resp);\n            \n            // Extract schema ID\n            if (resp.contains(&quot;\\&quot;id\\&quot;:&quot;)) {\n                String idStr = resp.split(&quot;\\&quot;id\\&quot;:&quot;)[1].split(&quot;,&quot;)[0].trim();\n                try {\n                    schemaId = Integer.parseInt(idStr);\n                    System.out.println(&quot;Schema ID: &quot; + schemaId);\n                } catch (NumberFormatException e) {\n                    System.out.println(&quot;Failed to parse schema ID: &quot; + idStr);\n                    return -1;\n                }\n            }\n            \n            // Extract and pretty print the schema\n            try {\n                String schemaJson = resp.split(&quot;\\&quot;schema\\&quot;:\\&quot;&quot;)[1].split(&quot;\\&quot;,\\&quot;schemaType\\&quot;&quot;)[0];\n                // Replace escaped quotes with regular quotes\n                schemaJson = schemaJson.replace(&quot;\\\\\\&quot;&quot;, &quot;\\&quot;&quot;);\n                // Replace escaped backslashes with regular backslashes\n                schemaJson = schemaJson.replace(&quot;\\\\\\\\&quot;, &quot;\\\\&quot;);\n                System.out.println(&quot;\\nSchema content (prettified):\\n&quot; + schemaJson);\n            } catch (Exception e) {\n                System.out.println(&quot;Failed to prettify schema: &quot; + e.getMessage());\n            }\n        }\n        return schemaId;\n    } else {\n        System.out.println(&quot;Failed to get version. Response code: &quot; + versionResponseCode);\n        return -1;\n    }\n}\n\npublic static void main(String[] args) throws Exception {\n    // Create truststore for SSL\n    String truststorePath = createCustomTruststore();\n    \n    // Get token\n    String tokenUrl = &quot;https://keycloak.vkp.versa-vani.com/realms/readonly-realm/protocol/openid-connect/token&quot;;\n    String clientId = &quot;apicurio-registry&quot;;\n    String clientSecret = &quot;&lt;secret&gt;&quot;;\n    String token = getAccessToken(tokenUrl, clientId, clientSecret);\n    System.out.println(&quot;Got access token: &quot; + token.substring(0, 15) + &quot;...&quot;);\n    \n    // Get schema ID during verification\n    int schemaId = verifySchemaAndGetId(token);\n    // System.out.println(&quot;schemaId&quot;,  schemaId);\n    if (schemaId &lt;= 0) {\n        System.out.println(&quot;Failed to get valid schema ID. Exiting.&quot;);\n        return;\n    }\n    \n    // Add direct schema ID check\n    String schemaIdUrl = String.format(&quot;%s/apis/ccompat/v7/schemas/ids/%d&quot;, REGISTRY_URL, schemaId);\n    System.out.println(&quot;\\n=== Testing direct schema retrieval by ID ===&quot;);\n    System.out.println(&quot;Testing URL: &quot; + schemaIdUrl);\n    \n    URL schemaIdUrlObj = new URL(schemaIdUrl);\n    HttpURLConnection schemaIdConn = (HttpURLConnection) schemaIdUrlObj.openConnection();\n    schemaIdConn.setRequestMethod(&quot;GET&quot;);\n    schemaIdConn.setRequestProperty(&quot;Authorization&quot;, &quot;Bearer &quot; + token);\n    \n    int schemaIdResponseCode = schemaIdConn.getResponseCode();\n    System.out.println(&quot;Schema ID check response code: &quot; + schemaIdResponseCode);\n    \n    if (schemaIdResponseCode == 200) {\n        try (Scanner scanner = new Scanner(schemaIdConn.getInputStream(), StandardCharsets.UTF_8.name())) {\n            String resp = scanner.useDelimiter(&quot;\\\\A&quot;).next();\n            System.out.println(&quot;Schema by ID response: &quot; + resp);\n        }\n    } else {\n        System.out.println(&quot;Failed to get schema by ID. Response code: &quot; + schemaIdResponseCode);\n    }\n    \n    // Set up Kafka producer\n    Properties props = new Properties();\n    props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;&lt;IP&gt;:&lt;port&gt;&quot;);\n    props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());\n    props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, KafkaAvroSerializer.class.getName());\n    \n    // Schema Registry config - Updated with dynamic schema ID\n    props.put(&quot;schema.registry.url&quot;, REGISTRY_URL + &quot;/apis/ccompat/v7&quot;);\n    props.put(&quot;bearer.auth.credentials.source&quot;, &quot;USER_INFO&quot;);\n    props.put(&quot;bearer.auth.token&quot;, token);\n    props.put(&quot;value.subject.name.strategy&quot;, &quot;io.confluent.kafka.serializers.subject.RecordNameStrategy&quot;);\n    props.put(&quot;auto.register.schemas&quot;, &quot;false&quot;);\n    props.put(&quot;apicurio.registry.as-confluent&quot;, &quot;true&quot;);\n    props.put(&quot;apicurio.registry.use-id&quot;, &quot;contentId&quot;);\n    \n    // props.put(&quot;value.subject.name.strategy&quot;, &quot;io.confluent.kafka.serializers.subject.TopicNameStrategy&quot;);\n    // props.put(&quot;auto.register.schemas&quot;, &quot;true&quot;);  // \n\n    // Use the dynamically retrieved schema ID\n    props.put(&quot;use.schema.id&quot;, String.valueOf(schemaId));\n    \n    // Additional helpful configuration\n    props.put(&quot;specific.avro.reader&quot;, &quot;true&quot;);\n    props.put(&quot;use.latest.version&quot;, &quot;true&quot;);\n    \n    // SSL settings for Kafka\n    props.put(&quot;ssl.truststore.location&quot;, &quot;/Users/karanalang/Documents/Technology/0.ACME/strimzi-certs/versa-kafka-poc-tf/versa-kafka-poc-tf-cluster-ca-cert/versa-kafka-poc-tf-ca.p12&quot;);\n    props.put(&quot;ssl.truststore.password&quot;, &quot;pwd&quot;);\n    props.put(&quot;ssl.truststore.type&quot;, &quot;PKCS12&quot;);\n    props.put(&quot;ssl.keystore.location&quot;, &quot;/Users/karanalang/Documents/Technology/0.ACME/strimzi-certs/versa-kafka-poc/syslog-vani-prefix/syslog-vani-prefix.p12&quot;);\n    props.put(&quot;ssl.keystore.password&quot;, &quot;pwd&quot;);\n    props.put(&quot;ssl.keystore.type&quot;, &quot;PKCS12&quot;);\n    props.put(&quot;security.protocol&quot;, &quot;SSL&quot;);\n    \n    // Schema Registry SSL settings\n    props.put(&quot;schema.registry.ssl.truststore.location&quot;, truststorePath);\n    props.put(&quot;schema.registry.ssl.truststore.password&quot;, TRUSTSTORE_PASSWORD);\n    props.put(&quot;schema.registry.ssl.truststore.type&quot;, &quot;JKS&quot;);\n    props.put(&quot;schema.registry.ssl.endpoint.identification.algorithm&quot;, &quot;HTTPS&quot;);\n\n    props.put(&quot;schema.reflection&quot;, &quot;false&quot;);\n    props.put(&quot;specific.avro.reader&quot;, &quot;true&quot;);\n    props.put(&quot;schema.registry.group.id&quot;, &quot;default&quot;);\n\n    // Add debugging parameter\n    props.put(&quot;debug&quot;, &quot;all&quot;);\n    \n    // For Apicurio 3.0.7, schema may be under a group\n    props.put(&quot;schema.registry.group.id&quot;, &quot;default&quot;);\n    \n    // Enhanced debugging\n    System.setProperty(&quot;org.slf4j.simpleLogger.log.io.confluent.kafka.serializers&quot;, &quot;TRACE&quot;);\n    System.setProperty(&quot;org.slf4j.simpleLogger.log.io.confluent.kafka.schemaregistry&quot;, &quot;TRACE&quot;);\n    \n    // Using your original topic\n    String topic = &quot;&lt;topic&gt;&quot;;\n    \n    // Update to your main method where you create and send messages\ntry (Producer&lt;String, Employee&gt; producer = new KafkaProducer&lt;&gt;(props)) {\n    System.out.println(&quot;Producer created successfully. Sending messages to: &quot; + topic);\n    \n    System.out.println(&quot;Sending employee records...&quot;);\n    \n    // Create employees with null values for new_col2 and new_col3\n    Employee[] employees = {\n        Employee.newBuilder()\n                .setId(1)\n                .setName(&quot;John Doe&quot;)\n                .setAge(30)\n                .setSalary(75000.0f)\n                .setDepartment(DepartmentEnum.ENGINEERING)\n                .setEmail(null)\n                .setNewCol(null)\n                .setNewCol2(null)\n                .setNewCol3(null)\n                .build(),\n        Employee.newBuilder()\n                .setId(2)\n                .setName(&quot;Jane Smith&quot;)\n                .setAge(28)\n                .setSalary(85000.0f)\n                .setDepartment(DepartmentEnum.HR)\n                .setEmail(null)\n                .setNewCol(null)\n                .setNewCol2(null)\n                .setNewCol3(null)\n                .build(),\n        Employee.newBuilder()\n                .setId(3)\n                .setName(&quot;Bob Johnson&quot;)\n                .setSalary(65000.0f)\n                .setDepartment(DepartmentEnum.SALES)\n                .setAge(null)\n                .setEmail(null)\n                .setNewCol(null)\n                .setNewCol2(null)\n                .setNewCol3(null)\n                .build()\n    };\n    \n    // Send each record\n    for (Employee emp : employees) {\n        System.out.println(&quot;Sending record for &quot; + emp.getName() + &quot; with ID: &quot; + emp.getId());\n        ProducerRecord&lt;String, Employee&gt; record = new ProducerRecord&lt;&gt;(topic, String.valueOf(emp.getId()), emp);\n        \n        // Use asynchronous sending with a callback instead of synchronous get()\n        producer.send(record, new Callback() {\n            @Override\n            public void onCompletion(RecordMetadata metadata, Exception e) {\n                if (e != null) {\n                    System.err.println(&quot;Error sending record for &quot; + emp.getName() + &quot;:&quot;);\n                    e.printStackTrace();\n                } else {\n                    System.out.println(&quot;Successfully sent &quot; + emp.getName() + &quot; to partition &quot; + \n                            metadata.partition() + &quot; at offset &quot; + metadata.offset());\n                }\n            }\n        });\n        \n        // Small delay to see logs clearly\n        Thread.sleep(100);\n    }\n    \n    // Ensure all records are sent before closing producer\n    producer.flush();\n    System.out.println(&quot;All messages sent successfully&quot;);\n}\n   \n\n</code></pre>\n<p>here is the error :</p>\n<pre><code>(base) Karans-MacBook-Pro:apicurio_confluent karanalang$ \n(base) Karans-MacBook-Pro:apicurio_confluent karanalang$ mvn exec:java -Dexec.mainClass=&quot;com.versa.apicurio.confluent.VersionBasedKafkaProducer&quot; -Dlog4j.debug\n[INFO] Scanning for projects...\n[INFO] \n[INFO] ----------&lt; com.versa.apicurio.confluent:apicurio_confluent &gt;-----------\n[INFO] Building apicurio_confluent 1.0-SNAPSHOT\n[INFO] --------------------------------[ jar ]---------------------------------\n[INFO] \n[INFO] --- exec-maven-plugin:3.5.0:java (default-cli) @ apicurio_confluent ---\nCreating custom truststore with Let's Encrypt certificates...\nDownloading Let's Encrypt Root certificate...\nDownloading Let's Encrypt R11 certificate...\nCustom truststore created at: /Users/karanalang/Documents/Technology/apicurio-schema-registry/SchemaRegistry/apicurio_confluent/apicurio-truststore.jks\nGot access token: eyJhbGciOiJSUzI...\n\n=== Verifying schema in registry ===\nChecking all subjects at: https://apicurio-sr.vkp.versa-vani.com/apis/ccompat/v7/subjects\nResponse Code: 200\nAll subjects: [&quot;com.versa.apicurio.confluent.Employee&quot;]\nSubject 'com.versa.apicurio.confluent.Employee' exists: true\nFetching versions at: https://apicurio-sr.vkp.versa-vani.com/apis/ccompat/v7/subjects/com.versa.apicurio.confluent.Employee/versions\nAvailable versions: [1,2,3,4]\nHighest version found: 4\nFetching schema at: https://apicurio-sr.vkp.versa-vani.com/apis/ccompat/v7/subjects/com.versa.apicurio.confluent.Employee/versions/4\nVersion 4 schema (raw): {&quot;subject&quot;:&quot;com.versa.apicurio.confluent.Employee&quot;,&quot;version&quot;:4,&quot;id&quot;:2,&quot;schema&quot;:&quot;{\\&quot;type\\&quot;: \\&quot;record\\&quot;, \\&quot;name\\&quot;: \\&quot;Employee\\&quot;, \\&quot;namespace\\&quot;: \\&quot;com.versa.apicurio.confluent\\&quot;, \\&quot;fields\\&quot;: [{\\&quot;name\\&quot;: \\&quot;id\\&quot;, \\&quot;type\\&quot;: \\&quot;int\\&quot;}, {\\&quot;name\\&quot;: \\&quot;name\\&quot;, \\&quot;type\\&quot;: \\&quot;string\\&quot;}, {\\&quot;name\\&quot;: \\&quot;salary\\&quot;, \\&quot;type\\&quot;: [\\&quot;null\\&quot;, \\&quot;float\\&quot;], \\&quot;default\\&quot;: null}, {\\&quot;name\\&quot;: \\&quot;age\\&quot;, \\&quot;type\\&quot;: [\\&quot;null\\&quot;, \\&quot;int\\&quot;], \\&quot;default\\&quot;: null}, {\\&quot;name\\&quot;: \\&quot;department\\&quot;, \\&quot;type\\&quot;: {\\&quot;type\\&quot;: \\&quot;enum\\&quot;, \\&quot;name\\&quot;: \\&quot;DepartmentEnum\\&quot;, \\&quot;symbols\\&quot;: [\\&quot;HR\\&quot;, \\&quot;ENGINEERING\\&quot;, \\&quot;SALES\\&quot;]}}, {\\&quot;name\\&quot;: \\&quot;email\\&quot;, \\&quot;type\\&quot;: [\\&quot;null\\&quot;, \\&quot;string\\&quot;], \\&quot;default\\&quot;: null}, {\\&quot;name\\&quot;: \\&quot;new_col\\&quot;, \\&quot;type\\&quot;: [\\&quot;null\\&quot;, \\&quot;string\\&quot;], \\&quot;default\\&quot;: null}, {\\&quot;name\\&quot;: \\&quot;new_col2\\&quot;, \\&quot;type\\&quot;: [\\&quot;null\\&quot;, \\&quot;string\\&quot;], \\&quot;default\\&quot;: null}, {\\&quot;name\\&quot;: \\&quot;new_col3\\&quot;, \\&quot;type\\&quot;: [\\&quot;null\\&quot;, \\&quot;string\\&quot;], \\&quot;default\\&quot;: null}]}&quot;,&quot;schemaType&quot;:&quot;AVRO&quot;,&quot;references&quot;:[]}\nSchema ID: 2\n\nSchema content (prettified):\n{&quot;type&quot;: &quot;record&quot;, &quot;name&quot;: &quot;Employee&quot;, &quot;namespace&quot;: &quot;com.versa.apicurio.confluent&quot;, &quot;fields&quot;: [{&quot;name&quot;: &quot;id&quot;, &quot;type&quot;: &quot;int&quot;}, {&quot;name&quot;: &quot;name&quot;, &quot;type&quot;: &quot;string&quot;}, {&quot;name&quot;: &quot;salary&quot;, &quot;type&quot;: [&quot;null&quot;, &quot;float&quot;], &quot;default&quot;: null}, {&quot;name&quot;: &quot;age&quot;, &quot;type&quot;: [&quot;null&quot;, &quot;int&quot;], &quot;default&quot;: null}, {&quot;name&quot;: &quot;department&quot;, &quot;type&quot;: {&quot;type&quot;: &quot;enum&quot;, &quot;name&quot;: &quot;DepartmentEnum&quot;, &quot;symbols&quot;: [&quot;HR&quot;, &quot;ENGINEERING&quot;, &quot;SALES&quot;]}}, {&quot;name&quot;: &quot;email&quot;, &quot;type&quot;: [&quot;null&quot;, &quot;string&quot;], &quot;default&quot;: null}, {&quot;name&quot;: &quot;new_col&quot;, &quot;type&quot;: [&quot;null&quot;, &quot;string&quot;], &quot;default&quot;: null}, {&quot;name&quot;: &quot;new_col2&quot;, &quot;type&quot;: [&quot;null&quot;, &quot;string&quot;], &quot;default&quot;: null}, {&quot;name&quot;: &quot;new_col3&quot;, &quot;type&quot;: [&quot;null&quot;, &quot;string&quot;], &quot;default&quot;: null}]}\n\n=== Testing direct schema retrieval by ID ===\nTesting URL: https://apicurio-sr.vkp.versa-vani.com/apis/ccompat/v7/schemas/ids/2\nSchema ID check response code: 200\nSchema by ID response: {&quot;schema&quot;:&quot;{\\&quot;type\\&quot;: \\&quot;record\\&quot;, \\&quot;name\\&quot;: \\&quot;Employee\\&quot;, \\&quot;namespace\\&quot;: \\&quot;com.versa.apicurio.confluent\\&quot;, \\&quot;fields\\&quot;: [{\\&quot;name\\&quot;: \\&quot;id\\&quot;, \\&quot;type\\&quot;: \\&quot;int\\&quot;}, {\\&quot;name\\&quot;: \\&quot;name\\&quot;, \\&quot;type\\&quot;: \\&quot;string\\&quot;}, {\\&quot;name\\&quot;: \\&quot;salary\\&quot;, \\&quot;type\\&quot;: [\\&quot;null\\&quot;, \\&quot;float\\&quot;], \\&quot;default\\&quot;: null}, {\\&quot;name\\&quot;: \\&quot;age\\&quot;, \\&quot;type\\&quot;: [\\&quot;null\\&quot;, \\&quot;int\\&quot;], \\&quot;default\\&quot;: null}, {\\&quot;name\\&quot;: \\&quot;department\\&quot;, \\&quot;type\\&quot;: {\\&quot;type\\&quot;: \\&quot;enum\\&quot;, \\&quot;name\\&quot;: \\&quot;DepartmentEnum\\&quot;, \\&quot;symbols\\&quot;: [\\&quot;HR\\&quot;, \\&quot;ENGINEERING\\&quot;, \\&quot;SALES\\&quot;]}}, {\\&quot;name\\&quot;: \\&quot;email\\&quot;, \\&quot;type\\&quot;: [\\&quot;null\\&quot;, \\&quot;string\\&quot;], \\&quot;default\\&quot;: null}, {\\&quot;name\\&quot;: \\&quot;new_col\\&quot;, \\&quot;type\\&quot;: [\\&quot;null\\&quot;, \\&quot;string\\&quot;], \\&quot;default\\&quot;: null}, {\\&quot;name\\&quot;: \\&quot;new_col2\\&quot;, \\&quot;type\\&quot;: [\\&quot;null\\&quot;, \\&quot;string\\&quot;], \\&quot;default\\&quot;: null}, {\\&quot;name\\&quot;: \\&quot;new_col3\\&quot;, \\&quot;type\\&quot;: [\\&quot;null\\&quot;, \\&quot;string\\&quot;], \\&quot;default\\&quot;: null}]}&quot;,&quot;schemaType&quot;:&quot;AVRO&quot;,&quot;references&quot;:[]}\nSLF4J: Class path contains multiple SLF4J bindings.\nSLF4J: Found binding in [jar:file:/Users/karanalang/.m2/repository/org/slf4j/slf4j-reload4j/1.7.36/slf4j-reload4j-1.7.36.jar!/org/slf4j/impl/StaticLoggerBinder.class]\nSLF4J: Found binding in [jar:file:/Users/karanalang/.m2/repository/ch/qos/logback/logback-classic/1.2.10/logback-classic-1.2.10.jar!/org/slf4j/impl/StaticLoggerBinder.class]\nSLF4J: See http://www.slf4j.org/codes.html#multiple_bindings for an explanation.\nlog4j: Trying to find [log4j.xml] using context classloader org.codehaus.mojo.exec.URLClassLoaderBuilder$ExecJavaClassLoader@34fe326d.\nlog4j: Trying to find [log4j.xml] using org.codehaus.mojo.exec.URLClassLoaderBuilder$ExecJavaClassLoader@34fe326d class loader.\nlog4j: Trying to find [log4j.xml] using ClassLoader.getSystemResource().\nlog4j: Trying to find [log4j.properties] using context classloader org.codehaus.mojo.exec.URLClassLoaderBuilder$ExecJavaClassLoader@34fe326d.\nlog4j: Using URL [jar:file:/Users/karanalang/.m2/repository/io/confluent/kafka-schema-registry/7.6.0/kafka-schema-registry-7.6.0.jar!/log4j.properties] for automatic log4j configuration.\nlog4j: Reading configuration from URL jar:file:/Users/karanalang/.m2/repository/io/confluent/kafka-schema-registry/7.6.0/kafka-schema-registry-7.6.0.jar!/log4j.properties\nlog4j: Parsing for [root] with value=[INFO, stdout].\nlog4j: Level token is [INFO].\nlog4j: Category root set to INFO\nlog4j: Parsing appender named &quot;stdout&quot;.\nlog4j: Parsing layout options for &quot;stdout&quot;.\nlog4j: Setting property [conversionPattern] to [[%d] %p %m (%c:%L)%n].\nlog4j: End of parsing for &quot;stdout&quot;.\nlog4j: Parsed &quot;stdout&quot; options.\nlog4j: Parsing for [org.apache.directory] with value=[ERROR, stdout].\nlog4j: Level token is [ERROR].\nlog4j: Category org.apache.directory set to ERROR\nlog4j: Parsing appender named &quot;stdout&quot;.\nlog4j: Appender &quot;stdout&quot; was already parsed.\nlog4j: Handling log4j.additivity.org.apache.directory=[null]\nlog4j: Parsing for [org.apache.zookeeper] with value=[ERROR, stdout].\nlog4j: Level token is [ERROR].\nlog4j: Category org.apache.zookeeper set to ERROR\nlog4j: Parsing appender named &quot;stdout&quot;.\nlog4j: Appender &quot;stdout&quot; was already parsed.\nlog4j: Handling log4j.additivity.org.apache.zookeeper=[null]\nlog4j: Parsing for [org.apache.kafka] with value=[ERROR, stdout].\nlog4j: Level token is [ERROR].\nlog4j: Category org.apache.kafka set to ERROR\nlog4j: Parsing appender named &quot;stdout&quot;.\nlog4j: Appender &quot;stdout&quot; was already parsed.\nlog4j: Handling log4j.additivity.org.apache.kafka=[null]\nlog4j: Parsing for [kafka] with value=[ERROR, stdout].\nlog4j: Level token is [ERROR].\nlog4j: Category kafka set to ERROR\nlog4j: Parsing appender named &quot;stdout&quot;.\nlog4j: Appender &quot;stdout&quot; was already parsed.\nlog4j: Handling log4j.additivity.kafka=[null]\nlog4j: Finished configuring.\nSLF4J: Actual binding is of type [org.slf4j.impl.Reload4jLoggerFactory]\n[2025-05-04 15:37:20,915] INFO KafkaAvroSerializerConfig values: \n    auto.register.schemas = false\n    avro.reflection.allow.null = false\n    avro.remove.java.properties = false\n    avro.use.logical.type.converters = false\n    basic.auth.credentials.source = URL\n    basic.auth.user.info = [hidden]\n    bearer.auth.cache.expiry.buffer.seconds = 300\n    bearer.auth.client.id = null\n    bearer.auth.client.secret = null\n    bearer.auth.credentials.source = USER_INFO\n    bearer.auth.custom.provider.class = null\n    bearer.auth.identity.pool.id = null\n    bearer.auth.issuer.endpoint.url = null\n    bearer.auth.logical.cluster = null\n    bearer.auth.scope = null\n    bearer.auth.scope.claim.name = scope\n    bearer.auth.sub.claim.name = sub\n    bearer.auth.token = [hidden]\n    context.name.strategy = class io.confluent.kafka.serializers.context.NullContextNameStrategy\n    http.connect.timeout.ms = 60000\n    http.read.timeout.ms = 60000\n    id.compatibility.strict = true\n    key.subject.name.strategy = class io.confluent.kafka.serializers.subject.TopicNameStrategy\n    latest.cache.size = 1000\n    latest.cache.ttl.sec = -1\n    latest.compatibility.strict = true\n    max.schemas.per.subject = 1000\n    normalize.schemas = false\n    proxy.host = \n    proxy.port = -1\n    rule.actions = []\n    rule.executors = []\n    rule.service.loader.enable = true\n    schema.format = null\n    schema.reflection = false\n    schema.registry.basic.auth.user.info = [hidden]\n    schema.registry.ssl.cipher.suites = null\n    schema.registry.ssl.enabled.protocols = [TLSv1.2, TLSv1.3]\n    schema.registry.ssl.endpoint.identification.algorithm = HTTPS\n    schema.registry.ssl.engine.factory.class = null\n    schema.registry.ssl.key.password = null\n    schema.registry.ssl.keymanager.algorithm = SunX509\n    schema.registry.ssl.keystore.certificate.chain = null\n    schema.registry.ssl.keystore.key = null\n    schema.registry.ssl.keystore.location = null\n    schema.registry.ssl.keystore.password = null\n    schema.registry.ssl.keystore.type = JKS\n    schema.registry.ssl.protocol = TLSv1.3\n    schema.registry.ssl.provider = null\n    schema.registry.ssl.secure.random.implementation = null\n    schema.registry.ssl.trustmanager.algorithm = PKIX\n    schema.registry.ssl.truststore.certificates = null\n    schema.registry.ssl.truststore.location = /Users/karanalang/Documents/Technology/apicurio-schema-registry/SchemaRegistry/apicurio_confluent/apicurio-truststore.jks\n    schema.registry.ssl.truststore.password = [hidden]\n    schema.registry.ssl.truststore.type = JKS\n    schema.registry.url = [https://apicurio-sr.vkp.versa-vani.com/apis/ccompat/v7]\n    use.latest.version = true\n    use.latest.with.metadata = null\n    use.schema.id = 2\n    value.subject.name.strategy = class io.confluent.kafka.serializers.subject.RecordNameStrategy\n (io.confluent.kafka.serializers.KafkaAvroSerializerConfig:370)\nProducer created successfully. Sending messages to: syslog.ueba-nov.v1.nov.nov\nSending employee records...\nSending record for John Doe with ID: 1\n[WARNING] \norg.apache.kafka.common.errors.SerializationException: Error retrieving schema ID{&quot;type&quot;:&quot;record&quot;,&quot;name&quot;:&quot;Employee&quot;,&quot;namespace&quot;:&quot;com.versa.apicurio.confluent&quot;,&quot;fields&quot;:[{&quot;name&quot;:&quot;id&quot;,&quot;type&quot;:&quot;int&quot;},{&quot;name&quot;:&quot;name&quot;,&quot;type&quot;:&quot;string&quot;},{&quot;name&quot;:&quot;salary&quot;,&quot;type&quot;:[&quot;null&quot;,&quot;float&quot;],&quot;default&quot;:null},{&quot;name&quot;:&quot;age&quot;,&quot;type&quot;:[&quot;null&quot;,&quot;int&quot;],&quot;default&quot;:null},{&quot;name&quot;:&quot;department&quot;,&quot;type&quot;:{&quot;type&quot;:&quot;enum&quot;,&quot;name&quot;:&quot;DepartmentEnum&quot;,&quot;symbols&quot;:[&quot;HR&quot;,&quot;ENGINEERING&quot;,&quot;SALES&quot;]}},{&quot;name&quot;:&quot;email&quot;,&quot;type&quot;:[&quot;null&quot;,&quot;string&quot;],&quot;default&quot;:null},{&quot;name&quot;:&quot;new_col&quot;,&quot;type&quot;:[&quot;null&quot;,&quot;string&quot;],&quot;default&quot;:null},{&quot;name&quot;:&quot;new_col2&quot;,&quot;type&quot;:[&quot;null&quot;,&quot;string&quot;],&quot;default&quot;:null},{&quot;name&quot;:&quot;new_col3&quot;,&quot;type&quot;:[&quot;null&quot;,&quot;string&quot;],&quot;default&quot;:null}]}\n    at io.confluent.kafka.serializers.AbstractKafkaSchemaSerDe.toKafkaException (AbstractKafkaSchemaSerDe.java:809)\n    at io.confluent.kafka.serializers.AbstractKafkaAvroSerializer.serializeImpl (AbstractKafkaAvroSerializer.java:176)\n    at io.confluent.kafka.serializers.KafkaAvroSerializer.serialize (KafkaAvroSerializer.java:68)\n    at org.apache.kafka.clients.producer.KafkaProducer.doSend (KafkaProducer.java:1000)\n    at org.apache.kafka.clients.producer.KafkaProducer.send (KafkaProducer.java:947)\n    at com.versa.apicurio.confluent.VersionBasedKafkaProducer.main (VersionBasedKafkaProducer.java:507)\n    at org.codehaus.mojo.exec.ExecJavaMojo.doMain (ExecJavaMojo.java:375)\n    at org.codehaus.mojo.exec.ExecJavaMojo.doExec (ExecJavaMojo.java:364)\n    at org.codehaus.mojo.exec.ExecJavaMojo.lambda$execute$0 (ExecJavaMojo.java:286)\n    at java.lang.Thread.run (Thread.java:833)\nCaused by: io.confluent.kafka.schemaregistry.client.rest.exceptions.RestClientException: Error; error code: 50005\n    at io.confluent.kafka.schemaregistry.client.rest.RestService.sendHttpRequest (RestService.java:336)\n    at io.confluent.kafka.schemaregistry.client.rest.RestService.httpRequest (RestService.java:409)\n    at io.confluent.kafka.schemaregistry.client.rest.RestService.getId (RestService.java:907)\n    at io.confluent.kafka.schemaregistry.client.rest.RestService.getId (RestService.java:880)\n    at io.confluent.kafka.schemaregistry.client.CachedSchemaRegistryClient.getSchemaByIdFromRegistry (CachedSchemaRegistryClient.java:333)\n    at io.confluent.kafka.schemaregistry.client.CachedSchemaRegistryClient.getSchemaBySubjectAndId (CachedSchemaRegistryClient.java:464)\n    at io.confluent.kafka.serializers.AbstractKafkaSchemaSerDe.getSchemaBySubjectAndId (AbstractKafkaSchemaSerDe.java:534)\n    at io.confluent.kafka.serializers.AbstractKafkaSchemaSerDe.lookupSchemaBySubjectAndId (AbstractKafkaSchemaSerDe.java:540)\n    at io.confluent.kafka.serializers.AbstractKafkaAvroSerializer.serializeImpl (AbstractKafkaAvroSerializer.java:130)\n    at io.confluent.kafka.serializers.KafkaAvroSerializer.serialize (KafkaAvroSerializer.java:68)\n    at org.apache.kafka.clients.producer.KafkaProducer.doSend (KafkaProducer.java:1000)\n    at org.apache.kafka.clients.producer.KafkaProducer.send (KafkaProducer.java:947)\n    at com.versa.apicurio.confluent.VersionBasedKafkaProducer.main (VersionBasedKafkaProducer.java:507)\n    at org.codehaus.mojo.exec.ExecJavaMojo.doMain (ExecJavaMojo.java:375)\n    at org.codehaus.mojo.exec.ExecJavaMojo.doExec (ExecJavaMojo.java:364)\n    at org.codehaus.mojo.exec.ExecJavaMojo.lambda$execute$0 (ExecJavaMojo.java:286)\n    at java.lang.Thread.run (Thread.java:833)\n[INFO] ------------------------------------------------------------------------\n[INFO] BUILD FAILURE\n\n</code></pre>\n<p>In function - verifySchemaAndGetId(), i'm able to get the SchemaId &amp; the schema details, but when i use the Producer to publish the schema - it is failing.</p>\n<p>Any idea on this ?</p>\n<p>tia!</p>\n",
    "tags" : [ "java", "apache-kafka", "apicurio-registry" ],
    "owner" : {
      "account_id" : 9209057,
      "reputation" : 1111,
      "user_id" : 6843103,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/72fd0b3d4b30be46080ac777a233d4db?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Karan Alang",
      "link" : "https://stackoverflow.com/users/6843103/karan-alang"
    },
    "is_answered" : false,
    "view_count" : 137,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1748313483,
    "creation_date" : 1746399348,
    "link" : "https://stackoverflow.com/questions/79606146/apicurio-schema-registry-3-0-7-producer-failing-in-confluent-compatibility-mod",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ ],
  "answer_comments" : { }
}