{
  "question" : {
    "question_id" : 79633620,
    "title" : "How to restrict visibility between Gradle modules in a modular monolith Spring Boot application",
    "body" : "<p>I'm working on a large modular monolith Spring Boot application (Java) that's structured into multiple Gradle build modules. Each module represents a specific domain (e.g., user management, notification handling), and contains its own internal business logic that ideally should remain private and inaccessible from other domains.</p>\n<p>To enforce this encapsulation, I've structured each domain module into two sub-modules: api and impl. Using Gradle plugins, I’ve defined rules such that only api sub-modules can be used as dependencies by other modules. This approach generally works, but it comes with two significant drawbacks:</p>\n<p><strong>Increased Module Count</strong>: Every domain now has two modules (api and impl), which essentially doubles the number of Gradle modules and increases project complexity.</p>\n<p><strong>Dependency Cycles</strong>: It’s still possible to accidentally introduce cycles—for example, moduleA:impl depending on moduleB:api, and moduleB:impl depending on moduleA:api. These cycles are hard to detect and can easily slip through code reviews.</p>\n<p>I’m looking for better tooling or practices to:</p>\n<ul>\n<li><p>Limit what can be accessed from a Gradle module (e.g., restrict\nvisibility to only specific packages or classes).</p>\n</li>\n<li><p>Prevent cross-module access to internal implementation code.</p>\n</li>\n<li><p>Possibly define and enforce these rules globally across the codebase.</p>\n</li>\n</ul>\n<p>One idea I’ve considered is using ArchUnit tests to assert architectural boundaries. For instance, moduleA could declare it’s only allowed to access the api package of moduleB. However, this raises a few concerns:</p>\n<p>Each module would need to explicitly define what it’s allowed to see, which could be error-prone if a developer forgets to add the appropriate rule.</p>\n<p>I'm unsure whether ArchUnit can be configured in a way that allows these rules to be enforced globally across the entire project.</p>\n<p>My question is:\nAre there tools, best practices, or Gradle configurations that can help enforce strict module boundaries and encapsulation in a multi-module Java project?</p>\n<p>Any advice or examples would be greatly appreciated.</p>\n",
    "tags" : [ "java", "gradle", "architecture", "archunit" ],
    "owner" : {
      "account_id" : 4727352,
      "reputation" : 1069,
      "user_id" : 3823862,
      "user_type" : "registered",
      "accept_rate" : 100,
      "profile_image" : "https://i.sstatic.net/tGs0Z.jpg?s=256",
      "display_name" : "mirzak",
      "link" : "https://stackoverflow.com/users/3823862/mirzak"
    },
    "is_answered" : true,
    "view_count" : 115,
    "answer_count" : 1,
    "score" : 1,
    "last_activity_date" : 1748391902,
    "creation_date" : 1747912336,
    "link" : "https://stackoverflow.com/questions/79633620/how-to-restrict-visibility-between-gradle-modules-in-a-modular-monolith-spring-b",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79641361,
    "question_id" : 79633620,
    "body" : "<p>I was going to comment, but for readability this will be easier as an answer.  I'm not sure this qualifies as an answer as I am not familiar with Gradle.</p>\n<p>Regarding:</p>\n<blockquote>\n<p>Are there tools, best practices ... that can help enforce strict module boundaries and encapsulation</p>\n</blockquote>\n<p>...and keeping in mind:</p>\n<blockquote>\n<p>I've structured each domain module into two sub-modules: api and impl.</p>\n</blockquote>\n<p>This answer <a href=\"https://stackoverflow.com/a/62257045/39094\">https://stackoverflow.com/a/62257045/39094</a> talks about access with regards to modules.  On the basis of that I'd have thought you can have one module instead of two for a given domain, and just have it so only the API methods are set as public / accessible on the module.  That way encapsulation can be enforced as you want it, and you have less modules and a simpler design.</p>\n<p>Regarding <strong>Dependency Cycles</strong>.  @SpaceTrucker makes an excellent point - just because calls go in both directions doesn't mean it's necessarily cyclical as in a death spiral, but it does indicate some potential coupling or at least that they work closely together to achieve something.  Might be worth a design review, but doesn't mean you should panic right off the bat.</p>\n<p>Some kind of static code review would probably be a good way to test for the presence of stuff like that, but I have not used static code analysis before so can't comment further.  It looks like there's no shortage of tooling options for Java in that regard.</p>\n<p>Internet search informs me that yes, you can use Gradle to control/initiate static code review - so yes it's possible, and based on my generic software engineering experience such an approach would not be an objectively bad idea.</p>\n",
    "score" : 1,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 17461,
      "reputation" : 10375,
      "user_id" : 39094,
      "user_type" : "registered",
      "accept_rate" : 78,
      "profile_image" : "https://www.gravatar.com/avatar/dcbc09ba91f447ef74bb453072bca452?s=256&d=identicon&r=PG",
      "display_name" : "Adrian K",
      "link" : "https://stackoverflow.com/users/39094/adrian-k"
    },
    "creation_date" : 1748391902,
    "last_activity_date" : 1748391902,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140451566,
    "post_id" : 79633620,
    "body" : "That is also a valid point, maybe I am overthinking it and splitting into sub modules does not really complicate the system that much.",
    "score" : 0,
    "owner" : {
      "account_id" : 4727352,
      "reputation" : 1069,
      "user_id" : 3823862,
      "user_type" : "registered",
      "accept_rate" : 100,
      "profile_image" : "https://i.sstatic.net/tGs0Z.jpg?s=256",
      "display_name" : "mirzak",
      "link" : "https://stackoverflow.com/users/3823862/mirzak"
    },
    "creation_date" : 1747980869,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140449221,
    "post_id" : 79633620,
    "body" : "For me there is no dependency cycle if <code>AImpl -&gt; BApi</code> and <code>BImpl -&gt; AApi</code> assuming you have <code>AImpl -&gt; AApi</code> and <code>BImpl -&gt; BApi</code> from your previous explanations. Regarding project complexity and increased module count - does this really make the project more complex compared to having api and impl in the same gradle module and having some rule sitting deep inside some gradle files that says there shouldn&#39;t be an <code>*.impl</code> or <code>*.internal</code> imports besides those of the current classes package? I don&#39;t really see that point.",
    "score" : 2,
    "owner" : {
      "account_id" : 1580843,
      "reputation" : 13706,
      "user_id" : 1466267,
      "user_type" : "registered",
      "accept_rate" : 91,
      "profile_image" : "https://www.gravatar.com/avatar/c47d1f7544a8c4a1bb7a41d511f53604?s=256&d=identicon&r=PG",
      "display_name" : "SpaceTrucker",
      "link" : "https://stackoverflow.com/users/1466267/spacetrucker"
    },
    "creation_date" : 1747915611,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}