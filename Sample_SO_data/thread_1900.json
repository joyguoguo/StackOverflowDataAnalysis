{
  "question" : {
    "question_id" : 79665579,
    "title" : "Finding the intersection of two geodetic lines in latitude and longitude",
    "body" : "<p>I have an issue with the below code that is not returning the correct answer. It is trying to find the intersection of two lines on the earth's surface, taking into account the earths curvature. I've put this together from snippets off the Web so I don't really understand the mathematics behind it and not sure where the problem lies.</p>\n<p>Longitude is correct, but latitude is wrong. The correct answer is around -26.5098, but the code returns -26.373957.</p>\n<p>I also suspect that the haversine formula being used is also wrong, as it does not take into account flattening.</p>\n<p>Hopefully, some of our mathematicians can point me in the right direction.</p>\n<pre><code>import org.apache.commons.math3.geometry.euclidean.threed.Vector3D;\n\npublic class Intersection {\n\n    // WGS84 ellipsoid constants\n    private static final double SEMI_MAJOR_AXIS = 6378137.0; // meters\n    private static final double FLATTENING = 1 / 298.257223563;\n    private static final double SEMI_MINOR_AXIS = SEMI_MAJOR_AXIS * (1 - FLATTENING);\n    private static final double ECCENTRICITY_SQUARED = 2 * FLATTENING - FLATTENING * FLATTENING;\n\n    public static void main(String[] args) {\n        // Example geodesic lines (latitude and longitude in degrees)\n        double[] line1Start = {-25.0, 10.0}; \n        double[] line1End = {-28.0, 13.0};   \n        double[] line2Start = {-25.0, 13.0}; \n        double[] line2End = {-28.0, 10.0};   \n        int option = 0;\n\n        double[] intersection = findIntersection(line1Start, line1End, line2Start, line2End, option);\n\n        if (intersection != null) {\n            System.out.printf(&quot;Intersection Point: Latitude = %.6f, Longitude = %.6f%n&quot;,\n                    intersection[0], intersection[1]);\n        } else {\n            System.out.println(&quot;No intersection found or lines are coincident.&quot;);\n        }\n    }\n\n    public static double[] findIntersection(double[] line1Start, double[] line1End,\n            double[] line2Start, double[] line2End, int option) {\n        // Convert geodetic coordinates to 3D Cartesian coordinates\n        Vector3D p1 = geodeticToCartesian2(line1Start[0], line1Start[1]);\n        Vector3D p2 = geodeticToCartesian2(line1End[0], line1End[1]);\n        Vector3D p3 = geodeticToCartesian2(line2Start[0], line2Start[1]);\n        Vector3D p4 = geodeticToCartesian2(line2End[0], line2End[1]);\n\n        double check[] = cartesianToGeodetic(p1);\n        System.out.println (String.format(&quot;Check 1: %.6f&quot;, check[0]) + String.format(&quot; %.6f&quot;, check[1]));\n\n        // Compute normal vectors for the planes containing the geodesics\n        Vector3D n1 = p1.crossProduct(p2);\n        Vector3D n2 = p3.crossProduct(p4);\n\n        // Find the intersection line of the two planes\n        Vector3D intersectionLine = n1.crossProduct(n2);\n        check = cartesianToGeodetic(intersectionLine);\n        System.out.println (String.format(&quot;Check 2: %.6f&quot;, check[0]) + String.format(&quot; %.6f&quot;, check[1]));\n\n        // Normalize the intersection line to find the intersection points on the spheroid\n\n        // These two steps are commented out as were giving very wrong results\n\n        // Vector3D intersectionPoint1 = intersectionLine.normalize();\n        // Vector3D intersectionPoint2 = intersectionLine.negate().normalize();\n        Vector3D intersectionPoint1 = intersectionLine;\n        Vector3D intersectionPoint2 = intersectionLine.negate();\n\n        // Convert back to geodetic coordinates\n        double[] geodeticPoint1 = cartesianToGeodetic(intersectionPoint1);\n        double[] geodeticPoint2 = cartesianToGeodetic(intersectionPoint2);\n        System.out.println (String.format(&quot;GP 1: %.6f&quot;, geodeticPoint1[0]) + String.format(&quot; %.6f&quot;, geodeticPoint1[1]));\n        System.out.println (String.format(&quot;GP 2: %.6f&quot;, geodeticPoint2[0]) + String.format(&quot; %.6f&quot;, geodeticPoint2[1]));\n\n        // Check which intersection point lies on both geodesics\n        if (isPointOnGeodesic(geodeticPoint1, line1Start, line1End) &amp;&amp;\n                isPointOnGeodesic(geodeticPoint1, line2Start, line2End)) {\n            return geodeticPoint1;\n        } \n        else {\n            System.out.println(&quot;Checking point 2&quot;);\n            if (isPointOnGeodesic(geodeticPoint2, line1Start, line1End) &amp;&amp;\n                    isPointOnGeodesic(geodeticPoint2, line2Start, line2End)) {\n                return geodeticPoint2;\n            }\n        } \n        return null;\n    }\n\n    private static boolean isPointOnGeodesic(double[] gp, double[] ls, double[] le) {\n        // TODO Auto-generated method stub\n        double ah = haversine(ls[0], ls[1], gp[0], gp[1]);\n        double bh = haversine(gp[0], gp[1], le[0], le[1]);\n        double ch = haversine(ls[0], ls[1], le[0], le[1]);\n\n        System.out.println (String.format(&quot;ah : %.2f&quot;, ah) +String.format(&quot; bh : %.2f&quot;, bh) + String.format(&quot; ch : %.6f&quot;, ch));\n        System.out.println (String.format(&quot;ah + bh : %.6f&quot;, ah + bh) + String.format(&quot; ch : %.6f&quot;, ch));\n        if ( (ah+bh) == ch ) return true;\n\n        return false;\n    }\n\n    private static double haversine(double lat1, double lon1, double lat2, double lon2) {\n\n        // Convert latitude and longitude from degrees to radians\n        double lat1Rad = Math.toRadians(lat1);\n        double lon1Rad = Math.toRadians(lon1);\n        double lat2Rad = Math.toRadians(lat2);\n        double lon2Rad = Math.toRadians(lon2);\n\n        // Haversine formula\n        // Why is this not using FLATTENING? Does it matter?\n        double dLat = lat2Rad - lat1Rad;\n        double dLon = lon2Rad - lon1Rad;\n        double a = Math.pow(Math.sin(dLat / 2), 2) +\n                Math.cos(lat1Rad) * Math.cos(lat2Rad) * Math.pow(Math.sin(dLon / 2), 2);\n        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n        // Distance in metres\n        return SEMI_MAJOR_AXIS * c;\n    }\n\n    private static double[] cartesianToGeodetic(Vector3D point) {\n        double x = point.getX();\n        double y = point.getY();\n        double z = point.getZ();\n        double longitude = Math.atan2(y, x); // Longitude in radians\n\n        double p = Math.sqrt(x * x + y * y);\n        double theta = Math.atan2(z * SEMI_MAJOR_AXIS, p * SEMI_MINOR_AXIS);\n\n        double sinTheta = Math.sin(theta);\n        double cosTheta = Math.cos(theta);\n\n        double latitude = Math.atan2(\n                z + ECCENTRICITY_SQUARED * SEMI_MINOR_AXIS * sinTheta * sinTheta * sinTheta,\n                p - ECCENTRICITY_SQUARED * SEMI_MAJOR_AXIS * cosTheta * cosTheta * cosTheta\n                );\n\n        double sinLatitude = Math.sin(latitude);\n        double N = SEMI_MAJOR_AXIS / Math.sqrt(1 - ECCENTRICITY_SQUARED * sinLatitude * sinLatitude);\n\n        double altitude = p / Math.cos(latitude) - N;\n\n        // Convert radians to degrees for latitude and longitude\n        double latitudeDegrees = Math.toDegrees(latitude);\n        double longitudeDegrees = Math.toDegrees(longitude);\n\n        return new double[]{latitudeDegrees, longitudeDegrees, altitude};\n    }\n\n    public static Vector3D geodeticToCartesian2(double latitude, double longitude) {\n        // Convert latitude and longitude from degrees to radians\n        double altitude = 0;\n        double latRad = Math.toRadians(latitude);\n        double lonRad = Math.toRadians(longitude);\n\n        // Calculate the radius of curvature in the prime vertical\n        double N = SEMI_MAJOR_AXIS / Math.sqrt(1 - ECCENTRICITY_SQUARED * Math.pow(Math.sin(latRad), 2));\n\n        // Calculate Cartesian coordinates\n        double x = (N + altitude) * Math.cos(latRad) * Math.cos(lonRad);\n        double y = (N + altitude) * Math.cos(latRad) * Math.sin(lonRad);\n        double z = ((1 - ECCENTRICITY_SQUARED) * N + altitude) * Math.sin(latRad);\n\n        return new Vector3D(x, y, z);\n    }\n}\n</code></pre>\n",
    "tags" : [ "java", "latitude-longitude", "wgs84" ],
    "owner" : {
      "account_id" : 7467538,
      "reputation" : 313,
      "user_id" : 5676501,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/ac17fb0590f5b20a3d0a0add4f189367?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Andrew L",
      "link" : "https://stackoverflow.com/users/5676501/andrew-l"
    },
    "is_answered" : false,
    "view_count" : 95,
    "answer_count" : 0,
    "score" : 2,
    "last_activity_date" : 1749958951,
    "creation_date" : 1749875743,
    "link" : "https://stackoverflow.com/questions/79665579/finding-the-intersection-of-two-geodetic-lines-in-latitude-and-longitude",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140514577,
    "post_id" : 79665579,
    "body" : "That is more a geodesy/mathematics problem and less a programming one - you must first find/specify the correct formula(s) to use, before you can implement it (&quot;<i>formula being used is also wrong</i>&quot;: most probably since the haversine formula is for spherical geometry)",
    "score" : 0,
    "owner" : {
      "account_id" : 31180,
      "reputation" : 29752,
      "user_id" : 85421,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/kKvXH.gif?s=256",
      "display_name" : "user85421",
      "link" : "https://stackoverflow.com/users/85421/user85421"
    },
    "creation_date" : 1749976680,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140513432,
    "post_id" : 79665579,
    "body" : "<a href=\"https://stackoverflow.com/posts/79665579/edit\">edit</a> the question to add the information from your comments.",
    "score" : 1,
    "owner" : {
      "account_id" : 372682,
      "reputation" : 26512,
      "user_id" : 721855,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/vZiox.png?s=256",
      "display_name" : "aled",
      "link" : "https://stackoverflow.com/users/721855/aled"
    },
    "creation_date" : 1749904546,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140513171,
    "post_id" : 79665579,
    "body" : "Also, in knowing the intersection is wrong, the Haversine formula should have returned distances that are close, and they way off, about 600m in 448 km.",
    "score" : 0,
    "owner" : {
      "account_id" : 7467538,
      "reputation" : 313,
      "user_id" : 5676501,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/ac17fb0590f5b20a3d0a0add4f189367?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Andrew L",
      "link" : "https://stackoverflow.com/users/5676501/andrew-l"
    },
    "creation_date" : 1749891758,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140513166,
    "post_id" : 79665579,
    "body" : "Intersecting the planes sounds interesting. How do you account the flattening with the earth being an ellipsoid rather than a sphere? I need these intersections to be accurate to the mm.",
    "score" : 0,
    "owner" : {
      "account_id" : 7467538,
      "reputation" : 313,
      "user_id" : 5676501,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/ac17fb0590f5b20a3d0a0add4f189367?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Andrew L",
      "link" : "https://stackoverflow.com/users/5676501/andrew-l"
    },
    "creation_date" : 1749891466,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140513163,
    "post_id" : 79665579,
    "body" : "How do I know it&#39;s wrong? I&#39;ve plotted the points in a graphical package, and the intersection is well off.",
    "score" : 0,
    "owner" : {
      "account_id" : 7467538,
      "reputation" : 313,
      "user_id" : 5676501,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/ac17fb0590f5b20a3d0a0add4f189367?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Andrew L",
      "link" : "https://stackoverflow.com/users/5676501/andrew-l"
    },
    "creation_date" : 1749891270,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140512944,
    "post_id" : 79665579,
    "body" : "I&#39;m curious, if you don&#39;t understand it, how do you know it&#39;s wrong?  How do you know what the right answer is?",
    "score" : 1,
    "owner" : {
      "account_id" : 1704483,
      "reputation" : 12144,
      "user_id" : 1563833,
      "user_type" : "registered",
      "accept_rate" : 40,
      "profile_image" : "https://www.gravatar.com/avatar/f3d7ae271e46eb178e7dd4f2ef760e6f?s=256&d=identicon&r=PG",
      "display_name" : "Wyck",
      "link" : "https://stackoverflow.com/users/1563833/wyck"
    },
    "creation_date" : 1749876412,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}