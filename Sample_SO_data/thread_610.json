{
  "question" : {
    "question_id" : 79789816,
    "title" : "How can I cache a single object?",
    "body" : "<p>I have a class which initializes its internal data from a resource file and I want to give clients an opportunity to choose to use new instances or a cached instance.</p>\n<p>Here comes what it looks like.</p>\n<pre class=\"lang-java prettyprint-override\"><code>// Immutable, hence, thread-safe\nclass MyClass {\n\n    // Returns a new instance.\n    public static MyClass newInstance() {\n        // Loads resources, and constructs a new object\n    }\n\n    private MyClass() {\n    }\n}\n</code></pre>\n<p>And here comes what I'm adding for those clients want to use a cached instance.</p>\n<pre class=\"lang-java prettyprint-override\"><code>    private static volatile SoftReference&lt;MyClass&gt; INSTANCE;\n\n    // multiple instances may be created,\n    // in a timing manner,\n    // which is ok\n    private static MyClass getInstance() {\n        var result = INSTANCE;\n        if (result == null || result.get() == null) {\n            result = INSTANCE = new SoftReference&lt;&gt;(newInstance());\n        }\n        return result.get();\n    }\n\n    public static &lt;R&gt; R applyInstance(\n            final Function&lt;? super MyClass, ? extends R&gt; function) {\n        Objects.requireNonNull(function, &quot;function is null&quot;);\n        return function.apply(getInstance());\n    }\n</code></pre>\n<p>My questions are,</p>\n<ul>\n<li>Is it property implemented as what I'm intending to do?</li>\n<li>Is the way using the <code>SoftReference</code> right?</li>\n</ul>\n",
    "tags" : [ "java", "soft-references" ],
    "owner" : {
      "account_id" : 130873,
      "reputation" : 22419,
      "user_id" : 330457,
      "user_type" : "registered",
      "accept_rate" : 82,
      "profile_image" : "https://i.sstatic.net/2JN6W.jpg?s=256",
      "display_name" : "Jin Kwon",
      "link" : "https://stackoverflow.com/users/330457/jin-kwon"
    },
    "is_answered" : true,
    "view_count" : 191,
    "answer_count" : 4,
    "score" : 1,
    "last_activity_date" : 1761592361,
    "creation_date" : 1760417515,
    "link" : "https://stackoverflow.com/questions/79789816/how-can-i-cache-a-single-object",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79789947,
    "question_id" : 79789816,
    "body" : "<p>The garbage collection can happen any time, so your <code>getInstance()</code> method could return <code>null</code> in certain cases.</p>\n<p>Try this:</p>\n<pre><code>    private static synchronized MyClass getInstance() {\n        var result = INSTANCE == null ? null : INSTANCE.get();\n        if (result == null) {\n            result = newInstance();\n            INSTANCE = new SoftReference&lt;&gt;(result);\n        }\n        return result;\n    }\n</code></pre>\n",
    "score" : 3,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 9463219,
      "reputation" : 9678,
      "user_id" : 7036419,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/66e3c04567f6d68a874c3007327c1373?s=256&d=identicon&r=PG",
      "display_name" : "Maurice Perry",
      "link" : "https://stackoverflow.com/users/7036419/maurice-perry"
    },
    "creation_date" : 1760428720,
    "last_activity_date" : 1760428720,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79789945,
    "question_id" : 79789816,
    "body" : "<p>Personally, I hate this static <code>getInstance()</code> singleton pattern. It's terrible for testing. Have you considered using dependency injection and maybe a <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html\" rel=\"nofollow noreferrer\">Supplier</a></p>\n<pre class=\"lang-java prettyprint-override\"><code>public class MyService {\n   private final Supplier&lt;MyClass&gt; supplier;\n\n   public MyService(Supplier&lt;MyClass&gt; supplier) { this.supplier = supplier; }\n\n   public void doStuff(int someVar) {\n      MyClass myClass = supplier.get();\n      myClass.doStuff(someVar);\n\n      // do extra stuff\n   }\n}\n</code></pre>\n<p>Then clients could pass in whatever <code>Supplier&lt;MyClass&gt;</code> implementation suits them</p>\n<p>eg:</p>\n<pre class=\"lang-java prettyprint-override\"><code>MyClass myClass1 = new MyClass(100);\n\n// supplier always returns the same instance\nSupplier&lt;MyClass&gt; supplier1 = () -&gt; myClass1; \nMyService myService1 = new MyService(suppplier1);\nmyService1.doStuff(10);\nmyService1.doStuff(20);\n\n// reference initially pointing to new MyClass(200)\nAtomicReference&lt;MyClass&gt; reference2 = new AtomicReference(new MyClass(200));\n\n// supplier returns current value of atomic reference\nSupplier&lt;MyClass&gt; supplier2 = reference2::get; \nMyService myService2 = new MyService(suppplier2);\nmyService2.doStuff(30);\nmyService2.doStuff(40);\n\n// change the reference so it now points to new MyClass(300)\nreference2.set(new MyClass(300)); \nmyService2.doStuff(50);\nmyService2.doStuff(60);\n</code></pre>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1096470,
      "reputation" : 29414,
      "user_id" : 1089967,
      "user_type" : "registered",
      "accept_rate" : 59,
      "profile_image" : "https://www.gravatar.com/avatar/1f256b904ff621d678598d8fa49f86c5?s=256&d=identicon&r=PG",
      "display_name" : "lance-java",
      "link" : "https://stackoverflow.com/users/1089967/lance-java"
    },
    "creation_date" : 1760428639,
    "last_activity_date" : 1760431103,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79793517,
    "question_id" : 79789816,
    "body" : "<p><a href=\"https://stackoverflow.com/a/79789947/6395627\">The answer</a> by <a href=\"https://stackoverflow.com/users/7036419/maurice-perry\">Maurice Perry</a> is correct. You need to locally cache the instance to avoid it being garbage collected between checking if it's null and returning it. However, I want to point out your implementation can also lead to two threads returning <em>different</em> instances of the &quot;singleton&quot; when they race to create a new instance.</p>\n<p>Now, you mention in code comments that it's okay if multiple instances of the singleton are created. But if you want multiple racing threads to ultimately return a <em>single</em> instance, even if more than one instance was created, then you need to add more checks to your implementation. This can be done without locking via an atomic reference. For example:</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.lang.ref.SoftReference;\nimport java.util.Objects;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Supplier;\n\npublic final class SoftSingleton&lt;T&gt; {\n\n  private final AtomicReference&lt;SoftReference&lt;T&gt;&gt; atomicRef = new AtomicReference&lt;&gt;();\n  private final Supplier&lt;? extends T&gt; factory;\n\n  public SoftSingleton(Supplier&lt;? extends T&gt; factory) {\n    this.factory = Objects.requireNonNull(factory);\n  }\n\n  public T getInstance() {\n    T instance;\n    while (true) {\n      SoftReference&lt;T&gt; softRef = atomicRef.get();\n\n      instance = (softRef == null) ? null : softRef.get();\n      if (instance != null) \n        break;\n\n      instance = Objects.requireNonNull(factory.get());\n      if (atomicRef.compareAndSet(softRef, new SoftReference&lt;&gt;(instance))) \n        break;\n    }\n    return instance;\n  }\n}\n</code></pre>\n<p>And if you decide you only want one instance of the singleton to ever exist then you can use a double-checked locking implementation. For example:</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.lang.ref.SoftReference;\nimport java.util.Objects;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.function.Supplier;\n\npublic final class SoftSingleton&lt;T&gt; {\n\n  private final Lock mutex = new ReentrantLock();\n  private volatile SoftReference&lt;T&gt; softRef;\n\n  private final Supplier&lt;? extends T&gt; factory;\n\n  public SoftSingleton(Supplier&lt;? extends T&gt; factory) {\n    this.factory = Objects.requireNonNull(factory);\n  }\n\n  public T getInstance() {\n    T instance = getCurrentInstance();\n    if (instance == null) {\n      mutex.lock();\n      try {\n        instance = getCurrentInstance();\n        if (instance == null) {\n          instance = Objects.requireNonNull(factory.get());\n          this.softRef = new SoftReference&lt;&gt;(instance);\n        }\n      } finally {\n        mutex.unlock();\n      }\n    }\n    return instance;\n  }\n\n  private T getCurrentInstance() {\n    var softRef = this.softRef;\n    return (softRef == null) ? null : softRef.get();\n  }\n}\n</code></pre>\n<hr />\n<p>Note both those solutions are more complex than Maurice's. My answer is based on your attempt with <code>volatile</code>, which I took to mean you want to avoid locking/synchronizing if the value already exists.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49884,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1760751212,
    "last_activity_date" : 1761592361,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79791842,
    "question_id" : 79789816,
    "body" : "<p>You can also use a static field to maintain the cached object. Separate methods can be exposed to client to get the cached instance and to get the new instance based on requirement</p>\n<pre><code>\npublic class Sample{\n    private static SampleObject cachedInstance;\n    \n    public static SampleObject getCachedInstance(){\n        return null!=cachedInstance?cachedInstance:new SampleObject();\n    }\n\n    public static SampleObject getNewInstance(){\n        return new SampleObject();\n    {\n}\n\n</code></pre>\n<p>SoftReference can be used for Softcaching by initilizing as below</p>\n<pre><code>\nprivate static SoftReference&lt;SampleObject&gt; instance = new SoftReference&lt;&gt;(null);\n</code></pre>\n",
    "score" : -1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 44319639,
      "reputation" : 32,
      "user_id" : 31692030,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/6e0828ef5d5b73747b3ad3e528290382?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Sathya Priya",
      "link" : "https://stackoverflow.com/users/31692030/sathya-priya"
    },
    "creation_date" : 1760596286,
    "last_activity_date" : 1760596286,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140796603,
    "post_id" : 79789816,
    "body" : "@user207421 that’s not an explanation at all. You are basically saying “X uses Y so Y must be better than Z” while there is no connection between X and Z at all. What <code>WeakHashMap</code> does, has nothing to do with the applicability of a <code>SoftReference</code> for caching data.",
    "score" : 1,
    "owner" : {
      "account_id" : 3211603,
      "reputation" : 300981,
      "user_id" : 2711488,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
      "display_name" : "Holger",
      "link" : "https://stackoverflow.com/users/2711488/holger"
    },
    "creation_date" : 1760518026,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140796091,
    "post_id" : 79789816,
    "body" : "@Holger I suppose I don&#39;t have a hard justification other than <code>WeakReference</code> seems to be the go-to. If I need to keep a <i>non</i>-strong reference to something then I would use a weak reference first, then use a soft reference if and when there&#39;s a demonstrated need. That said, looking into it more, a soft reference <i>might</i> be appropriate for a cache like this (assuming, as pointed out by rzwitserloot, a non-strong reference is even beneficial in the first place).",
    "score" : 0,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49884,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1760490485,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140796084,
    "post_id" : 79789816,
    "body" : "@OP In fact have a good look at <code>WeakHashMap</code>. It already does all you need and more.",
    "score" : 0,
    "owner" : {
      "account_id" : 71739,
      "reputation" : 311869,
      "user_id" : 207421,
      "user_type" : "registered",
      "accept_rate" : 82,
      "profile_image" : "https://www.gravatar.com/avatar/5cfe5f7d64f44be04f147295f5c7b88e?s=256&d=identicon&r=PG",
      "display_name" : "user207421",
      "link" : "https://stackoverflow.com/users/207421/user207421"
    },
    "creation_date" : 1760490153,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140796083,
    "post_id" : 79789816,
    "body" : "@Holger That&#39;s what the JDK does, in <code>WeakHashMap</code>. I don&#39;t see much use for <code>SoftReference</code> outside the JDK itself, or <code>PhantomReference</code> either.",
    "score" : 0,
    "owner" : {
      "account_id" : 71739,
      "reputation" : 311869,
      "user_id" : 207421,
      "user_type" : "registered",
      "accept_rate" : 82,
      "profile_image" : "https://www.gravatar.com/avatar/5cfe5f7d64f44be04f147295f5c7b88e?s=256&d=identicon&r=PG",
      "display_name" : "user207421",
      "link" : "https://stackoverflow.com/users/207421/user207421"
    },
    "creation_date" : 1760490106,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140794707,
    "post_id" : 79789816,
    "body" : "As a trivial example, the JVM doesn&#39;t &#39;unload classes&#39; even though it trivially could and they take up memory too. There&#39;s a good reason for that. Unloading and reloading classes would be absolutely terrible for performance. Just load em once and leave em if you did the work. In essence, <b>unless</b> you have a report from e.g. a profiler that gives you a really strong indication this would help, <b>this is a very bad idea</b>.",
    "score" : 3,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107186,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1760442007,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140794671,
    "post_id" : 79789816,
    "body" : "I&#39;d just write the usual singleton. Initialized on first touch and never forgotten. You&#39;re presumably doing all this rigamarole to improve performance: If the JVM process has no need for this instance for a few hours you want to allow the garbage collector to ditch this instance. But, simply having a reference to an object itself slows things down, the garbage collector needs to do extra work. I bet all of this just complicates matters and <b>adds no benefit in any way</b>. If your server&#39;s environ lacks the memory to have this object loaded permanently + do work.. you need more RAM.",
    "score" : 1,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107186,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1760441024,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140794535,
    "post_id" : 79789816,
    "body" : "@Slaw why would you use a <code>WeakReference</code>?",
    "score" : 1,
    "owner" : {
      "account_id" : 3211603,
      "reputation" : 300981,
      "user_id" : 2711488,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
      "display_name" : "Holger",
      "link" : "https://stackoverflow.com/users/2711488/holger"
    },
    "creation_date" : 1760435615,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140794394,
    "post_id" : 79789816,
    "body" : "You say it&#39;s okay if multiple instances are created, but are you okay with different instances being used simultaneously in some cases? If yes, then I believe <a href=\"https://stackoverflow.com/a/79789947/6395627\">Maurice Perry&#39;s answer</a> will work for you (though I also would instead use a <code>WeakReference</code>). Otherwise, you&#39;ll need to use some form of double-checked locking. Or just acquire a mutex for the entire method (note if you do that then the field no longer needs to be volatile).",
    "score" : 0,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49884,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1760431268,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140794219,
    "post_id" : 79789816,
    "body" : "I would use synchronization and a <code>WeakReference</code>.",
    "score" : 3,
    "owner" : {
      "account_id" : 71739,
      "reputation" : 311869,
      "user_id" : 207421,
      "user_type" : "registered",
      "accept_rate" : 82,
      "profile_image" : "https://www.gravatar.com/avatar/5cfe5f7d64f44be04f147295f5c7b88e?s=256&d=identicon&r=PG",
      "display_name" : "user207421",
      "link" : "https://stackoverflow.com/users/207421/user207421"
    },
    "creation_date" : 1760425535,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79793517" : [ {
      "comment_id" : 140823327,
      "post_id" : 79793517,
      "body" : "Basically, the garbage collector only cares whether <i>the memory</i> of an object is actually needed. But optimized code can “use an instance” without actually using its memory, e.g. by keeping values in CPU registers. This allows garbage collecting an object even if it is still “in use“ from a semantic point of view. It’s the source of <a href=\"https://bugs.openjdk.org/browse/JDK-8191002\" rel=\"nofollow noreferrer\">this bug</a> and <a href=\"https://bugs.openjdk.org/browse/JDK-8145304\" rel=\"nofollow noreferrer\">that bug</a>, for example.",
      "score" : 2,
      "owner" : {
        "account_id" : 3211603,
        "reputation" : 300981,
        "user_id" : 2711488,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
        "display_name" : "Holger",
        "link" : "https://stackoverflow.com/users/2711488/holger"
      },
      "creation_date" : 1761674173,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140821207,
      "post_id" : 79793517,
      "body" : "Thanks. I missed the <code>synchronized</code>. But if the caller is using the instance (i.e., has a strong reference to it), how can it be garbage collected so that a second caller can use a second instance simultaneously? As I understand it, in both my solutions, so long as at least one thread/caller keeps a reference to the instance then no other thread can get a different instance. Or am I misunderstanding your comment?",
      "score" : 0,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49884,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1761592603,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140821077,
      "post_id" : 79793517,
      "body" : "In Maurice&#39;s implementation, the <code>getInstance()</code> method is <code>synchronized</code>, so there is no race at all. And it wins in terms of simplicity. By the way, there’s still the possibility that the returned instance gets garbage collected while being in use, allowing a concurrent caller to get a different instance. Only the callers can protect against that scenario…",
      "score" : 1,
      "owner" : {
        "account_id" : 3211603,
        "reputation" : 300981,
        "user_id" : 2711488,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
        "display_name" : "Holger",
        "link" : "https://stackoverflow.com/users/2711488/holger"
      },
      "creation_date" : 1761587876,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}