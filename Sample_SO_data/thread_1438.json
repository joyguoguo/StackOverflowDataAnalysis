{
  "question" : {
    "question_id" : 79705866,
    "title" : "Improving View.animate() performance on older Android versions",
    "body" : "<p>I'm developing an Android game that animates rectangular views moving horizontally across the screen using <code>View.animate().translationX(...)</code>. The animation is just a plain rectangle moving left over a few seconds, yet it consistently lags on older devices (Samsung S7 and old tablets) and even slightly on newer ones in power-saving mode (Samsung S22 Ultra).</p>\n<p>Stripped-down version:</p>\n<pre><code>View rectangle = ...; // A dynamically added View to a ConstraintLayout\n\nrectangle.animate()\n    .setDuration(6000)\n    .translationX(-widthDisplay)\n    .setInterpolator(new LinearInterpolator())\n    .start();\n</code></pre>\n<p>Iâ€™ve tried the following optimizations, but the lag persists:</p>\n<ul>\n<li>Using <code>View.setLayerType(View.LAYER_TYPE_HARDWARE, null)</code>.</li>\n<li>Reducing the number of simultaneously animated views to just one.</li>\n<li>Avoiding any other heavy processing on the UI thread.</li>\n<li>Using ObjectAnimator instead.</li>\n</ul>\n<p>The issue is not related to the view complexity, number of views, or background tasks. Even animating a single rectangle causes lag on older or throttled devices. Removing <code>setAlpha()</code> or similar calls doesn't help.</p>\n<p>Is there a performance bottleneck with <code>View.animate()</code> (ViewPropertyAnimator) on older or throttled Android devices? And if so, is there a more efficient alternative or workaround for smooth, long-duration translation animations?</p>\n<p>My code for setting up the rectangles and animating them:</p>\n<pre><code>for (int currentElement =0; currentElement &lt;arrayList_GameEventRectangles.size(); currentElement++) {\n\n    //Create view and set\n    if (currentTimeSlot == arrayList_GameEventRectangles.get(currentElement).getStartingTimeSlot() - 15) {\n\n        arrayList_GameEventRectangles.get(currentElement).setActive(true);\n\n        //Set the parameters and the background of the view element\n        arrayList_GameEventRectangles.get(currentElement).setLayoutParams(new ViewGroup.LayoutParams(0, 0));\n\n        if(arrayList_GameEventRectangles.get(currentElement).getEventType().equals(VIEW_EVENT_RECTANGLE_SOLAR)) {\n            arrayList_GameEventRectangles.get(currentElement).setBackground(Objects.requireNonNull(ContextCompat.getDrawable(requireActivity(), R.drawable.game_event_rectangle_solar_1)).mutate());\n        }\n\n        if(arrayList_GameEventRectangles.get(currentElement).getEventType().equals(VIEW_EVENT_RECTANGLE_WIND)) {\n            arrayList_GameEventRectangles.get(currentElement).setBackground(Objects.requireNonNull(ContextCompat.getDrawable(requireActivity(), R.drawable.game_event_rectangle_wind_1)).mutate());\n        }\n\n        if(arrayList_GameEventRectangles.get(currentElement).getEventType().equals(VIEW_EVENT_RECTANGLE_GAS)) {\n            arrayList_GameEventRectangles.get(currentElement).setBackground(Objects.requireNonNull(ContextCompat.getDrawable(requireActivity(), R.drawable.game_event_rectangle_gas_1)).mutate());\n        }\n\n        if(arrayList_GameEventRectangles.get(currentElement).getEventType().equals(VIEW_EVENT_RECTANGLE_COAL)) {\n            arrayList_GameEventRectangles.get(currentElement).setBackground(Objects.requireNonNull(ContextCompat.getDrawable(requireActivity(), R.drawable.game_event_rectangle_coal_1)).mutate());\n        }\n\n        arrayList_GameEventRectangles.get(currentElement).setId(View.generateViewId());\n\n        //Make the view invisible (before it's appearance time)\n        arrayList_GameEventRectangles.get(currentElement).getBackground().setAlpha(0);\n\n        constraintLayout.bringChildToFront(binding.imageViewTargetRectangle);\n        // Set the ConstraintLayout programmatically for the view\n        View view = arrayList_GameEventRectangles.get(currentElement);\n        ViewGroup parent = (ViewGroup) view.getParent();\n\n       // Check if the view already has a parent\n        if (parent != null) {\n            parent.removeView(view); // Remove the view from its existing parent\n        }\n\n        constraintLayout.addView(view); // Now add the view to the constraintLayout\n\n        constraintSet.clone(constraintLayout);\n        float percentageHeightOfEventElement = 0.071f;\n        constraintSet.constrainPercentHeight(arrayList_GameEventRectangles.get(currentElement).getId(), percentageHeightOfEventElement);\n\n        float widthConstrainPercentage_element1 = (float)(arrayList_GameEventRectangles.get(currentElement).getDuration() / 100.0);\n\n        constraintSet.constrainPercentWidth(arrayList_GameEventRectangles.get(currentElement).getId(), widthConstrainPercentage_element1);\n        constraintSet.connect(arrayList_GameEventRectangles.get(currentElement).getId(),ConstraintSet.BOTTOM, ConstraintSet.PARENT_ID,ConstraintSet.BOTTOM,0);\n        constraintSet.connect(arrayList_GameEventRectangles.get(currentElement).getId(),ConstraintSet.TOP,ConstraintSet.PARENT_ID ,ConstraintSet.TOP,0);\n        constraintSet.connect(arrayList_GameEventRectangles.get(currentElement).getId(),ConstraintSet.LEFT,ConstraintSet.PARENT_ID ,ConstraintSet.LEFT,0);\n        constraintSet.connect(arrayList_GameEventRectangles.get(currentElement).getId(),ConstraintSet.RIGHT,ConstraintSet.PARENT_ID ,ConstraintSet.RIGHT,0);\n\n        float horizontalBias = 1.0f ;\n        constraintSet.setHorizontalBias(arrayList_GameEventRectangles.get(currentElement).getId(), horizontalBias);\n        float verticalBiasOfEventElementToBeInTheLine = 0.049f;\n        constraintSet.setVerticalBias(arrayList_GameEventRectangles.get(currentElement).getId(), verticalBiasOfEventElementToBeInTheLine);\n        constraintSet.applyTo(constraintLayout);\n\n    }\n\n    //Shift the view to the right border of the display. This is done before the view is being displayed to the user such that it can flow from right to left in the game\n    if (currentTimeSlot == arrayList_GameEventRectangles.get(currentElement).getStartingTimeSlot() - 10) {\n        arrayList_GameEventRectangles.get(currentElement).setTranslationX(arrayList_GameEventRectangles.get(currentElement).getWidth());\n    }\n\n    //Animate view element\n    if (currentTimeSlot == arrayList_GameEventRectangles.get(currentElement).getStartingTimeSlot()) {\n        arrayList_GameEventRectangles.get(currentElement).getBackground().setAlpha(255);\n\n        View rectangle = arrayList_GameEventRectangles.get(currentElement);\n        int rectangleWidth = rectangle.getWidth();\n\n        float distanceToCover_current = widthDisplay + rectangleWidth;\n        float distanceToCover_normalizedObject = widthDisplay + 20;\n        double ratioDistanceDifference = distanceToCover_current /distanceToCover_normalizedObject;\n\n        int numberOfMillisecondsUntilTheMiddleOfTheScreen_Level1 = 8000;\n        long durationForTheAnimation = (long)(numberOfMillisecondsUntilTheMiddleOfTheScreen_Level1 * speedMultiplicatorLevel [currentLevel - 1] * ratioDistanceDifference);\n\n        arrayList_GameEventRectangles.get(currentElement).animate().setDuration(durationForTheAnimation).translationX(widthDisplay*(-1)).setInterpolator(new LinearInterpolator()).start();\n    }\n\n    helpCounterUpdateScreen++;\n\n    //Check if the view is still running\n    if (arrayList_GameEventRectangles.get(currentElement).isActive() &amp;&amp; currentElement==0) {\n        if (arrayList_GameEventRectangles.get(currentElement).getX() &lt; arrayList_GameEventRectangles.get(currentElement).getWidth() * (-0.8)) {\n            arrayList_GameEventRectangles.get(currentElement).incrementNumberOfTimeSlotsAfterFinishing();\n        }\n        if (arrayList_GameEventRectangles.get(currentElement).getNumberOfTimeSlotsAfterFinishing()&gt; 100) {\n            arrayList_GameEventRectangles.get(currentElement).setActive(false);\n        }\n    }\n}\n</code></pre>\n<p><strong>Reminder</strong>: Does anyone have another idea without SurfaceView?</p>\n",
    "tags" : [ "java", "android", "animation", "android-animation", "viewanimator" ],
    "owner" : {
      "account_id" : 13060317,
      "reputation" : 717,
      "user_id" : 9437740,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/6yvEH.png?s=256",
      "display_name" : "VanessaF",
      "link" : "https://stackoverflow.com/users/9437740/vanessaf"
    },
    "is_answered" : true,
    "view_count" : 279,
    "answer_count" : 1,
    "score" : 3,
    "last_activity_date" : 1754123897,
    "creation_date" : 1752825693,
    "link" : "https://stackoverflow.com/questions/79705866/improving-view-animate-performance-on-older-android-versions",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79711129,
    "question_id" : 79705866,
    "body" : "<p>Using <a href=\"https://developer.android.com/reference/android/view/SurfaceView\" rel=\"nofollow noreferrer\"><strong>SurfaceView</strong></a> with the same logic of rectangles and animating them:</p>\n<p><code>GameSurfaceView</code> class:</p>\n<pre><code>package com.example.surfaceanimationtest;\n\n\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.util.AttributeSet;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\n\nimport androidx.annotation.NonNull;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class GameSurfaceView extends SurfaceView implements SurfaceHolder.Callback {\n\n    private List&lt;MyGameRect&gt; rectangles = new ArrayList&lt;&gt;();\n    private MyDrawThread mMyDrawThread;\n\n    public GameSurfaceView(Context context) {\n        super(context);\n        getHolder().addCallback(this);\n    }\n\n\n    private void init() {\n        getHolder().addCallback(this);\n        int screenWidth = Resources.getSystem().getDisplayMetrics().widthPixels;\n        rectangles = new ArrayList&lt;&gt;();\n        mMyDrawThread = new MyDrawThread(getHolder(), rectangles, screenWidth);\n\n    }\n\n\n    public GameSurfaceView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init();\n    }\n\n\n\n    @Override\n    public void surfaceChanged(@NonNull SurfaceHolder surfaceHolder, int i, int i1, int i2) {\n\n    }\n\n    @Override\n    public void surfaceCreated(@NonNull SurfaceHolder holder) {\n        mMyDrawThread = new MyDrawThread(getHolder(), rectangles, getWidth());\n        mMyDrawThread.start();\n    }\n\n    @Override\n    public void surfaceDestroyed(@NonNull SurfaceHolder holder) {\n        if (mMyDrawThread != null) {\n            mMyDrawThread.stopDrawing();\n        }\n    }\n\n    public void addRectangle() {\n    MyGameRect rect = new MyGameRect();\n    rect.x = getWidth(); // from right\n    rect.y = getHeight() * 0.05f;\n    rect.width = getWidth() * 0.1f;\n    rect.height = getHeight() * 0.07f;\n    rect.startTime = System.currentTimeMillis();\n    rect.duration = 6000; // ms\n\n    synchronized (rectangles) {\n        rectangles.add(rect);\n    }\n}\n\n}\n</code></pre>\n<p><code>MyGameRect</code> class:</p>\n<pre><code>public class MyGameRect {\n    float x, y, width, height;\n    long startTime;\n    long duration;\n\n    boolean isFinished() {\n        return (System.currentTimeMillis() - startTime) &gt; duration;\n    }\n\n    void updatePosition(float screenWidth) {\n        float elapsed = System.currentTimeMillis() - startTime;\n        float progress = Math.min(1f, elapsed / (float) duration);\n        x = screenWidth - progress * (screenWidth + width);\n    }\n}\n</code></pre>\n<p><code>MyDrawThread</code> class:</p>\n<pre><code>public class MyDrawThread extends Thread {\n    private final SurfaceHolder holder;\n    private final List&lt;MyGameRect&gt; rectangles;\n    private final float screenWidth;\n    private boolean running = true;\n\n    public MyDrawThread(SurfaceHolder holder, List&lt;MyGameRect&gt; rectangles, float screenWidth) {\n        this.holder = holder;\n        this.rectangles = rectangles;\n        this.screenWidth = screenWidth;\n    }\n\n    public void stopDrawing() {\n        running = false;\n        interrupt();\n    }\n\n    @Override\n    public void run() {\n        Paint paint = new Paint();\n        paint.setColor(Color.YELLOW);\n\n        while (running) {\n            Canvas canvas = holder.lockCanvas();\n            if (canvas == null) continue;\n\n            canvas.drawColor(Color.BLACK);\n\n            synchronized (rectangles) {\n                Iterator&lt;MyGameRect&gt; iterator = rectangles.iterator();\n                while (iterator.hasNext()) {\n                    MyGameRect rect = iterator.next();\n                    rect.updatePosition(screenWidth);\n\n                    if (rect.isFinished()) {\n                        iterator.remove();\n                        continue;\n                    }\n\n                    canvas.drawRect(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, paint);\n                }\n            }\n\n            holder.unlockCanvasAndPost(canvas);\n\n            try {\n                sleep(16); // about 60 FPS\n            } catch (InterruptedException ignored) {}\n        }\n    }\n}\n</code></pre>\n<p>Setting view in main activity XML or your fragment:</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;\n    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;\n    xmlns:tools=&quot;http://schemas.android.com/tools&quot;\n    android:id=&quot;@+id/main&quot;\n    android:layout_width=&quot;match_parent&quot;\n    android:layout_height=&quot;match_parent&quot;\n    tools:context=&quot;.MainActivity&quot;&gt;\n\n    &lt;com.example.surfaceanimationtest.GameSurfaceView\n        android:id=&quot;@+id/gameSurfaceView&quot;\n        android:layout_width=&quot;0dp&quot;\n        android:layout_height=&quot;0dp&quot;\n        app:layout_constraintTop_toTopOf=&quot;parent&quot;\n        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;\n        app:layout_constraintStart_toStartOf=&quot;parent&quot;\n        app:layout_constraintEnd_toEndOf=&quot;parent&quot; /&gt;\n&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;\n</code></pre>\n<p>MainActivity:</p>\n<pre><code>package com.example.surfaceanimationtest;\n\nimport android.os.Bundle;\nimport android.os.Handler;\n\nimport androidx.activity.EdgeToEdge;\nimport androidx.appcompat.app.AppCompatActivity;\nimport androidx.core.graphics.Insets;\nimport androidx.core.view.ViewCompat;\nimport androidx.core.view.WindowInsetsCompat;\n\npublic class MainActivity extends AppCompatActivity {\n\n    GameSurfaceView gameSurfaceView;\n\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        EdgeToEdge.enable(this);\n        setContentView(R.layout.activity_main);\n        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main), (v, insets) -&gt; {\n            Insets systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars());\n            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom);\n            return insets;\n        });\n\n        gameSurfaceView = findViewById(R.id.gameSurfaceView);\n\n\n        // this will add rectangles every 1.5 seconds\n        new Handler().postDelayed(new Runnable() {\n            @Override\n            public void run() {\n                gameSurfaceView.addRectangle();\n                gameSurfaceView.postDelayed(this, 1500);\n            }\n        }, 1000);\n    }\n}\n</code></pre>\n<p>The result on Google Pixel Emulator 2 is similar to the Samsung Galaxy S7:</p>\n<img src=\"https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExejJ0NzZ3Y2EzMmtvMGc3emlpN3I2bzc2ZDRxYW55bWI2M2V5a2p3ZCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/tqeXmB9DZiJOipfJfa/giphy.gif\">\n<p>Add <code>android:hardwareAccelerated=&quot;true&quot;</code> in AndroidManifest.xml. This enables hardware acceleration which can significantly improve animation performance on supported devices.</p>\n<p>As an alternative to a raw thread consider <a href=\"https://github.com/ReactiveX/RxJava\" rel=\"nofollow noreferrer\">RxJava</a> for thread management and scheduling. It provides a cleaner and more reactive approach to handle frame updates or timed animations, especially UI-related timing operations. It should have better performance on weak devices.</p>\n",
    "score" : 3,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 10358025,
      "reputation" : 2976,
      "user_id" : 7639296,
      "user_type" : "registered",
      "accept_rate" : 75,
      "profile_image" : "https://www.gravatar.com/avatar/725aeaec2a3701c879f5d819f5b6e2fc?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Dr Mido",
      "link" : "https://stackoverflow.com/users/7639296/dr-mido"
    },
    "creation_date" : 1753224434,
    "last_activity_date" : 1753413824,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79711129" : [ {
      "comment_id" : 140615261,
      "post_id" : 79711129,
      "body" : "Thank you for your feedback, btw I tested my solution on my real device (old Xiaomi 2018 smartphone), and its working flawlessly without this problem, anyway I hope you find another solution fitting with your scinario",
      "score" : 2,
      "owner" : {
        "account_id" : 10358025,
        "reputation" : 2976,
        "user_id" : 7639296,
        "user_type" : "registered",
        "accept_rate" : 75,
        "profile_image" : "https://www.gravatar.com/avatar/725aeaec2a3701c879f5d819f5b6e2fc?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Dr Mido",
        "link" : "https://stackoverflow.com/users/7639296/dr-mido"
      },
      "creation_date" : 1753365635,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140614996,
      "post_id" : 79711129,
      "body" : "Just one side remark: Using an emulator to evaluate the performance is not a good option. I also made this mistake. When using an emulator, even one with very limited ressources, the animations don&#39;t lag at all while on a real device they lag strongly. The reason for this is that the emulator finally gets its computational resources from the underlyning hardware. As my computer&#39;s CPU is powerful, even an explicity designed emulator on Android Studio with very low performance parameters let&#39;s the animation flow smoothly. As a matter of fact I also used an emulator of Pixel2_Low_Performance",
      "score" : 1,
      "owner" : {
        "account_id" : 13060317,
        "reputation" : 717,
        "user_id" : 9437740,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/6yvEH.png?s=256",
        "display_name" : "VanessaF",
        "link" : "https://stackoverflow.com/users/9437740/vanessaf"
      },
      "creation_date" : 1753360708,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140614991,
      "post_id" : 79711129,
      "body" : "Thanks Dr for your answer and your tremendous help, which I highly appreciate. As my game logic in the app is storngly based on the views and their position and your suggested approach is way to complex for me to adapt it to my case, I unfortunately can&#39;t use your answer. I am more seeking for an easy solution how to improve the performance of View.animate directly without redesigning my whole code which would require quite some effort. Still I highly appreciate your help.",
      "score" : 2,
      "owner" : {
        "account_id" : 13060317,
        "reputation" : 717,
        "user_id" : 9437740,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/6yvEH.png?s=256",
        "display_name" : "VanessaF",
        "link" : "https://stackoverflow.com/users/9437740/vanessaf"
      },
      "creation_date" : 1753360551,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}