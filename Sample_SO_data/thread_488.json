{
  "question" : {
    "question_id" : 79800240,
    "title" : "Why does Container&#39;s add(panel, Integer) provide a different result than add(panel, int)?",
    "body" : "<p>To provide background and explanation of the question:</p>\n<p>I was working with a base program (below) to figure out how to use <code>JLayeredPane</code>.  I created a JLayeredPane and added it to the JFrame, then moved onto creating and adding the panels to the JLayeredPane.  The GeeksForGeeks <a href=\"https://www.geeksforgeeks.org/java/java-jlayeredpane/\" rel=\"nofollow noreferrer\">example</a> I was going from had a red square on bottom, then an overlapping green square, and finally an overlapping blue square on top.  It <code>add()</code>ed the panels to the JLayeredPane using the constants <code>JLayeredPane.DEFAULT_LAYER</code>, <code>JLayeredPane.PALETTE_LAYER</code>, and <code>JLayeredPane.MODAL_LAYER</code>.  However, as I was planning on perhaps using more control over the layers, I didn't use those, but rather used numbers for the layers.  The bottom layer is 0, with higher numbers indicating higher layers.</p>\n<p>But when I tried running the code, the panels were reversed.  The red was on top, green in middle, and blue on bottom.  The problem was I had the code</p>\n<pre><code>layeredPane.add(panel1, 0);\nlayeredPane.add(panel2, 1);\nlayeredPane.add(panel2, 2);\n</code></pre>\n<p>To rectify the code, I had to use not the primitive <code>int</code> I had before, but rather <code>Integer</code>s (which, it turns out, <code>JLayeredPane.DEFAULT_LAYER</code> etc. are).</p>\n<pre><code>layeredPane.add(panel1, Integer.valueOf(0));\n...\n</code></pre>\n<p>I was curious why it exhibited this behaviour, so I did a little digging.  It turns out that <code>javax.swing.JLayeredPane</code> is a descendant of <code>java.awt.Container</code> (which itself derives from <code>java.lang.Object</code>).  <code>Container</code> (Oracle <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/Container.html\" rel=\"nofollow noreferrer\">JavaDoc</a>, ClassPath <a href=\"https://developer.classpath.org/doc/java/awt/Container-source.html\" rel=\"nofollow noreferrer\">source code</a>) has overloaded <code>add</code> methods (narrowing down to the methods I used):</p>\n<pre><code>public Component add(Component comp, int index) {\n    addImpl(comp, null, index);\n    return comp;\n}\n</code></pre>\n<p>and</p>\n<pre><code>public void add(Component comp, Object constraints) {\n    addImpl(comp, constraints, -1);\n}\n</code></pre>\n<p>My understanding of the problem begins to get a little fuzzy here.  I know they both called the <code>addImpl</code> method, with the <code>int</code> version passing a <code>null</code> constraint with the given index, while the <code>Integer</code> version passed the <code>Integer</code> as the constraint and -1 as the index.  The JavaDoc for <code>addImpl</code> says (partly summarizing for conciseness):</p>\n<blockquote>\n<p>...</p>\n<p>The constraints are defined by the particular layout manager used.  <code>BorderLayout</code> ... <code>GridBagLayout</code> ... <code>LayoutManager2</code> ... if the current layout manager does not implement <code>LayoutManager2</code> and constraints is a <code>String</code>, then <code>LayoutManager...</code> is invoked ...</p>\n<p>If the component is not an ancestor of this container and has a non-null parent, it is removed from its current parent before it is added to this container.</p>\n<p>...</p>\n<p>@param <code>constraints</code> an object expressing layout constraints for this component</p>\n<p>@param <code>index</code> the position in the container's list at which to insert the component, where <code>-1</code> means appended to the end</p>\n<p>...</p>\n<p><code>protected void addImpl(Component comp, Object constraints, int index) {</code></p>\n<p>...</p>\n</blockquote>\n<p>As far as I can tell, <code>JLayeredPane</code> (nor <code>Integer</code>) does not derive from any of those layouts (or from <code>String</code>).  I thus suspect the last standard line of the JavaDoc comes into play.  Beyond that, I have zero idea as to why the <code>Object</code> of a number as the constraints provides different behavior than <code>null</code> constraints and a numbered index.  When passing <code>Integer</code>, it doesnt appear (to me) that -1 index is used as the component's index, but as a routing flag within <code>addImpl</code>.  But the actual mechanics?  I don't understand.</p>\n<p>How is the <code>Integer</code> object functioning to place it in the proper layer, rather than an <code>int</code>?  It doesn't appear the order the components are added matters, just the passed numbers.  Any help/explanations would be appreciated.</p>\n<pre><code>import javax.swing.*;\nimport java.awt.*;\n\npublic class SandboxGuiOne\n{\n    public static void main(String[] args)\n    {\n        // Create JFrame (main window of application)\n        JFrame frame = new JFrame(&quot;JLayeredPane Example&quot;);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.setSize(500, 500);\n\n        // Create JLayeredPane to manage layering of components\n        JLayeredPane layeredPane = new JLayeredPane();\n        frame.add(layeredPane); // add JLayeredPane to JFrame\n\n        // Create three colored panels to add to layered pane\n        JPanel panel1 = createColoredPanel(Color.RED, 100, 100, 200, 200);\n        JPanel panel2 = createColoredPanel(Color.GREEN, 150, 150, 200, 200);\n        JPanel panel3 = createColoredPanel(Color.BLUE, 200, 200, 200, 200);\n\n        // Add panels to layered pane with different layer values.\n        // Layers determine stacking order of the panels.\n        layeredPane.add(panel1, Integer.valueOf(0));\n        layeredPane.add(panel2, Integer.valueOf(1));\n        layeredPane.add(panel3, Integer.valueOf(2));\n\n        frame.setVisible(true);\n    }\n\n    private static JPanel createColoredPanel(Color color, int x, int y, int width, int height)\n    {\n        // Create colored JPanel with specific color and position\n        JPanel panel = new JPanel();\n        panel.setBackground(color);\n        panel.setBounds(x, y, width, height);\n        return panel;\n    }\n}\n</code></pre>\n<p>Layouting when <code>add(Component comp, int index)</code> (primitive int argument) is used:\n<a href=\"https://i.sstatic.net/xavcCqiI.jpg\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/xavcCqiI.jpg\" alt=\"int result\" /></a></p>\n<p>Layouting when <code>add(Component comp, Object constraints)</code> (with <code>Integer</code> objects) is used:\n<a href=\"https://i.sstatic.net/2UYxVTM6.jpg\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/2UYxVTM6.jpg\" alt=\"Integer result\" /></a></p>\n",
    "tags" : [ "java", "swing", "containers", "awt", "jlayeredpane" ],
    "owner" : {
      "account_id" : 19873413,
      "reputation" : 69,
      "user_id" : 14559008,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/eRFKr.jpg?s=256",
      "display_name" : "Eliezer Meth",
      "link" : "https://stackoverflow.com/users/14559008/eliezer-meth"
    },
    "is_answered" : true,
    "view_count" : 168,
    "answer_count" : 2,
    "score" : 3,
    "last_activity_date" : 1761559709,
    "creation_date" : 1761503194,
    "link" : "https://stackoverflow.com/questions/79800240/why-does-containers-addpanel-integer-provide-a-different-result-than-addpan",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79800336,
    "question_id" : 79800240,
    "body" : "<p>You're going to be asking <em>why</em> pretty soon, if not already. Without looking at history there is no answer to this question. The design of this API makes no sense. Unless, history.</p>\n<h2>The history of all this</h2>\n<h3>Part 1: Generics</h3>\n<p>In a distant past, java didn't have generics (the <code>&lt;String&gt;</code> in <code>List&lt;String&gt;</code>). When using lists you'd just write <code>List foo = new ArrayList();</code>. To retrieve objects from it, you'd call <code>foo.get(0)</code> as normal, but, the type of that expression is <code>Object</code>.</p>\n<p>As you can imagine, we did <em>a lot</em> of casting in those days, and <em>many</em> APIs had <code>Object</code> all over the place.</p>\n<p>But nowadays, we don't do that anymore. We have generics.</p>\n<p>Generics do need some sort of thing to hang itself on - a coatrack. In other words, to link the type of <code>list.get(0)</code> and the type of x in <code>list.add(x)</code>, we need <em>something</em> to convey the notion 'the same type for both please'. With <code>List</code>, it's simply <em>the list</em> - it's typed <code>List&lt;T&gt;</code>.</p>\n<p>With swing's API design this is not really possible; not without tying ourselves into crazy knots. The original swing design is as follows:</p>\n<ul>\n<li>A LayoutManager is created and is told 'you are the layout manager for this particular container thingie'.</li>\n<li>All components added to the container have an optional 'constraints' object associated with it. The container has no idea what this is in any way and has zero functionality associated with it (that's convenient; as it has no idea what it is, if it had some functionality associated, that'd be a problem). Instead, the component just hands the constraint object off to the layout manager and assumes <em>it</em> knows what to do with it.</li>\n</ul>\n<p>In such a design you'd want to associate the types same as <code>List</code> does: That any given <code>LayoutManager</code> explains exactly what type of constraint object it understands, and that you are then prevented from associating anything but the right kind of object with a component when adding it to the container.</p>\n<p>But the coat rack is missing. You don't call <code>.add(component, constraint)</code> on the layout manager. You invoke it on the container. The only coat rack we can find is the container itself, but that's a bit bizarre. We'd have to write:</p>\n<pre><code>class javax.swing.JContainer&lt;C extends LayoutConstraint&gt; {\n  public void setLayoutManager(LayoutManager&lt;? super C&gt;) { ... }\n  public void add(Component component, C constraint) { ... }\n}\n</code></pre>\n<p>Which could have been done and might even have been a good idea but it is misleading; we'd normally assume that <em>if</em> containers have a generics type, that, like <code>java.util.List</code>, that's referring to the kinds of things you can put in this container. It's not exactly obvious that it's referring to the kind of layout constraint. So, this choice wasn't made.</p>\n<p>And thus, the type of 'constraint' is <code>java.lang.Object</code> <strong>eventhough</strong> the LayoutManager obviously can't do anything with e.g. <code>new Object()</code>. It has a spec as to what constraint object it can understand. For example, <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/GridBagLayout.html\" rel=\"nofollow noreferrer\">GridBagLayout</a> says that the only constraint object it actually understands is <code>GridBagConstraint</code>.</p>\n<p>Its examples even use a different path to associate constraint with component. Instead of:</p>\n<pre><code>container.add(component, new GridBagConstraint());\n</code></pre>\n<p>They use:</p>\n<pre><code>container.add(component);\ngridBagLayout.setConstraints(component, new GridBagConstraint());\n</code></pre>\n<p>So why does that wonky <code>add</code> method exist?</p>\n<p>It does. It's 30 years old, you'd have to ask the author. It was added. Why is probably lost to the mists of history.</p>\n<p>But given that it exists, <em>removing it</em> is a breaking change. Any java code out there that called it needs to rewrite. Which is not generally how java rolls. OpenJDK doesn't break APIs unless it is impossible to maintain the API, it is fundamentally insecure, or the maintenance burden to keep it is excessive. &quot;It is terribly designed, misleading API that results in hard to read and hard to test code&quot; is <strong>not</strong> sufficient reason to delete functionality.</p>\n<p>Hence, at least, we have an explanation for why it's still around.</p>\n<h3>Part 2: no enums</h3>\n<p>Java didn't have enums either. Any API designed today, if you have a limited set of parameterless 'choices', which describes exactly the constraint that JLayeredPane wants, would be delivered as an enum. You'd have:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public enum JLayeredPane {\n  DEFAULT_LAYER,\n  PALETTE_LAYER,\n}\n</code></pre>\n<p>Though in this case that's debatable; the point of this design is that you can use any integer value as layer. Even then, you'd use some wrapper object to avoid this confusion.</p>\n<p>Because enums didn't exist back then, primitive constants were used instead. They had all sorts of nasty downsides (if you try to <code>System.out.println</code> the <code>DEFAULT_LAYER</code> value you get a useless '0'; if it had been an enum, you'd have gotten <code>DEFAULT_LAYER</code>).</p>\n<h3>Part 3: Autoboxing</h3>\n<p>Less relevant but autoboxing didn't exist either. In today's java, <code>int</code> and <code>Integer</code> are still separate concepts but the compiler will automatically translate one to the other if the code would not be valid if it didn't. But 25 years ago when swing was designed that wasn't true. You had to write it explicitly. Hence, <code>int</code> and <code>Integer</code> were better understood and treated as completely independent concepts, hence having a method where you're meant to call <code>.add(component, SomeIntegerRef)</code> as being different from <code>.add(component, someInt)</code> was slightly less bizarre than it is today.</p>\n<h3>Part 4: ... um ...</h3>\n<p>It's still even with all that in mind pretty bad API design. There are downsides to the whole 'we do not break APIs lightly' thing, which is that a design mistake lasts forever. We still have <code>java.util.Date</code>. It's terrible. Don't ever use that class. It's drivel. But it's still there.</p>\n<p>Also keep in mind that the JVM was <em>way</em> less good at optimising and lots of APIs were designed with the especially now but still to some extent also back in the past <em>misguided</em> notion of making the API harder to use if it feels like it might make things faster. Using a bunch of integers instead of more convoluted layout constraint objects 'felt' faster - way back when, lots of objects was an issue. The benefits of modern garbage collectors that make cheap fast garbage essentially free didn't exist yet.</p>\n<p>With that context:</p>\n<h2>So what's happening here?</h2>\n<ul>\n<li><p>The -1 magic value means: Add at end. For a container with 4 elements, there is no difference whatsoever between <code>.add(component, -1)</code> and <code>.add(component, 4)</code>. It's just convenient - with -1 you can just say 'add at end', whereas if you use the number you have to know how many components have been added so far.</p>\n</li>\n<li><p>The JVM spec has a complicated ordered list of how to figure out which method is 'meant' for any particular method call. Given <code>add(component, x)</code> where <code>x</code> is of type <code>Integer</code> is considered a call to the <code>add(Component, Object)</code> (i.e. constraint is provided, index is not) variant, because that would have been how that code was interpreted way back in the day. Autoboxing or unboxing <strong>does not occur</strong> unless the code would fail to compile if you didn't do it, and <code>Integer</code> is an object, therefore, it's valid and no autounboxing is applied. But similarly, no boxing is applied either - <code>add(component, x)</code> where <code>x</code> is of type <code>int</code> is interpreted as a call to <code>add(component, index)</code> (i.e. constraint is not provided, so implied to be <code>null</code>, index is provided) for the same reason: That was valid before without any boxing being applied so no boxing will be applied.</p>\n</li>\n</ul>\n<h2>The difference between the calls</h2>\n<p>The Container object just has an <strong>ordered</strong> list of the components inside. It has no idea how to lay them out, but the container is the one responsible both for maintaining the bunch of components that it contains as well as the ordering of them. This ordering has no inherent meaning (i.e. 'a is ordered before b' <em>does not</em> require as per spec that 'a is shown behind b' if that ever becomes relevant. 'a is ordered before b' is the only thing it means. Because the container is not responsible for laying things out).</p>\n<p>It's the layout manager that decides how to render those components. Each component has a 'constraint' object associated with it (or <code>null</code>). The layout manager takes the <strong>ordered</strong> list of [component, constraint] pairs and renders it according to its code.</p>\n<p>With <code>.add(component, 0)</code> you're just adding the components (as the index number is the same as 'the end'), with no constraint object. With <code>.add(component, Integer.valueOf(0))</code>, you're adding to the end, but with a constraint object that happens to be an integer. The container just stores this; it's the layout manager that fetches this integer and uses it as it wants.</p>\n<p>For JLayeredPane, that integer is also kinda used as a component ordering thing.</p>\n<h2>Closing notes</h2>\n<p>Swing API is 25 years old, which is its only excuse, because, lordy lord it's terrible. Don't use it unless you absolutely have to. It's essentially obsolete (barely maintained). 99% of all java code out there doesn't have a GUI, or if it is, it's web based: The java app runs as a server and emits HTML which a browser renders into a GUI. If you must write a desktop app, you should use javafx, swt, or some other higher level less terrible API design.</p>\n<p>Note that swing <strong>works</strong>. It's just hard to use and unintuitive. You run into issues like this all the time with it. It's also hard to find help and tutorials because so few people use it.</p>\n",
    "score" : 4,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107186,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1761516460,
    "last_activity_date" : 1761516460,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79801683,
    "question_id" : 79800240,
    "body" : "<p>Your question’s title asks why <code>add(panel, Integer)</code> provides a different result than <code>add(panel, int)</code> but you already noticed yourself that there is no <code>add(panel, Integer)</code> method but rather <code>add(panel, Object)</code>. So there are two entirely different kinds of arguments, a constraints object and an integer position number. You can specify both in one <code>add</code> operation using <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/java/awt/Container.html#add(java.awt.Component,java.lang.Object,int)\" rel=\"nofollow noreferrer\"><code>add(Component,Object,int)</code></a>. All other methods with less parameters are just convenience methods providing defaults for the omitted parameters. They will all end up at the same <code>addImpl</code> method.</p>\n<p>The documentation of <code>Container</code> says, as you cited, “<em>The constraints are defined by the particular layout manager used</em>”. Since <code>JLayeredPane</code> doesn’t name a layout manager, it would delegate the work to, but instead manages the layout itself, it is also responsible for documenting the constraints and <a href=\"https://docs.oracle.com/en/java/javase/11/docs/api/java.desktop/javax/swing/JLayeredPane.html\" rel=\"nofollow noreferrer\">it delivered</a></p>\n<blockquote>\n<p>An Integer object specifies each component's depth in the container, where higher-numbered components sit &quot;on top&quot; of other components.</p>\n</blockquote>\n<p>It also provides predefined constraints, like <code>JLayeredPane.DEFAULT_LAYER</code>, <code>JLayeredPane.PALETTE_LAYER</code>, and <code>JLayeredPane.MODAL_LAYER</code>, as you already noted yourself. If you forget about the fact that the type of those constraint objects happens to be convertible to the type of the position argument, all confusion should disappear.</p>\n<p>The documentation even specifies the interaction between the constraints objects (layers) and the <code>int</code> position:</p>\n<blockquote>\n<p>The position of a component within a layer can also be specified directly. Valid positions range from 0 up to one less than the number of components in that layer. A value of -1 indicates the bottommost position. A value of 0 indicates the topmost position. Unlike layer numbers, higher position values are <em>lower</em> in the display.</p>\n</blockquote>\n<p>This is exactly what you got with your first code snippet. You specified <code>int</code> values which were interpreted as position rather than constraints/layer. Since no constraints object was given, all components ended in the same layer and were ordered according to their position which is the opposite order.</p>\n<hr />\n<p>Before the introduction of auto-boxing, the technical differences between <code>int</code> and <code>Integer</code> led to cases like this where they were used like semantically different types, which can be seen as a historical design mistake. There are worse cases, like <code>java.util.List</code> having a <code>remove(int)</code> and a <code>remove(Object)</code> method with entirely different outcome.</p>\n",
    "score" : 4,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 3211603,
      "reputation" : 300981,
      "user_id" : 2711488,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
      "display_name" : "Holger",
      "link" : "https://stackoverflow.com/users/2711488/holger"
    },
    "creation_date" : 1761559709,
    "last_activity_date" : 1761559709,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140820415,
    "post_id" : 79800240,
    "body" : "short: <code>int index</code> is not the same as <code>Object constraints</code> (used for <code>Integer</code>)",
    "score" : 0,
    "owner" : {
      "account_id" : 31180,
      "reputation" : 29752,
      "user_id" : 85421,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/kKvXH.gif?s=256",
      "display_name" : "user85421",
      "link" : "https://stackoverflow.com/users/85421/user85421"
    },
    "creation_date" : 1761569390,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140818292,
    "post_id" : 79800240,
    "body" : "Regardless of the LayoutManager used, JLayeredPane will only assign a layer to a Component added with an Integer constraint (unless the layer is later specified using <code>setLayer</code> or <code>putLayer</code>).  add(Component, int) does not specify any constraint.",
    "score" : 0,
    "owner" : {
      "account_id" : 2053598,
      "reputation" : 44936,
      "user_id" : 1831987,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/38b1c37530189ec4471a43a618e33f67?s=256&d=identicon&r=PG",
      "display_name" : "VGR",
      "link" : "https://stackoverflow.com/users/1831987/vgr"
    },
    "creation_date" : 1761510951,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}