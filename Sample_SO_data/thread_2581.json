{
  "question" : {
    "question_id" : 79610688,
    "title" : "How can I get my tests to use dynamically generated instances in the JVM when working with Kotlin?",
    "body" : "<p>I'm building a self-repairing web scraper through the use of an LLM.</p>\n<p>My current problem is that after dynamically compiling a new version of the scraper, when calling testScraper for it, it uses the previous version still in memory.</p>\n<p>In my point of view, this doesn't make sense given I am closing the previous ClassLoader, nullifying the instance and calling the GC. Also, in my test scraper i'm using the same CL as the new version to instantiate the tests. Why is it using the old version?</p>\n<p>Is what I'm trying to do possible (safely) or should I just use manual versioning through different class names.</p>\n<p>Heres the code for the &quot;main&quot; component:</p>\n<pre class=\"lang-kotlin prettyprint-override\"><code>package wrapper\n\nimport Configurations\nimport classes.data.Element\nimport classes.llm.LLM\nimport classes.service_model.Modification\nimport compiler.ScraperCompiler\nimport domain.model.classes.data.CompiledScraperResult\nimport domain.model.interfaces.IScraperWrapper\nimport domain.prompts.FEW_SHOT_SCRAPER_UPDATE_MESSAGES\nimport html_fetcher.WebExtractor\nimport interfaces.IScraperData\nimport modification_detection.IModificationDetectionService\nimport okio.Closeable\nimport org.openqa.selenium.*\nimport org.openqa.selenium.NoSuchElementException\nimport persistence.PersistenceService\nimport snapshots.ISnapshotService\nimport java.io.File\nimport java.lang.management.ClassLoadingMXBean\nimport java.lang.management.ManagementFactory\nimport java.lang.reflect.Method\nimport kotlin.reflect.KClass\n\nfun findLastCreatedDirectory(directoryPath: String): File? {\n    val directory = File(directoryPath)\n    if (!directory.exists() || !directory.isDirectory) {\n        throw IllegalArgumentException(&quot;The provided path is not a valid directory&quot;)\n    }\n\n    return directory.listFiles { file -&gt; file.isDirectory }?.maxByOrNull { it.lastModified() }\n}\n\nclass Scraper(\n    private val modificationDetectionService: IModificationDetectionService,\n    private val snapshotService: ISnapshotService,\n    private val webExtractor: WebExtractor,\n    private val persistenceService: PersistenceService,\n    private val driver: WebDriver,\n    private val scraperTestClassName: String,\n    private var backupScraper: CompiledScraperResult?,\n    private var currentScraper: CompiledScraperResult?,\n    private val retries: Int,\n    private val model: LLM\n) : IScraperWrapper, Closeable {\n\n    private fun closeBackup() {\n        backupScraper?.classLoader?.close()\n        backupScraper = null\n        System.gc()\n    }\n\n    private fun closeCurrent() {\n        currentScraper?.classLoader?.close()\n        currentScraper = null\n        System.gc()\n    }\n\n    private suspend fun correctScraper(\n        oldScraper: IScraperData,\n        modifications: List&lt;Modification&lt;Element&gt;&gt;,\n    ): Boolean {\n        return attemptCorrectingScraper(oldScraper, modifications)\n    }\n\n    private suspend fun attemptCorrectingScraper(\n        oldScraper: IScraperData,\n        modifications: List&lt;Modification&lt;Element&gt;&gt;\n    ): Boolean {\n        // Get the fixed script from the LLM\n        val newScript = when (model.modelName) {\n            LLM.Mistral7B.modelName -&gt; modificationDetectionService.modifyScriptChatHistory(\n                oldScraper.code,\n                modifications,\n                LLM.Mistral7B.modelName,\n                FEW_SHOT_SCRAPER_UPDATE_MESSAGES\n            )\n\n            LLM.CodeLlama7B.modelName -&gt; modificationDetectionService.modifyScriptChatHistory(\n                oldScraper.code,\n                modifications,\n                LLM.CodeLlama7B.modelName,\n                FEW_SHOT_SCRAPER_UPDATE_MESSAGES\n            )\n\n            LLM.DeepSeekCoder1Point3B.modelName -&gt; modificationDetectionService.modifyScriptChatHistory(\n                oldScraper.code,\n                modifications,\n                LLM.DeepSeekCoder1Point3B.modelName,\n                FEW_SHOT_SCRAPER_UPDATE_MESSAGES\n            )\n\n            LLM.Gemma3_1B.modelName -&gt; modificationDetectionService.modifyScriptChatHistory(\n                oldScraper.code,\n                modifications,\n                LLM.Gemma3_1B.modelName,\n                FEW_SHOT_SCRAPER_UPDATE_MESSAGES\n            )\n\n            else -&gt; throw Exception(&quot;Unrecognized model name.&quot;)\n        }\n\n        // Overwrite scraper's source code\n        persistenceService.write(Configurations.scrapersBaseDir + &quot;${oldScraper.name}.kt&quot;, newScript)\n\n        // First close the current classloader to avoid any leaks\n        closeCurrent()\n\n        // Make sure we wait for any lingering references to be cleaned up\n        System.gc()\n        Thread.sleep(100) // Small pause to allow GC to work\n\n        val newScraperResult =\n            ScraperCompiler.attemptToCompileAndInstantiate(Configurations.scrapersBaseDir + &quot;${oldScraper.name}.kt&quot;, driver, snapshotService)\n\n        if (newScraperResult == null) {\n            println(&quot;Compilation of the new scraper failed&quot;)\n            val oldScript = persistenceService.read(Configurations.versioningBaseDir + &quot;${oldScraper.name}.kt&quot;)\n            persistenceService.write(Configurations.scrapersBaseDir + &quot;${oldScraper.name}.kt&quot;, oldScript)\n\n            return false\n        }\n\n        // currentScraper is now the newly compiled one\n        currentScraper = newScraperResult\n\n        backupScraper = currentScraper\n\n        val currentScraperValue = currentScraper ?: throw IllegalStateException(&quot;Current scraper is null.&quot;)\n\n        val success = testScraper(currentScraperValue)\n        if (!success) {\n            // Revert currentScraper to the backup scraper\n            closeCurrent()\n            currentScraper = backupScraper\n            println(&quot;Scraper tests failed.&quot;)\n            return false\n        }\n\n        // Close the backup CL and attempt to eliminate it from memory\n        closeBackup()\n\n        // Save the current scraper as the new backup\n        backupScraper = currentScraper\n\n        println(&quot;Scraper tests were successful!&quot;)\n        return true\n    }\n\n    /**\n     * Runs the given scraper.\n     *\n     * @param snapshotsPath The path to the snapshots' directory.\n     */\n    private suspend fun runScraper(snapshotsPath: String): Boolean {\n        try {\n            currentScraper?.scraper?.scrape()\n            return true\n        } catch (e: Exception) {\n\n            val lastCreated = findLastCreatedDirectory(snapshotsPath)\n                ?: throw IllegalStateException(&quot;Could not find step directory.&quot;)\n            val stepName = lastCreated.name\n\n            val exceptionsToCheck = listOf(\n                NoSuchElementException::class,\n                StaleElementReferenceException::class,\n                ElementNotInteractableException::class,\n                TimeoutException::class\n            )\n\n            for (exception in exceptionsToCheck) {\n                if (exception.isInstance(e)) {\n                    println(&quot;Caught exception: ${e::class.simpleName}&quot;)\n                    val currentScraperValue = currentScraper ?: throw IllegalStateException(&quot;Current scraper is null&quot;)\n                    val modifications = getModifications(currentScraperValue.scraper.getScraperData(), stepName)\n                    val wasSuccessful = correctScraper(currentScraperValue.scraper.getScraperData(), modifications)\n\n                    if (!wasSuccessful) {\n                        println(&quot;Scraper correction failed.&quot;)\n                    }\n\n                    return wasSuccessful\n                }\n            }\n\n            throw e\n        }\n    }\n\n    /**\n     * Tests the given CompiledScraperResult.\n     * This updated method takes the CompiledScraperResult directly rather than just the IScraper instance\n     * to ensure we're using the correct classloader for both the test class and scraper.\n     *\n     * @param compiledResult The compiled scraper result containing both the scraper and its classloader\n     */\n    private fun testScraper(compiledResult: CompiledScraperResult): Boolean {\n        println(&quot;Testing scraper with proper classloader...&quot;)\n\n        // Use the same classloader for both test class and scraper interface\n        val classLoader = compiledResult.classLoader\n        val scraper = compiledResult.scraper\n\n        // Load test class from the same classloader as the scraper\n        val testClass = requireNotNull(classLoader.loadClass(scraperTestClassName)) {\n            &quot;Failed to load test class $scraperTestClassName&quot;\n        }\n\n        // Load IScraper interface from the same classloader\n        val scraperInterface = requireNotNull(classLoader.loadClass(&quot;interfaces.IScraper&quot;)) {\n            &quot;Failed to load IScraper interface from same classloader&quot;\n        }\n\n        // Verify that the scraper is indeed an instance of the correct IScraper interface\n        if (!scraperInterface.isInstance(scraper)) {\n            println(&quot;WARNING: Scraper is not an instance of the expected IScraper interface!&quot;)\n            println(&quot;Scraper class: ${scraper.javaClass.name}&quot;)\n            println(&quot;Expected interface: ${scraperInterface.name}&quot;)\n            println(&quot;Scraper's classloader: ${scraper.javaClass.classLoader}&quot;)\n            println(&quot;Interface's classloader: ${scraperInterface.classLoader}&quot;)\n            return false\n        }\n\n        // Create the test instance with the correct scraper\n        val testInstance = testClass.getDeclaredConstructor(scraperInterface).newInstance(scraper)\n\n        // Run setup methods\n        getSetUpMethods(testClass).forEach { it.invoke(testInstance) }\n\n        val testMethods = testClass.methods.filter {\n            it.isAnnotationPresent(org.junit.jupiter.api.Test::class.java)\n        }\n\n        var failedTests = 0\n\n        for (method in testMethods) {\n            try {\n                println(&quot;Running test: ${method.name}&quot;)\n                method.invoke(testInstance)\n            } catch (e: Exception) {\n                failedTests++\n                println(&quot;Test failed: ${method.name}&quot;)\n                println(e.cause?.message?.substringBefore(&quot;Build info:&quot;))\n            }\n        }\n\n        getTearDownMethods(testClass)\n            .forEach { it.invoke(testInstance) }\n\n        return failedTests == 0\n    }\n\n    private fun getSetUpMethods(clazz: Class&lt;*&gt;): List&lt;Method&gt; =\n        clazz.methods.filter { it.isAnnotationPresent(org.junit.jupiter.api.BeforeAll::class.java) }\n\n    private fun getTearDownMethods(clazz: Class&lt;*&gt;): List&lt;Method&gt; =\n        clazz.methods.filter { it.isAnnotationPresent(org.junit.jupiter.api.AfterAll::class.java) }\n\n\n    private suspend fun getModifications(oldScraper: IScraperData, stepName: String): List&lt;Modification&lt;Element&gt;&gt; {\n        val latestSnapshot =\n            snapshotService.getSnapshot(Configurations.snapshotBaseDir + &quot;${oldScraper.name}/latest/$stepName/html/source.html&quot;)\n        val latestStableSnapshot =\n            snapshotService.getSnapshot(Configurations.snapshotBaseDir + &quot;${oldScraper.name}/latest_stable/$stepName/html/source.html&quot;)\n        val latestSnapshotHtml = latestSnapshot.html.readText()\n        val latestStableSnapshotHtml = latestStableSnapshot.html.readText()\n\n        val previousElements = webExtractor.getRelevantHTMLElements(latestStableSnapshotHtml)\n        val newElements = webExtractor.getRelevantHTMLElements(latestSnapshotHtml)\n        val modifiedElements = modificationDetectionService.getMissingElements(previousElements, newElements)\n\n        return modifiedElements.map { modificationDetectionService.getModification(it, newElements) }\n    }\n\n    override fun close() {\n        closeCurrent()\n        closeBackup()\n        System.gc()\n    }\n\n    override suspend fun scrape(): Boolean {\n        var attempts = 0\n        var success = false\n\n        while (!success &amp;&amp; attempts &lt; retries) {\n            val currentScraperValue = currentScraper ?: throw IllegalStateException(&quot;Current scraper is null&quot;)\n            success = runScraper(Configurations.snapshotBaseDir + currentScraperValue.scraper::class.simpleName + &quot;/latest&quot;)\n            if (!success) {\n                println(&quot;Retry #${attempts + 1} failed.&quot;)\n            }\n            attempts++\n        }\n\n        if (!success) {\n            println(&quot;Max retries reached.&quot;)\n        }\n\n        return success\n    }\n}\n</code></pre>\n<p>Here's the code for compilation:</p>\n<pre class=\"lang-kotlin prettyprint-override\"><code>package compiler\n\nimport Configurations\nimport domain.model.classes.data.CompiledScraperResult\nimport interfaces.IScraper\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\nimport org.openqa.selenium.WebDriver\nimport snapshots.ISnapshotService\nimport java.io.File\nimport java.net.URLClassLoader\nimport java.nio.file.Files\nimport java.nio.file.Paths\nimport java.util.*\n\nobject ScraperCompiler {\n    suspend fun attemptToCompileAndInstantiate(scraperCodePath: String, driver: WebDriver, snapshotService: ISnapshotService): CompiledScraperResult? =\n        withContext(Dispatchers.IO) {\n            try {\n                val originalFile = File(scraperCodePath)\n\n                // Clear the versioning folder\n                val versioningBaseDir = Paths.get(Configurations.versioningBaseDir)\n                if (Files.exists(versioningBaseDir)) {\n                    Files.walk(versioningBaseDir)\n                        .sorted(Comparator.reverseOrder())\n                        .map { it.toFile() }\n                        .forEach { it.delete() }\n                }\n\n                // Create a new versioning folder\n                val tempFolder = File(&quot;${Configurations.versioningBaseDir}/compiled_${System.currentTimeMillis()}&quot;)\n                tempFolder.mkdirs()\n\n                // Copy the Kotlin file to the versioning folder\n                val tempKtFile = File(tempFolder, originalFile.name)\n                originalFile.copyTo(tempKtFile)\n\n                // Compile to the versioning folder\n                val classpath = System.getProperty(&quot;java.class.path&quot;)\n                val process = ProcessBuilder(&quot;kotlinc&quot;, tempKtFile.path, &quot;-d&quot;, tempFolder.path, &quot;-classpath&quot;, classpath)\n                    .redirectErrorStream(true)\n                    .start()\n\n                val compilerOutput = process.inputStream.bufferedReader().readText()\n                println(&quot;Compiler output:\\n$compilerOutput&quot;)\n\n                val exitCode = process.waitFor()\n                if (exitCode != 0) {\n                    println(&quot;Compilation failed for ${tempKtFile.name}&quot;)\n                    return@withContext null\n                }\n\n                val newClassLoader =\n                    URLClassLoader.newInstance(arrayOf(tempFolder.toURI().toURL()), this::class.java.classLoader)\n                val className = tempKtFile.nameWithoutExtension.replaceFirstChar {\n                    if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString()\n                }\n                val clazz = newClassLoader.loadClass(&quot;scrapers.$className&quot;)\n\n                return@withContext CompiledScraperResult(\n                    clazz.getDeclaredConstructor(WebDriver::class.java, ISnapshotService::class.java)\n                        .newInstance(driver, snapshotService) as IScraper,\n                    newClassLoader\n                )\n\n            } catch (e: Exception) {\n                e.printStackTrace()\n                return@withContext null\n            }\n        }\n}\n</code></pre>\n<p>Here's the code for the builder:</p>\n<pre class=\"lang-kotlin prettyprint-override\"><code>package library.builder\n\nimport classes.llm.LLM\nimport compiler.ScraperCompiler\nimport html_fetcher.WebExtractor\nimport modification_detection.IModificationDetectionService\nimport org.openqa.selenium.WebDriver\nimport persistence.PersistenceService\nimport snapshots.ISnapshotService\nimport wrapper.Scraper\n\nclass ScraperBuilder {\n\n    private var modificationDetectionService: IModificationDetectionService? = null\n    private var snapshotService: ISnapshotService? = null\n    private var webExtractor: WebExtractor? = null\n    private var persistenceService: PersistenceService? = null\n    private var driver: WebDriver? = null\n    private var scraperTestClassName: String? = null\n    private var retries: Int = 3\n    private var model: LLM = LLM.Mistral7B\n\n    fun withModificationDetectionService(service: IModificationDetectionService) = apply {\n        this.modificationDetectionService = service\n    }\n\n    fun withSnapshotService(service: ISnapshotService) = apply {\n        this.snapshotService = service\n    }\n\n    fun withWebExtractor(extractor: WebExtractor) = apply {\n        this.webExtractor = extractor\n    }\n\n    fun withPersistenceService(service: PersistenceService) = apply {\n        this.persistenceService = service\n    }\n\n    fun withWebDriver(driver: WebDriver) = apply {\n        this.driver = driver\n    }\n\n    fun withScraperTestClassName(className: String) = apply {\n        this.scraperTestClassName = className\n    }\n\n    fun withRetries(retries: Int) = apply {\n        this.retries = retries\n    }\n\n    fun withModel(model: LLM) = apply {\n        this.model = model\n    }\n\n    suspend fun build(driver: WebDriver, scraperPath: String): Scraper {\n\n        val compiled = ScraperCompiler.attemptToCompileAndInstantiate(\n            driver = driver,\n            snapshotService = snapshotService ?: error(&quot;snapshotService not set&quot;),\n            scraperCodePath = scraperPath\n        ) ?: error(&quot;Initial scraper compilation failed.&quot;)\n\n        return Scraper(\n            modificationDetectionService = modificationDetectionService ?: error(&quot;modificationDetectionService not set&quot;),\n            snapshotService = snapshotService!!,\n            webExtractor = webExtractor ?: error(&quot;webExtractor not set&quot;),\n            persistenceService = persistenceService ?: error(&quot;persistenceService not set&quot;),\n            driver = driver,\n            scraperTestClassName = scraperTestClassName ?: error(&quot;scraperTestClassName not set&quot;),\n            backupScraper = null,\n            currentScraper = compiled,\n            retries = retries,\n            model = model\n        )\n    }\n\n}\n</code></pre>\n<p>Here's the entry point:</p>\n<pre class=\"lang-kotlin prettyprint-override\"><code>import classes.llm.LLM\nimport com.cardoso.common.buildChromeDriver\nimport domain.prompts.FEW_SHOT_GET_MODIFICATION_PROMPT\nimport html_fetcher.WebExtractor\nimport kotlinx.coroutines.runBlocking\nimport library.builder.ScraperBuilder\nimport modification_detection.ModificationDetectionService\nimport okhttp3.OkHttpClient\nimport ollama.OllamaClient\nimport persistence.implementations.FilePersistenceService\nimport snapshots.SnapshotService\nimport java.util.concurrent.TimeUnit\n\nfun main() {\n    runBlocking {\n        val driver = buildChromeDriver()\n        val snapshotService = SnapshotService()\n        val persistenceService = FilePersistenceService()\n        val webExtractor = WebExtractor()\n        val httpClient = OkHttpClient.Builder()\n            .connectTimeout(120, TimeUnit.SECONDS)\n            .readTimeout(120, TimeUnit.SECONDS)\n            .writeTimeout(120, TimeUnit.SECONDS)\n            .build()\n        val llmClient = OllamaClient(httpClient)\n        val modificationDetectionService = ModificationDetectionService(llmClient, LLM.Gemma3_4B.modelName, FEW_SHOT_GET_MODIFICATION_PROMPT)\n\n\n        val scraper = ScraperBuilder()\n            .withModel(LLM.CodeLlama7B)\n            .withRetries(3)\n            .withSnapshotService(snapshotService)\n            .withWebDriver(driver)\n            .withPersistenceService(persistenceService)\n            .withWebExtractor(webExtractor)\n            .withScraperTestClassName(&quot;scrapers.DemoScraperTest&quot;)\n            .withModificationDetectionService(modificationDetectionService)\n            .build(\n                driver,\n                scraperPath = Configurations.scrapersBaseDir + &quot;DemoScraper.kt&quot;\n            )\n\n        try {\n            scraper.scrape()\n        } catch (e: Exception) {\n            println(&quot;Error during scraping: ${e.message}&quot;)\n            e.printStackTrace()\n        } finally {\n            scraper.close()\n        }\n    }\n}\n</code></pre>\n",
    "tags" : [ "java", "kotlin", "jvm", "classloader", "urlclassloader" ],
    "owner" : {
      "account_id" : 30032806,
      "reputation" : 1,
      "user_id" : 23015512,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/52907e967822b22ce7913e235830c75f?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Jo&#227;o Cardoso",
      "link" : "https://stackoverflow.com/users/23015512/jo%c3%a3o-cardoso"
    },
    "is_answered" : false,
    "view_count" : 49,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1746632204,
    "creation_date" : 1746625651,
    "link" : "https://stackoverflow.com/questions/79610688/how-can-i-get-my-tests-to-use-dynamically-generated-instances-in-the-jvm-when-wo",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140409532,
    "post_id" : 79610688,
    "body" : "To help you identify the fault, and to help anyone who might like to help, reduce the size of the code you post to a Small Reproducible Case.  Surely much of the code referenced (the LLM, the use of OkHttpClient) are all irrelevant.  Make a <i>much</i> smaller case of a piece of Kotlin that prints a different value to the console... compile that, destroy the classloader, re-instantiate, repeat, etc.",
    "score" : 0,
    "owner" : {
      "account_id" : 2073393,
      "reputation" : 3675,
      "user_id" : 1847378,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/e8990d3c34829910b2318ed16b09544d?s=256&d=identicon&r=PG",
      "display_name" : "AndrewL",
      "link" : "https://stackoverflow.com/users/1847378/andrewl"
    },
    "creation_date" : 1746751985,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140404763,
    "post_id" : 79610688,
    "body" : "@TevinS Thanks for the heads up, I completely forgot.",
    "score" : 0,
    "owner" : {
      "account_id" : 30032806,
      "reputation" : 1,
      "user_id" : 23015512,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/52907e967822b22ce7913e235830c75f?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Jo&#227;o Cardoso",
      "link" : "https://stackoverflow.com/users/23015512/jo%c3%a3o-cardoso"
    },
    "creation_date" : 1746632244,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}