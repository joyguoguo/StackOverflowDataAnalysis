{
  "question" : {
    "question_id" : 79716434,
    "title" : "How to pass an object into a method that accepts a generic type",
    "body" : "<p>I have a class where listeners can listen for certain events.</p>\n<p>To make it easier to call, this method is statically bound to the generic parameter T:</p>\n<pre><code>static public &lt;T&gt; void addListener(final Class&lt;T&gt; pTriggerOnClass, final JcIEventListener&lt;T&gt; pListener) {\n</code></pre>\n<p>so I can call</p>\n<pre><code>JcUEventQueue.addListener(String.class, e -&gt; System.out.println(&quot;GOT INCOMING EVENT: &quot; + e));\n</code></pre>\n<p>and have <code>e</code> as type that I'm expecting back (in this case e is of Class <code>String</code>). [ as opposed to receiving an <code>Object</code> when not using type bounding ].</p>\n<h2>Problem</h2>\n<ul>\n<li>I do NOT want to create a new <code>JcUEventQueue</code> for every possible type, (I want to keep using one the one central static Class)</li>\n<li>I still want to accept <strong>ANY</strong> reference type</li>\n</ul>\n<p>so inside <code>JcUEventQueue</code> I work with Object as type.</p>\n<p>When an event occurs, I have to notify the according listeners.</p>\n<pre><code>listener.receiveInternalMessage(pMessage);\n</code></pre>\n<p>But Java will not accept this, because the types are incompatible. <code>pMessage</code> is of another type than required by the method <code>receiveInternalMessage</code>. This is obvious, because of the follwing:</p>\n<p>Now, internally, <code>pMessage</code> is an Object:</p>\n<pre><code>static private ArrayList&lt;Throwable&gt; notifyListeners(final Class&lt;?&gt; pClazz, final Object pMessage) {\n</code></pre>\n<p>And even if I defined the event-raising with static type parameter <code>T pMessage</code>:</p>\n<pre><code>static private &lt;T&gt; ArrayList&lt;Throwable&gt; notifyListeners(final Class&lt;?&gt; pClazz, final T pMessage) {\n</code></pre>\n<p>the T passed into the method would not match the T that the called method <code>receiveInternalMessage</code> would accept (different definition sources).</p>\n<p>I also cannot cast the variable <code>pMessage</code> into anything useful in order to call\nlistener.receiveInternalMessage(pMessage);</p>\n<h2>Possible Solution</h2>\n<p>So far, I have only found <strong>Reflection</strong> as a workable tool for this problem:</p>\n<pre><code>final String methodName = &quot;receiveInternalMessage&quot;;\nsListenerMethod = JcIEventListener.class.getDeclaredMethod(methodName, Object.class);\nsListenerMethod.invoke(listener, pMessage); // use reflection to we can force an object into a T\n</code></pre>\n<h2>Question</h2>\n<p>Do you guys know of any other possible solutions to this problem, without creating and managing listst for each possible type?</p>\n<p>Here's my full source code:</p>\n<pre><code>public interface JcIEventListener&lt;T&gt; {\n    void receiveInternalMessage(final T pMessage);\n}\n</code></pre>\n<p>and</p>\n<pre><code>package jc.lib.observer.events;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport jc.lib.gui.window.dialog.JcUDialog;\n\npublic class JcUEventQueue {\n\n\n\n    static private final ConcurrentHashMap&lt;Class&lt;?&gt;, List&lt;JcIEventListener&lt;?&gt;&gt;&gt; sClass2Listeners = new ConcurrentHashMap&lt;&gt;();\n\n    static private Method sListenerMethod;\n\n    static {\n        final String methodName = &quot;receiveInternalMessage&quot;;\n        try {\n            sListenerMethod = JcIEventListener.class.getDeclaredMethod(methodName, Object.class);\n        } catch (NoSuchMethodException | SecurityException e) {\n            System.err.println(&quot;Critical shutdown while initializing &quot; + JcUEventQueue.class.getCanonicalName() + &quot;: Method not found: &quot; + methodName);\n            JcUDialog.showError(e);\n            System.exit(1);\n        }\n    }\n\n\n\n    static public &lt;T&gt; void addListener(final Class&lt;T&gt; pTriggerOnClass, final JcIEventListener&lt;T&gt; pListener) {\n        if (pTriggerOnClass == null) throw new IllegalArgumentException(&quot;Triggering Class cannot be null!&quot;);\n        if (pListener == null) throw new IllegalArgumentException(&quot;Listener cannot be null!&quot;);\n\n        // T gets lost here\n        final List&lt;JcIEventListener&lt;?&gt;&gt; list = sClass2Listeners.computeIfAbsent(pTriggerOnClass, p -&gt; Collections.synchronizedList(new ArrayList&lt;&gt;()));\n        if (!list.contains(pListener)) list.add(pListener);\n    }\n\n    static public &lt;T&gt; void submitMessage(final T pMessage) {\n        Class&lt;?&gt; clazz = pMessage.getClass();\n        while (true) { // trigger on class and all of its super-classes\n            // I removed the code to also cover all interfaces, as this would bloat this question up\n            notifyListeners(clazz, pMessage);\n            clazz = clazz.getSuperclass();\n            if (clazz == null) break;\n        }\n    }\n\n    static private &lt;T&gt; ArrayList&lt;Throwable&gt; notifyListeners(final Class&lt;?&gt; pClazz, final T pMessage) {\n        if (pClazz == null) return null;\n        // if (pMessage == null) return null; // explicitly allow sending of null message Objects\n\n        final List&lt;JcIEventListener&lt;?&gt;&gt; listeners = sClass2Listeners.get(pClazz);\n        if (listeners == null || listeners.size() &lt; 1) return null;\n\n        ArrayList&lt;Throwable&gt; errors = null;\n        for (final JcIEventListener&lt;?&gt; listener : listeners) {\n            try {\n\n                // Problem:\n                // listener.receiveInternalMessage(pMessage); // cannot cast Object into T; Do not have T here, as it's registered\n\n                // Solution:\n                sListenerMethod.invoke(listener, pMessage); // use reflection to we can force an object into a T\n                // The conversion Object -&gt; T is type-safe, due to the inner workings of this class: only\n                // See static initializer above for getting mListenerMethod\n\n            } catch (final Throwable e) {\n                if (errors == null) errors = new ArrayList&lt;&gt;();\n                errors.add(e);\n            }\n        }\n        return errors;\n    }\n\n\n\n}\n</code></pre>\n<p>and its use</p>\n<pre><code>package jc.lib.observer.events;\n\npublic class JcUEventQueue_Test {\n\n    public static void main(final String... args) {\n\n        /*\n         * the contract of method signature\n         *  - static public &lt;T&gt; void addListener(final Class&lt;T&gt; pTriggerOnClass, final JcEventListener&lt;T&gt; pListener) { ... }\n         * is advantageous, because the 'e' parameter in the lambdas is already typed-bound to the Class&lt;T&gt; (first argument), and not just an Object\n         */\n\n        JcUEventQueue.addListener(String.class, e -&gt; System.out.println(&quot;GOT INCOMING EVENT: &quot; + e));\n        JcUEventQueue.addListener(CharSequence.class, e -&gt; System.out.println(&quot;GOT INCOMING EVENT on CS: &quot; + e));\n        JcUEventQueue.addListener(Object.class, e -&gt; System.out.println(&quot;GOT INCOMING EVENT on Object: &quot; + e));\n        JcUEventQueue.submitMessage(&quot;Peter&quot;);\n\n        /*\n         * Will show only\n         *\n         * GOT INCOMING EVENT: Peter\n         * GOT INCOMING EVENT on Object: Peter\n         *\n         * because we left out the interface casts+calls for brevity\n         */\n    }\n\n}\n</code></pre>\n",
    "tags" : [ "java", "generics", "casting", "type-erasure" ],
    "owner" : {
      "account_id" : 2182934,
      "reputation" : 2660,
      "user_id" : 1932011,
      "user_type" : "registered",
      "accept_rate" : 71,
      "profile_image" : "https://www.gravatar.com/avatar/612163480a1ccb4785fd647a003eefbb?s=256&d=identicon&r=PG",
      "display_name" : "JayC667",
      "link" : "https://stackoverflow.com/users/1932011/jayc667"
    },
    "is_answered" : true,
    "view_count" : 143,
    "answer_count" : 1,
    "score" : 3,
    "last_activity_date" : 1753625320,
    "creation_date" : 1753623038,
    "link" : "https://stackoverflow.com/questions/79716434/how-to-pass-an-object-into-a-method-that-accepts-a-generic-type",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79716456,
    "question_id" : 79716434,
    "body" : "<p>You can cast the listener to the appropriate type and call the method directly inside <code>notifyListeners</code>. Just replace reflection invoke:</p>\n<pre><code>// sListenerMethod.invoke(listener, pMessage);force an object into a T\nJcIEventListener&lt;T&gt; l2 = (JcIEventListener&lt;T&gt;)listener;\nl2.receiveInternalMessage(pMessage);\n</code></pre>\n",
    "score" : 3,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 5998820,
      "reputation" : 16283,
      "user_id" : 4712734,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f6e922a2cb7e2da59286f27b162aaca5?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "DuncG",
      "link" : "https://stackoverflow.com/users/4712734/duncg"
    },
    "creation_date" : 1753625202,
    "last_activity_date" : 1753625202,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140624257,
    "post_id" : 79716434,
    "body" : "Thanx! Forgot. Fixed both problems with a <code>synchronized (list) {</code> block in the real code.",
    "score" : 1,
    "owner" : {
      "account_id" : 2182934,
      "reputation" : 2660,
      "user_id" : 1932011,
      "user_type" : "registered",
      "accept_rate" : 71,
      "profile_image" : "https://www.gravatar.com/avatar/612163480a1ccb4785fd647a003eefbb?s=256&d=identicon&r=PG",
      "display_name" : "JayC667",
      "link" : "https://stackoverflow.com/users/1932011/jayc667"
    },
    "creation_date" : 1753716930,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140623498,
    "post_id" : 79716434,
    "body" : "Side note: your code is not thread safe. <code>if (!list.contains(pListener)) list.add(pListener);</code> matches the check-then-act antipattern. Between the <code>contains</code> check and the subsequent <code>add</code>, another thread could add a listener. Further, your <code>notifyListeners</code> method is iterating over the list and <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/Collections.html#synchronizedList(java.util.List)\" rel=\"nofollow noreferrer\">the documentation</a> clearly says you must use an explicit <code>synchronized</code> block.",
    "score" : 1,
    "owner" : {
      "account_id" : 3211603,
      "reputation" : 300981,
      "user_id" : 2711488,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
      "display_name" : "Holger",
      "link" : "https://stackoverflow.com/users/2711488/holger"
    },
    "creation_date" : 1753699592,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79716456" : [ {
      "comment_id" : 140621761,
      "post_id" : 79716456,
      "body" : "Correct. The compiler will give an unchecked cast warning, but that because the listener is guaranteed to accept <code>pMessage</code> as argument due to the type-based lookup, it can safely be suppressed by annotating <code>l2</code> with <code>@SuppressWarnings(&quot;unchecked&quot;)</code>.",
      "score" : 4,
      "owner" : {
        "account_id" : 1211967,
        "reputation" : 9964,
        "user_id" : 1180351,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
        "display_name" : "Rob Spoor",
        "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
      },
      "creation_date" : 1753625478,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}