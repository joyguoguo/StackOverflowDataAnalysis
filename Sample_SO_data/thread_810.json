{
  "question" : {
    "question_id" : 79770036,
    "title" : "RxJava Maybe.doFinally() executing much later than doOnSuccess() in high-throughput multithreaded environment",
    "body" : "<p>I'm experiencing a confusing timing issue with RxJava's Maybe operators in a high-throughput service (40 TPS) with concurrent execution. I have two classes that log execution times, but they're showing very different timings for what should be the same operation.</p>\n<p><strong>The Problem</strong></p>\n<p><code>Class A (the actual implementation):</code></p>\n<pre><code>public Maybe&lt;Decision&gt; execute(Input input) {\n    long start = System.nanoTime();\n    \n    return Maybe.fromCallable(() -&gt; {\n        // Some processing that takes ~500ms\n        return callExternalService();\n    })\n    .doOnSuccess(decision -&gt; {\n        log.info(&quot;Implementation took {} ms&quot;, \n                 ((System.nanoTime() - start) / 1000000)); // Logs ~500ms\n    });\n}\n\n</code></pre>\n<p><code>Class B (a decorator that wraps Class A):</code></p>\n<pre><code>public Maybe&lt;Decision&gt; execute(Input input) {\n    return Maybe.defer(() -&gt; {\n        long startTime = System.nanoTime();\n        \n        return delegate.execute(input)  // Calls Class A\n                .doOnSuccess(decision -&gt; {\n                    // Other success logic\n                })\n                .doFinally(() -&gt; {\n                    log.info(&quot;Strategy took {} ms&quot;,\n                             ((System.nanoTime() - startTime) / 1000000)); // Logs ~1300ms\n                });\n    });\n}\n</code></pre>\n<p><strong>The Timing Issue</strong></p>\n<p><em>Class A's <code>doOnSuccess</code>: Logs at ~500ms ✓ (expected)</em></p>\n<p><em>Class B's <code>doFinally</code>: Logs at ~1300ms ❌ (800ms later than expected)</em></p>\n<p>The <code>doFinally</code> in the decorator is executing much later than the <code>doOnSuccess</code> in the implementation, even though they should be measuring the same operation. The log from <code>doFinally</code> gets printed somewhere in-between during the downstream processing (not at the end).</p>\n<p><strong>The Context</strong>\nAll the 'A' like classes are strategies. The strategies are executed by an executor. All high priority strategies are executed first in parallel, followed by medium and then the low priority ones. Class A was a low priority strategy executed at the end.</p>\n<pre><code>@Singleton\npublic class StrategyExecutor {\n    private final Executor executor; // ThreadContextAwareExecutor with cached thread pool\n    \n    public Maybe&lt;Decision&gt; strategyExecute(Request request, /* other params */) {\n        return Maybe.defer(() -&gt; {\n            return Observable.fromArray(HIGH, MEDIUM, LOW)               \n                    .concatMapMaybe(priority -&gt; {\n                        List&lt;Strategy&gt; strategies = strategyMap.get(priority);\n                        \n                        // Convert each strategy to Maybe and run concurrently\n                        List&lt;Maybe&lt;Decision&gt;&gt; maybesFromStrategies = strategies.stream()\n                                .map(strategy -&gt; strategy.execute(input)\n                                        .subscribeOn(Schedulers.from(executor)) \n                                        .onErrorComplete() // Graceful error handling\n                                        .filter(Decision::isValid))\n                                .collect(Collectors.toList());\n\n                        return Maybe.merge(maybesFromStrategies)\n                                .firstElement();\n                    })\n                    .firstElement();\n        });\n    }\n}\n\n</code></pre>\n<ol>\n<li><p>High Throughput Environment:</p>\n</li>\n<li><p>Running at 40 TPS (transactions per second)</p>\n</li>\n<li><p>Multiple concurrent requests being processed</p>\n</li>\n<li><p>Each request runs on cached thread pools, with the executor shown below.</p>\n</li>\n</ol>\n<p><code>Executor Used - Executors.newCachedThreadPool()</code></p>\n<p>The strategy executor's result gets consumed by a top-level class which calls the downstream services. Downstream services are highly latent services</p>\n<pre><code>public Observable&lt;Response&gt; processRequest(Request request) {\n    return strategyExecutor.strategyExecute(request, /* params */)  // Returns Maybe&lt;Decision&gt;\n            .toObservable()\n            .flatMap(decision -&gt; {\n                Service selectedService = serviceMap.get(decision.serviceName());\n                return selectedService.process(request); \n            });\n}\n</code></pre>\n<p><strong>Threading Concerns</strong></p>\n<p>Since we're running at high throughput with concurrent requests:</p>\n<ol>\n<li><p>Could thread scheduling delays cause doFinally to execute much later?</p>\n</li>\n<li><p>Is <code>doFinally</code> waiting for some part of the downstream chain to complete before executing? (this does not happen for high/medium priority strategies)</p>\n</li>\n<li><p>In a multithreaded environment, does doFinally behavior differ from single-threaded execution?</p>\n</li>\n</ol>\n<p><strong>Questions</strong></p>\n<ol>\n<li><p>Is Maybe.merge() with firstElement() causing doFinally to wait for the entire downstream chain?</p>\n</li>\n<li><p>In this concurrent execution model, does doFinally wait until the consumer completely processes the result, not just when the Maybe emits?</p>\n</li>\n<li><p>Could the Executor and thread scheduling at 40 TPS be affecting when doFinally executes?</p>\n</li>\n<li><p>Is there a difference in how doFinally behaves when the Maybe is part of a Maybe.merge() operation vs. standalone execution?</p>\n</li>\n</ol>\n<blockquote>\n<p>What's the correct way to measure just the strategy execution time (not downstream processing) in this concurrent merge scenario?</p>\n</blockquote>\n<p><strong>What I've Tried</strong>\nMoving the timing logic to doOnSuccess and doOnError instead of doFinally, but I want to understand if the high throughput and threading model is contributing to this behavior. If I use <code>timeInterval()</code> in the strategy executor and use a <code>doOnSuccess</code> to log, it works as expected.</p>\n<p>RxJava Version: 3.x</p>\n<p>JDK 17</p>\n",
    "tags" : [ "java", "rx-java", "reactive-programming" ],
    "owner" : {
      "account_id" : 5307034,
      "reputation" : 419,
      "user_id" : 4234538,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/KeoIP.png?s=256",
      "display_name" : "Karthik Bhat",
      "link" : "https://stackoverflow.com/users/4234538/karthik-bhat"
    },
    "is_answered" : true,
    "view_count" : 89,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1758474664,
    "creation_date" : 1758327599,
    "link" : "https://stackoverflow.com/questions/79770036/rxjava-maybe-dofinally-executing-much-later-than-doonsuccess-in-high-through",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79770558,
    "question_id" : 79770036,
    "body" : "<p>Functionally there is a clear difference between <code>doOnSuccess</code> and <code>doFinally</code>:</p>\n<p><code>Maybe.doOnSuccess</code> uses <a href=\"https://github.com/ReactiveX/RxJava/blob/9cd6b9ebb458e1ebd713abdec1ae7a76d61c510d/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybePeek.java#L109\" rel=\"nofollow noreferrer\"><code>MaybePeek</code></a> internally:</p>\n<pre class=\"lang-java prettyprint-override\"><code>        @Override\n        public void onSuccess(T value) {\n            if (this.upstream == DisposableHelper.DISPOSED) {\n                return;\n            }\n            try {\n                parent.onSuccessCall.accept(value); &lt;-- callback happens here\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                onErrorInner(ex);\n                return;\n            }\n            this.upstream = DisposableHelper.DISPOSED;\n\n            downstream.onSuccess(value);\n\n            onAfterTerminate();\n        }\n</code></pre>\n<p><code>Maybe.doFinally</code> uses <a href=\"https://github.com/ReactiveX/RxJava/blob/9cd6b9ebb458e1ebd713abdec1ae7a76d61c510d/src/main/java/io/reactivex/rxjava3/internal/operators/maybe/MaybeDoFinally.java\" rel=\"nofollow noreferrer\"><code>MaybeDoFinally</code></a> internally:</p>\n<pre class=\"lang-java prettyprint-override\"><code>        @Override\n        public void onSuccess(T t) {\n            downstream.onSuccess(t);\n            runFinally(); &lt;-- callback happens here\n        }\n</code></pre>\n<p>So the most likely explanation is that the downstream operator takes 800ms to execute.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1562546,
      "reputation" : 25813,
      "user_id" : 1452094,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/7a12b28824b215e4886da2e9f376369f?s=256&d=identicon&r=PG",
      "display_name" : "Kiskae",
      "link" : "https://stackoverflow.com/users/1452094/kiskae"
    },
    "creation_date" : 1758404406,
    "last_activity_date" : 1758404406,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79770558" : [ {
      "comment_id" : 140753040,
      "post_id" : 79770558,
      "body" : "@KarthikBhat <code>onSuccess</code> flows down from the source observable, so <code>downstream</code> are whatever operators you applied after the <code>doFinally</code> operator. Until it reaches the observer in the <code>.subscribe</code> call.",
      "score" : 0,
      "owner" : {
        "account_id" : 1562546,
        "reputation" : 25813,
        "user_id" : 1452094,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/7a12b28824b215e4886da2e9f376369f?s=256&d=identicon&r=PG",
        "display_name" : "Kiskae",
        "link" : "https://stackoverflow.com/users/1452094/kiskae"
      },
      "creation_date" : 1758572779,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140752789,
      "post_id" : 79770558,
      "body" : "What is the downstream here? is it - selectedService.process(request);   The selected process here is highly latent and takes way longer than 800ms to complete.     From your experience, do you suspect anything else going on with the scheduler or the internal queue maintained by the maybe.merge?",
      "score" : 0,
      "owner" : {
        "account_id" : 5307034,
        "reputation" : 419,
        "user_id" : 4234538,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/KeoIP.png?s=256",
        "display_name" : "Karthik Bhat",
        "link" : "https://stackoverflow.com/users/4234538/karthik-bhat"
      },
      "creation_date" : 1758564502,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}