{
  "question" : {
    "question_id" : 79537039,
    "title" : "How to transfer or bypass security context when calling protected Quarkus REST method from within a concurrent thread context",
    "body" : "<p>I'm playing around with Quarkus JWT, and I want to transfer the security context to a CompletableFuture async supplier, which calls methods that require authorization.  In Spring, I don't have this problem, but with Quarkus the security context is not transferred, and calls to protected methods from within an async supplier fail due to authorization concerns.</p>\n<p>The error message below mentions <code>@ActivateRequestContext</code>.  Adding that to <code>getTreasureCount()</code> and <code>getAliBabasTreasureCount()</code> method bypasses the error, but results in a 401 UNAUTHORIZED exception (maybe that could be expected if the secondary methods are applying auth restrictions and the token doesn't have those permissions/roles, but the token does as proved by both direct REST calls and inspection/augmentation of the token).</p>\n<ul>\n<li>What's the best(-practice) approach, here?</li>\n<li>What's actually happening?  It appears the security annotations are applied upon ALL calls to a method, not just from the REST entry.</li>\n</ul>\n<p>This is very simple code, and the error occurs in method <code>takeTreasure()</code> on call <code>getTreasureCount();</code>:</p>\n<pre class=\"lang-java prettyprint-override\"><code>\n@RequestScoped\n@Path(&quot;/api/cave&quot;)\npublic class CaveRestController {\n\n    @Inject\n    private RedisService redis;\n\n    @Inject\n    JsonWebToken accessToken;\n\n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    @Path(value=&quot;/authorities&quot;)\n    public Map&lt;String,Object&gt; getPrincipalInfo() {\n\n        //accessToken.getClaimNames().forEach(claim -&gt; System.out.printf(&quot;Claim: %s, Value: %s%n&quot;, claim, accessToken.getClaim(claim)));\n\n        Collection&lt;String&gt; authorities = accessToken.getClaimNames();\n\n        Map&lt;String,Object&gt; info = new HashMap&lt;&gt;();\n        info.put(&quot;name&quot;, accessToken.getSubject());\n        info.put(&quot;authorities&quot;, authorities);\n\n        return info;\n    }\n\n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    @Path(value=&quot;/thieves-treasure&quot;)\n    @RolesAllowed(&quot;treasure-hunter&quot;)\n    public CompletableFuture&lt;TreasureModel&gt; getTreasureCount() {\n        return getTreasure(&quot;thieves-treasure&quot;, 1000);\n    }\n\n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    @Path(value=&quot;/alibaba-treasure&quot;)\n    @PermissionsAllowed(&quot;see:alibaba-treasure&quot;)\n    public CompletableFuture&lt;TreasureModel&gt; getAliBabasTreasureCount() {\n        return getTreasure(&quot;alibaba-treasure&quot;, 0);\n    }\n\n    @POST\n    @Path(value=&quot;/take-treasure&quot;)\n    @Produces(MediaType.APPLICATION_JSON)\n    @Consumes(MediaType.APPLICATION_JSON)\n    @PermissionsAllowed(&quot;take:thieves-treasure&quot;)\n    @ActivateRequestContext\n    public CompletableFuture&lt;Map&lt;String, Integer&gt;&gt; takeTreasure(TreasureModel takeTreasure) {\n        return CompletableFuture.supplyAsync(() -&gt; {\n\n            CompletableFuture&lt;TreasureModel&gt; thievesCountFuture = getTreasureCount(); // ERROR!!!\n            CompletableFuture&lt;TreasureModel&gt; alibabaCountFuture = getAliBabasTreasureCount();\n\n            // Wait for both to complete and retrieve results\n            CompletableFuture&lt;Void&gt; combinedFuture = CompletableFuture.allOf(thievesCountFuture, alibabaCountFuture);\n\n            // Block until all are done\n            combinedFuture.join();\n\n            TreasureModel thievesTreasure = null;\n            TreasureModel alibabaTreasure = null;\n            try {\n                thievesTreasure = thievesCountFuture.get();\n                alibabaTreasure = alibabaCountFuture.get();\n            } catch (InterruptedException | ExecutionException e) {\n                throw new RuntimeException(e);\n            }\n            if (thievesTreasure.amount() &lt; takeTreasure.amount()) {\n                throw new IllegalArgumentException(&quot;Not enough treasure to take&quot;);\n            }\n\n            alibabaTreasure = new TreasureModel(alibabaTreasure.owner(), alibabaTreasure.amount() + takeTreasure.amount());\n            thievesTreasure = new TreasureModel(thievesTreasure.owner(), thievesTreasure.amount() - takeTreasure.amount());\n\n            redis.set(alibabaTreasure.owner(), alibabaTreasure.amount());\n            redis.set(thievesTreasure.owner(), thievesTreasure.amount());\n            Map&lt;String, Integer&gt; results = new HashMap&lt;&gt;();\n            results.put(alibabaTreasure.owner(), alibabaTreasure.amount());\n            results.put(thievesTreasure.owner(), thievesTreasure.amount());\n            return results;\n        });\n    }\n\n\n    private CompletableFuture&lt;TreasureModel&gt; getTreasure(String key, Integer initialValue) {\n        return CompletableFuture.supplyAsync(() -&gt; {\n            try {\n                return redis.get(key)\n                        .thenApply((value) -&gt; {\n                            if (value.isEmpty()) {\n                                redis.set(key, initialValue);\n                            }\n                            return value.orElse(initialValue);\n                        }).thenApply(amount -&gt; new TreasureModel(key, amount)).get();\n            } catch (InterruptedException | ExecutionException e) {\n                throw new RuntimeException(e);\n            }\n        });\n    }\n\n}\n\n</code></pre>\n<p>Here is the error:</p>\n<pre><code>2025-03-26 14:38:12,445 ERROR [io.qua.ver.htt.run.QuarkusErrorHandler] (vert.x-eventloop-thread-3) HTTP Request to /api/cave/take-treasure failed, error id: 29f5d35b-e0ee-4b39-b721-a373813eea8a-1\n\nException in CaveRestController.java:71\n          69          return CompletableFuture.supplyAsync(() -&gt; {\n          70  \n        → 71              CompletableFuture&lt;TreasureModel&gt; thievesCountFuture = getTreasureCount();\n          72              CompletableFuture&lt;TreasureModel&gt; alibabaCountFuture = getAliBabasTreasureCount();\n          73  : jakarta.enterprise.context.ContextNotActiveException: RequestScoped context was not active when trying to obtain a bean instance for a client proxy of CLASS bean [class=io.quarkus.vertx.http.runtime.CurrentVertxRequest, id=0_6n6EmChCiiDdd8HelptG_A0AE]\n        - you can activate the request context for a specific method using the @ActivateRequestContext interceptor binding\n</code></pre>\n<p>BTW, I'm using a token augmentor to shape the Auth0 token to Quarkus friendly roles/permissions:</p>\n<pre class=\"lang-java prettyprint-override\"><code>\n\n@ApplicationScoped\npublic class CustomJWTIdentityAugmentor implements SecurityIdentityAugmentor {\n\n    @ConfigProperty(name = &quot;app.config.server.auth.auth0.custom-jwt-namespace.roles&quot;)\n    private String customRolesNamespace;\n    @ConfigProperty(name = &quot;app.config.server.auth.auth0.custom-jwt-namespace.permissions&quot;)\n    private String customPermissionsNamespace;\n\n    @Override\n    public Uni&lt;SecurityIdentity&gt; augment(SecurityIdentity identity, AuthenticationRequestContext context) {\n        //return Uni.createFrom().item(build(identity));\n        return context.runBlocking(build(identity));\n    }\n\n    private Supplier&lt;SecurityIdentity&gt; build(SecurityIdentity identity) {\n        if(identity.isAnonymous()) {\n            return () -&gt; identity;\n        } else {\n            // create a new builder and copy principal, attributes, credentials and roles from the original identity\n            QuarkusSecurityIdentity.Builder builder = QuarkusSecurityIdentity.builder(identity);\n            Object principal = identity.getPrincipal();\n            if (principal instanceof JsonWebToken accessToken) {\n\n                // Extract custom roles and permissions from the JWT claims\n                Set&lt;String&gt; customRoles = convertClaimToSet(accessToken.getClaim(customRolesNamespace));\n                Set&lt;String&gt; permissions = convertClaimToSet(accessToken.getClaim(customPermissionsNamespace));\n\n                // Add custom roles and permissions.\n                if (!customRoles.isEmpty()) {\n                    builder.addRoles(customRoles);\n                }\n                if (!permissions.isEmpty()) {\n                    permissions.forEach(permission -&gt; System.out.println(&quot;Permission: &quot; + permission));\n                    builder.addPermissionsAsString(permissions);\n                }\n            }\n\n            return builder::build;\n        }\n    }\n\n    private Set&lt;String&gt; convertClaimToSet(Object claimValue) {\n        Set&lt;String&gt; result = new HashSet&lt;&gt;();\n        if (claimValue instanceof JsonArray jsonArray) {\n            for (JsonValue jv : jsonArray) {\n                if (jv.getValueType() == JsonValue.ValueType.STRING) {\n                    result.add(((JsonString) jv).getString());\n                }\n            }\n        } else if (claimValue instanceof Iterable&lt;?&gt; iterable) {\n            for (Object item : iterable) {\n                if (item instanceof String) {\n                    result.add((String) item);\n                }\n            }\n        }\n        return result;\n    }\n\n}\n</code></pre>\n<p>The permissions are present:</p>\n<pre><code>Permission: take:thieves-treasure\nPermission: see:thieves-treasure\nPermission: see:alibaba-treasure\n</code></pre>\n<p>Lastly, simply returning data works:</p>\n<pre class=\"lang-java prettyprint-override\"><code>\n    @POST\n    @Path(value=&quot;/take-treasure&quot;)\n    @Produces(MediaType.APPLICATION_JSON)\n    @Consumes(MediaType.APPLICATION_JSON)\n    @PermissionsAllowed(&quot;take:thieves-treasure&quot;)\n    public CompletableFuture&lt;Map&lt;String, Integer&gt;&gt; takeTreasure(TreasureModel takeTreasure) {\n\n        return CompletableFuture.supplyAsync(() -&gt; {\n                Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();\n                map.put(&quot;test1&quot;, 980);\n                map.put(&quot;test2&quot;, 20);\n                return map;\n        });\n}\n</code></pre>\n<pre class=\"lang-bash prettyprint-override\"><code>&gt; Content-Length: 42\n&gt; \n} [42 bytes data]\n* upload completely sent off: 42 bytes\n&lt; HTTP/1.1 200 OK\n&lt; content-length: 24\n&lt; Content-Type: application/json;charset=UTF-8\n&lt; \n{ [24 bytes data]\n100    66  100    24  100    42   4811   8420 --:--:-- --:--:-- --:--:-- 16500\n* Connection #0 to host localhost left intact\n{\n  &quot;test2&quot;: 20,\n  &quot;test1&quot;: 980\n}\n\n</code></pre>\n",
    "tags" : [ "java", "quarkus", "quarkus-oidc" ],
    "owner" : {
      "account_id" : 1862192,
      "reputation" : 1972,
      "user_id" : 1686575,
      "user_type" : "registered",
      "accept_rate" : 65,
      "profile_image" : "https://i.sstatic.net/5fMdJ.jpg?s=256",
      "display_name" : "John Manko",
      "link" : "https://stackoverflow.com/users/1686575/john-manko"
    },
    "is_answered" : true,
    "view_count" : 202,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1743085053,
    "creation_date" : 1743015735,
    "link" : "https://stackoverflow.com/questions/79537039/how-to-transfer-or-bypass-security-context-when-calling-protected-quarkus-rest-m",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79537261,
    "question_id" : 79537039,
    "body" : "<p>Quarkus addresses the context propagation in the guide Context Propagation in Quarkus (<a href=\"https://quarkus.io/guides/context-propagation\" rel=\"nofollow noreferrer\">https://quarkus.io/guides/context-propagation</a>), but I would still like any feedback you have on this topic/issue.</p>\n<p>So, changing the code to the following:</p>\n<pre><code>@RequestScoped\n@Path(&quot;/api/cave&quot;)\npublic class RestController {\n\n    @Inject\n    ManagedExecutor executor;\n\n    @POST\n    @Path(value=&quot;/take-treasure&quot;)\n    @Produces(MediaType.APPLICATION_JSON)\n    @Consumes(MediaType.APPLICATION_JSON)\n    @PermissionsAllowed(&quot;take:thieves-treasure&quot;)\n    public CompletableFuture&lt;Map&lt;String, Integer&gt;&gt; takeTreasure(TreasureModel takeTreasure) {\n\n        return CompletableFuture.supplyAsync(() -&gt; {\n                 /// CODE HERE\n                },\n                executor);\n\n    }\n}\n</code></pre>\n<p>A little more from ChatGPT:</p>\n<p>Below is a comparison of how Quarkus and Spring Boot handle context propagation for security, particularly when running asynchronous code:</p>\n<hr />\n<h2>Quarkus</h2>\n<ul>\n<li><p><strong>Reactive Foundation:</strong><br />\nQuarkus is built on top of Vert.x and emphasizes non‑blocking, reactive patterns. As such, the CDI request context—including the security context—is tightly bound to the HTTP request that triggers the call.</p>\n</li>\n<li><p><strong>Explicit Context Propagation Required:</strong><br />\nWhen you offload work to another thread (for example, using <code>CompletableFuture.supplyAsync</code>), Quarkus does not automatically propagate the request (and hence the security) context to the new thread. This is why you encountered 401 errors when secured methods (annotated with <code>@RolesAllowed</code> or <code>@PermissionsAllowed</code>) were invoked in async code without proper context propagation.</p>\n</li>\n<li><p><strong>Solution via ManagedExecutor or Reactive Types:</strong><br />\nTo address this, Quarkus recommends using a ManagedExecutor (or reactive types like Uni/Multi) that automatically captures and propagates the request context, including security identity, to asynchronous tasks. This ensures that when your secured methods are called—even from your own code—the required security context is available.</p>\n</li>\n<li><p><strong>Method Security Invocation:</strong><br />\nIn Quarkus, method-level security (e.g., via <code>@RolesAllowed</code>) is enforced by interceptors that require an active request context with the proper security identity. If you call a secured method asynchronously without propagating that context, the interceptor won’t see the correct authentication data, and the call will be rejected.</p>\n</li>\n</ul>\n<hr />\n<h2>Spring Boot</h2>\n<ul>\n<li><p><strong>ThreadLocal-Based Security Context:</strong><br />\nSpring Security uses a <code>SecurityContextHolder</code> that, by default, stores the security context in a <code>ThreadLocal</code> (often an <code>InheritableThreadLocal</code>). This design means that when asynchronous methods are executed using Spring’s <code>@Async</code> (or similar mechanisms), the security context is automatically inherited by the new thread—provided that the default executor (or a properly configured one) is used.</p>\n</li>\n<li><p><strong>Automatic Propagation (Usually):</strong><br />\nBecause the security context is thread-local, asynchronous calls in Spring Boot typically “see” the same security information as the parent thread without any additional configuration. (Note: If you use a custom executor that does not inherit thread-local values, you might need a <code>DelegatingSecurityContextExecutor</code> to propagate the context.)</p>\n</li>\n<li><p><strong>Method Security Invocation:</strong><br />\nAs in Quarkus, Spring’s method-level security (using annotations like <code>@PreAuthorize</code> or <code>@RolesAllowed</code>) is applied through AOP proxies. When a method is invoked asynchronously, as long as the security context is correctly propagated (which it usually is by default), the security checks will occur as expected—even if the method is called from your own code.</p>\n</li>\n</ul>\n<hr />\n<h2>Key Differences</h2>\n<ul>\n<li><p><strong>Context Propagation Mechanism:</strong></p>\n<ul>\n<li><strong>Quarkus:</strong> Requires explicit context propagation (ManagedExecutor or reactive types) to carry the request and security context to asynchronous threads. Without this, secured methods won’t have the necessary security identity, leading to authentication failures (e.g., 401 errors).</li>\n<li><strong>Spring Boot:</strong> Uses a thread-local mechanism that generally propagates the security context automatically to asynchronous threads, so extra steps are not usually necessary.</li>\n</ul>\n</li>\n<li><p><strong>Asynchronous Execution:</strong></p>\n<ul>\n<li><strong>Quarkus:</strong> If you simply offload tasks using <code>CompletableFuture.supplyAsync</code> without an executor that propagates context, the security interceptors won’t be able to find the authenticated identity.</li>\n<li><strong>Spring Boot:</strong> With its default configuration, asynchronous execution (via <code>@Async</code>) usually inherits the security context from the parent thread, meaning that method security is enforced as expected.</li>\n</ul>\n</li>\n<li><p><strong>Internal vs. External Calls:</strong><br />\nIn both frameworks, security annotations like <code>@RolesAllowed</code> (or Spring’s <code>@PreAuthorize</code>) are applied when methods are invoked through proxies. Self‑invocation (calling a secured method from within the same bean) bypasses these interceptors in both Quarkus and Spring Boot.</p>\n</li>\n</ul>\n<hr />\n<h2>Summary</h2>\n<ul>\n<li><p><strong>Quarkus:</strong></p>\n<ul>\n<li><strong>Pros:</strong> Optimized for reactive, non‑blocking patterns; explicit context propagation offers fine control.</li>\n<li><strong>Cons:</strong> Requires explicit use of a ManagedExecutor or reactive types to ensure that security context (and other request-scoped contexts) is propagated to asynchronous tasks. Without this, secured methods may return 401 errors.</li>\n</ul>\n</li>\n<li><p><strong>Spring Boot:</strong></p>\n<ul>\n<li><strong>Pros:</strong> Automatically propagates the security context using ThreadLocal storage, making asynchronous security easier to manage in many cases.</li>\n<li><strong>Cons:</strong> Relies on ThreadLocal inheritance, which can become tricky if custom executors that don’t inherit thread locals are used.</li>\n</ul>\n</li>\n</ul>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1862192,
      "reputation" : 1972,
      "user_id" : 1686575,
      "user_type" : "registered",
      "accept_rate" : 65,
      "profile_image" : "https://i.sstatic.net/5fMdJ.jpg?s=256",
      "display_name" : "John Manko",
      "link" : "https://stackoverflow.com/users/1686575/john-manko"
    },
    "creation_date" : 1743022314,
    "last_activity_date" : 1743085053,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}