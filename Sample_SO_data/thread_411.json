{
  "question" : {
    "question_id" : 79808532,
    "title" : "PDFBox 3.0.x external and late signing causes &quot;Signature is invalid&quot;",
    "body" : "<p>I am going to implement the external and late signing with PDFBox 3.0.x but the output signed PDF causes &quot;Signature is invalid&quot;. The following is my code:</p>\n<pre><code>public class CreateSignature2 {\n\n    final DataSigner signer;\n    private Certificate cert;\n    private Certificate[] certificateChain;\n    \n    public CreateSignature2(DataSigner signer) {\n        this.signer = signer;\n        \n        try {\n            this.cert = signer.getSignerCert();\n            this.certificateChain = signer.getSignerCertChain().toArray(new Certificate[0]);\n        } catch (ApiException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n\n    public void signDocument(File inFile, Certificate cert, Certificate[] certChain) throws\n    Exception,\n                                                                   IOException,\n                                                                   CertificateEncodingException,\n                                                                   NoSuchAlgorithmException,\n                                                                   OperatorCreationException,\n                                                                   CMSException {\n        this.cert = cert;\n        setCertificateChain(certChain);\n\n        String name = inFile.getName();\n        String substring = name.substring(0, name.lastIndexOf('.'));\n        File outFile = new File(inFile.getParent(), substring + &quot;_signed_pdfbox.pdf&quot;);\n        \n        // Use late signing approach\n        LateSigningSession session = prepareSigning(inFile, outFile);\n        byte[] dataToSign = session.getDataToSign();\n        \n        // Sign the data externally\n        List&lt;byte[]&gt; dataList = Arrays.asList(dataToSign);\n        List&lt;byte[]&gt; signatures = signer.sign(dataList);\n        byte[] signature = signatures.get(0);\n        \n        // Complete the signing\n        completeSigning(session, signature);\n    }\n\n    private void setCertificateChain(final Certificate[] certificateChain) {\n        this.certificateChain = certificateChain;\n    }\n\n    /**\n     * Prepares the document for signing and returns the data that needs to be signed\n     */\n    public LateSigningSession prepareSigning(File inFile, File outFile) throws\n                                                         IOException,\n                                                         NoSuchAlgorithmException,\n                                                         CertificateEncodingException,\n                                                         OperatorCreationException,\n                                                         CMSException {\n        FileOutputStream output = new FileOutputStream(outFile);\n        PDDocument document = Loader.loadPDF(inFile);\n        \n        try {\n            PDSignature signature = new PDSignature();\n            signature.setFilter(PDSignature.FILTER_ADOBE_PPKLITE);\n            signature.setSubFilter(PDSignature.SUBFILTER_ADBE_PKCS7_DETACHED);\n            signature.setName(&quot;Test Name&quot;);\n            signature.setSignDate(Calendar.getInstance());\n\n            SignatureOptions signatureOptions = new SignatureOptions();\n            signatureOptions.setPage(0);\n\n            document.addSignature(signature, signatureOptions);\n            ExternalSigningSupport externalSigning = document.saveIncrementalForExternalSigning(output);\n\n            // Build CMS structure\n            ESSCertIDv2 certid = new ESSCertIDv2(\n                new AlgorithmIdentifier(NISTObjectIdentifiers.id_sha256),\n                MessageDigest.getInstance(&quot;SHA-256&quot;).digest(cert.getEncoded())\n            );\n            SigningCertificateV2 sigcert = new SigningCertificateV2(certid);\n            Attribute attr = new Attribute(PKCSObjectIdentifiers.id_aa_signingCertificateV2, new DERSet(sigcert));\n\n            ASN1EncodableVector v = new ASN1EncodableVector();\n            v.add(attr);\n            AttributeTable atttributeTable = new AttributeTable(v);\n            CMSAttributeTableGenerator attrGen = new DefaultSignedAttributeTableGenerator(atttributeTable);\n\n            org.bouncycastle.asn1.x509.Certificate cert2 = org.bouncycastle.asn1.x509.Certificate.getInstance(\n                ASN1Primitive.fromByteArray(cert.getEncoded())\n            );\n            JcaSignerInfoGeneratorBuilder sigb = new JcaSignerInfoGeneratorBuilder(\n                new JcaDigestCalculatorProviderBuilder().build()\n            );\n            sigb.setSignedAttributeGenerator(attrGen);\n\n            // Create a ContentSigner that captures the data\n            HashCapturingContentSigner contentSigner = new HashCapturingContentSigner();\n\n            CMSSignedDataGenerator gen = new CMSSignedDataGenerator();\n            gen.addCertificates(new JcaCertStore(Arrays.asList(certificateChain)));\n            gen.addSignerInfoGenerator(sigb.build(contentSigner, new X509CertificateHolder(cert2)));\n\n            // Process the document content to populate the ContentSigner's OutputStream\n            CMSTypedData msg = new CMSProcessableInputStream(externalSigning.getContent());\n            \n            // This will write the data to be signed to the ContentSigner's OutputStream\n            // We catch the expected exception when getSignature() is called prematurely\n            try {\n                CMSSignedData signedData = gen.generate(msg, false);\n            } catch (RuntimeException e) {\n                if (e.getMessage() != null &amp;&amp; e.getMessage().contains(&quot;Signature not set&quot;)) {\n                    // Expected - we're capturing the data for late signing\n                } else {\n                    throw e;\n                }\n            }\n\n            // Get the captured data from the ContentSigner\n            byte[] dataToSign = contentSigner.getCapturedData();\n            \n            return new LateSigningSession(document, output, externalSigning, contentSigner, \n                                        gen, msg, dataToSign);\n\n        } catch (Exception e) {\n            // Clean up resources if anything fails\n            document.close();\n            output.close();\n            throw e;\n        }\n    }\n\n    /**\n     * Completes the signing process with the externally generated signature\n     */\n    public void completeSigning(LateSigningSession session, byte[] externalSignature) throws\n                                                                        IOException,\n                                                                        CMSException {\n        try {\n            // Set the external signature on the ContentSigner\n            session.getContentSigner().setSignature(externalSignature);\n            \n            // Now generate the final CMS signature\n            CMSSignedData signedData = session.getGenerator().generate(session.getMessage(), false);\n            byte[] cmsSignature = signedData.getEncoded();\n            \n            // Set the signature on the document\n            session.getExternalSigningSupport().setSignature(cmsSignature);\n        } finally {\n            // Always close resources\n            session.close();\n        }\n    }\n\n    /**\n     * ContentSigner that captures data for late signing\n     */\n    private static class HashCapturingContentSigner implements ContentSigner {\n        private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        private byte[] signature;\n        private boolean signatureSet = false;\n\n        @Override\n        public byte[] getSignature() {\n            if (!signatureSet) {\n                throw new RuntimeException(&quot;Signature not set. Use setSignature() for late signing.&quot;);\n            }\n            return signature;\n        }\n\n        public void setSignature(byte[] signature) {\n            this.signature = signature;\n            this.signatureSet = true;\n        }\n\n        @Override\n        public OutputStream getOutputStream() {\n            return outputStream;\n        }\n\n        @Override\n        public AlgorithmIdentifier getAlgorithmIdentifier() {\n            return new AlgorithmIdentifier(new ASN1ObjectIdentifier(&quot;1.2.840.113549.1.1.11&quot;));\n        }\n\n        public byte[] getCapturedData() {\n            return outputStream.toByteArray();\n        }\n    }\n\n    /**\n     * Session class to hold signing state between preparation and completion\n     */\n    public static class LateSigningSession implements AutoCloseable {\n        private final PDDocument document;\n        private final FileOutputStream output;\n        private final ExternalSigningSupport externalSigningSupport;\n        private final HashCapturingContentSigner contentSigner;\n        private final CMSSignedDataGenerator generator;\n        private final CMSTypedData message;\n        private final byte[] dataToSign;\n\n        public LateSigningSession(PDDocument document, FileOutputStream output,\n                                ExternalSigningSupport externalSigningSupport,\n                                HashCapturingContentSigner contentSigner,\n                                CMSSignedDataGenerator generator,\n                                CMSTypedData message,\n                                byte[] dataToSign) {\n            this.document = document;\n            this.output = output;\n            this.externalSigningSupport = externalSigningSupport;\n            this.contentSigner = contentSigner;\n            this.generator = generator;\n            this.message = message;\n            this.dataToSign = dataToSign;\n        }\n\n        public byte[] getDataToSign() {\n            return dataToSign;\n        }\n\n        public ExternalSigningSupport getExternalSigningSupport() {\n            return externalSigningSupport;\n        }\n\n        public HashCapturingContentSigner getContentSigner() {\n            return contentSigner;\n        }\n\n        public CMSSignedDataGenerator getGenerator() {\n            return generator;\n        }\n\n        public CMSTypedData getMessage() {\n            return message;\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (document != null) {\n                document.close();\n            }\n            if (output != null) {\n                output.close();\n            }\n        }\n    }\n\n    /**\n     * Alternative approach that recreates the CMS structure for completion\n     * This is more robust if the first approach has issues\n     */\n    public LateSigningSession prepareSigningAlternative(File inFile, File outFile) throws\n                                                         IOException,\n                                                         NoSuchAlgorithmException,\n                                                         CertificateEncodingException {\n        FileOutputStream output = new FileOutputStream(outFile);\n        PDDocument document = Loader.loadPDF(inFile);\n        \n        try {\n            PDSignature signature = new PDSignature();\n            signature.setFilter(PDSignature.FILTER_ADOBE_PPKLITE);\n            signature.setSubFilter(PDSignature.SUBFILTER_ADBE_PKCS7_DETACHED);\n            signature.setName(&quot;Test Name&quot;);\n            signature.setSignDate(Calendar.getInstance());\n\n            SignatureOptions signatureOptions = new SignatureOptions();\n            signatureOptions.setPage(0);\n\n            document.addSignature(signature, signatureOptions);\n            ExternalSigningSupport externalSigning = document.saveIncrementalForExternalSigning(output);\n\n            // Read the document content that will be processed\n            InputStream contentStream = externalSigning.getContent();\n            ByteArrayOutputStream contentBaos = new ByteArrayOutputStream();\n            byte[] buffer = new byte[8192];\n            int bytesRead;\n            while ((bytesRead = contentStream.read(buffer)) != -1) {\n                contentBaos.write(buffer, 0, bytesRead);\n            }\n            byte[] documentContent = contentBaos.toByteArray();\n\n            return new LateSigningSession(document, output, externalSigning, null, \n                                        null, null, documentContent);\n\n        } catch (Exception e) {\n            document.close();\n            output.close();\n            throw e;\n        }\n    }\n\n    /**\n     * Alternative completion that recreates the CMS structure\n     */\n    public void completeSigningAlternative(LateSigningSession session, byte[] externalSignature) throws\n                                                                        IOException,\n                                                                        NoSuchAlgorithmException,\n                                                                        CertificateEncodingException,\n                                                                        OperatorCreationException,\n                                                                        CMSException {\n        try {\n            // Recreate the CMS structure with the external signature\n            ESSCertIDv2 certid = new ESSCertIDv2(\n                new AlgorithmIdentifier(NISTObjectIdentifiers.id_sha256),\n                MessageDigest.getInstance(&quot;SHA-256&quot;).digest(cert.getEncoded())\n            );\n            SigningCertificateV2 sigcert = new SigningCertificateV2(certid);\n            Attribute attr = new Attribute(PKCSObjectIdentifiers.id_aa_signingCertificateV2, new DERSet(sigcert));\n\n            ASN1EncodableVector v = new ASN1EncodableVector();\n            v.add(attr);\n            AttributeTable atttributeTable = new AttributeTable(v);\n            CMSAttributeTableGenerator attrGen = new DefaultSignedAttributeTableGenerator(atttributeTable);\n\n            org.bouncycastle.asn1.x509.Certificate cert2 = org.bouncycastle.asn1.x509.Certificate.getInstance(\n                ASN1Primitive.fromByteArray(cert.getEncoded())\n            );\n\n            // Create ContentSigner with the pre-computed signature\n            ContentSigner contentSigner = new PrecomputedContentSigner(externalSignature);\n\n            JcaSignerInfoGeneratorBuilder sigb = new JcaSignerInfoGeneratorBuilder(\n                new JcaDigestCalculatorProviderBuilder().build()\n            );\n            sigb.setSignedAttributeGenerator(attrGen);\n\n            CMSSignedDataGenerator gen = new CMSSignedDataGenerator();\n            gen.addCertificates(new JcaCertStore(Arrays.asList(certificateChain)));\n            gen.addSignerInfoGenerator(sigb.build(contentSigner, new X509CertificateHolder(cert2)));\n\n            // Use the captured document content\n            CMSTypedData msg = new CMSProcessableByteArray(session.getDataToSign());\n            CMSSignedData signedData = gen.generate(msg, false);\n\n            byte[] cmsSignature = signedData.getEncoded();\n            session.getExternalSigningSupport().setSignature(cmsSignature);\n        } finally {\n            session.close();\n        }\n    }\n\n    /**\n     * ContentSigner that uses a pre-computed signature\n     */\n    private static class PrecomputedContentSigner implements ContentSigner {\n        private final byte[] signature;\n        private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n\n        public PrecomputedContentSigner(byte[] signature) {\n            this.signature = signature;\n        }\n\n        @Override\n        public byte[] getSignature() {\n            return signature;\n        }\n\n        @Override\n        public OutputStream getOutputStream() {\n            return outputStream;\n        }\n\n        @Override\n        public AlgorithmIdentifier getAlgorithmIdentifier() {\n            return new AlgorithmIdentifier(new ASN1ObjectIdentifier(&quot;1.2.840.113549.1.1.11&quot;));\n        }\n    }\n}\n</code></pre>\n<p>And the following is to call the above class:</p>\n<pre><code>    File inputFile = new File(inPdfPath1);\nFile outputFile = new File(inPdfPath2);\n\nCreateSignature2 sig2 = new CreateSignature2(externalSignService);\n\nCreateSignature2.LateSigningSession session = sig2.prepareSigning(inputFile, outputFile);\nbyte[] dataToSign = session.getDataToSign();\n\n\nSystem.out.println(&quot;&gt;&gt;&gt;&gt;SIZE: &quot; + dataToSign.length);\n\n// Send to external signing service\nList&lt;byte[]&gt; dataList = Arrays.asList(dataToSign);\nList&lt;byte[]&gt; signatures = externalSignService.sign(dataList);\nbyte[] signature = signatures.get(0);\n\n// Complete the signing stage\nsig2.completeSigning(session, signature);\n</code></pre>\n<p>Depends on the above CreateSignature2 class, please give me a hand and advice how can I implement the external and late sign using PDFBox? Thanks.</p>\n",
    "tags" : [ "java", "pdfbox", "digital-signature" ],
    "owner" : {
      "account_id" : 3804005,
      "reputation" : 171,
      "user_id" : 3156889,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/3bd83a018ab9a63d571ee503793c102b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "EricMacau",
      "link" : "https://stackoverflow.com/users/3156889/ericmacau"
    },
    "is_answered" : true,
    "view_count" : 83,
    "answer_count" : 1,
    "score" : 2,
    "last_activity_date" : 1762507237,
    "creation_date" : 1762232550,
    "link" : "https://stackoverflow.com/questions/79808532/pdfbox-3-0-x-external-and-late-signing-causes-signature-is-invalid",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79808805,
    "question_id" : 79808532,
    "body" : "<p>The <code>CMSTypedData msg</code> you create in <code>prepareSigning</code> is a <code>CMSProcessableInputStream</code> instance.</p>\n<p>As the name indicates, it is based on an <code>InputStream</code>. This <code>InputStream</code> in the first use of <code>msg</code> (in <code>prepareSigning</code>) is read to its end and <code>msg</code> returns the data of the stream.</p>\n<p>But if <code>msg</code> is re-used, the stream already is at the end and <code>msg</code> returns the data of an empty stream. This happens in your <code>completeSigning</code> where you use <code>session.getMessage()</code> which holds the previously used <code>msg</code> from <code>prepareSigning</code>.</p>\n<p>Thus, you generate a signature value for the original signed attributes with the correct PDF hash. But in the resulting signature container you have signed attributes that contain the hash of an empty PDF.</p>\n",
    "score" : 2,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 1916831,
      "reputation" : 97003,
      "user_id" : 1729265,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/VMMeP.jpg?s=256",
      "display_name" : "mkl",
      "link" : "https://stackoverflow.com/users/1729265/mkl"
    },
    "creation_date" : 1762253027,
    "last_activity_date" : 1762253027,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}