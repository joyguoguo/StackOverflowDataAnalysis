{
  "question" : {
    "question_id" : 79565386,
    "title" : "Spring Boot Security /login return 404 when POST from postman",
    "body" : "<p>I followed a basic manual on how to implement oauth2 token based security on rest endpoints of a spring boot application,</p>\n<p>I have 2 apps atm, one being the oauth server and the client, port 9000 and 8080 respectively,</p>\n<p>so the process is as follow:</p>\n<ol>\n<li>in a browser, go to <a href=\"http://127.0.0.1:8080/oauth2/autorization/client-app\" rel=\"nofollow noreferrer\">http://127.0.0.1:8080/oauth2/autorization/client-app</a></li>\n<li>that redirects me to <a href=\"http://127.0.0.1:9000/login\" rel=\"nofollow noreferrer\">http://127.0.0.1:9000/login</a></li>\n<li>after login and redirect back, I have and endpoint that return the generated CODE of the successful log in,</li>\n<li>I took that code and via postman I generate an oauth2 token at <a href=\"http://127.0.0.1:9000/oauth2/token\" rel=\"nofollow noreferrer\">http://127.0.0.1:9000/oauth2/token</a> with:\n<ul>\n<li>in Authorization being basic, using the client name and secret that I configured,</li>\n<li>in the body, alongside the code, grant_type = authorization_code, redirect_uri = <a href=\"http://127.0.0.1:8080/authorized\" rel=\"nofollow noreferrer\">http://127.0.0.1:8080/authorized</a></li>\n</ul>\n</li>\n</ol>\n<p>Up to this point everything is alright, I can take the returned token an use it to access my secured endpoints in my client,</p>\n<p><strong>NOW</strong>, I'm trying to make a POST call from postman to that <a href=\"http://127.0.0.1:9000/login\" rel=\"nofollow noreferrer\">http://127.0.0.1:9000/login</a>, <em>but I'm getting a <strong>404</strong> code</em></p>\n<p>this is my request:</p>\n<p><a href=\"https://i.sstatic.net/JWZSdS2C.jpg\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/JWZSdS2C.jpg\" alt=\"postman request\" /></a></p>\n<p>and this is the response of the request,</p>\n<pre><code> {\n    &quot;timestamp&quot;: &quot;...&quot;,\n    &quot;status&quot;: 404,\n    &quot;error&quot;: &quot;Not Found&quot;,\n    &quot;trace&quot;: &quot;org.springframework.web.servlet.resource.NoResourceFoundException: No static resource .\\r\\n\\tat org.springframework.web.servlet.resource.ResourceHttpRequestHandler.handleRequest(ResourceHttpRequestHandler.java:585)\\r\\n\\tat org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter.handle(HttpRequestHandlerAdapter.java:52)\\r\\n\\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1089)\\r\\n\\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:979)\\r\\n\\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1014)\\r\\n\\tat org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:903)\\r\\n\\tat jakarta.servlet.http.HttpServlet.service(HttpServlet.java:564)\\r\\n\\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:885)\\r\\n\\tat jakarta.servlet.http.HttpServlet.service(HttpServlet.java:658)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:195)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)\\r\\n\\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)\\r\\n\\tat org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:108)\\r\\n\\tat org.springframework.security.web.FilterChainProxy.lambda$doFilterInternal$3(FilterChainProxy.java:231)\\r\\n\\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:365)\\r\\n\\tat org.springframework.security.web.access.intercept.AuthorizationFilter.doFilter(AuthorizationFilter.java:101)\\r\\n\\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)\\r\\n\\tat org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:126)\\r\\n\\tat org.springframework.security.web.access.ExceptionTranslationFilter.doFilter(ExceptionTranslationFilter.java:120)\\r\\n\\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)\\r\\n\\tat org.springframework.security.web.authentication.AnonymousAuthenticationFilter.doFilter(AnonymousAuthenticationFilter.java:100)\\r\\n\\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)\\r\\n\\tat org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter.doFilter(SecurityContextHolderAwareRequestFilter.java:179)\\r\\n\\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)\\r\\n\\tat org.springframework.security.web.savedrequest.RequestCacheAwareFilter.doFilter(RequestCacheAwareFilter.java:63)\\r\\n\\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)\\r\\n\\tat org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter.doFilterInternal(DefaultLogoutPageGeneratingFilter.java:58)\\r\\n\\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)\\r\\n\\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)\\r\\n\\tat org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:220)\\r\\n\\tat org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter.doFilter(DefaultLoginPageGeneratingFilter.java:206)\\r\\n\\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)\\r\\n\\tat org.springframework.security.web.authentication.ui.DefaultResourcesFilter.doFilter(DefaultResourcesFilter.java:72)\\r\\n\\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)\\r\\n\\tat org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:227)\\r\\n\\tat org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter.doFilter(AbstractAuthenticationProcessingFilter.java:221)\\r\\n\\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)\\r\\n\\tat org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:107)\\r\\n\\tat org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:93)\\r\\n\\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)\\r\\n\\tat org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:90)\\r\\n\\tat org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:75)\\r\\n\\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)\\r\\n\\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)\\r\\n\\tat org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:82)\\r\\n\\tat org.springframework.security.web.context.SecurityContextHolderFilter.doFilter(SecurityContextHolderFilter.java:69)\\r\\n\\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)\\r\\n\\tat org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:62)\\r\\n\\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)\\r\\n\\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)\\r\\n\\tat org.springframework.security.web.session.DisableEncodeUrlFilter.doFilterInternal(DisableEncodeUrlFilter.java:42)\\r\\n\\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)\\r\\n\\tat org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:374)\\r\\n\\tat org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:233)\\r\\n\\tat org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:191)\\r\\n\\tat org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)\\r\\n\\tat org.springframework.web.servlet.handler.HandlerMappingIntrospector.lambda$createCacheFilter$3(HandlerMappingIntrospector.java:243)\\r\\n\\tat org.springframework.web.filter.CompositeFilter$VirtualFilterChain.doFilter(CompositeFilter.java:113)\\r\\n\\tat org.springframework.web.filter.CompositeFilter.doFilter(CompositeFilter.java:74)\\r\\n\\tat org.springframework.security.config.annotation.web.configuration.WebMvcSecurityConfiguration$CompositeFilterChainProxy.doFilter(WebMvcSecurityConfiguration.java:238)\\r\\n\\tat org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:362)\\r\\n\\tat org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:278)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)\\r\\n\\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\\r\\n\\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)\\r\\n\\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\\r\\n\\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)\\r\\n\\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\\r\\n\\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:116)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:164)\\r\\n\\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:140)\\r\\n\\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:167)\\r\\n\\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:90)\\r\\n\\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:483)\\r\\n\\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:115)\\r\\n\\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:93)\\r\\n\\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74)\\r\\n\\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:344)\\r\\n\\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:397)\\r\\n\\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:63)\\r\\n\\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:905)\\r\\n\\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1743)\\r\\n\\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:52)\\r\\n\\tat org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1190)\\r\\n\\tat org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)\\r\\n\\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:63)\\r\\n\\tat java.base/java.lang.Thread.run(Thread.java:1583)\\r\\n&quot;,\n    &quot;message&quot;: &quot;No static resource .&quot;,\n    &quot;path&quot;: &quot;/&quot;\n }\n</code></pre>\n<p>this is the improtant part of my Spring security configuration class:</p>\n<pre><code>@Bean\n@Order(1)\nSecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {\n    OAuth2AuthorizationServerConfigurer authorizationServerConfigurer = OAuth2AuthorizationServerConfigurer\n            .authorizationServer();\n\n    http.securityMatcher(authorizationServerConfigurer.getEndpointsMatcher()).with(authorizationServerConfigurer,\n            (authorizationServer) -&gt; authorizationServer.oidc(Customizer.withDefaults()) \n    ).authorizeHttpRequests((authorize) -&gt; authorize //\n\n            // HERE :)\n\n            .anyRequest().authenticated())\n            // Redirect to the login page when not authenticated from the\n            // authorization endpoint\n            .exceptionHandling((exceptions) -&gt; exceptions//\n                    .defaultAuthenticationEntryPointFor( //\n                            new LoginUrlAuthenticationEntryPoint(&quot;/login&quot;),\n                            new MediaTypeRequestMatcher(MediaType.TEXT_HTML, MediaType.APPLICATION_JSON)));\n\n    return http.build();\n}\n\n@Bean\n@Order(2)\nSecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {\n    http.authorizeHttpRequests((authorize) -&gt; authorize.anyRequest().authenticated()).csrf(CsrfConfigurer::disable)\n            // Form login handles the redirect to the login page from the\n            // authorization server filter chain\n            .formLogin(Customizer.withDefaults());\n\n    return http.build();\n}\n\n@Bean\nUserDetailsService userDetailsService() {\n    UserDetails userDetails = User.builder() // .withDefaultPasswordEncoder()\n            .username(&quot;user&quot;) //\n            .password(&quot;{noop}123&quot;) //\n            .roles(&quot;USER&quot;) //\n            .build();\n\n    return new InMemoryUserDetailsManager(userDetails);\n}\n\nprivate static final String CLIENT_ID = &quot;client-app&quot;;\nprivate static final String CLIENT_SECRET = &quot;secret12345&quot;;\n\n@Bean\nRegisteredClientRepository registeredClientRepository() {\n    RegisteredClient oidcClient = RegisteredClient.withId(UUID.randomUUID().toString()).clientId(CLIENT_ID)\n            .clientSecret(&quot;{noop}&quot; + CLIENT_SECRET)\n            .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n            .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n            .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)\n            .redirectUri(&quot;http://127.0.0.1:8080/login/oauth2/code/&quot; + CLIENT_ID)\n            .redirectUri(&quot;http://127.0.0.1:8080/authorized&quot;) //\n            .postLogoutRedirectUri(&quot;http://127.0.0.1:8080/logout&quot;) //\n            .scope(OidcScopes.OPENID) //\n            .scope(OidcScopes.PROFILE) //\n            .scope(&quot;read&quot;) //\n            .scope(&quot;write&quot;) //\n            .clientSettings(ClientSettings.builder().requireAuthorizationConsent(true).build()).build();\n\n    return new InMemoryRegisteredClientRepository(oidcClient);\n}\n</code></pre>\n<p>I tried adding the /login to the not secured paths without any effect, right before the .anyRequest().authenticated()):</p>\n<pre><code>            .requestMatchers(&quot;/login&quot;).permitAll() //\n</code></pre>\n<p>as this is a spring boot application, I dont have any xml configuration files as some other solutions mentions, so, <em>what should I change to be able to make that login via postman request and not directly in the browser?</em></p>\n",
    "tags" : [ "java", "spring-boot" ],
    "owner" : {
      "account_id" : 16223118,
      "reputation" : 143,
      "user_id" : 11714220,
      "user_type" : "registered",
      "profile_image" : "https://lh5.googleusercontent.com/-mhbD83YE024/AAAAAAAAAAI/AAAAAAAAAAc/Qy5DIqFJaZk/s256-rj/photo.jpg",
      "display_name" : "Alfredo Morales",
      "link" : "https://stackoverflow.com/users/11714220/alfredo-morales"
    },
    "is_answered" : false,
    "view_count" : 101,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1744275270,
    "creation_date" : 1744235436,
    "link" : "https://stackoverflow.com/questions/79565386/spring-boot-security-login-return-404-when-post-from-postman",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79565680,
    "question_id" : 79565386,
    "body" : "<blockquote>\n<p>I followed a basic manual on how to implement oauth2 token based security</p>\n</blockquote>\n<p>No you did not. Both of <code>formLogin</code> and <code>oauth2Login</code> are session-based and rely on cookies, not on tokens. By the way, both are vulnerable to CSRF, so disabling CSRF protection in a filter-chain with any of them is not reasonable.</p>\n<p>The tokens <strong>issued by the authorization server</strong> (the app with <code>formLogin</code>) <strong>to an OAuth2 client</strong> (app with <code>oauth2Login</code> and a registration for the <code>authorization_code</code> flow, or <code>oauth2Client</code> and a registration for <code>client_credentials</code>) can be used only to <strong>authorize requests to OAuth2 resource servers</strong> (apps with <code>oauth2ResourceServer</code>).</p>\n<p>OAuth2 is a three actors dance, and only resource servers are stateless (no session, making them immune to CSRF attacks). The authorization server needs session to maintain the user state (logged in or not), and the OAuth2 client to persist the tokens it uses to authorize its requests to resource servers.</p>\n<p>You should consider:</p>\n<ul>\n<li>using an already implemented authorization server: Keycloak, Auth0, Amazon Cognito, or whatever your cloud provider proposes (if it does). This is much less work, and you apparently don't have enough OAuth2 and web-security background to build one yourself with Spring Authorization Server framework.</li>\n<li>configure your REST API with <code>oauth2ResourceServer</code>, disabling sessions and protection against CSRF. That will make it super scalable, and you'll be able to query it with Postman and tokens</li>\n<li>as <strong>users can't <em>&quot;login&quot;</em> to a stateless app</strong>, you'll need an OAuth2 client too. This cloud be:\n<ul>\n<li>a single page or mobile application configured as <em>&quot;public&quot;</em> OAuth2 client (<a href=\"https://github.com/spring-projects/spring-authorization-server/issues/297#issue-896744390\" rel=\"nofollow noreferrer\">not recommended</a>)</li>\n<li>an app rendering templates on the server (with Thymeleaf, JSP,...) and using a REST client to call the resource server</li>\n<li>an OAuth2 BFF standing between a single page or mobile application and the resource server(s) to bridge bewteen session-based and token-based authorizations.</li>\n<li>Postman</li>\n</ul>\n</li>\n</ul>\n<p>You may also keep the REST API configured with <code>oauth2Login</code> instead of <code>oauth2ResourceServer</code>, but:</p>\n<ul>\n<li>access tokens will never be used (no resource server to call with it), which makes it worth reconsidering the usage of OAuth2</li>\n<li>you'll have to set the session cookie and X_XSRF_TOKEN header for Postman requests to be authorized</li>\n<li>it won't scale easily (you'll need something to share sessions between instances)</li>\n</ul>\n<p>I wrote articles on Baeldung for:</p>\n<ul>\n<li><a href=\"https://www.baeldung.com/spring-cloud-gateway-bff-oauth2\" rel=\"nofollow noreferrer\">implementing the OAuth2 BFF pattern with Spring Cloud Gateway</a></li>\n<li><a href=\"https://www.baeldung.com/spring-boot-keycloak\" rel=\"nofollow noreferrer\">getting started with Keycloak and Spring</a></li>\n</ul>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 308139,
      "reputation" : 13879,
      "user_id" : 619830,
      "user_type" : "registered",
      "accept_rate" : 75,
      "profile_image" : "https://www.gravatar.com/avatar/f4d00b0a82e9307b1d68b29867fee4e5?s=256&d=identicon&r=PG",
      "display_name" : "ch4mp",
      "link" : "https://stackoverflow.com/users/619830/ch4mp"
    },
    "creation_date" : 1744256956,
    "last_activity_date" : 1744275270,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}