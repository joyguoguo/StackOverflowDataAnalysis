{
  "question" : {
    "question_id" : 79810625,
    "title" : "No context is current or a function that is not available in the current context was called",
    "body" : "<p>I'm trying to learn Nuklear. I have seen others with this issue, but I have added both <code>GL.create capabilities</code> and <code>glfwmakecontextcurrent</code>, as well as set up <code>version_major</code> and <code>version_minor</code>. So I don't know what's causing it.</p>\n<p>I've also tried changing the version from 3.3 to more recent ones, but that didn't help. It's to do with loading an image, without the image loading lines in <code>Console</code> class it works, but with them it spits out this error:</p>\n<pre><code>FATAL ERROR in native method: Thread[main,5,main]: No context is current or a function that is not available in the current context was called. The JVM will abort execution.\n    at org.lwjgl.opengl.GL11C.nglGenTextures(Native Method)\n    at org.lwjgl.opengl.GL11C.glGenTextures(GL11C.java:667)\n    at org.lwjgl.opengl.GL11.glGenTextures(GL11.java:2439)\n    at test.Texture.generateTexture(Texture.java:57)\n    at test.Texture.&lt;init&gt;(Texture.java:42)\n    at test.Console.&lt;init&gt;(Console.java:36)\n    at test.GLFWDemo.&lt;init&gt;(GLFWDemo.java:83)\n    at test.GLFWDemo.main(GLFWDemo.java:53)\n</code></pre>\n<hr />\n<p>Console class</p>\n<pre><code>class Console {\n    \n    private NkRect windowRect = null;\n    private String windowName = &quot;Console&quot;;\n    private int windowOptions = NK_WINDOW_TITLE|NK_WINDOW_BORDER|NK_WINDOW_MINIMIZABLE|NK_WINDOW_CLOSABLE | NK_WINDOW_MOVABLE| NK_WINDOW_SCALABLE;\n    \n    \n    Texture imageTexture = new Texture(&quot;src/main/java/test/cubemap.png&quot;);\n    //\n    // OpenGL texture loading code\n    //\n    NkColor blue = NkColor.create().set((byte)0x00, (byte)0x00, (byte)0xFF, (byte)0xFF);\n    NkColor red = NkColor.create().set((byte)0xFF, (byte)0x00, (byte)0x00, (byte)0xFF);\n    NkColor white = NkColor.create().set((byte)0xFF, (byte)0xFF, (byte)0xFF, (byte)0xFF);\n    NkImage image = NkImage.create();\n    \n    Console(){\n        \n    }\n    \n    void layout(NkContext ctx, int x, int y) {\n        \n        image.handle(it -&gt; it.id(imageTexture.getTextureId())); // this line breaks it\n        //other styling here\n        if(windowRect == null) {\n            // Create the rectangle that represents\n            windowRect = NkRect.create();\n            nk_rect(10, 10, 300, 200, windowRect);\n\n            // Draw the window just once to create it\n            nk_begin(ctx, windowName, windowRect, windowOptions);\n            nk_end(ctx);\n        } else if(!nk_window_is_closed(ctx, windowName)) {\n            if(nk_begin(ctx, windowName, windowRect, windowOptions)) {\n                // Widgets in here\n            }\n            nk_end(ctx);\n        }\n    }\n\n}\n</code></pre>\n<hr />\n<p>Texture class</p>\n<pre><code>public class Texture {\n\n     private int textureId;\n        private String texturePath;\n        private int imageW;\n        private int imageH;\n\n\n        public Texture(int width, int height, ByteBuffer buf) {\n            this.texturePath = &quot;&quot;;\n            generateTexture(width, height, buf);\n        }\n\n        public Texture(String texturePath) {\n            try (MemoryStack stack = MemoryStack.stackPush()) {\n                this.texturePath = texturePath;\n                IntBuffer w = stack.mallocInt(1);\n                IntBuffer h = stack.mallocInt(1);\n                IntBuffer channels = stack.mallocInt(1);\n\n                ByteBuffer buf = stbi_load(texturePath, w, h, channels, 4);\n                if (buf == null) {\n                    throw new RuntimeException(&quot;Image file [&quot; + texturePath + &quot;] not loaded: &quot; + stbi_failure_reason());\n                }\n\n                int width = w.get();\n                int height = h.get();\n\n                generateTexture(width, height, buf);\n\n                stbi_image_free(buf);\n            }\n        }\n\n        public void bind() {\n            glBindTexture(GL_TEXTURE_2D, textureId);\n        }\n\n        public void cleanup() {\n            glDeleteTextures(textureId);\n        }\n\n        private void generateTexture(int width, int height, ByteBuffer buf) {\n            textureId = glGenTextures();\n            imageW = width;\n            imageH = height;\n\n            glBindTexture(GL_TEXTURE_2D, textureId);\n            glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0,\n                    GL_RGBA, GL_UNSIGNED_BYTE, buf);\n            glGenerateMipmap(GL_TEXTURE_2D);\n        }\n\n        public String getTexturePath() {\n            return texturePath;\n        }\n        \n        public int getTextureId() {\n            return textureId;\n        }\n        \n        public int getHeight() {\n            return imageH;\n        }\n        \n        public int getWidth() {\n            return imageW;\n        }\n\n}\n</code></pre>\n<hr />\n<p>Window class</p>\n<pre><code>public class GLFWDemo {\n\n    private static final int BUFFER_INITIAL_SIZE = 4 * 1024;\n\n    private static final int MAX_VERTEX_BUFFER  = 512 * 1024;\n    private static final int MAX_ELEMENT_BUFFER = 128 * 1024;\n\n    private static final NkAllocator ALLOCATOR;\n\n    private static final NkDrawVertexLayoutElement.Buffer VERTEX_LAYOUT;\n\n    static {\n        ALLOCATOR = NkAllocator.create()\n            .alloc((handle, old, size) -&gt; nmemAllocChecked(size))\n            .mfree((handle, ptr) -&gt; nmemFree(ptr));\n\n        VERTEX_LAYOUT = NkDrawVertexLayoutElement.create(4)\n            .position(0).attribute(NK_VERTEX_POSITION).format(NK_FORMAT_FLOAT).offset(0)\n            .position(1).attribute(NK_VERTEX_TEXCOORD).format(NK_FORMAT_FLOAT).offset(8)\n            .position(2).attribute(NK_VERTEX_COLOR).format(NK_FORMAT_R8G8B8A8).offset(16)\n            .position(3).attribute(NK_VERTEX_ATTRIBUTE_COUNT).format(NK_FORMAT_COUNT).offset(0)\n            .flip();\n    }\n\n    public static void main(String[] args) {\n        new GLFWDemo().run();\n    }\n\n    private final ByteBuffer ttf;\n\n    private long win;\n\n    private int\n        width,\n        height;\n\n    private int\n        display_width,\n        display_height;\n\n    private NkContext  ctx          = NkContext.create();\n    private NkUserFont default_font = NkUserFont.create();\n\n    private NkBuffer          cmds         = NkBuffer.create();\n    private NkDrawNullTexture null_texture = NkDrawNullTexture.create();\n\n    private int vbo, vao, ebo;\n    private int prog;\n    private int vert_shdr;\n    private int frag_shdr;\n    private int uniform_tex;\n    private int uniform_proj;\n\n    private final Demo       demo = new Demo();\n    private final Calculator calc = new Calculator();\n    private final Console console = new Console();\n\n    public GLFWDemo() {\n        try {\n            //digital normal is good\n            //din is good\n            //long german one is really good\n            \n            this.ttf = IOUtil.ioResourceToByteBuffer(&quot;test/AlteDin1451Mittelschrift-gBdP.ttf&quot;, 512 * 1024);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private void run() {\n        GLFWErrorCallback.createPrint().set();\n        if (!glfwInit()) {\n            throw new IllegalStateException(&quot;Unable to initialize glfw&quot;);\n        }\n\n        glfwDefaultWindowHints();\n        glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE);\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);\n        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n        if (glfwGetPlatform() == GLFW_PLATFORM_COCOA) {\n            glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE);\n        }\n        glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GLFW_TRUE);\n\n        int WINDOW_WIDTH  = 640;\n        int WINDOW_HEIGHT = 640;\n\n        win = glfwCreateWindow(WINDOW_WIDTH, WINDOW_HEIGHT, &quot;GLFW Nuklear Demo&quot;, NULL, NULL);\n        if (win == NULL) {\n            throw new RuntimeException(&quot;Failed to create the GLFW window&quot;);\n        }\n\n        glfwMakeContextCurrent(win);\n        GLCapabilities caps      = GL.createCapabilities();\n        Callback       debugProc = GLUtil.setupDebugMessageCallback();\n\n        if (caps.OpenGL43) {\n            GL43.glDebugMessageControl(GL43.GL_DEBUG_SOURCE_API, GL43.GL_DEBUG_TYPE_OTHER, GL43.GL_DEBUG_SEVERITY_NOTIFICATION, (IntBuffer)null, false);\n        } else if (caps.GL_KHR_debug) {\n            KHRDebug.glDebugMessageControl(\n                KHRDebug.GL_DEBUG_SOURCE_API,\n                KHRDebug.GL_DEBUG_TYPE_OTHER,\n                KHRDebug.GL_DEBUG_SEVERITY_NOTIFICATION,\n                (IntBuffer)null,\n                false\n            );\n        } else if (caps.GL_ARB_debug_output) {\n            glDebugMessageControlARB(GL_DEBUG_SOURCE_API_ARB, GL_DEBUG_TYPE_OTHER_ARB, GL_DEBUG_SEVERITY_LOW_ARB, (IntBuffer)null, false);\n        }\n\n        NkContext ctx = setupWindow(win);\n\n        int BITMAP_W = 1024;\n        int BITMAP_H = 1024;\n\n        int FONT_HEIGHT = 18;\n        int fontTexID   = glGenTextures();\n\n        STBTTFontinfo          fontInfo = STBTTFontinfo.create();\n        STBTTPackedchar.Buffer cdata    = STBTTPackedchar.create(95);\n\n        float scale;\n        float descent;\n\n        try (MemoryStack stack = stackPush()) {\n            stbtt_InitFont(fontInfo, ttf);\n            scale = stbtt_ScaleForPixelHeight(fontInfo, FONT_HEIGHT);\n\n            IntBuffer d = stack.mallocInt(1);\n            stbtt_GetFontVMetrics(fontInfo, null, d, null);\n            descent = d.get(0) * scale;\n\n            ByteBuffer bitmap = memAlloc(BITMAP_W * BITMAP_H);\n\n            STBTTPackContext pc = STBTTPackContext.malloc(stack);\n            stbtt_PackBegin(pc, bitmap, BITMAP_W, BITMAP_H, 0, 1, NULL);\n            stbtt_PackSetOversampling(pc, 4, 4);\n            stbtt_PackFontRange(pc, ttf, 0, FONT_HEIGHT, 32, cdata);\n            stbtt_PackEnd(pc);\n\n            // Convert R8 to RGBA8\n            ByteBuffer texture = memAlloc(BITMAP_W * BITMAP_H * 4);\n            for (int i = 0; i &lt; bitmap.capacity(); i++) {\n                texture.putInt((bitmap.get(i) &lt;&lt; 24) | 0x00FFFFFF);\n            }\n            texture.flip();\n\n            glBindTexture(GL_TEXTURE_2D, fontTexID);\n            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, BITMAP_W, BITMAP_H, 0, GL_RGBA, GL_UNSIGNED_INT_8_8_8_8_REV, texture);\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\n            memFree(texture);\n            memFree(bitmap);\n        }\n\n        default_font\n            .width((handle, h, text, len) -&gt; {\n                float text_width = 0;\n                try (MemoryStack stack = stackPush()) {\n                    IntBuffer unicode = stack.mallocInt(1);\n\n                    int glyph_len = nnk_utf_decode(text, memAddress(unicode), len);\n                    int text_len  = glyph_len;\n\n                    if (glyph_len == 0) {\n                        return 0;\n                    }\n\n                    IntBuffer advance = stack.mallocInt(1);\n                    while (text_len &lt;= len &amp;&amp; glyph_len != 0) {\n                        if (unicode.get(0) == NK_UTF_INVALID) {\n                            break;\n                        }\n\n                        /* query currently drawn glyph information */\n                        stbtt_GetCodepointHMetrics(fontInfo, unicode.get(0), advance, null);\n                        text_width += advance.get(0) * scale;\n\n                        /* offset next glyph */\n                        glyph_len = nnk_utf_decode(text + text_len, memAddress(unicode), len - text_len);\n                        text_len += glyph_len;\n                    }\n                }\n                return text_width;\n            })\n            .height(FONT_HEIGHT)\n            .query((handle, font_height, glyph, codepoint, next_codepoint) -&gt; {\n                try (MemoryStack stack = stackPush()) {\n                    FloatBuffer x = stack.floats(0.0f);\n                    FloatBuffer y = stack.floats(0.0f);\n\n                    STBTTAlignedQuad q       = STBTTAlignedQuad.malloc(stack);\n                    IntBuffer        advance = stack.mallocInt(1);\n\n                    stbtt_GetPackedQuad(cdata, BITMAP_W, BITMAP_H, codepoint - 32, x, y, q, false);\n                    stbtt_GetCodepointHMetrics(fontInfo, codepoint, advance, null);\n\n                    NkUserFontGlyph ufg = NkUserFontGlyph.create(glyph);\n\n                    ufg.width(q.x1() - q.x0());\n                    ufg.height(q.y1() - q.y0());\n                    ufg.offset().set(q.x0(), q.y0() + (FONT_HEIGHT + descent));\n                    ufg.xadvance(advance.get(0) * scale);\n                    ufg.uv(0).set(q.s0(), q.t0());\n                    ufg.uv(1).set(q.s1(), q.t1());\n                }\n            })\n            .texture(it -&gt; it\n                .id(fontTexID));\n\n        nk_style_set_font(ctx, default_font);\n\n        glfwShowWindow(win);\n        while (!glfwWindowShouldClose(win)) {\n            /* Input */\n            newFrame();\n\n            demo.layout(ctx, 50, 50);\n            calc.layout(ctx, 300, 50);\n            console.layout(ctx, 60, 60);\n\n            try (MemoryStack stack = stackPush()) {\n                IntBuffer width  = stack.mallocInt(1);\n                IntBuffer height = stack.mallocInt(1);\n\n                glfwGetWindowSize(win, width, height);\n                glViewport(0, 0, width.get(0), height.get(0));\n\n                NkColorf bg = demo.background;\n                glClearColor(bg.r(), bg.g(), bg.b(), bg.a());\n            }\n            glClear(GL_COLOR_BUFFER_BIT);\n            /*\n             * IMPORTANT: `nk_glfw_render` modifies some global OpenGL state\n             * with blending, scissor, face culling, depth test and viewport and\n             * defaults everything back into a default state.\n             * Make sure to either a.) save and restore or b.) reset your own state after\n             * rendering the UI.\n             */\n            render(NK_ANTI_ALIASING_ON, MAX_VERTEX_BUFFER, MAX_ELEMENT_BUFFER);\n            glfwSwapBuffers(win);\n        }\n\n        shutdown();\n\n        glfwFreeCallbacks(win);\n        if (debugProc != null) {\n            debugProc.free();\n        }\n        glfwTerminate();\n        Objects.requireNonNull(glfwSetErrorCallback(null)).free();\n    }\n\n    private void setupContext() {\n        String NK_SHADER_VERSION = Platform.get() == Platform.MACOSX ? &quot;#version 150\\n&quot; : &quot;#version 300 es\\n&quot;;\n        String vertex_shader =\n            NK_SHADER_VERSION +\n            &quot;uniform mat4 ProjMtx;\\n&quot; +\n            &quot;in vec2 Position;\\n&quot; +\n            &quot;in vec2 TexCoord;\\n&quot; +\n            &quot;in vec4 Color;\\n&quot; +\n            &quot;out vec2 Frag_UV;\\n&quot; +\n            &quot;out vec4 Frag_Color;\\n&quot; +\n            &quot;void main() {\\n&quot; +\n            &quot;   Frag_UV = TexCoord;\\n&quot; +\n            &quot;   Frag_Color = Color;\\n&quot; +\n            &quot;   gl_Position = ProjMtx * vec4(Position.xy, 0, 1);\\n&quot; +\n            &quot;}\\n&quot;;\n        String fragment_shader =\n            NK_SHADER_VERSION +\n            &quot;precision mediump float;\\n&quot; +\n            &quot;uniform sampler2D Texture;\\n&quot; +\n            &quot;in vec2 Frag_UV;\\n&quot; +\n            &quot;in vec4 Frag_Color;\\n&quot; +\n            &quot;out vec4 Out_Color;\\n&quot; +\n            &quot;void main(){\\n&quot; +\n            &quot;   Out_Color = Frag_Color * texture(Texture, Frag_UV.st);\\n&quot; +\n            &quot;}\\n&quot;;\n\n        nk_buffer_init(cmds, ALLOCATOR, BUFFER_INITIAL_SIZE);\n        prog = glCreateProgram();\n        vert_shdr = glCreateShader(GL_VERTEX_SHADER);\n        frag_shdr = glCreateShader(GL_FRAGMENT_SHADER);\n        glShaderSource(vert_shdr, vertex_shader);\n        glShaderSource(frag_shdr, fragment_shader);\n        glCompileShader(vert_shdr);\n        glCompileShader(frag_shdr);\n        if (glGetShaderi(vert_shdr, GL_COMPILE_STATUS) != GL_TRUE) {\n            throw new IllegalStateException();\n        }\n        if (glGetShaderi(frag_shdr, GL_COMPILE_STATUS) != GL_TRUE) {\n            throw new IllegalStateException();\n        }\n        glAttachShader(prog, vert_shdr);\n        glAttachShader(prog, frag_shdr);\n        glLinkProgram(prog);\n        if (glGetProgrami(prog, GL_LINK_STATUS) != GL_TRUE) {\n            throw new IllegalStateException();\n        }\n\n        uniform_tex = glGetUniformLocation(prog, &quot;Texture&quot;);\n        uniform_proj = glGetUniformLocation(prog, &quot;ProjMtx&quot;);\n        int attrib_pos = glGetAttribLocation(prog, &quot;Position&quot;);\n        int attrib_uv  = glGetAttribLocation(prog, &quot;TexCoord&quot;);\n        int attrib_col = glGetAttribLocation(prog, &quot;Color&quot;);\n\n        {\n            // buffer setup\n            vbo = glGenBuffers();\n            ebo = glGenBuffers();\n            vao = glGenVertexArrays();\n\n            glBindVertexArray(vao);\n            glBindBuffer(GL_ARRAY_BUFFER, vbo);\n            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);\n\n            glEnableVertexAttribArray(attrib_pos);\n            glEnableVertexAttribArray(attrib_uv);\n            glEnableVertexAttribArray(attrib_col);\n\n            glVertexAttribPointer(attrib_pos, 2, GL_FLOAT, false, 20, 0);\n            glVertexAttribPointer(attrib_uv, 2, GL_FLOAT, false, 20, 8);\n            glVertexAttribPointer(attrib_col, 4, GL_UNSIGNED_BYTE, true, 20, 16);\n        }\n\n        {\n            // null texture setup\n            int nullTexID = glGenTextures();\n\n            null_texture.texture().id(nullTexID);\n            null_texture.uv().set(0.5f, 0.5f);\n\n            glBindTexture(GL_TEXTURE_2D, nullTexID);\n            try (MemoryStack stack = stackPush()) {\n                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, 1, 1, 0, GL_RGBA, GL_UNSIGNED_INT_8_8_8_8_REV, stack.ints(0xFFFFFFFF));\n            }\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n        }\n\n        glBindTexture(GL_TEXTURE_2D, 0);\n        glBindBuffer(GL_ARRAY_BUFFER, 0);\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n        glBindVertexArray(0);\n    }\n\n    private NkContext setupWindow(long win) {\n        glfwSetScrollCallback(win, (window, xoffset, yoffset) -&gt; {\n            try (MemoryStack stack = stackPush()) {\n                NkVec2 scroll = NkVec2.malloc(stack)\n                    .x((float)xoffset)\n                    .y((float)yoffset);\n                nk_input_scroll(ctx, scroll);\n            }\n        });\n        glfwSetCharCallback(win, (window, codepoint) -&gt; nk_input_unicode(ctx, codepoint));\n        glfwSetKeyCallback(win, (window, key, scancode, action, mods) -&gt; {\n            boolean press = action == GLFW_PRESS;\n            switch (key) {\n                case GLFW_KEY_ESCAPE:\n                    glfwSetWindowShouldClose(window, true);\n                    break;\n                case GLFW_KEY_DELETE:\n                    nk_input_key(ctx, NK_KEY_DEL, press);\n                    break;\n                case GLFW_KEY_ENTER:\n                    nk_input_key(ctx, NK_KEY_ENTER, press);\n                    break;\n                case GLFW_KEY_TAB:\n                    nk_input_key(ctx, NK_KEY_TAB, press);\n                    break;\n                case GLFW_KEY_BACKSPACE:\n                    nk_input_key(ctx, NK_KEY_BACKSPACE, press);\n                    break;\n                case GLFW_KEY_UP:\n                    nk_input_key(ctx, NK_KEY_UP, press);\n                    break;\n                case GLFW_KEY_DOWN:\n                    nk_input_key(ctx, NK_KEY_DOWN, press);\n                    break;\n                case GLFW_KEY_HOME:\n                    nk_input_key(ctx, NK_KEY_TEXT_START, press);\n                    nk_input_key(ctx, NK_KEY_SCROLL_START, press);\n                    break;\n                case GLFW_KEY_END:\n                    nk_input_key(ctx, NK_KEY_TEXT_END, press);\n                    nk_input_key(ctx, NK_KEY_SCROLL_END, press);\n                    break;\n                case GLFW_KEY_PAGE_DOWN:\n                    nk_input_key(ctx, NK_KEY_SCROLL_DOWN, press);\n                    break;\n                case GLFW_KEY_PAGE_UP:\n                    nk_input_key(ctx, NK_KEY_SCROLL_UP, press);\n                    break;\n                case GLFW_KEY_LEFT_SHIFT:\n                case GLFW_KEY_RIGHT_SHIFT:\n                    nk_input_key(ctx, NK_KEY_SHIFT, press);\n                    break;\n                case GLFW_KEY_LEFT_CONTROL:\n                case GLFW_KEY_RIGHT_CONTROL:\n                    if (press) {\n                        nk_input_key(ctx, NK_KEY_COPY, glfwGetKey(window, GLFW_KEY_C) == GLFW_PRESS);\n                        nk_input_key(ctx, NK_KEY_PASTE, glfwGetKey(window, GLFW_KEY_P) == GLFW_PRESS);\n                        nk_input_key(ctx, NK_KEY_CUT, glfwGetKey(window, GLFW_KEY_X) == GLFW_PRESS);\n                        nk_input_key(ctx, NK_KEY_TEXT_UNDO, glfwGetKey(window, GLFW_KEY_Z) == GLFW_PRESS);\n                        nk_input_key(ctx, NK_KEY_TEXT_REDO, glfwGetKey(window, GLFW_KEY_R) == GLFW_PRESS);\n                        nk_input_key(ctx, NK_KEY_TEXT_WORD_LEFT, glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS);\n                        nk_input_key(ctx, NK_KEY_TEXT_WORD_RIGHT, glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS);\n                        nk_input_key(ctx, NK_KEY_TEXT_LINE_START, glfwGetKey(window, GLFW_KEY_B) == GLFW_PRESS);\n                        nk_input_key(ctx, NK_KEY_TEXT_LINE_END, glfwGetKey(window, GLFW_KEY_E) == GLFW_PRESS);\n                    } else {\n                        nk_input_key(ctx, NK_KEY_LEFT, glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS);\n                        nk_input_key(ctx, NK_KEY_RIGHT, glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS);\n                        nk_input_key(ctx, NK_KEY_COPY, false);\n                        nk_input_key(ctx, NK_KEY_PASTE, false);\n                        nk_input_key(ctx, NK_KEY_CUT, false);\n                        nk_input_key(ctx, NK_KEY_SHIFT, false);\n                    }\n                    break;\n            }\n        });\n        glfwSetCursorPosCallback(win, (window, xpos, ypos) -&gt; nk_input_motion(ctx, (int)xpos, (int)ypos));\n        glfwSetMouseButtonCallback(win, (window, button, action, mods) -&gt; {\n            try (MemoryStack stack = stackPush()) {\n                DoubleBuffer cx = stack.mallocDouble(1);\n                DoubleBuffer cy = stack.mallocDouble(1);\n\n                glfwGetCursorPos(window, cx, cy);\n\n                int x = (int)cx.get(0);\n                int y = (int)cy.get(0);\n\n                int nkButton;\n                switch (button) {\n                    case GLFW_MOUSE_BUTTON_RIGHT:\n                        nkButton = NK_BUTTON_RIGHT;\n                        break;\n                    case GLFW_MOUSE_BUTTON_MIDDLE:\n                        nkButton = NK_BUTTON_MIDDLE;\n                        break;\n                    default:\n                        nkButton = NK_BUTTON_LEFT;\n                }\n                nk_input_button(ctx, nkButton, x, y, action == GLFW_PRESS);\n            }\n        });\n\n        nk_init(ctx, ALLOCATOR, null);\n        ctx.clip()\n            .copy((handle, text, len) -&gt; {\n                if (len == 0) {\n                    return;\n                }\n\n                try (MemoryStack stack = stackPush()) {\n                    ByteBuffer str = stack.malloc(len + 1);\n                    memCopy(text, memAddress(str), len);\n                    str.put(len, (byte)0);\n\n                    glfwSetClipboardString(win, str);\n                }\n            })\n            .paste((handle, edit) -&gt; {\n                long text = nglfwGetClipboardString(win);\n                if (text != NULL) {\n                    nnk_textedit_paste(edit, text, nnk_strlen(text));\n                }\n            });\n\n        setupContext();\n        return ctx;\n    }\n\n    private void newFrame() {\n        try (MemoryStack stack = stackPush()) {\n            IntBuffer w = stack.mallocInt(1);\n            IntBuffer h = stack.mallocInt(1);\n\n            glfwGetWindowSize(win, w, h);\n            width = w.get(0);\n            height = h.get(0);\n\n            glfwGetFramebufferSize(win, w, h);\n            display_width = w.get(0);\n            display_height = h.get(0);\n        }\n\n        nk_input_begin(ctx);\n        glfwPollEvents();\n\n        NkMouse mouse = ctx.input().mouse();\n        if (mouse.grab()) {\n            glfwSetInputMode(win, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);\n        } else if (mouse.grabbed()) {\n            float prevX = mouse.prev().x();\n            float prevY = mouse.prev().y();\n            glfwSetCursorPos(win, prevX, prevY);\n            mouse.pos().x(prevX);\n            mouse.pos().y(prevY);\n        } else if (mouse.ungrab()) {\n            glfwSetInputMode(win, GLFW_CURSOR, GLFW_CURSOR_NORMAL);\n        }\n\n        nk_input_end(ctx);\n    }\n\n    private void render(int AA, int max_vertex_buffer, int max_element_buffer) {\n        try (MemoryStack stack = stackPush()) {\n            // setup global state\n            glEnable(GL_BLEND);\n            glBlendEquation(GL_FUNC_ADD);\n            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n            glDisable(GL_CULL_FACE);\n            glDisable(GL_DEPTH_TEST);\n            glEnable(GL_SCISSOR_TEST);\n            glActiveTexture(GL_TEXTURE0);\n\n            // setup program\n            glUseProgram(prog);\n            glUniform1i(uniform_tex, 0);\n            glUniformMatrix4fv(uniform_proj, false, stack.floats(\n                2.0f / width, 0.0f, 0.0f, 0.0f,\n                0.0f, -2.0f / height, 0.0f, 0.0f,\n                0.0f, 0.0f, -1.0f, 0.0f,\n                -1.0f, 1.0f, 0.0f, 1.0f\n            ));\n            glViewport(0, 0, display_width, display_height);\n        }\n\n        {\n            // convert from command queue into draw list and draw to screen\n\n            // allocate vertex and element buffer\n            glBindVertexArray(vao);\n            glBindBuffer(GL_ARRAY_BUFFER, vbo);\n            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);\n\n            glBufferData(GL_ARRAY_BUFFER, max_vertex_buffer, GL_STREAM_DRAW);\n            glBufferData(GL_ELEMENT_ARRAY_BUFFER, max_element_buffer, GL_STREAM_DRAW);\n\n            // load draw vertices &amp; elements directly into vertex + element buffer\n            ByteBuffer vertices = Objects.requireNonNull(glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY, max_vertex_buffer, null));\n            ByteBuffer elements = Objects.requireNonNull(glMapBuffer(GL_ELEMENT_ARRAY_BUFFER, GL_WRITE_ONLY, max_element_buffer, null));\n            try (MemoryStack stack = stackPush()) {\n                // fill convert configuration\n                NkConvertConfig config = NkConvertConfig.calloc(stack)\n                    .vertex_layout(VERTEX_LAYOUT)\n                    .vertex_size(20)\n                    .vertex_alignment(4)\n                    .tex_null(null_texture)\n                    .circle_segment_count(22)\n                    .curve_segment_count(22)\n                    .arc_segment_count(22)\n                    .global_alpha(1.0f)\n                    .shape_AA(AA)\n                    .line_AA(AA);\n\n                // setup buffers to load vertices and elements\n                NkBuffer vbuf = NkBuffer.malloc(stack);\n                NkBuffer ebuf = NkBuffer.malloc(stack);\n\n                nk_buffer_init_fixed(vbuf, vertices/*, max_vertex_buffer*/);\n                nk_buffer_init_fixed(ebuf, elements/*, max_element_buffer*/);\n                nk_convert(ctx, cmds, vbuf, ebuf, config);\n            }\n            glUnmapBuffer(GL_ELEMENT_ARRAY_BUFFER);\n            glUnmapBuffer(GL_ARRAY_BUFFER);\n\n            // iterate over and execute each draw command\n            float fb_scale_x = (float)display_width / (float)width;\n            float fb_scale_y = (float)display_height / (float)height;\n\n            long offset = NULL;\n            for (NkDrawCommand cmd = nk__draw_begin(ctx, cmds); cmd != null; cmd = nk__draw_next(cmd, cmds, ctx)) {\n                if (cmd.elem_count() == 0) {\n                    continue;\n                }\n                glBindTexture(GL_TEXTURE_2D, cmd.texture().id());\n                glScissor(\n                    (int)(cmd.clip_rect().x() * fb_scale_x),\n                    (int)((height - (int)(cmd.clip_rect().y() + cmd.clip_rect().h())) * fb_scale_y),\n                    (int)(cmd.clip_rect().w() * fb_scale_x),\n                    (int)(cmd.clip_rect().h() * fb_scale_y)\n                );\n                glDrawElements(GL_TRIANGLES, cmd.elem_count(), GL_UNSIGNED_SHORT, offset);\n                offset += cmd.elem_count() * 2;\n            }\n            nk_clear(ctx);\n            nk_buffer_clear(cmds);\n        }\n\n        // default OpenGL state\n        glUseProgram(0);\n        glBindBuffer(GL_ARRAY_BUFFER, 0);\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);\n        glBindVertexArray(0);\n        glDisable(GL_BLEND);\n        glDisable(GL_SCISSOR_TEST);\n    }\n\n    private void destroy() {\n        glDetachShader(prog, vert_shdr);\n        glDetachShader(prog, frag_shdr);\n        glDeleteShader(vert_shdr);\n        glDeleteShader(frag_shdr);\n        glDeleteProgram(prog);\n        glDeleteTextures(default_font.texture().id());\n        glDeleteTextures(null_texture.texture().id());\n        glDeleteBuffers(vbo);\n        glDeleteBuffers(ebo);\n        nk_buffer_free(cmds);\n\n        GL.setCapabilities(null);\n    }\n\n    private void shutdown() {\n        Objects.requireNonNull(ctx.clip().copy()).free();\n        Objects.requireNonNull(ctx.clip().paste()).free();\n        nk_free(ctx);\n        destroy();\n        Objects.requireNonNull(default_font.query()).free();\n        Objects.requireNonNull(default_font.width()).free();\n\n        calc.numberFilter.free();\n\n        Objects.requireNonNull(ALLOCATOR.alloc()).free();\n        Objects.requireNonNull(ALLOCATOR.mfree()).free();\n    }\n\n}\n</code></pre>\n",
    "tags" : [ "java", "opengl", "lwjgl", "glfw", "nuklear" ],
    "owner" : {
      "account_id" : 34685663,
      "reputation" : 1,
      "user_id" : 26711850,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/J7zmyh2C.jpg?s=256",
      "display_name" : "Circle",
      "link" : "https://stackoverflow.com/users/26711850/circle"
    },
    "is_answered" : false,
    "view_count" : 84,
    "answer_count" : 0,
    "score" : -3,
    "last_activity_date" : 1762394790,
    "creation_date" : 1762378162,
    "link" : "https://stackoverflow.com/questions/79810625/no-context-is-current-or-a-function-that-is-not-available-in-the-current-context",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140841637,
    "post_id" : 79810625,
    "body" : "This page should not be resolved via comments. Instead, someone should post a resolving answer or the community should vote to close the page with a valid reason.",
    "score" : 0,
    "owner" : {
      "account_id" : 3521176,
      "reputation" : 49237,
      "user_id" : 2943403,
      "user_type" : "moderator",
      "profile_image" : "https://i.sstatic.net/1nKmA.jpg?s=256",
      "display_name" : "mickmackusa",
      "link" : "https://stackoverflow.com/users/2943403/mickmackusa"
    },
    "creation_date" : 1762513260,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140841144,
    "post_id" : 79810625,
    "body" : "@BDL Thanks so much, such an obvious solution it works now!",
    "score" : 0,
    "owner" : {
      "account_id" : 34685663,
      "reputation" : 1,
      "user_id" : 26711850,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/J7zmyh2C.jpg?s=256",
      "display_name" : "Circle",
      "link" : "https://stackoverflow.com/users/26711850/circle"
    },
    "creation_date" : 1762491586,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140838846,
    "post_id" : 79810625,
    "body" : "Simplified example: <a href=\"https://www.programiz.com/online-compiler/5WamU6GfA3Aq6\" rel=\"nofollow noreferrer\">programiz.com/online-compiler/5WamU6GfA3Aq6</a>",
    "score" : 0,
    "owner" : {
      "account_id" : 3043323,
      "reputation" : 22409,
      "user_id" : 2579738,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/oXata.png?s=256",
      "display_name" : "BDL",
      "link" : "https://stackoverflow.com/users/2579738/bdl"
    },
    "creation_date" : 1762378660,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140838845,
    "post_id" : 79810625,
    "body" : "I&#39;m not 100% fluent in Java, but as far as I remember, member variables of a class are initialized before the constructor body is run. Since you initialize console and thus the texture from the definition line, the code will be run before anything from the run() method and thus before the context has been initialized. Put breakpoints or console outputs into the texture constructor to see that.",
    "score" : 0,
    "owner" : {
      "account_id" : 3043323,
      "reputation" : 22409,
      "user_id" : 2579738,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/oXata.png?s=256",
      "display_name" : "BDL",
      "link" : "https://stackoverflow.com/users/2579738/bdl"
    },
    "creation_date" : 1762378644,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}