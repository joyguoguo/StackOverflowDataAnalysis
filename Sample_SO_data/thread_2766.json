{
  "question" : {
    "question_id" : 79596954,
    "title" : "find maximum length of subsequence with adjancent diff less than 2",
    "body" : "<p><strong>Problem Statement:</strong></p>\n<p>You are given an array of integers arr of size n.</p>\n<p>Select a subsequence of integers and rearrange them to form a circular sequence such that the absolute difference between any two adjacent integers (including the last and first) is at most 1.</p>\n<p>Find the maximum number of integers that can be selected.</p>\n<p><strong>Notes:</strong></p>\n<p>A subsequence is formed by deleting zero or more elements without changing the order of the remaining elements.</p>\n<p>The selected integers can be rearranged in any order.</p>\n<p>The sequence is <strong>circular</strong> — the last and first integers are considered adjacent.</p>\n<p><strong>Constraints:</strong></p>\n<pre><code>1 &lt;= n &lt;= 2 × 10^5\n\n0 &lt;= arr[i] &lt;= 10^9\n</code></pre>\n<p><strong>Examples:</strong></p>\n<pre><code>Input: arr = [4, 3, 5, 1, 2, 2, 1]\nOutput: 5\nExplanation: maximum length subsequence is : [3, 1, 2, 2, 1], it can be rearranged to seq : [2, 1, 1, 2, 3] of length 5, note that the condition must be satisfied in circular also, means abs(seq[0] - seq[seq.length-1]) means abs(2-3) &lt;= 0 \n\nInput: arr = [3, 7, 5, 1, 5]\nOutput: 2\nExplanation: maximum length subsequence is : [5,5] of length 2\n\nInput: arr = [2, 2, 3, 2, 1, 2, 2]\nOutput: 7\nExplanation: maximum length subsequence is : [2,2,3,2,1,2,2] of length 7\n\nInput: arr = [1,2,3,4,5]\nOutput = 2\nExplanation: maximum length subsequence is : [1,2] or [2,3] or [3,4] or [4,5], so length is 2. \n</code></pre>\n<p>Note, that the subsequence should satisfy the circular condition also\nHere is my code:</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.util.*;\n\nclass Main {\n    public static int solve(int[] arr) {\n        Map&lt;Integer, Integer&gt; freq = new HashMap&lt;&gt;();\n        for (int num : arr) {\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\n        }\n\n        int max = 0;\n        for (int num : freq.keySet()) {\n            int count = freq.get(num);\n            int countWithNext = freq.getOrDefault(num + 1, 0);\n            int countWithPrev = freq.getOrDefault(num - 1, 0);\n            max = Math.max(max, countWithPrev + count + countWithNext);\n        }\n\n        return max;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(solve(new int[]{4,3,5,1,2,2,1})); // Expected: 5\n        System.out.println(solve(new int[]{3,7,5,1,5})); // Expected: 2\n        System.out.println(solve(new int[]{2,2,3,2,1,2,2})); // Expected: 7\n        System.out.println(solve(new int[]{1,2,3,4,5})); // Expected: 2\n    }\n}\n</code></pre>\n<p>I am able to find the maximum length subsequences, but not to find how to meet the circular condition, so for the test case [1,2,3,4,5], my code is returning 5 instead of 2.</p>\n<p>Also, the approach itself is failing for input [1,2,3,4,3,2] as commented by John Bollinger</p>\n<p>What is the correct approach to solve this with less time complexity.</p>\n",
    "tags" : [ "java", "algorithm" ],
    "owner" : {
      "account_id" : 31187804,
      "reputation" : 794,
      "user_id" : 23993901,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/7417aaad0c8ece3fac44f06d05a8ba8b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "CodeCrusader",
      "link" : "https://stackoverflow.com/users/23993901/codecrusader"
    },
    "is_answered" : true,
    "view_count" : 509,
    "answer_count" : 2,
    "score" : 4,
    "last_activity_date" : 1745871902,
    "creation_date" : 1745859163,
    "link" : "https://stackoverflow.com/questions/79596954/find-maximum-length-of-subsequence-with-adjancent-diff-less-than-2",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79597189,
    "question_id" : 79596954,
    "body" : "<blockquote>\n<p>What is the correct approach to solve this with less time complexity.</p>\n</blockquote>\n<p>Note well the hint from @btilly in comments:</p>\n<blockquote>\n<p>Your subsequence has a min, has a max, and every value between those must appear 2+ times.</p>\n</blockquote>\n<p>That's very nearly a fingerprint that you can match, but before we extend it into such a fingerprint, let's first consider why it is so.</p>\n<p>Consider a member <em>s<sub>n</sub></em> of a contiguous circular sequence that is neither its minimum value nor its maximum value.  Now suppose we traverse the cycle starting at <em>s<sub>n</sub></em>.  Before we return to <em>s<sub>n</sub></em>, we will traverse both the sequence minimum and the sequence maximum, and because the sequence is arranged contiguously, between those we must traverse another element whose value is the same as <em>s<sub>n</sub></em>.  Therefore, every member that is neither minimum nor maximum in the sequence must occur at least twice.</p>\n<p>The same is not true of minimum or maximum, however.  There <em>may</em> be multiple appearances of one or both of those, but we can still form a cycle with only one of each.  In the most trivial case, a single appearance of a single number satisfies the criteria, but we can have a single appearance each of the minimum and maximum with any overall number of elements other than exactly 3.</p>\n<p>Now suppose that we have a collection of contiguous numbers, in any order, such that there are at least two appearances of each, except possibly for the minimum and maximum among them.  We can form from them a circular sequence by first sorting them in ascending order, then taking one of each number that is neither minimum nor maximum, and shifting them to the end, in descending order.  For example,</p>\n<ul>\n<li>starting with <strong>2, 4, 3, 2, 3, 1, 3, 5, 5, 4</strong>,</li>\n<li>we sort to get <strong>1, 2, 2, 3, 3, 3, 4, 4, 5, 5</strong></li>\n<li>then we move one 4, one 3, and one 2 to the end to get <strong>1, 2, 3, 3, 4, 5, 5, 4, 3, 2</strong>, which satisfies the requirements</li>\n</ul>\n<p>It follows that for a collection of numbers to be suitable for forming the kind of circular sequence you require, <strong>it is both necessary and sufficient that (i) they are contiguous, and (ii) every number that is neither the minimum nor the maximum appears at least twice.</strong></p>\n<p>NOW you have your fingerprint.  It is possible to find the maximal sequence with that fingerprint in O(<em>n</em> log <em>n</em>) steps (worst case), but I leave it to you to work out the details.</p>\n",
    "score" : 9,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1745869574,
    "last_activity_date" : 1745869574,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79597232,
    "question_id" : 79596954,
    "body" : "<p>Your code only looks at the frequencies of the immediate &quot;neighbors&quot; (in sorted order) to determine a count. This will give wrong results when the correct answer will involve more than 3 distinct numbers.</p>\n<p>Counting frequencies is a good approach, but then scan further than only to the direct neighbors of the value at hand. It will also be helpful to only look for neighbors when you are sure you are at a low end of a potential range -- that way you only have to scan values in <em>ascending</em> order. A value is a &quot;low&quot; when either its frequency is 1 or there is no occurrence of that value minus one.</p>\n<p>Here is how the loop (after you got the frequencies) can be made to work:</p>\n<pre><code>        int max = 0;\n        for (int num : freq.keySet()) {\n            int count = freq.get(num);\n            if (count != 1 &amp;&amp; freq.containsKey(num-1)) continue;\n            // We're at a low end of a range\n            int groupCount = count;\n            do {\n                num++;\n                count = freq.getOrDefault(num, 0);\n                groupCount += count;\n            } while (count &gt; 1);\n            max = Math.max(max, groupCount);\n        }\n        return max;\n</code></pre>\n<p>Assuming that <code>get</code> and <code>put</code> operations on a hash map have a amortised time complexity of O(1), this algorithm has a O(\uD835\uDC5B) time complexity, where \uD835\uDC5B is the size of the input array.</p>\n",
    "score" : 3,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 7142980,
      "reputation" : 357178,
      "user_id" : 5459839,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/lUUgh.png?s=256",
      "display_name" : "trincot",
      "link" : "https://stackoverflow.com/users/5459839/trincot"
    },
    "creation_date" : 1745871583,
    "last_activity_date" : 1745871902,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140377455,
    "post_id" : 79596954,
    "body" : "The code presented does not do the job correctly even without the circularity constraint.  Consider input <code>1,2,3,4,3,2</code>.  The whole sequence can be selected, even with the circularity constraint, but your program returns 5 instead of 6.",
    "score" : 1,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1745861091,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140377439,
    "post_id" : 79596954,
    "body" : "By the way, a slightly more compact way to count the numbers is with <code>for (int num : arr) { freq.merge(num, 1, Math::addExact); }</code> See <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Map.html#merge(K,V,java.util.function.BiFunction)\" rel=\"nofollow noreferrer\"><code>Map::merge</code></a>",
    "score" : 0,
    "owner" : {
      "account_id" : 318670,
      "reputation" : 16467,
      "user_id" : 636009,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/IIQJV.jpg?s=256",
      "display_name" : "David Conrad",
      "link" : "https://stackoverflow.com/users/636009/david-conrad"
    },
    "creation_date" : 1745860929,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}