{
  "question" : {
    "question_id" : 79786308,
    "title" : "Angular + Spring Boot: file download blocks until fully received (needs “save as” first, then stream in background)",
    "body" : "<p>I have an Angular frontend calling a Spring Boot endpoint that returns a CSV (with JWT auth). The download currently does not start immediately: the browser finishes downloading the whole file in the background, the UI feels blocked until file gets downladed (without “Save As…” dialog pops up). I need the opposite flow: prompt the user first to pick the location/name, then stream the bytes to disk in the background while the user can keep using the app.</p>\n<p><strong>Backend (Spring)</strong></p>\n<pre class=\"lang-java prettyprint-override\"><code>public ResponseEntity&lt;ByteArrayResource&gt; downloadFeedbackCsv(String search, HttpServletRequest request) {\n    List&lt;Feedback&gt; rows = feedbackService.findAllForExport(search, request);\n\n    String csvContent = generateFeedbackCsv(rows);\n    byte[] bytes = csvContent.getBytes(StandardCharsets.UTF_8);\n    ByteArrayResource resource = new ByteArrayResource(bytes);\n\n    String fileName = &quot;feedback&quot; + nowStamp() + &quot;.csv&quot;;\n\n    HttpHeaders headers = new HttpHeaders();\n    headers.add(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment; filename=\\&quot;&quot; + fileName + &quot;\\&quot;&quot;);\n    headers.add(&quot;File-Name&quot;, fileName);\n    headers.add(&quot;Access-Control-Expose-Headers&quot;, &quot;File-Name&quot;);\n\n    return ResponseEntity.ok()\n            .headers(headers)\n            .contentType(MediaType.parseMediaType(&quot;text/csv&quot;))\n            .contentLength(resource.contentLength())\n            .body(resource);\n}\n\nprivate String generateFeedbackCsv(List&lt;Feedback&gt; rows) {\n    StringWriter writer = new StringWriter();\n\n    try (CSVPrinter csv = new CSVPrinter(writer, CSVFormat.DEFAULT\n            .withHeader(&quot;Id&quot;, &quot;Date&quot;, &quot;Creation Date&quot;, &quot;Sensor Code&quot;, &quot;Reading Value&quot;,\n                    &quot;Latitude&quot;, &quot;Longitude&quot;, &quot;Altitude&quot;, &quot;Status value&quot;,\n                    &quot;Battery level&quot;, &quot;Sensor state&quot;))) {\n\n        for (Feedback f : rows) {\n            csv.printRecord(\n                    f.getFeedbackId(),\n                    f.getFeedDate(),\n                    f.getFeedCreationDate(),\n                    f.getSensCode(),\n                    f.getFeedValue(),\n                    f.getLatitude(),\n                    f.getLongitude(),\n                    f.getAltitude(),\n                    f.getFeedAlphanumericValue(),\n                    f.getFeedBattery(),\n                    f.getFeedState()\n            );\n        }\n    } catch (Exception e) {\n        log.error(&quot;Error while generating feedback list CSV&quot;, e);\n    }\n\n    return writer.toString();\n}\n\n@GetMapping(&quot;/download&quot;)\n@Operation(summary = &quot;Download feedback list&quot;, description = &quot;Returns a CSV file with feedback data&quot;)\npublic ResponseEntity&lt;ByteArrayResource&gt; downloadFeedbackList(\n        @RequestParam(defaultValue = &quot;&quot;, name = &quot;search&quot;) String search,\n        HttpServletRequest request) {\n    return utilitiesService.downloadFeedbackCsv(search, request);\n}\n\n</code></pre>\n<p><strong>Frontend (Angular)</strong></p>\n<p>JWT is added by an HTTP interceptor (Bearer token)</p>\n<pre class=\"lang-ts prettyprint-override\"><code>public onDownloadFeedbacks(): void {\n  const filterString = this.dataSource.filterToString(this.filters);\n\n  this.feedbackService.downloadFeedbacks(filterString)\n    .pipe(takeUntil(this.destroy$))\n    .subscribe(event =&gt; {\n      if (event.type == HttpEventType.Response) {\n        saveAs(\n          new File(\n            [event.body!],\n            event.headers.get('File-Name')!,\n            { type: `${event.headers.get('Content-Type')};charset=utf-8` }\n          )\n        );\n      } else {\n        console.log(event);\n      }\n    });\n}\n\ndownloadFeedbacks(filterString: string): Observable&lt;HttpEvent&lt;Blob&gt;&gt; {\n  const url = `${config.apiUrl}/api/feedback/download`;\n\n  return this.http.get(url, {\n    reportProgress: true,\n    observe: 'events',\n    responseType: 'blob',\n    params: new HttpParams().set('search', filterString)\n  })\n  .pipe(tap(() =&gt; console.log(`fetched feedbacks file`)));\n}\n</code></pre>\n<p>What I tried:</p>\n<ol>\n<li>Keeping the current HttpClient + FileSaver approach. But it always needs the full Blob before saving.</li>\n<li>Using an  link, but I have auth problem; also still tends to download first when using XHR/Blob.</li>\n</ol>\n",
    "tags" : [ "java", "angular", "spring" ],
    "owner" : {
      "account_id" : 32173414,
      "reputation" : 65,
      "user_id" : 24970870,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/3ee2e2dcdea08dfea1bae44740296bbb?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Salvatore Montagna",
      "link" : "https://stackoverflow.com/users/24970870/salvatore-montagna"
    },
    "is_answered" : true,
    "view_count" : 86,
    "answer_count" : 2,
    "score" : 1,
    "last_activity_date" : 1760009703,
    "creation_date" : 1760007071,
    "link" : "https://stackoverflow.com/questions/79786308/angular-spring-boot-file-download-blocks-until-fully-received-needs-save-as",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79786351,
    "question_id" : 79786308,
    "body" : "<p>Well that is how you programmed your controller. Generate a full <code>String</code> of all the data first, turn that into a <code>byte[]</code> and afterwards send it. As that is the way you created it, it will behave like that. There is no streaming done here. Instead of using the <code>StringWriter</code> and returning after processing use a <code>StreamingResponseBody</code> and write the CSV directly to the <code>OutputStream</code>.</p>\n<p>Something along these lines.</p>\n<pre class=\"lang-java prettyprint-override\"><code>public ResponseEntity&lt;ByteArrayResource&gt; downloadFeedbackCsv(String search, HttpServletRequest request) {\n\n    String fileName = &quot;feedback&quot; + nowStamp() + &quot;.csv&quot;;\n\n    HttpHeaders headers = new HttpHeaders();\n    headers.add(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment; filename=\\&quot;&quot; + fileName + &quot;\\&quot;&quot;);\n    headers.add(&quot;File-Name&quot;, fileName);\n    headers.add(&quot;Access-Control-Expose-Headers&quot;, &quot;File-Name&quot;);\n\n    return ResponseEntity.ok()\n            .headers(headers)\n            .contentType(MediaType.parseMediaType(&quot;text/csv&quot;))\n            .body(new StreamingResponseBody() {\n        public void writeTo(OutputStream out) throws IOException {\n          generateFeedbackCsv(search, request, out);\n        }\n      });\n}\n\nprivate void generateFeedbackCsv(String search, HttpServletRequest request, OutputStream out) {\n    try (\n      Writer writer = new BufferedWriter(new OutputStreamWriter(out));\n      CSVPrinter csv = new CSVPrinter(writer, CSVFormat.DEFAULT\n            .withHeader(&quot;Id&quot;, &quot;Date&quot;, &quot;Creation Date&quot;, &quot;Sensor Code&quot;, &quot;Reading Value&quot;,\n                    &quot;Latitude&quot;, &quot;Longitude&quot;, &quot;Altitude&quot;, &quot;Status value&quot;,\n                    &quot;Battery level&quot;, &quot;Sensor state&quot;))) {\n        List&lt;Feedback&gt; rows = feedbackService.findAllForExport(search, request);\n        for (Feedback f : rows) {\n            csv.printRecord(\n                    f.getFeedbackId(),\n                    f.getFeedDate(),\n                    f.getFeedCreationDate(),\n                    f.getSensCode(),\n                    f.getFeedValue(),\n                    f.getLatitude(),\n                    f.getLongitude(),\n                    f.getAltitude(),\n                    f.getFeedAlphanumericValue(),\n                    f.getFeedBattery(),\n                    f.getFeedState()\n            );\n        }\n    } catch (Exception e) {\n        log.error(&quot;Error while generating feedback list CSV&quot;, e);\n    }\n}\n</code></pre>\n<p>Added benefit less resource usage (memory) on the server as you aren't creating a large <code>String</code> and copy of that with a <code>byte[]</code> anymore.</p>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 3192259,
      "reputation" : 126800,
      "user_id" : 2696260,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/qHEzx.png?s=256",
      "display_name" : "M. Deinum",
      "link" : "https://stackoverflow.com/users/2696260/m-deinum"
    },
    "creation_date" : 1760009703,
    "last_activity_date" : 1760009703,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79786328,
    "question_id" : 79786308,
    "body" : "<p>What i understood is ur app becomes slow because it is waiting for the whole file to load and then it shows you the save as dialog box.<br />\nSo ur UI feels like blocked or stuck ....So if this is the problem then ,   Instead of using Angular httpclient to fetch the file, you must let the browser to handle the download directly.</p>\n<p>public void download(....){</p>\n<p>// dont return Response Entity&lt;ByteArrayResource&gt; ....<br />\ninstead</p>\n<p>response.setContentType(&quot;text/csv&quot;);<br />\nresponse.setHeader( your header);</p>\n<p>response.setContentLength(butes.length);</p>\n<p>ServletOutputStream os = response.getOutputStream();</p>\n<p>os.write();</p>\n<p>os.flush()</p>\n<p>os.close();</p>\n<p>/*Pls. check the code before use ... just giving you an idea*/</p>\n<p>// this approach streams the bytes directly to the HTTP response and browser confuses with the input type and transfer the control on client side that &quot;what you want my boss&quot;</p>\n<p>}</p>\n<p>and make some changes in front end side too</p>\n<p>because you r using</p>\n<p>this.http.get(url,{</p>\n<p>// some code</p>\n<p>})<br />\nmand<br />\nif(event.type== ..response){</p>\n<p>saveAs(...)</p>\n<p>}<br />\nmeans first download the file / load the file and then use ..only then after u would able to do save as</p>\n",
    "score" : -1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1778502,
      "reputation" : 950,
      "user_id" : 1621777,
      "user_type" : "registered",
      "accept_rate" : 17,
      "profile_image" : "https://i.sstatic.net/cnmnU.jpg?s=256",
      "display_name" : "Ashish Bansal",
      "link" : "https://stackoverflow.com/users/1621777/ashish-bansal"
    },
    "creation_date" : 1760008534,
    "last_activity_date" : 1760008534,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140786144,
    "post_id" : 79786308,
    "body" : "Well that is how you programmed your controller. Generate a full <code>String</code> of all the data first, turn that into a <code>byte[]</code> and afterwards send it. As that is the way you created it, it will behave like that. There is no streaming done here. Instead of using the <code>StringWriter</code> and returning after processing use a <code>StreamingResponseBody</code> and write the CSV directly to the <code>OutputStream</code>.",
    "score" : 0,
    "owner" : {
      "account_id" : 3192259,
      "reputation" : 126800,
      "user_id" : 2696260,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/qHEzx.png?s=256",
      "display_name" : "M. Deinum",
      "link" : "https://stackoverflow.com/users/2696260/m-deinum"
    },
    "creation_date" : 1760009175,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79786351" : [ {
      "comment_id" : 140792140,
      "post_id" : 79786351,
      "body" : "@SalvatoreMontagna Well yes if you are using a background process in your browser you would need to handle things on that side as well (as it is in the backgroud).",
      "score" : 0,
      "owner" : {
        "account_id" : 3192259,
        "reputation" : 126800,
        "user_id" : 2696260,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/qHEzx.png?s=256",
        "display_name" : "M. Deinum",
        "link" : "https://stackoverflow.com/users/2696260/m-deinum"
      },
      "creation_date" : 1760334481,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140788557,
      "post_id" : 79786351,
      "body" : "Switching to StreamingResponseBody did help on the server side, but with that change alone the frontend was still just receiving a Blob via XHR/HttpClient. The browser wouldn’t show the Save As dialog automatically. What finally solved it was generating a short-lived signed URL and then navigating the browser to that URL. Making this signed URL was necessary because I couldn&#39;t call the URL without using XHR and putting Authorization header with JWT. That way the file is streamed directly to the browser’s download manager (prompt + background save), instead of being buffered as a Blob in JS",
      "score" : 0,
      "owner" : {
        "account_id" : 32173414,
        "reputation" : 65,
        "user_id" : 24970870,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/3ee2e2dcdea08dfea1bae44740296bbb?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Salvatore Montagna",
        "link" : "https://stackoverflow.com/users/24970870/salvatore-montagna"
      },
      "creation_date" : 1760104236,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}