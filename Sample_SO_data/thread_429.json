{
  "question" : {
    "question_id" : 79806535,
    "title" : "JPA recursive hierarchy read - StackOverflowError with FetchType.EAGER but LazyInitializationException with FetchType.LAZY",
    "body" : "<p>I'm working with these entities:</p>\n<p>UserEntity:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Entity\n@Table (name = &quot;users&quot;, uniqueConstraints = @UniqueConstraint(columnNames={&quot;name&quot;}))\npublic class UserEntity {\n\n    @Id\n    @GeneratedValue (strategy = GenerationType.SEQUENCE, generator = &quot;user_id_seq&quot;)\n    private Long id;\n\n    @Column( name = &quot;name&quot;)\n    private String name;\n\n    private int level;\n\n    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = &quot;user&quot;)\n    private Set&lt;BerryInventoryEntity&gt; berryInventory;\n</code></pre>\n<p>BerryInventoryEntity:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Entity\n@Table (name = &quot;berry_inventory&quot;)\npublic class BerryInventoryEntity {\n\n    @Id\n    @GeneratedValue (strategy = GenerationType.SEQUENCE, generator = &quot;inventory_id_seq&quot;)\n    private Long id;\n\n    @ManyToOne (optional = false)\n    @JoinColumn (name = &quot;user_id&quot;)\n    private UserEntity user;\n\n    @ManyToOne (optional = false)\n    @JoinColumn (name = &quot;berry_id&quot;)\n    private BerryEntity berry;\n\n    private int quantity;\n}\n</code></pre>\n<p>I'm testing the repository of BerryInventory and I ran into a problem. I created an instance of BerryInventoryEntity and saved it using the repository:</p>\n<pre class=\"lang-java prettyprint-override\"><code>BerryInventoryEntity berryInventory = BerryInventoryEntity.builder()\n        .berry(berry)\n        .user(user)\n        .quantity(1)\n        .build();\n\nberryInventoryRepository.save(berryInventory);\n</code></pre>\n<p>Then I used this query to retrieve the BerryInventoryEntity I just saved:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Query(&quot;SELECT b FROM BerryInventoryEntity b WHERE b.user = :user&quot;)\nIterable&lt;BerryInventoryEntity&gt; findInventoryOfUser(UserEntity user);\n</code></pre>\n<p>Like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>Iterable&lt;BerryInventoryEntity&gt; berryInventoryCreated = berryInventoryRepository.findInventoryOfUser(userCreated);\n</code></pre>\n<p>But then U get two different errors depending on the FetchType in the @OneToMany relationship indicated in UserEntity.</p>\n<p>If the FetchType is &quot;LAZY&quot; the UserEntity comes with an instance of BerryInventoryEntity that throws the exception:</p>\n<blockquote>\n<p>Method threw 'org.hibernate.LazyInitializationException' exception. Cannot evaluate com.dpr.berry.domain.entities.UserEntity.toString()</p>\n</blockquote>\n<p>But if I change it to &quot;EAGER&quot; then a StackOverFlowError is thrown because UserEntity contains a list of BerryInventoryEntity that also contains UserEntity and so on.</p>\n<p>Can I retrieve a BerryInventoryEntity that its UserEntity doesn't also come with a BerryInventoryEntity? What is the correct way of fixing this issue?</p>\n",
    "tags" : [ "java", "spring-boot", "jpa", "spring-data-jpa" ],
    "owner" : {
      "account_id" : 23153848,
      "reputation" : 33,
      "user_id" : 19284946,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/ttEG7.jpg?s=256",
      "display_name" : "Rikelo",
      "link" : "https://stackoverflow.com/users/19284946/rikelo"
    },
    "is_answered" : true,
    "view_count" : 203,
    "answer_count" : 3,
    "score" : 2,
    "last_activity_date" : 1762531641,
    "creation_date" : 1762001683,
    "link" : "https://stackoverflow.com/questions/79806535/jpa-recursive-hierarchy-read-stackoverflowerror-with-fetchtype-eager-but-lazyi",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79807765,
    "question_id" : 79806535,
    "body" : "<blockquote>\n<p>Can I retrieve a <code>BerryInventoryEntity</code> that its <code>UserEntity</code> doesn't also come with a <code>BerryInventoryEntity</code>?</p>\n</blockquote>\n<p>No. As long as they are linked through the relation fields (<code>UserEntity.berryInventory</code> &amp; <code>BerryInventoryEntity.user</code>) the code will always be able to access them and lead to potential circular reference/stack overflow OR lazy initialization errors.</p>\n<p>JPA offers you ways of stopping it from querying the DB in a circular way (<code>LAZY</code>, Entity Graphs), but as long as it's in the code, you can always use it.</p>\n<blockquote>\n<p>What is the correct way of fixing this issue?</p>\n</blockquote>\n<p>There are many ways actually, choose the one that works better for you! Pick one or more:</p>\n<h4>Fix only the immediate symptom</h4>\n<p>This can be treacherous as it may solve your problem now, only to cause more problems down the way, beware! Anyway here it goes:</p>\n<p>Obviously the problem is caused by Lombok over-eagerly using all the entity fields for the <code>toString()</code> it generates. What we are using in this case is white-listing of fields to include by annotating the class with <code>@ToString(onlyExplicitlyIncluded = true)</code> and then each field we actually want to include in <code>toString()</code> with <code>@ToString.Include</code>. Collections and relations are almost always a no-no for inclusion.</p>\n<p>Another way the circular dependency may come back to bite you is if you are serializing the entities themselves. I see this happening all the time, using the JPA entity as an entity (ok obviously), domain model (i.e. used in the business logic) and DTO. Single responsibility principle totally violated. Anyway, if you have the option of using separate DTOs for serialization (if ever needed), I advise you to do it, even though you will have to write a bit more code. Otherwise this is frequently solved e.g. with Jackson annotations on the entity class.</p>\n<h4>Slightly revise the design</h4>\n<p>The root of the problem is the circular dependency. Ask yourself, do you really need the &quot;to many&quot; side of the relationship, i.e. the <code>berryInventory</code>, to be explicitly declared in the <code>UserEntity</code>? Can't you live without this property? I have found out that, in most cases I can! Probably this is why you are using a method in the repository to fetch the berry inventory of a user - <code>repo.findInventoryOfUser(userCreated)</code>, instead of <code>userCreated.getBerryInventory()</code>.</p>\n<p><code>UserEntity.berryInventory</code> gone, problem gone! And you can still use the relation in your queries, perhaps with a little more effort if you relied on JPA's fancy collection operators.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 3284439,
      "reputation" : 40394,
      "user_id" : 2764255,
      "user_type" : "registered",
      "accept_rate" : 50,
      "profile_image" : "https://www.gravatar.com/avatar/2c14e217d79c08ca104e6e11d8e1710f?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Nikos Paraskevopoulos",
      "link" : "https://stackoverflow.com/users/2764255/nikos-paraskevopoulos"
    },
    "creation_date" : 1762166354,
    "last_activity_date" : 1762166354,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79812539,
    "question_id" : 79806535,
    "body" : "<p>Thank you everyone who helped. This is how I solved it.</p>\n<p><strong>First, &quot;LazyInitializationException&quot;:</strong></p>\n<blockquote>\n<p>Method threw 'org.hibernate.LazyInitializationException' exception. Cannot evaluate com.dpr.berry.domain.entities.UserEntity.toString()</p>\n</blockquote>\n<p>The problem here wasn't leaving the <code>FetchType</code> on the &quot;OneToMany&quot; part of the relationship as &quot;LAZY&quot;, since that's the default anyway.</p>\n<p>What was causing this problem was the Lombok <code>@Data</code> annotation. It wasn't behaving correctly when handling the variables that referenced the related entities.</p>\n<p>The solution to this was writing my own <code>toString</code> for each entity, where i only included the ID + Name. Also, I got rid of the <code>@Data</code> annotations and instead I'm just using the <code>@Getter</code> and <code>@Setter</code> annotations.</p>\n<p><strong>Second, &quot;StackOverflowError&quot;:</strong></p>\n<p>This problem happened when I set the <code>FetchType</code> on the &quot;OneToMany&quot; relationship as &quot;EAGER&quot;.</p>\n<p>The solution to this was leaving it as default, which is &quot;LAZY&quot;, on the two sides of the &quot;OneToMany&quot; relationship. And also, setting it as &quot;LAZY&quot; on the &quot;ManyToOne&quot; part of the relationship, since the default there is &quot;EAGER&quot;:</p>\n<p>UserEntity:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@OneToMany (mappedBy = &quot;user&quot;)\n@OnDelete (action = OnDeleteAction.CASCADE)\nprivate Set&lt;BerryInventoryEntity&gt; berryInventory;\n</code></pre>\n<p>BerryEntity:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@OneToMany (mappedBy = &quot;berry&quot;)\n@OnDelete (action = OnDeleteAction.CASCADE)\nprivate Set&lt;BerryInventoryEntity&gt; berryInventory;\n</code></pre>\n<p>BerryInventoryEntity:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@ManyToOne (optional = false, fetch = FetchType.LAZY)\n@JoinColumn (name = &quot;user_id&quot;)\nprivate UserEntity user;\n\n@ManyToOne (optional = false, fetch = FetchType.LAZY)\n@JoinColumn (name = &quot;berry_id&quot;)\nprivate BerryEntity berry;\n</code></pre>\n<p>Also, i added <code>LEFT JOIN FETCH b.berry</code> to the <code>findInventoryOfUser</code> method on <code>BerryInventoryRepository</code>:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Query (&quot;SELECT b FROM BerryInventoryEntity b LEFT JOIN FETCH b.berry WHERE b.user = :user&quot;)\nIterable&lt;BerryInventoryEntity&gt; findInventoryOfUser(UserEntity user);\n</code></pre>\n<p>So this way I only fetch the data i need.</p>\n",
    "score" : 1,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 23153848,
      "reputation" : 33,
      "user_id" : 19284946,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/ttEG7.jpg?s=256",
      "display_name" : "Rikelo",
      "link" : "https://stackoverflow.com/users/19284946/rikelo"
    },
    "creation_date" : 1762531209,
    "last_activity_date" : 1762531641,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79807697,
    "question_id" : 79806535,
    "body" : "<p>As you say, you have a cycle:\nBerryInventoryEntity -&gt; UserEntity -&gt; BerryInventoryEntity -&gt; UserEntity -&gt; ad infinitum.</p>\n<p>The <strong>only solution is to not use EAGER</strong> and stay with the default, ie LAZY.</p>\n<p>Then allow spring-data-jpa (without the <code>@Query</code> annotation) to build a query that takes the user id as a parameter rather than the UserEntity, ie:</p>\n<pre><code>Iterable&lt;BerryInventoryEntity&gt; findByUserId(Long userId);\n\n</code></pre>\n<p>and use it thus:</p>\n<pre><code>Iterable&lt;BerryInventoryEntity&gt; berryInventoryCreated = berryInventoryRepository.findByUserId(userCreated.getId());\n\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 10941198,
      "reputation" : 5803,
      "user_id" : 8041003,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/cAZ4d.jpg?s=256",
      "display_name" : "John Williams",
      "link" : "https://stackoverflow.com/users/8041003/john-williams"
    },
    "creation_date" : 1762162328,
    "last_activity_date" : 1762162328,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140836798,
    "post_id" : 79806535,
    "body" : "Yes, thank you @Chris and @talex . I&#39;m using Lombok, and it seems the <code>toString</code> method was causing some trouble. Changed the <code>@Data</code> annotation for <code>@Getter</code> and <code>@Setter</code> and implemented my own <code>toString</code>. Apparently it was also causing an AssertionError on another part of the code. Seems to be working better now.",
    "score" : 0,
    "owner" : {
      "account_id" : 23153848,
      "reputation" : 33,
      "user_id" : 19284946,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/ttEG7.jpg?s=256",
      "display_name" : "Rikelo",
      "link" : "https://stackoverflow.com/users/19284946/rikelo"
    },
    "creation_date" : 1762297293,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140836647,
    "post_id" : 79806535,
    "body" : "Revisit @Talex &#39;s comment. The error states it can&#39;t execute UserEntity.toString() and getting the exception - so your toString implementation IS the problem. You must ensure it isn&#39;t going to turn the entire object graph into a String - Lombok is awful if you don&#39;t understand what it is generating, and likely is the cause of both your issues as it traverses the object graph recursively to build a string. Just print the entity ID if you really need a toString implementation.",
    "score" : 1,
    "owner" : {
      "account_id" : 231721,
      "reputation" : 21335,
      "user_id" : 496099,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/efa7510cf47d7bd79e80486246e7e39e?s=256&d=identicon&r=PG",
      "display_name" : "Chris",
      "link" : "https://stackoverflow.com/users/496099/chris"
    },
    "creation_date" : 1762290301,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140834793,
    "post_id" : 79806535,
    "body" : "@Rikelo - Nothing wrong with using the repo, that&#39;s what it&#39;s built for. If you wantfrom another table, do a &quot;left join fetch&quot;, perhaps &quot;SELECT b FROM BerryInventoryEntity b left join fetch b.user WHERE b.user = :user&quot; assuming you want the user details of the user you already have. It&#39;s a relational database if you can relate to that.",
    "score" : 0,
    "owner" : {
      "account_id" : 4688171,
      "reputation" : 11611,
      "user_id" : 3795036,
      "user_type" : "registered",
      "accept_rate" : 88,
      "profile_image" : "https://i.sstatic.net/eM2E2.png?s=256",
      "display_name" : "K.Nicholas",
      "link" : "https://stackoverflow.com/users/3795036/k-nicholas"
    },
    "creation_date" : 1762220111,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140834736,
    "post_id" : 79806535,
    "body" : "@K.Nicholas I understand, thank you for your reply. I left it as default. About the JPQL thing, currently I&#39;m using a repository to do basic CRUD stuff for the BerryInventory, but I feel like that&#39;s not correct. Should I be interacting with the BerryInventory table exclusively through queries inside the Berry and User repositories?",
    "score" : 0,
    "owner" : {
      "account_id" : 23153848,
      "reputation" : 33,
      "user_id" : 19284946,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/ttEG7.jpg?s=256",
      "display_name" : "Rikelo",
      "link" : "https://stackoverflow.com/users/19284946/rikelo"
    },
    "creation_date" : 1762216176,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140831844,
    "post_id" : 79806535,
    "body" : "What is in <code>UserEntity.toString</code>? Lokks like you use <code>lombok</code> <code>@ToString</code> or something similar.",
    "score" : 2,
    "owner" : {
      "account_id" : 4497436,
      "reputation" : 20786,
      "user_id" : 3656904,
      "user_type" : "registered",
      "accept_rate" : 67,
      "profile_image" : "https://www.gravatar.com/avatar/8bdbd1f89f8907e8e8b15ab88c084c65?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "talex",
      "link" : "https://stackoverflow.com/users/3656904/talex"
    },
    "creation_date" : 1762071795,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140830871,
    "post_id" : 79806535,
    "body" : "I suspect that the issue is related to code that has not yet been presented.  Possibly <code>BerryEntity</code>, and possibly additional code in the entities that have been provided.  It might even be mostly unrelated to JPA.",
    "score" : 1,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1762004314,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140830870,
    "post_id" : 79806535,
    "body" : "You throw the errors while printing the results. Since you have a circular reference either UserEntity is not loaded or when it loads it also reloads (again) the BerryInventoryEntity until the stack overflows. Leave FetchType at the default and write a corect JPQL to get what you want. Old timer to new guy, investigate what you don&#39;t know about before using it. Save you many hours of nonsense.",
    "score" : 5,
    "owner" : {
      "account_id" : 4688171,
      "reputation" : 11611,
      "user_id" : 3795036,
      "user_type" : "registered",
      "accept_rate" : 88,
      "profile_image" : "https://i.sstatic.net/eM2E2.png?s=256",
      "display_name" : "K.Nicholas",
      "link" : "https://stackoverflow.com/users/3795036/k-nicholas"
    },
    "creation_date" : 1762004309,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140830862,
    "post_id" : 79806535,
    "body" : "Probably the <code>StackOverflowError</code> is what you should be looking into, rather than the <code>LazyInitializationException</code>.  It seems likely that they have the same underlying cause, but that the former approaches it more directly.",
    "score" : 1,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1762004020,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140830851,
    "post_id" : 79806535,
    "body" : "@JohnBollinger yes, <code>User</code> and <code>Berry</code> entities are saved on the DB before i save a <code>BerryInventory</code> entity. I have looked in the DB and the data of the three entities is being created correctly.",
    "score" : 0,
    "owner" : {
      "account_id" : 23153848,
      "reputation" : 33,
      "user_id" : 19284946,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/ttEG7.jpg?s=256",
      "display_name" : "Rikelo",
      "link" : "https://stackoverflow.com/users/19284946/rikelo"
    },
    "creation_date" : 1762003463,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140830835,
    "post_id" : 79806535,
    "body" : "Are the <code>User</code> and <code>Berry</code> entities you are using <i>persistent</i> when you use them to build the <code>BerryInventoryEntity</code>?  Have you looked in the DB directly to see what was actually stored and whether it is consistent?",
    "score" : 0,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1762002761,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79807697" : [ {
      "comment_id" : 140838011,
      "post_id" : 79807697,
      "body" : "Yes. JPA should have no problem building an object graph - the spec requires that A-&gt;B-&gt;A that it not build a new A instance every time it is encountered in the graph. Most decent serialization mechanisms take this into account with various different schemes, but JPA has and requires IDs for the purpose.",
      "score" : 0,
      "owner" : {
        "account_id" : 231721,
        "reputation" : 21335,
        "user_id" : 496099,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/efa7510cf47d7bd79e80486246e7e39e?s=256&d=identicon&r=PG",
        "display_name" : "Chris",
        "link" : "https://stackoverflow.com/users/496099/chris"
      },
      "creation_date" : 1762353605,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140836801,
      "post_id" : 79807697,
      "body" : "@Chris I&#39;m curious about this. Now that I solved the problems I had with the <code>toString</code> function and other stuff that was causing trouble. When i retrieve a <code>BerryInventoryEntity</code> fetching the <code>User</code>, it comes with a <code>UserEntity</code> that comes with a <code>BerryInventoryEntity</code> and so on. I&#39;m not getting a StackOverFlow error anymore. I&#39;m guessing based on your comment this is normal behavior?",
      "score" : 0,
      "owner" : {
        "account_id" : 23153848,
        "reputation" : 33,
        "user_id" : 19284946,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/ttEG7.jpg?s=256",
        "display_name" : "Rikelo",
        "link" : "https://stackoverflow.com/users/19284946/rikelo"
      },
      "creation_date" : 1762297370,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140836799,
      "post_id" : 79807697,
      "body" : "Tried this but didn&#39;t seem to behave differently.",
      "score" : 0,
      "owner" : {
        "account_id" : 23153848,
        "reputation" : 33,
        "user_id" : 19284946,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/ttEG7.jpg?s=256",
        "display_name" : "Rikelo",
        "link" : "https://stackoverflow.com/users/19284946/rikelo"
      },
      "creation_date" : 1762297336,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140836642,
      "post_id" : 79807697,
      "body" : "JPA providers should have no problem with recursive object graphs. It is part of the requirements that parent/children relationships be bidirectional, and lazy is only a hint, not a requirement. That is the point of entities having IDs; they know what has already been fetched and can cache it when building an object graph",
      "score" : 1,
      "owner" : {
        "account_id" : 231721,
        "reputation" : 21335,
        "user_id" : 496099,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/efa7510cf47d7bd79e80486246e7e39e?s=256&d=identicon&r=PG",
        "display_name" : "Chris",
        "link" : "https://stackoverflow.com/users/496099/chris"
      },
      "creation_date" : 1762290150,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140835383,
      "post_id" : 79807697,
      "body" : "@Rikelo What happens if you set the following parameter to true: spring.jpa.properties.hibernate.enable_lazy_load_no_trans ?",
      "score" : 0,
      "owner" : {
        "account_id" : 10941198,
        "reputation" : 5803,
        "user_id" : 8041003,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/cAZ4d.jpg?s=256",
        "display_name" : "John Williams",
        "link" : "https://stackoverflow.com/users/8041003/john-williams"
      },
      "creation_date" : 1762250720,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140834739,
      "post_id" : 79807697,
      "body" : "Not using EAGER seems the way to go. Still, when using the query you suggest i still get the same result. Passing a UserEntity or the Id doesn&#39;t change what the function returns. The BerryInventoryEntity will always come with an entity of User and Berry regardless.",
      "score" : 0,
      "owner" : {
        "account_id" : 23153848,
        "reputation" : 33,
        "user_id" : 19284946,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/ttEG7.jpg?s=256",
        "display_name" : "Rikelo",
        "link" : "https://stackoverflow.com/users/19284946/rikelo"
      },
      "creation_date" : 1762216283,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79807765" : [ {
      "comment_id" : 140834758,
      "post_id" : 79807765,
      "body" : "@Rikelo Since you are using Hibernate there is a Hibernate-specific solution presented in <a href=\"https://stackoverflow.com/a/38495206\">this answer</a>. Another answer for the same question gives a DB-based solution. I would hesitate to choose proprietary or DB solutions, but I wouldn&#39;t rule them out completely. Your choice!",
      "score" : 0,
      "owner" : {
        "account_id" : 3284439,
        "reputation" : 40394,
        "user_id" : 2764255,
        "user_type" : "registered",
        "accept_rate" : 50,
        "profile_image" : "https://www.gravatar.com/avatar/2c14e217d79c08ca104e6e11d8e1710f?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Nikos Paraskevopoulos",
        "link" : "https://stackoverflow.com/users/2764255/nikos-paraskevopoulos"
      },
      "creation_date" : 1762217404,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140834748,
      "post_id" : 79807765,
      "body" : "@Rikelo Oh, indeed, this is one valid case for keeping the &quot;to many&quot; side of the relationship. Unless you would be willing to do some extra effort and, in the service method that handles the deletion of the user, you also manually delete the inventory. But this is a manual, error prone step (e.g. someone may forget to do it). Go for the whitelisting of fields to include in <code>toString</code> then. Are you facing any other problems?",
      "score" : 0,
      "owner" : {
        "account_id" : 3284439,
        "reputation" : 40394,
        "user_id" : 2764255,
        "user_type" : "registered",
        "accept_rate" : 50,
        "profile_image" : "https://www.gravatar.com/avatar/2c14e217d79c08ca104e6e11d8e1710f?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Nikos Paraskevopoulos",
        "link" : "https://stackoverflow.com/users/2764255/nikos-paraskevopoulos"
      },
      "creation_date" : 1762216857,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140834742,
      "post_id" : 79807765,
      "body" : "Yes, as you say, the intention of the findInventoryOfUser function was to get the inventory of a user separating it from getting it from the UserEntity itself.    Getting rid of the berryInventory on UserEntity doesn&#39;t sound bad. But losing the &quot;toMany&quot; side of the relationship would cause that a user being deleted won&#39;t automatically delete its inventory.    In the case I decide to go with that option. What do you think it would be the best way to implement said function?",
      "score" : 0,
      "owner" : {
        "account_id" : 23153848,
        "reputation" : 33,
        "user_id" : 19284946,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/ttEG7.jpg?s=256",
        "display_name" : "Rikelo",
        "link" : "https://stackoverflow.com/users/19284946/rikelo"
      },
      "creation_date" : 1762216425,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}