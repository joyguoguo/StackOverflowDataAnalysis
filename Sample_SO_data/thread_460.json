{
  "question" : {
    "question_id" : 79803967,
    "title" : "while task inside @Async cannot be stopped with @PreDestroy in Spring Boot",
    "body" : "<p>I have a Problem with asynchronous methods that run on a customTaskExecutors. In the run method I never reach the last log.info that the thread is finished running (where I would usualy put other cleanup code). I would like to stop that thread in the PreDestroy method with setting the boolean to false, but pre destroy only gets called when spring has ended all his threads, which includes the customTaskExecutor. I already have put the custom Exectur with a short awaitTermination time, didn't change anything. I also made a class, where I wire all taskExecutors in and shut them down externaly. That all stops the ThreadExecutor but never in a way where I can have code after the while loop running.</p>\n<p>Does anybody have a best practice for what i want to do (basically change the boolean for the while loop on sigterm signal)? Or am I bound to use PreDestroy for all cleanup stuff when I want to use TaskExecutors of Spring Boot?</p>\n<pre><code>@PreDestroy\npublic void shutDown() {\n    log.info(&quot;Shutting down AsyncRunner...&quot;);\n    printingRunning = false;\n}\n\n@Override\n@Async(&quot;customTaskExecutor&quot;)  // Using the custom executor from AsyncConfig\npublic void run(String... args) throws Exception {\n    log.info(&quot;AsyncRunner starting on thread: {}&quot;, Thread.currentThread().getName());\n\n    try {\n        while(printingRunning &amp;&amp; !Thread.currentThread().isInterrupted()) {\n            Thread.sleep(1000);\n            this.printWorkOut();\n        }\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt(); // Restore interrupted status\n        log.info(&quot;AsyncRunner was interrupted.&quot;);\n    }\n\n    log.info(&quot;AsyncRunner finished on thread: {}&quot;, Thread.currentThread().getName());\n}\n</code></pre>\n",
    "tags" : [ "java", "spring-boot", "asynchronous" ],
    "owner" : {
      "account_id" : 16725808,
      "reputation" : 3,
      "user_id" : 12089459,
      "user_type" : "registered",
      "profile_image" : "https://lh6.googleusercontent.com/-a_hGRZ135Kc/AAAAAAAAAAI/AAAAAAAAAAA/ACHi3re-IBDqeLxluskwCzhb1kvDdrAgdQ/s256-rj/photo.jpg",
      "display_name" : "Shardic",
      "link" : "https://stackoverflow.com/users/12089459/shardic"
    },
    "is_answered" : true,
    "view_count" : 47,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1762521690,
    "creation_date" : 1761752064,
    "link" : "https://stackoverflow.com/questions/79803967/while-task-inside-async-cannot-be-stopped-with-predestroy-in-spring-boot",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79804619,
    "question_id" : 79803967,
    "body" : "<ol>\n<li><p><strong>Use a <code>volatile</code> flag</strong> to control the loop.</p>\n</li>\n<li><p><strong>Register a shutdown hook</strong> to set the flag.</p>\n</li>\n<li><p><strong>Ensure the thread checks the flag and exits cleanly.</strong></p>\n</li>\n<li><p><strong>Avoid relying solely on <code>@PreDestroy</code> for thread control.</strong></p>\n</li>\n</ol>\n<pre><code>@Component\npublic class AsyncRunner implements CommandLineRunner {\n\n    private volatile boolean printingRunning = true;\n\n    @Autowired\n    private TaskExecutor customTaskExecutor;\n\n    @Override\n    public void run(String... args) {\n        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {\n            log.info(&quot;Shutdown hook triggered. Stopping AsyncRunner...&quot;);\n            printingRunning = false;\n        }));\n\n        customTaskExecutor.execute(() -&gt; {\n            log.info(&quot;AsyncRunner starting on thread: {}&quot;, Thread.currentThread().getName());\n\n            try {\n                while (printingRunning &amp;&amp; !Thread.currentThread().isInterrupted()) {\n                    Thread.sleep(1000);\n                    printWorkOut();\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                log.info(&quot;AsyncRunner was interrupted.&quot;);\n            }\n\n            log.info(&quot;AsyncRunner finished on thread: {}&quot;, Thread.currentThread().getName());\n            // Cleanup logic here\n        });\n    }\n\n    private void printWorkOut() {\n        log.info(&quot;Working out...&quot;);\n    }\n}\n``\n</code></pre>\n",
    "score" : 1,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 38077386,
      "reputation" : 106,
      "user_id" : 28582581,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/1290181c8be3c97ffa01c4ac59488c65?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Vamsi Krishna",
      "link" : "https://stackoverflow.com/users/28582581/vamsi-krishna"
    },
    "creation_date" : 1761818210,
    "last_activity_date" : 1761818210,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140827444,
    "post_id" : 79803967,
    "body" : "Feels like a wrong design to start with. You shouldn&#39;t do a <code>Thread.sleep</code> in an async task, as that will block a thread. If you are using that task executor for more things you will run out of threads or even worse have a non responsive system. Looks like you would need a scheduler instead of an async task and trigger the method each 1 second.",
    "score" : 0,
    "owner" : {
      "account_id" : 3192259,
      "reputation" : 126800,
      "user_id" : 2696260,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/qHEzx.png?s=256",
      "display_name" : "M. Deinum",
      "link" : "https://stackoverflow.com/users/2696260/m-deinum"
    },
    "creation_date" : 1761837341,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}