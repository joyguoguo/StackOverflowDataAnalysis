{
  "question" : {
    "question_id" : 79579043,
    "title" : "@Valid annotation to validate outgoing (not incoming) request body payload body",
    "body" : "<p>I am trying to use the <code>@Valid</code> annotation to validate outgoing, (not incoming) request payload body.</p>\n<p>There is this construct to validate <em>incoming</em> request's body payload in Spring Boot:</p>\n<pre><code>@RestController\nclass FieldValidationController {\n\n    @PostMapping(&quot;/validate&quot;)\n    String question(@Valid @RequestBody SomeRequest someRequest) {\n        return &quot;please validate the field&quot;;\n    }\n\n}\n</code></pre>\n<pre><code>public record SomeRequest(@Email String email) { }\n</code></pre>\n<p>This would ensure that an incoming request to this web API would be validated (in this case, that the incoming request's email field is indeed an email).</p>\n<p>Is it possible to do the same, not for incoming, but for outgoing requests?</p>\n<p>With the same construct, I did this:</p>\n<pre><code>@HttpExchange(accept = &quot;application/json&quot;)\npublic interface FooHttpExchange {\n\n    @PostExchange(&quot;/outgoing&quot;)\n    String question(@RequestBody @Valid final OutgoingFoo foo);\n\n}\n\n</code></pre>\n<pre><code>public record OutgoingFoo(\n       int score,\n        @Email\n        String email\n) {\n}\n\n</code></pre>\n<p>And when trying to send the request, I do this:</p>\n<pre><code>String s = fooHttpExchange.question(foo);\n</code></pre>\n<pre><code>OutgoingFoo foo = new OutgoingFoo(42, &quot;thisisnotanemailpleasefaildontsendtherequest&quot;)\n</code></pre>\n<p>As you can see in the outgoing object, this is violating the rule.</p>\n<p>I would have expected this to fail before sending the request.</p>\n<p>I understand I could have written some custom if statements after the construction of my outgoing object. And this is not a question about email specifically, but the <code>@Valid</code> annotation in general.</p>\n<p>How to use it for outgoing (not incoming) request validation?</p>\n",
    "tags" : [ "java", "spring-boot", "hibernate-validator" ],
    "owner" : {
      "account_id" : 14482834,
      "reputation" : 5468,
      "user_id" : 10461625,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/fgo5D.jpg?s=256",
      "display_name" : "PatPanda",
      "link" : "https://stackoverflow.com/users/10461625/patpanda"
    },
    "is_answered" : true,
    "view_count" : 85,
    "answer_count" : 1,
    "score" : -1,
    "last_activity_date" : 1744900630,
    "creation_date" : 1744886033,
    "link" : "https://stackoverflow.com/questions/79579043/valid-annotation-to-validate-outgoing-not-incoming-request-body-payload-body",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79579496,
    "question_id" : 79579043,
    "body" : "<p>Don't forget to add the <code>@Validated</code> annotation to the target classes:</p>\n<ul>\n<li>the <code>@HttpExchange</code> annotated interface or</li>\n<li>any <code>class</code> that implements it, same as</li>\n<li>to controller or service classes.</li>\n</ul>\n<p>I will explain Spring's requirements for bean-validation and possible restrictions for HTTP interfaces below.</p>\n<h2>Bean validation in Spring</h2>\n<p>According to the Spring Framework reference documentation on <a href=\"https://docs.spring.io/spring-framework/reference/core/validation/beanvalidation.html#validation-beanvalidation-spring-method\" rel=\"nofollow noreferrer\">Java Bean Validation, section Spring-driven Method Validation</a>:</p>\n<blockquote>\n<p>To be eligible for Spring-driven method validation, <em>target classes need to be annotated with Spring’s <code>@Validated</code> annotation</em>, which can optionally also declare the validation groups to use.</p>\n</blockquote>\n<p>This annotation <code>@Validated</code> should be used for example in your controller class, or like given in the example of section &quot;Customizing Validation Errors&quot; in the same docs, at the service class:</p>\n<pre class=\"lang-java prettyprint-override\"><code>record Person(@Size(min = 1, max = 10) String name) {\n}\n\n@Validated\npublic class MyService {\n\n    void addStudent(@Valid Person person, @Max(2) int degrees) {\n        // ...\n    }\n}\n</code></pre>\n<p><strong>Note:</strong> Those examples are annotated <code>class</code>es, not <code>interface</code>s. This could make a difference.</p>\n<h2>HTTP Interface annotated with <code>@HttpExchange</code></h2>\n<p>In Spring Frameworks's HTTP Interface, i.e. Jave <code>interface</code>s annotated with <code>@HttpExchange</code>, same bean-validation logic would make sense.\nBut section <a href=\"https://docs.spring.io/spring-framework/docs/6.0.0-RC1/reference/html/integration.html#rest-http-interface-method-parameters\" rel=\"nofollow noreferrer\">1.3.1. Method Parameters</a> the annotation <code>@Valid</code> is not listed, although it could be applied to any parameter, theoretically.</p>\n<p>Still, stictly speaking, then the requirement for Spring's bean-validation as given above:</p>\n<blockquote>\n<p><em>target classes need to be annotated with Spring’s <code>@Validated</code> annotation</em></p>\n</blockquote>\n<p>can probably not be applied to an <code>interface</code> itself. But, it should work on a <code>class</code> if this class implements the HTTP interface, i.e. the <code>interface</code> annotated with <code>@HttpExchange</code>.</p>\n",
    "score" : 1,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 7547772,
      "reputation" : 9694,
      "user_id" : 5730279,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/9GYwj.jpg?s=256",
      "display_name" : "hc_dev",
      "link" : "https://stackoverflow.com/users/5730279/hc-dev"
    },
    "creation_date" : 1744900270,
    "last_activity_date" : 1744900630,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}