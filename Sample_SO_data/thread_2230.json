{
  "question" : {
    "question_id" : 79636631,
    "title" : "Multi-threading: Run processes in batches",
    "body" : "<p>For the following code -</p>\n<p>Class: Client</p>\n<pre><code>public class Client {\n    Integer id;\n    Integer priority;\n}\n</code></pre>\n<p>Class: CPU</p>\n<pre><code>package target2024.systemDesign.cpuProcessor;\n\nimport lombok.SneakyThrows;\n\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n//Singleton design pattern\npublic class CPU {\n    private static CPU instance;\n    private final Integer MAX_THREAD_POOL = 3;\n    Object lock = new Object();\n\n    static Queue&lt;Client&gt; executingThreadPool;\n    static Queue&lt;Client&gt; waitingThreadPool;\n\n    private CPU() {\n        executingThreadPool = new LinkedList&lt;&gt;();\n        waitingThreadPool = new LinkedList&lt;&gt;();\n    }\n\n    public synchronized static CPU getInstance() {\n        if(instance == null) {\n            instance = new CPU();\n        }\n        return instance;\n    }\n\n    @SneakyThrows\n    public void execute(Client client) {\n        System.out.println(&quot;Received client=&quot; + client.id);\n        waitingThreadPool.add(client);\n        synchronized (lock) {\n            if(executingThreadPool.size() &lt; MAX_THREAD_POOL) {\n                executingThreadPool.add(waitingThreadPool.poll());\n            } else {\n                lock.wait();\n                executingThreadPool.add(waitingThreadPool.poll());\n            }\n        }\n\n        Client clientToProcess;\n        synchronized (lock) {\n            clientToProcess = executingThreadPool.poll();\n        }\n        process(clientToProcess);\n\n        synchronized (lock) {\n            lock.notifyAll();\n        }\n    }\n\n    @SneakyThrows\n    public void process(Client client) {\n        System.out.println(&quot;-----Executing client=&quot; + client.id);\n        Thread.sleep(1000);\n    }\n}\n</code></pre>\n<p>Class: CPUDemo</p>\n<pre><code>package target2024.systemDesign.cpuProcessor;\n\nimport lombok.SneakyThrows;\n\npublic class CPUDemo {\n    @SneakyThrows\n    public static void main(String[] args) {\n        CPU cpu = CPU.getInstance();\n\n        int clientSize = 10;\n        Thread[] tarr = new Thread[clientSize];\n        Client[] carr = new Client[clientSize];\n\n        //Create clients\n        for(int i=0; i&lt;clientSize; i++) {\n            carr[i] = new Client(i, i);\n        }\n\n        //Create threads\n        for(int i=0; i&lt;clientSize; i++) {\n            int finalI = i;\n            tarr[i] = new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    cpu.execute(carr[finalI]);\n                }\n            });\n        }\n\n        //Initialize threads\n        for(int i=0; i&lt;clientSize; i++) {\n            tarr[i].start();\n        }\n    }\n}\n</code></pre>\n<p>The output I'm trying to have is running 3 threads together, then next 3.\nHowever, all the threads are executing together printing 10 logs at the same time. What am I doing wrong?</p>\n",
    "tags" : [ "java", "multithreading", "locks" ],
    "owner" : {
      "account_id" : 2332852,
      "reputation" : 1118,
      "user_id" : 2045807,
      "user_type" : "registered",
      "accept_rate" : 62,
      "profile_image" : "https://i.sstatic.net/H50us.jpg?s=256",
      "display_name" : "Bhavuk Mathur",
      "link" : "https://stackoverflow.com/users/2045807/bhavuk-mathur"
    },
    "is_answered" : true,
    "view_count" : 151,
    "answer_count" : 3,
    "score" : 4,
    "last_activity_date" : 1748232774,
    "creation_date" : 1748079917,
    "link" : "https://stackoverflow.com/questions/79636631/multi-threading-run-processes-in-batches",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79636652,
    "question_id" : 79636631,
    "body" : "<p>Your CPU class isn't controlling the concurrency level of process execution. The threads you start in CPUDemo are doing their own processing... the CPU isn't starting the &quot;processing&quot; threads itself.</p>\n<p>Try to to decouple thread creation from task execution.</p>\n<p>Classic approach:</p>\n<ul>\n<li><p>Clients submit tasks (like your cpu.execute())</p>\n</li>\n<li><p>The CPU maintains a queue and a pool of worker threads (only 3)</p>\n</li>\n<li><p>Each worker takes a task from the queue, processes it, and picks the next</p>\n</li>\n</ul>\n",
    "score" : 3,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 108205,
      "reputation" : 28585,
      "user_id" : 287316,
      "user_type" : "registered",
      "accept_rate" : 87,
      "profile_image" : "https://www.gravatar.com/avatar/91e3968b06238889b8e1bcd7d3991a9a?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Student",
      "link" : "https://stackoverflow.com/users/287316/student"
    },
    "creation_date" : 1748081277,
    "last_activity_date" : 1748081277,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79637219,
    "question_id" : 79636631,
    "body" : "<h2>tl;dr</h2>\n<p>To batch tasks, use a fresh <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/ExecutorService.html\" rel=\"nofollow noreferrer\"><code>ExecutorService</code></a> instance in a try-with-resources.</p>\n<h2>Details</h2>\n<p>Besides the issues raised in the other Answersâ€¦</p>\n<ul>\n<li>Your queues <code>Queue&lt;Client&gt; executingThreadPool</code> &amp; <code>waitingThreadPool</code> are not thread-safe.</li>\n<li>Your code has other issues.</li>\n<li>Alternatively, your code could be revamped to use <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/ExecutorService.html\" rel=\"nofollow noreferrer\"><code>ExecutorService</code></a>.</li>\n</ul>\n<p>Regarding thread-safety, your two <code>Queue&lt;Client</code> objects use <code>LinkedList</code> class. You access those from the <code>execute</code> method which is called across threads by this code:</p>\n<pre class=\"lang-java prettyprint-override\"><code>            tarr[i] = new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    cpu.execute(carr[finalI]);\n                }\n            });\n</code></pre>\n<p>Though not contributing to your issue, your code has some naming choices that make for confusing or misleading reading.</p>\n<p>The name <code>execute</code> is name of the sole method of the <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/Executor.html\" rel=\"nofollow noreferrer\">Executor</a> interface, a fundamental part of modern threading in Java 5+. So I suggest avoiding that name. Be more descriptive; in this case <code>enqueue</code> because that method feeds each passed <code>Client</code> object into the processor.</p>\n<p>Your <code>Client</code> class could more simply be a <a href=\"https://openjdk.org/jeps/395\" rel=\"nofollow noreferrer\">record</a>.</p>\n<pre class=\"lang-java prettyprint-override\"><code>public record Client( Integer id , Integer priority ) { }\n</code></pre>\n<p>The simplest and generally best way to make a Singleton in Java is as an enum. And, using an enum eliminates the need to declare a reference variable in you demo <code>main</code> method.</p>\n<p>You can omit the constructor of <code>CPU</code> by assigning instances of <code>LinkedList</code> when declaring their reference variable. And, instead of <code>LinkedList</code>, use a thread-safe class. Use <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/BlockingQueue.html\" rel=\"nofollow noreferrer\"><code>BlockingQueue</code></a> rather than <code>Queue</code> as that interfaces requires its implementations to be thread-safe.  And given your field <code>priority</code> in <code>Client</code> I presume that you are headed in the directing of processing the <code>Client</code> object by their priority. So we can choose <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/PriorityBlockingQueue.html\" rel=\"nofollow noreferrer\"><code>PriorityBlockingQueue</code></a> as our implementation.</p>\n<p>To enable that prioritization, we make the <code>Client</code> record class <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/Comparable.html\" rel=\"nofollow noreferrer\"><code>Comparable</code></a>.</p>\n<p>Regarding your <code>Thread[]</code> and <code>Client[]</code> arrays, using the <a href=\"https://en.wikipedia.org/wiki/Java_collections_framework\" rel=\"nofollow noreferrer\"><em>Java Collections Framework</em></a> is more flexible and likely more common. Those could be a <code>SequencedCollection</code> like <code>List</code>. Tip: Use plain descriptive names like <code>threads</code> &amp; <code>clients</code> rather than <code>tarr</code> &amp; <code>carr</code>. The need for <a href=\"https://en.wikipedia.org/wiki/Hungarian_notation\" rel=\"nofollow noreferrer\">Hungarian Notation</a> evaporated decades ago. And a little thing, generally best to make <code>clientSize</code> a constant (<code>final</code> &amp; all-uppercase name): <code>final int CLIENT_COUNT = 10;</code>.</p>\n<p>Streams could be used instead of <code>for</code> loops to set up your threads and clients. One might consider the result more readable, but perhaps not.</p>\n<p>We can use a lambda to simplify your <code>new Thread</code> code.</p>\n<p>Your <code>executingThreadPool</code> &amp; <code>waitingThreadPool</code> should be marked <code>final</code> as a precaution to avoid inadvertently assigning another collection instance.</p>\n<p>Those two <code>executingThreadPool</code> &amp; <code>waitingThreadPool</code> are <em>not</em> thread pools. Thinking of them in that way is quite confusing. They are both collections of <code>Client</code> objects, so name them to say so. Similarly <code>CPU</code> is a confusing name for this class, where something like <code>ClientProcessor</code> is more clear.</p>\n<p>The name <code>MAX_THREAD_POOL</code> presumes an implementation choice prematurely. Instead, name it to describe its true intention, which is to limit the batch size of clients being processed simultaneously. Perhaps <code>CLIENT_BATCH_SIZE</code>. And, Java programmers generally expect primitive <code>int</code> rather than <code>Integer</code> for simple math, looping, and such where an object is not really needed.</p>\n<p><a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/Thread.html#sleep(java.time.Duration)\" rel=\"nofollow noreferrer\"><code>Thread.sleep</code></a> now takes a <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/time/Duration.html\" rel=\"nofollow noreferrer\"><code>Duration</code></a> for clarity: <code>Thread.sleep ( Duration.ofSeconds ( 1 ) )</code>.</p>\n<p>Where you call <code>process ( clientToProcess );</code>, the <code>clientToProcess</code> might be null. So skip calling <code>process</code> if null. Similarly, you might add calls to <code>Objects.requireNonNull</code> to your <code>executingThreadPool.add</code> calls.</p>\n<p>To avoid subtle concurrency bugs, your <code>lock</code> should be marked <code>final</code>.</p>\n<p>Resulting code:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public record Client( Integer id , Integer priority ) implements Comparable &lt; Client &gt;\n{\n    private static final Comparator &lt; Client &gt; COMPARATOR =\n            Comparator\n                    .comparing ( Client :: priority )\n                    .thenComparing ( Client :: id );\n\n    @Override\n    public int compareTo ( final Client that )\n    {\n        return Client.COMPARATOR.compare ( this , that );\n    }\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>public enum ClientProcessor\n{\n    INSTANCE; // Singleton pattern.\n\n    private final int CLIENT_BATCH_SIZE = 3;\n    final Object lock = new Object ( );\n\n    static final BlockingQueue &lt; Client &gt; clientsBeingProcessed = new PriorityBlockingQueue &lt;&gt; ( ); // A `BlockingQueue` is thread-safe by interface contract.\n    static final BlockingQueue &lt; Client &gt; clientsToProcess = new PriorityBlockingQueue &lt;&gt; ( );\n\n    public void enqueue ( Client client )\n    {\n        System.out.println ( &quot;Received client=&quot; + client.id ( ) );\n        clientsToProcess.add ( client );\n        synchronized ( lock )\n        {\n            if ( clientsBeingProcessed.size ( ) &lt; CLIENT_BATCH_SIZE )\n            {\n                clientsBeingProcessed.add ( Objects.requireNonNull ( clientsToProcess.poll ( ) ) );\n            }\n            else\n            {\n                try { lock.wait ( ); } catch ( InterruptedException e ) { throw new RuntimeException ( e ); }\n                clientsBeingProcessed.add ( Objects.requireNonNull ( clientsToProcess.poll ( ) ) );\n            }\n        }\n\n        Client clientToProcess;\n        synchronized ( lock ) { clientToProcess = clientsBeingProcessed.poll ( ); }\n        if ( Objects.nonNull ( clientToProcess ) ) process ( clientToProcess );\n\n        synchronized ( lock ) { lock.notifyAll ( ); }\n    }\n\n    public void process ( Client client )\n    {\n        System.out.println ( &quot;-----Executing client=&quot; + client.id ( ) );\n        try { Thread.sleep ( Duration.ofSeconds ( 1 ) ); } catch ( InterruptedException e ) { throw new RuntimeException ( e ); }\n    }\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>public class Demo\n{\n    public static void main ( String[] args )\n    {\n        final int CLIENT_COUNT = 10;\n\n        SequencedCollection &lt; Client &gt; clients =\n                IntStream\n                        .rangeClosed ( 1 , CLIENT_COUNT )\n                        .mapToObj ( i -&gt; new Client ( i , i ) )\n                        .toList ( );\n\n        SequencedCollection &lt; Thread &gt; threads =\n                clients\n                        .stream ( )\n                        .map (\n                                ( Client client ) -&gt; new Thread ( ( ) -&gt; ClientProcessor.INSTANCE.enqueue ( client ) )\n                        )\n                        .toList ( );\n        threads.forEach ( Thread :: start );  // Execute threads.\n    }\n}\n</code></pre>\n<h2><em>Executors</em> framework</h2>\n<p>But that still leaves us with your core problem of not batching properly. For that we can revamp your code to use the Executors framework added to Java 5. That framework greatly simplifies the challenges of threading.</p>\n<p>Package your task as a <code>Runnable</code> or <code>Callable</code>. Submit instances of those to an <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/ExecutorService.html\" rel=\"nofollow noreferrer\"><code>ExecutorService</code></a> object. A <code>ExecutorService</code> is <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/lang/AutoCloseable.html\" rel=\"nofollow noreferrer\"><code>AutoCloseable</code></a>. So you can use try-with-resources syntax.</p>\n<p>Now we can mark the <code>process</code> method on <code>ClientProcessor</code> as <code>private</code>. And no longer need your <code>lock</code> object and <code>synchronize</code> if our processor is only passed <code>Client</code> objects from a single thread (the main thread in this case).</p>\n<p>Each time <code>enqueue</code> is called, we collect the passed <code>Client</code>. We check to see if our collection has at least as many as we want in a batch (three). If so, we make a <code>Runnable</code> tasks from our each <code>Client</code>, and submit to a fresh new executor service. That executor service runs each of our <code>Runnable</code> tasks on background threads. Our code waits, blocking until those submitted tasks resolve (are done or fail).</p>\n<p>By the way, <code>final BlockingQueue &lt; Client &gt; clientsToProcess</code> need not be <code>static</code>. We are already implementing the <a href=\"https://en.wikipedia.org/wiki/Singleton_pattern\" rel=\"nofollow noreferrer\">Singleton pattern</a> by way of an <code>enum</code>, so the <code>static</code> is sort of redundant. But it should be <code>private</code> to conceal from prying eyes.</p>\n<pre class=\"lang-java prettyprint-override\"><code>public enum ClientProcessor\n{\n    INSTANCE; // Singleton pattern.\n\n    private final int CLIENT_BATCH_SIZE = 3;\n\n    private final BlockingQueue &lt; Client &gt; clientsToProcess = new PriorityBlockingQueue &lt;&gt; ( );\n\n    public void enqueue ( final Collection &lt;Client&gt; clients )\n    {\n        clients.forEach (client -&gt; System.out.println(&quot;Received client = &quot; + client.id ( ) ) );\n        clientsToProcess.addAll ( clients );\n        while ( clientsToProcess.size ( ) &gt;= CLIENT_BATCH_SIZE )\n        {\n            BlockingQueue &lt; Client &gt; batch = new PriorityBlockingQueue &lt;&gt; ( );\n            clientsToProcess.drainTo ( batch , CLIENT_BATCH_SIZE );\n            System.out.println ( &quot;batch = &quot; + batch );\n            try (\n                    ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor ( ) ;\n            )\n            {\n                batch\n                        .stream ( )\n                        .map ( ( Client c ) -&gt; ( Runnable ) ( ) -&gt; INSTANCE.process ( c ) )\n                        .forEach ( executorService :: submit );\n            } // Flow-of-control blocks here until all submitted tasks resolve.\n        }\n    }\n\n    public void process ( Client client )\n    {\n        System.out.println ( &quot; -----Executing client=&quot; + client.id ( ) );\n        try { Thread.sleep ( Duration.ofSeconds ( 1 ) ); } catch ( InterruptedException e ) { throw new RuntimeException ( e ); }\n    }\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>public class Demo\n{\n    public static void main ( String[] args )\n    {\n        final int CLIENT_COUNT = 10;\n\n        SequencedCollection &lt; Client &gt; clients =\n                IntStream\n                        .rangeClosed ( 1 , CLIENT_COUNT )\n                        .mapToObj ( i -&gt; new Client ( i , i ) )\n                        .toList ( );\n\n        ClientProcessor.INSTANCE.enqueue ( clients );  // Pass  clients.reversed() to prove the priority feature works.\n    }\n}\n</code></pre>\n<p>When run, we see our batches of three.</p>\n<pre class=\"lang-none prettyprint-override\"><code>Received client = 1\nReceived client = 2\nReceived client = 3\nReceived client = 4\nReceived client = 5\nReceived client = 6\nReceived client = 7\nReceived client = 8\nReceived client = 9\nReceived client = 10\nbatch = [Client[id=1, priority=1], Client[id=2, priority=2], Client[id=3, priority=3]]\n -----Executing client=3\n -----Executing client=1\n -----Executing client=2\nbatch = [Client[id=4, priority=4], Client[id=5, priority=5], Client[id=6, priority=6]]\n -----Executing client=4\n -----Executing client=6\n -----Executing client=5\nbatch = [Client[id=7, priority=7], Client[id=8, priority=8], Client[id=9, priority=9]]\n -----Executing client=7\n -----Executing client=8\n -----Executing client=9\n</code></pre>\n<p>Notice that the tenth <code>Client</code> object is extra (3 batches of 3 each is 9), enqueued but not yet processed. We need to add a <code>flush</code> method that processes any remaining <code>Client</code> objects that have been enqueued but not yet processed.</p>\n<p>We break out the batching logic to helper methods, so they may be called from two places: <code>enqueue</code> and <code>flush</code>.</p>\n<pre class=\"lang-java prettyprint-override\"><code>public enum ClientProcessor\n{\n    INSTANCE; // Singleton pattern.\n\n    private final int CLIENT_BATCH_SIZE = 3;\n\n    private final BlockingQueue &lt; Client &gt; clientsToProcess = new PriorityBlockingQueue &lt;&gt; ( );\n\n    public void enqueue ( final Collection &lt; Client &gt; clients )\n    {\n        clients.forEach ( client -&gt; System.out.println ( &quot;Received client = &quot; + client.id ( ) ) );\n        clientsToProcess.addAll ( clients );\n        this.processBatches ( );\n    }\n\n    private void processBatches ( )\n    {\n        while ( clientsToProcess.size ( ) &gt;= CLIENT_BATCH_SIZE )\n        {\n            BlockingQueue &lt; Client &gt; batch = new PriorityBlockingQueue &lt;&gt; ( );\n            clientsToProcess.drainTo ( batch , CLIENT_BATCH_SIZE );\n            System.out.println ( &quot;batch = &quot; + batch );\n            this.processBatch ( batch );\n        }\n    }\n\n    private void processBatch ( final BlockingQueue &lt; Client &gt; batch )\n    {\n        try (\n                ExecutorService executorService = Executors.newVirtualThreadPerTaskExecutor ( ) ;\n        )\n        {\n            batch\n                    .stream ( )\n                    .map ( ( Client c ) -&gt; ( Runnable ) ( ) -&gt; INSTANCE.process ( c ) )\n                    .forEach ( executorService :: submit );\n        } // Flow-of-control blocks here until all submitted tasks resolve.\n    }\n\n    private void process ( Client client )\n    {\n        System.out.println ( &quot; ----- Processing client=&quot; + client.id ( ) );\n        try { Thread.sleep ( Duration.ofSeconds ( 1 ) ); } catch ( InterruptedException e ) { throw new RuntimeException ( e ); }\n    }\n\n    public void flush ( )\n    {\n        //  Process any than remain.\n        this.processBatches ( ); // Run through batches in case we have more than 3 remaining.\n        System.out.println ( &quot; ----- Flushing &quot; + clientsToProcess.size ( ) + &quot; clients: &quot; );\n        clientsToProcess.forEach ( client -&gt; System.out.println ( &quot;   --- Will process Client=&quot; + client.id ( ) ) );\n        this.processBatch ( clientsToProcess ); // Process any remaining (1 or 2) Client objects as a batch, the last batch.\n    }\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>public class Demo\n{\n    public static void main ( String[] args )\n    {\n        final int CLIENT_COUNT = 10;\n\n        SequencedCollection &lt; Client &gt; clients =\n                IntStream\n                        .rangeClosed ( 1 , CLIENT_COUNT )\n                        .mapToObj ( i -&gt; new Client ( i , i ) )\n                        .toList ( );\n\n        ClientProcessor.INSTANCE.enqueue ( clients );  // Pass  clients.reversed() to prove the priority feature works.\n        ClientProcessor.INSTANCE.flush ( );\n    }\n}\n</code></pre>\n<p>Now we see the tenth Client object processed after the three batches of three.</p>\n<pre class=\"lang-none prettyprint-override\"><code>Received client = 1\nReceived client = 2\nReceived client = 3\nReceived client = 4\nReceived client = 5\nReceived client = 6\nReceived client = 7\nReceived client = 8\nReceived client = 9\nReceived client = 10\nbatch = [Client[id=1, priority=1], Client[id=2, priority=2], Client[id=3, priority=3]]\n ----- Processing client=1\n ----- Processing client=2\n ----- Processing client=3\nbatch = [Client[id=4, priority=4], Client[id=5, priority=5], Client[id=6, priority=6]]\n ----- Processing client=4\n ----- Processing client=5\n ----- Processing client=6\nbatch = [Client[id=7, priority=7], Client[id=8, priority=8], Client[id=9, priority=9]]\n ----- Processing client=7\n ----- Processing client=9\n ----- Processing client=8\n ----- Flushing 1 clients: \n   --- Will process Client=10\n ----- Processing client=10\n</code></pre>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 322981,
      "reputation" : 346951,
      "user_id" : 642706,
      "user_type" : "registered",
      "accept_rate" : 58,
      "profile_image" : "https://i.sstatic.net/ZWEI3.jpg?s=256",
      "display_name" : "Basil Bourque",
      "link" : "https://stackoverflow.com/users/642706/basil-bourque"
    },
    "creation_date" : 1748125618,
    "last_activity_date" : 1748232774,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79636733,
    "question_id" : 79636631,
    "body" : "<p>Your locks don't prevent more than MAX_THREAD_POOL running threads at once because each thread that calls <code>executingThreadPool.add</code> immediately uses <code>executingThreadPool.poll</code> and thus frees up a slot for another thread to do the same. Also any waiter queues without checking MAX_THREAD_POOL size. Hence most likely more than MAX_THREAD_POOL tasks will run concurrently.</p>\n<p>An alternative is to let each thread process the current client, use a while loop to check size, and use a set to define which are currently running, and remove from set at end rather than before calling <code>process(client)</code>:</p>\n<pre><code>static final Set&lt;Client&gt; executingThreadPool = new HashSet&lt;&gt;();\n\npublic void execute(Client client) throws InterruptedException {\n    System.out.println(&quot;Received client=&quot; + client);\n    synchronized (lock) {\n        while(executingThreadPool.size() &gt;= MAX_THREAD_POOL) {\n            lock.wait();\n        }\n        executingThreadPool.add(client);\n    }\n\n    process(client);\n\n    synchronized (lock) {\n        executingThreadPool.remove(client);\n        lock.notifyAll();\n    }\n}\n</code></pre>\n<p>Note that I've kept to the structure you've used for CPU class. You could use a counter (AtomicInteger) instead of <code>HashSet</code>, or <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/Semaphore.html\" rel=\"nofollow noreferrer\"><code>Semaphore</code></a> which is intended for this type of use.</p>\n<p>Overall your approach is wrong as it creates many threads when only MAX_THREAD_POOL are required - its more suitable when using virtual threads.</p>\n<p>However thread pools / worker threads as suggested by Student's answer would be more effective way to handle multiple tasks constrained to N at a time.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 5998820,
      "reputation" : 16283,
      "user_id" : 4712734,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f6e922a2cb7e2da59286f27b162aaca5?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "DuncG",
      "link" : "https://stackoverflow.com/users/4712734/duncg"
    },
    "creation_date" : 1748086927,
    "last_activity_date" : 1748088395,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140455492,
    "post_id" : 79636631,
    "body" : "...See <a href=\"https://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html\" rel=\"nofollow noreferrer\">docs.oracle.com/javase/tutorial/essential/concurrency/&hellip;</a> for a deeper dive into wait/notify.",
    "score" : 0,
    "owner" : {
      "account_id" : 422870,
      "reputation" : 27582,
      "user_id" : 801894,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/67f2ccd17aa6fd622152ad88fc2ae784?s=256&d=identicon&r=PG",
      "display_name" : "Solomon Slow",
      "link" : "https://stackoverflow.com/users/801894/solomon-slow"
    },
    "creation_date" : 1748098578,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140455485,
    "post_id" : 79636631,
    "body" : "FYI: Your use of <code>wait</code> and <code>notifyAll</code> is problematic. <code>CPU#execute</code> calls <code>lock.wait()</code> if <code>executingThreadPool.size()&gt;=MAX_THREAD_POOL</code>, but then after the <code>wait</code> returns, it blindly proceeds <i>as if</i> the size now is less than MAX_THREAD_POOL. The problem is, more than one thread may be waiting. When <i>one</i> other thread removes <i>one</i> item from the queue and calls notifyAll, then <i>all</i> of the waiting threads will wake up, and <i>all</i> of them will add their items to the queue. You might think that calling <code>notify</code> instead of <code>notifyAll</code> fixes the problem, but there are other complications...",
    "score" : 2,
    "owner" : {
      "account_id" : 422870,
      "reputation" : 27582,
      "user_id" : 801894,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/67f2ccd17aa6fd622152ad88fc2ae784?s=256&d=identicon&r=PG",
      "display_name" : "Solomon Slow",
      "link" : "https://stackoverflow.com/users/801894/solomon-slow"
    },
    "creation_date" : 1748098464,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}