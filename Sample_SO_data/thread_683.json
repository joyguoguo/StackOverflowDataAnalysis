{
  "question" : {
    "question_id" : 79782956,
    "title" : "Instant animation with KeyValue when using the overlay parent height as the target value",
    "body" : "<p>I previously posted a <a href=\"https://stackoverflow.com/questions/79782134/how-to-make-an-overlay-animation-in-a-stackpane-with-javafx\">question</a> about why the overlay animation in the <a href=\"https://openjfx.io/javadoc/25/javafx.graphics/javafx/scene/layout/StackPane.html\" rel=\"nofollow noreferrer\">StackPane</a> container occurs instantly when using <a href=\"https://openjfx.io/javadoc/25/javafx.graphics/javafx/animation/KeyFrame.html\" rel=\"nofollow noreferrer\">KeyFrame</a>.</p>\n<p>@Slaw pointed out the root of the issue in a <a href=\"https://stackoverflow.com/questions/79782134/how-to-make-an-overlay-animation-in-a-stackpane-with-javafx#comment-140776591:%7E:text=A%20couple%20things,yesterday\">comment</a>:</p>\n<blockquote>\n<p>You're using on-finished handlers of <code>KeyFrame</code>. Those are executed once at the end of the frame's duration. They do not cause the value to change incrementally over time.</p>\n</blockquote>\n<p>And to solve it:</p>\n<blockquote>\n<p>For that, pass a <code>KeyValue</code> when creating the <code>KeyFrame</code></p>\n</blockquote>\n<p>He also suggested reading his <a href=\"https://stackoverflow.com/questions/77385708/is-there-a-way-to-detect-the-same-event-on-multiple-nodes/77386307#77386307\">answer</a> to a previously posted <a href=\"https://stackoverflow.com/questions/77385708/is-there-a-way-to-detect-the-same-event-on-multiple-nodes\">question</a>, explaining how similar animations should be handled.</p>\n<h2>Solution</h2>\n<p>Following @slaw, answer: the <code>OverLayAnimation</code> class handles the <code>overlay</code> and <code>iconLabel</code> animations, respectively, using <a href=\"https://openjfx.io/javadoc/25/javafx.graphics/javafx/animation/ParallelTransition.html\" rel=\"nofollow noreferrer\">ParallelTransition</a>, for both sliding the overlay down and fading the label in. <code>playForward()</code>  <code>playBackward()</code> handles both events <code>MOUSE_ENTERED</code>  <code>MOUSE_EXITED</code></p>\n<h2>Problem</h2>\n<p>The <code>createToBottomAnimation()</code> returns a <a href=\"https://openjfx.io/javadoc/25/javafx.graphics/javafx/animation/Timeline.html\" rel=\"nofollow noreferrer\">Timeline</a> for transitioning the overlay. When the Keyframe's to value is hardcoded (200, for example), the animation occurs smoothly and the max height updates gradually. However, the issue is that when resizing the window, the overlay will not fill all its container since its <code>parent</code> has grown and the value is hardcoded.</p>\n<p>For that, I set the value to <code>overlay.getParent().getMaxHeight()</code>. The overlay does fill its container now, but <strong>no animation is occurring</strong></p>\n<h2>Code</h2>\n<pre><code>import javafx.animation.*;\nimport javafx.application.Application;\nimport javafx.geometry.Insets;\nimport javafx.geometry.Pos;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Label;\nimport javafx.scene.image.Image;\nimport javafx.scene.image.ImageView;\nimport javafx.scene.input.MouseEvent;\nimport javafx.scene.layout.*;\nimport javafx.stage.Stage;\nimport javafx.util.Duration;\n\nimport java.util.Objects;\n\npublic class Example extends Application {\n    private ImageView createImageIcon(String path) {\n        Image image = new Image(Objects.requireNonNull(getClass().getResourceAsStream(path)));\n        ImageView imageView = new ImageView(image);\n        imageView.setPreserveRatio(true);\n        imageView.setFitHeight(200);\n        imageView.setFitWidth(200);\n\n        return imageView;\n    }\n\n    private Pane crateImageIconContainer(ImageView image, VBox overlay, String iconTitle, HBox rootElement) {\n        Pane region = new Pane();\n        HBox.setMargin(region, new Insets(30, 30, 30, 30));\n        region.maxWidthProperty().bind(rootElement.widthProperty().divide(3));\n        region.maxHeightProperty().bind(region.widthProperty());\n        region.setPrefSize(400, 400);\n\n        StackPane stackableContainer = new StackPane();\n        HBox.setMargin(stackableContainer, new Insets(30, 30, 30, 30));\n        stackableContainer.prefWidthProperty().bind(region.widthProperty());\n        stackableContainer.prefHeightProperty().bind(region.heightProperty());\n\n        stackableContainer.setStyle(&quot;-fx-background-color: #ff0000;&quot;);\n\n        region.getChildren().add(stackableContainer);\n\n        image.fitWidthProperty().bind(stackableContainer.widthProperty().divide(1.5));\n        image.fitHeightProperty().bind(stackableContainer.heightProperty().divide(1.5));\n\n        Label iconLabel = new Label(iconTitle);\n        iconLabel.setOpacity(0);\n        overlay.getChildren().add(iconLabel);\n\n        overlay.setAlignment(Pos.CENTER);\n        StackPane.setAlignment(overlay, Pos.TOP_CENTER);\n        overlay.setStyle(&quot;-fx-background-color: #ffffff;&quot;);\n        overlay.setOpacity(0.8);\n        overlay.setMaxHeight(0);\n\n        stackableContainer.getChildren().addAll(image, overlay);\n\n        var animation = new OverLayAnimation(overlay, iconLabel);\n        stackableContainer.addEventHandler(MouseEvent.MOUSE_ENTERED, e -&gt; {\n            e.consume();\n            animation.playForward();\n        });\n        stackableContainer.addEventHandler(MouseEvent.MOUSE_EXITED, e -&gt; {\n            e.consume();\n            animation.playBackward();\n        });\n        return region;\n    }\n\n    @Override\n    public void start(Stage primaryStage) throws Exception {\n        HBox mainContainer = new HBox();\n        HBox.setHgrow(mainContainer, Priority.ALWAYS);\n        mainContainer.setAlignment(Pos.CENTER);\n        mainContainer.setStyle(&quot;-fx-background-color: #00396c;&quot;);\n\n        ImageView photoIcon = createImageIcon(&quot;../resources/photo.png&quot;);\n        ImageView videoIcon = createImageIcon(&quot;../resources/video.png&quot;);\n        ImageView webCamIcon = createImageIcon(&quot;../resources/webcam.png&quot;);\n\n        Pane photoIconContainer = crateImageIconContainer(photoIcon, new VBox(), &quot;Photo&quot;, mainContainer);\n        Pane videoIconContainer = crateImageIconContainer(videoIcon, new VBox(), &quot;Video&quot;, mainContainer);\n        Pane webCamIconContainer = crateImageIconContainer(webCamIcon, new VBox(), &quot;Web Cam&quot;, mainContainer);\n\n        mainContainer.getChildren().addAll(photoIconContainer, videoIconContainer, webCamIconContainer);\n\n        Scene scene = new Scene(mainContainer, 900, 350);\n        primaryStage.setTitle(&quot;Color isolator&quot;);\n        primaryStage.setScene(scene);\n        primaryStage.show();\n    }\n\n    private static class OverLayAnimation {\n        private final VBox overlay;\n        private final Label iconLabel;\n        private static final Duration DURATION = Duration.millis(350);\n        private final ParallelTransition transition;\n\n        OverLayAnimation(VBox overlay, Label iconLabel) {\n            this.overlay = overlay;\n            this.iconLabel = iconLabel;\n\n            var toBottom = createToBottomAnimation();\n            var fadeInOut = createFadeInAndOutAnimation();\n\n            transition = new ParallelTransition(toBottom, fadeInOut);\n        }\n\n        void playForward() {\n            transition.setRate(1);\n            transition.play();\n        }\n\n        void playBackward() {\n            // Does not execute\n            // transition.setRate(-1);\n            // transition.play();\n\n            KeyValue x = new KeyValue(overlay.maxHeightProperty(), 0);\n            KeyFrame frame = new KeyFrame(DURATION, x);\n            Timeline timeline = new Timeline(frame);\n            timeline.play();\n        }\n\n        private Animation createToBottomAnimation() {\n            // Animate instantly\n            KeyValue x = new KeyValue(overlay.maxHeightProperty(), ((Pane) overlay.getParent()).getMaxHeight());\n\n            // Animate smoothly\n            // KeyValue x = new KeyValue(overlay.maxHeightProperty(), 200);\n            KeyFrame frame = new KeyFrame(DURATION, x);\n            return new Timeline(frame);\n        }\n\n        private Animation createFadeInAndOutAnimation() {\n            var fadeInOut = new FadeTransition(DURATION, iconLabel);\n            fadeInOut.setFromValue(0);\n            fadeInOut.setToValue(1);\n            return fadeInOut;\n        }\n    }\n}\n</code></pre>\n<h2>Results</h2>\n<p>This is how the <a href=\"https://imgur.com/a/UOA0hr4\" rel=\"nofollow noreferrer\">instant</a> animation look like. And <a href=\"https://imgur.com/a/1H5oR47\" rel=\"nofollow noreferrer\">this</a> is how the animation is supposed to look like, but since the to value is 200, it will not fill the container.</p>\n<p>I would like to know why the animation occurs instantly and, if possible, why <code>setRate(-1)</code> in <code>playBackward()</code> does not cause the keyFrame to go backward with the overlay animation.</p>\n",
    "tags" : [ "java", "animation", "javafx", "key-value" ],
    "owner" : {
      "account_id" : 12506291,
      "reputation" : 811,
      "user_id" : 9103039,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
      "display_name" : "Starnec",
      "link" : "https://stackoverflow.com/users/9103039/starnec"
    },
    "is_answered" : true,
    "view_count" : 184,
    "answer_count" : 1,
    "score" : 4,
    "last_activity_date" : 1759931031,
    "creation_date" : 1759664241,
    "link" : "https://stackoverflow.com/questions/79782956/instant-animation-with-keyvalue-when-using-the-overlay-parent-height-as-the-targ",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79783939,
    "question_id" : 79782956,
    "body" : "<p>I recommend against binding the sizes of nodes to sizes of their parents.</p>\n<p>The JavaFX layout mechanism implicitly defines a dependency of the size of a parent node on the sizes of its child nodes. If you bind the size of a child node to the size of its parent, you create a circular dependency, from which <a href=\"https://gist.github.com/james-d/08971a9d511727ea44d72917dec40e20\" rel=\"nofollow noreferrer\">strange things can happen</a>.</p>\n<p>To make a child node's size dependent on the parent node, either (the most common case) use a layout pane with constraints that support the dependency you want to implement, or create a custom region, and implement the <code>layoutChildren()</code> method to resize and position the child nodes depending on the size available. In the following example I use the first method (specifically, a <code>GridPane</code> with column constraints) to position the three panes equally across the width of the container, and the second technique to position an image in the center of the pane, sized to the maximum size available (while respecting the <code>preserveRatio</code> property, or at least acknowledging that the size of the image may not be the size requested by <code>fitWidth</code> and <code>fitHeight</code>), with an overlay placed over it.</p>\n<p>The strategy I'd recommend for sliding an overlay across another node, and retracting it, is to define a property representing how much of the overlay is visible, as a proportion from 0 (no overlay) to 1 (overlay completely covering the node). In the layout, place the overlay directly on top of the node with the same position and same size. Add a clip to the overlay, and set the size of the clip based on the size of the node/overlay and the property (so, e.g. use a rectangle for the clip with the height of the rectangle equal to the height of the node, multiplied by the property value).</p>\n<p>In this example I define a subclass of <code>Region</code> that positions the image and its overlay, and supports an <code>overlayProportion</code> property as described above. When the property changes, a layout pass is requested (via an invalidation listener). A rectangular clip is used, extending down from the top, but you can also experiment with other options (e.g. a circle or making the rectangle spread from the center, etc.).</p>\n<p>Now all that the animation has to do is to animate the value of the <code>overlayProportionProperty</code> between 0 and 1. A simple <code>Timeline</code> can do this.</p>\n<p>Here is a full solution; I modified the original code to generate an on-the-fly image so it can be run without access to any resources.</p>\n<pre><code>import javafx.animation.*;\nimport javafx.application.Application;\nimport javafx.beans.property.DoubleProperty;\nimport javafx.beans.property.SimpleDoubleProperty;\nimport javafx.geometry.Insets;\nimport javafx.geometry.Pos;\nimport javafx.scene.Node;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Label;\nimport javafx.scene.image.ImageView;\nimport javafx.scene.image.PixelWriter;\nimport javafx.scene.image.WritableImage;\nimport javafx.scene.input.MouseEvent;\nimport javafx.scene.layout.*;\nimport javafx.scene.paint.Color;\nimport javafx.scene.shape.Rectangle;\nimport javafx.stage.Stage;\nimport javafx.util.Duration;\n\npublic class Example extends Application {\n    private ImageView createImageIcon(Color baseColor) {\n//        Image image = new Image(Objects.requireNonNull(getClass().getResourceAsStream(path)));\n        WritableImage image = new WritableImage(2,2);\n        PixelWriter pw = image.getPixelWriter();\n        pw.setColor(0, 0, baseColor);\n        pw.setColor(0, 1, baseColor.darker());\n        pw.setColor(1, 0, baseColor.darker());\n        pw.setColor(1, 1, baseColor);\n        ImageView imageView = new ImageView(image);\n        imageView.setPreserveRatio(true);\n        imageView.setFitHeight(200);\n        imageView.setFitWidth(200);\n\n        return imageView;\n    }\n\n    private Region createImageIconContainer(ImageView image, String iconTitle) {\n        Label label = new Label(iconTitle);\n        VBox overlay = new VBox(label);\n        overlay.setMouseTransparent(true);\n        overlay.setOpacity(0.8);\n        ImageOverlayContainer imageOverlayContainer = new ImageOverlayContainer(image, overlay);\n        imageOverlayContainer.setPadding(new Insets(30));\n        imageOverlayContainer.setPrefSize(400, 400);\n        imageOverlayContainer.setStyle(&quot;-fx-background-color: #ff0000;&quot;);\n\n        overlay.setAlignment(Pos.TOP_CENTER);\n        overlay.setStyle(&quot;-fx-background-color: #ffffff;&quot;);\n        overlay.setOpacity(0.8);\n\n        Timeline timeline = new Timeline(\n                new KeyFrame(Duration.ZERO, new KeyValue(imageOverlayContainer.overlayProportionProperty(), 0.0)),\n                new KeyFrame(Duration.millis(350), new KeyValue(imageOverlayContainer.overlayProportionProperty(), 1.0))\n        );\n\n        image.addEventHandler(MouseEvent.MOUSE_ENTERED, e -&gt; {\n            e.consume();\n            timeline.setRate(1);\n            timeline.play();\n        });\n        image.addEventHandler(MouseEvent.MOUSE_EXITED, e -&gt; {\n            e.consume();\n            timeline.setRate(-1);\n            timeline.play();\n        });\n        return imageOverlayContainer;\n    }\n\n    @Override\n    public void start(Stage primaryStage) throws Exception {\n        GridPane mainContainer = new GridPane();\n        mainContainer.setAlignment(Pos.CENTER);\n        mainContainer.setStyle(&quot;-fx-background-color: #00396c;&quot;);\n        ColumnConstraints cc = new ColumnConstraints();\n        cc.setPercentWidth(100.0/3);\n        mainContainer.getColumnConstraints().addAll(cc, cc, cc);\n\n        ImageView photoIcon = createImageIcon(Color.RED);\n        ImageView videoIcon = createImageIcon(Color.GREEN);\n        ImageView webCamIcon = createImageIcon(Color.BLUE);\n\n        Region photoIconContainer = createImageIconContainer(photoIcon, &quot;Photo&quot;);\n        Region videoIconContainer = createImageIconContainer(videoIcon, &quot;Video&quot;);\n        Region webCamIconContainer = createImageIconContainer(webCamIcon, &quot;Web Cam&quot;);\n\n        mainContainer.addRow(0, photoIconContainer, videoIconContainer, webCamIconContainer);\n\n        Scene scene = new Scene(mainContainer, 900, 350);\n        primaryStage.setTitle(&quot;Color isolator&quot;);\n        primaryStage.setScene(scene);\n        primaryStage.show();\n    }\n\n    private static class ImageOverlayContainer extends Region {\n        private final ImageView imageView;\n        private final Node overlay ;\n        private final Rectangle overlayClip = new Rectangle(0, 0, 0, 0);\n\n        private final DoubleProperty overlayProportion = new SimpleDoubleProperty();\n        public DoubleProperty overlayProportionProperty() {\n            return overlayProportion;\n        }\n        public final double getOverlayProportion() {\n            return overlayProportionProperty().get();\n        }\n        public final void setOverlayProportion(double overlayProportion) {\n            overlayProportionProperty().set(overlayProportion);\n        }\n\n        public ImageOverlayContainer(ImageView imageView, Node overlay) {\n            this.imageView = imageView;\n            this.overlay = overlay;\n            this.overlay.setClip(overlayClip);\n            getChildren().addAll(imageView, overlay);\n            overlayProportion.addListener(_ -&gt; requestLayout());\n        }\n        @Override\n        protected void layoutChildren() {\n            double availWidth = snapSizeX(getWidth() - getInsets().getLeft() - getInsets().getRight());\n            double availHeight = snapSizeY(getHeight() - getInsets().getTop() - getInsets().getBottom());\n            imageView.setFitWidth(availWidth);\n            imageView.setFitHeight(availHeight);\n\n            double imgW = imageView.getBoundsInLocal().getWidth();\n            double imgH = imageView.getBoundsInLocal().getHeight();\n\n            double x = snapPositionX(getInsets().getLeft() + (availWidth - imgW) / 2);\n            double y = snapPositionY(getInsets().getTop() + (availHeight - imgH) / 2);\n\n            imageView.setX(x);\n            imageView.setY(y);\n\n            overlayClip.setWidth(imgW);\n            overlayClip.setHeight(imgH * Math.clamp(getOverlayProportion(), 0, 1));\n            overlay.resizeRelocate(x, y, imgW, imgH);\n\n        }\n    }\n}\n</code></pre>\n",
    "score" : 4,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 2518243,
      "reputation" : 210906,
      "user_id" : 2189127,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
      "display_name" : "James_D",
      "link" : "https://stackoverflow.com/users/2189127/james-d"
    },
    "creation_date" : 1759772415,
    "last_activity_date" : 1759931031,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79783939" : [ {
      "comment_id" : 140780394,
      "post_id" : 79783939,
      "body" : "@Starnec The point is really that sizes are determined by the layout mechanism. Outside of that mechanism, it&#39;s difficult to know what the actual size of something is at any given time, and if you&#39;re trying to determine the size during an animation, it gets very difficult to know what the target values should be. This mechanism just abstracts out the value you need (proportion that is covered by the overlay) and &quot;animates&quot; that value. Then it ensures the layout is recomputed on the fly when that value changes. In other words, it does the size lookups and computations <i>inside</i> the layout mechan",
      "score" : 3,
      "owner" : {
        "account_id" : 2518243,
        "reputation" : 210906,
        "user_id" : 2189127,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
        "display_name" : "James_D",
        "link" : "https://stackoverflow.com/users/2189127/james-d"
      },
      "creation_date" : 1759779427,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140780380,
      "post_id" : 79783939,
      "body" : "@Slaw Thanks. I think I knew that, but forgot it along the way. I updated the code to use it.",
      "score" : 0,
      "owner" : {
        "account_id" : 2518243,
        "reputation" : 210906,
        "user_id" : 2189127,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
        "display_name" : "James_D",
        "link" : "https://stackoverflow.com/users/2189127/james-d"
      },
      "creation_date" : 1759779047,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140780372,
      "post_id" : 79783939,
      "body" : "@Starnec Yes, in that deleted answer, he did <code>region.heightProperty().addListener((...) -&gt; { ... stackableContainer.addEventHandler( ... ); ...});</code>. So every time the height changes, the listener is invoked, and every time the listener is invoked, a new event handler is added to the <code>stackableContainer</code>. Then when the event (in this case a mouse entered event) occurs, <i>all</i> of those event handlers will be invoked. Just put a <code>System.out.println(...)</code> in the mouse event handler to see the problem.",
      "score" : 1,
      "owner" : {
        "account_id" : 2518243,
        "reputation" : 210906,
        "user_id" : 2189127,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
        "display_name" : "James_D",
        "link" : "https://stackoverflow.com/users/2189127/james-d"
      },
      "creation_date" : 1759778904,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140780363,
      "post_id" : 79783939,
      "body" : "Thank you; I doubted that the issue might have been caused by binding the child&#39;s size to its parent&#39;s. Extending the <code>Region</code> class and overriding <code>layoutChildren()</code>, is the best solution to dictate how the parent should position and size its children",
      "score" : 0,
      "owner" : {
        "account_id" : 12506291,
        "reputation" : 811,
        "user_id" : 9103039,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
        "display_name" : "Starnec",
        "link" : "https://stackoverflow.com/users/9103039/starnec"
      },
      "creation_date" : 1759778704,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140780362,
      "post_id" : 79783939,
      "body" : "Note <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Math.html#clamp(double,double,double)\" rel=\"nofollow noreferrer\"><code>Math::clamp</code></a> was added in Java 21. That can be used instead of the old <code>max(a, min(b, v))</code> approach.",
      "score" : 2,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49884,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1759778701,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140780329,
      "post_id" : 79783939,
      "body" : "I thought that the only thing is that a new animation will be created for each resize event occurring for the container. Do you mean <code>region.heightProperty().addListener((obs, oldValue, newValue))</code> will cause creation of many handlers for the current and last container size, as well as the handlers in between when resizing? (This is about the answer Sederik deleted)",
      "score" : 0,
      "owner" : {
        "account_id" : 12506291,
        "reputation" : 811,
        "user_id" : 9103039,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
        "display_name" : "Starnec",
        "link" : "https://stackoverflow.com/users/9103039/starnec"
      },
      "creation_date" : 1759777526,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}