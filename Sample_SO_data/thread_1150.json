{
  "question" : {
    "question_id" : 79737888,
    "title" : "Minimum cost to convert all 1&#39;s to 0&#39;s using window of size k",
    "body" : "<p>There is a row of toys, where each toy is represented as either:</p>\n<pre><code>1 → red toy (needs to be painted blue),\n\n0 → blue toy (already painted).\n</code></pre>\n<p>An integer k is given. An operation can be performed as follows:</p>\n<p>Select any consecutive subarray of length k.</p>\n<p>Compute the cost of this operation as the sum of values in the subarray.</p>\n<p>Within this subarray, choose one toy and paint it blue (1 → 0).</p>\n<p>The goal is to paint all red toys (1) blue (0) with the minimum total cost.</p>\n<p><strong>Example:</strong></p>\n<pre><code>Toys: 1 1 1 0 1\nk = 4\n\nStep 1: Choose indices [2..5] → cost = 1+1+0+1 = 3 → paint index 2 → [1 0 1 0 1]  \nStep 2: Choose indices [1..4] → cost = 1+0+1+0 = 2 → paint index 3 → [1 0 0 0 1]  \nStep 3: Choose indices [2..5] → cost = 0+0+0+1 = 1 → paint index 5 → [1 0 0 0 0]  \nStep 4: Choose indices [1..4] → cost = 1+0+0+0 = 1 → paint index 1 → [0 0 0 0 0]  \n\nTotal cost = 3 + 2 + 1 + 1 = 7\n</code></pre>\n<p><strong>Contrainsts are:</strong></p>\n<pre><code>1 &lt;= k,n &lt;= 10^5\ntoys[i] = {0,1} for all 0 &lt;= i &lt;n\n</code></pre>\n<p>Here is my program with logic explained :</p>\n<p>I haved used recursion with memoization, with Base case as, If all toys are 0, cost = 0 (no more work needed).\nMemoization check is, If this toy arrangement was solved before, just return the stored result.</p>\n<p>Otherwise:\nTry every window of length k.\nCalculate the cost of that window (sum of values inside).\nInside that window, try flipping each 1 to 0.\nThis creates a new toy arrangement.\nRecursively solve that new arrangement, and add the cost.\nKeep track of the minimum cost among all possibilities.\nSave it in memo and return.</p>\n<pre><code>import java.util.*;\n\npublic class MinCostToys {\n    public static int minCost(List&lt;Integer&gt; toys, int k) {\n        return dfs(toys, k, new HashMap&lt;&gt;());\n    }\n\n    private static int dfs(List&lt;Integer&gt; toys, int k, Map&lt;List&lt;Integer&gt;, Integer&gt; memo) {\n        if (!toys.contains(1)) {\n            return 0; // all are blue\n        }\n        if (memo.containsKey(toys)) {\n            return memo.get(toys);\n        }\n\n        int n = toys.size();\n        int min = Integer.MAX_VALUE;\n\n        // Try all windows of size k\n        for (int i = 0; i &lt;= n - k; i++) {\n            List&lt;Integer&gt; window = toys.subList(i, i + k);\n            int cost = window.stream().mapToInt(x -&gt; x).sum();\n\n            // Try painting each position in the window\n            for (int j = 0; j &lt; k; j++) {\n                if (toys.get(i + j) == 1) {\n                    List&lt;Integer&gt; next = new ArrayList&lt;&gt;(toys);\n                    next.set(i + j, 0);\n                    min = Math.min(min, cost + dfs(next, k, memo));\n                }\n            }\n        }\n\n        memo.put(toys, min);\n        return min;\n    }\n\n    \n    public static void main(String[] args) {\n        System.out.println(minCost(Arrays.asList(1,1,1,0,1), 4));//7\n        System.out.println(minCost(Arrays.asList(1,0,1,0,1), 3));//3\n        System.out.println(minCost(Arrays.asList(1,1,0,1), 3));//4\n    }   \n}\n</code></pre>\n<p>Time complexity of this code is : <strong>O(2^n * n * k)</strong></p>\n<p>How to solve this in less time complexity? Is it possible to solve in less than O(n*k) time?</p>\n",
    "tags" : [ "java", "algorithm", "time-complexity" ],
    "owner" : {
      "account_id" : 31187804,
      "reputation" : 794,
      "user_id" : 23993901,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/7417aaad0c8ece3fac44f06d05a8ba8b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "CodeCrusader",
      "link" : "https://stackoverflow.com/users/23993901/codecrusader"
    },
    "is_answered" : true,
    "view_count" : 302,
    "answer_count" : 1,
    "score" : 2,
    "last_activity_date" : 1755460954,
    "creation_date" : 1755440839,
    "link" : "https://stackoverflow.com/questions/79737888/minimum-cost-to-convert-all-1s-to-0s-using-window-of-size-k",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79737945,
    "question_id" : 79737888,
    "body" : "<h3>Minimizing operation cost:</h3>\n<p>We can invert <strong>only</strong> <strong>one</strong> toy, cost for that operation varies from 1 to <code>k</code>.</p>\n<p>Hence for minimizing final sum, we should chose subarray with maximum number of zeros every time. Let's call that subarray <code>Z</code>.</p>\n<p>After inverting the first red toy, subarray <code>Z</code> remains the best, because we reduced the cost of the operation</p>\n<h3>Algorithm:</h3>\n<ol>\n<li><p>Find subarray <code>Z</code> with maximum number of zeros. It will be O(n) complexity;</p>\n</li>\n<li><p>Calculate sum of operations to invert all <code>1 -&gt; 0</code> in <code>Z</code>. Аrithmetic progression formula with O(1) complexity;</p>\n</li>\n<li><p>Calculate sum of other operations. That will be equal number of '1' in whole array, because we will move <code>Z</code> on one index left/right. O(n) complexity.</p>\n</li>\n</ol>\n<h3>Implementation O(n) algorithm:</h3>\n<pre><code>import java.util.List;\n\npublic class MinCostToys {\n    public long minCost(List&lt;Integer&gt; toys, int k) {\n        int n = toys.size();\n        if (k &gt; n) {\n            return -1;\n        }\n        int totalOnes = 0;\n        for (int toy : toys) {\n            totalOnes += toy;\n        }\n        if (totalOnes == 0) {\n            return 0;\n        }\n        int windowOnes = 0;\n        for (int i = 0; i &lt; k; i++) {\n            windowOnes += toys.get(i);\n        }\n        int minOnes = windowOnes;\n        for (int i = k; i &lt; n; i++) {\n            windowOnes = windowOnes - toys.get(i - k) + toys.get(i);\n            if (windowOnes &lt; minOnes) {\n                minOnes = windowOnes;\n            }\n        }\n        long costForMinOnes = (long) minOnes * (minOnes + 1) / 2;\n        return costForMinOnes + (totalOnes - minOnes);\n    }\n}  \n</code></pre>\n",
    "score" : 6,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 43516472,
      "reputation" : 118,
      "user_id" : 31280687,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/ced26c26ba7d25781d2768ddba293c9d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Gerwerus",
      "link" : "https://stackoverflow.com/users/31280687/gerwerus"
    },
    "creation_date" : 1755447847,
    "last_activity_date" : 1755459458,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}