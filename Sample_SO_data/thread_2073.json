{
  "question" : {
    "question_id" : 79650880,
    "title" : "Performance nosedive on Swing updates",
    "body" : "<p>Here's an MRE.</p>\n<pre class=\"lang-java prettyprint-override\"><code>import javax.swing.JComponent;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\nimport javax.swing.JTextField;\nimport javax.swing.WindowConstants;\nimport javax.swing.border.Border;\nimport javax.swing.border.EmptyBorder;\nimport javax.swing.plaf.basic.BasicTextFieldUI;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.Graphics;\n\npublic class TextFieldDemo {\n\n    public static void main(String[] args) {\n        Container mainPanel = createMainPanel();\n        JFrame frame = new JFrame(&quot;Text field demo&quot;);\n        frame.setContentPane(mainPanel);\n        frame.setLocationRelativeTo(null);\n        frame.pack();\n        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        frame.setVisible(true);\n    }\n\n    private static Container createMainPanel() {\n        JPanel panel = new JPanel();\n        panel.add(createTextField());\n        return panel;\n    }\n\n    private static Component createTextField() {\n        JTextField textField = new JTextField(10);\n        textField.setUI(new BasicTextFieldUI() {\n            int counter = 1;\n\n            @Override\n            public void update(Graphics g, JComponent c) {\n                super.update(g, c);\n                textField.setBorder(textField.getBorder());\n//                textField.setBorder(getBorder());\n                System.out.printf(&quot;UPDATING %d...%n&quot;, counter++);\n            }\n\n            private Border getBorder() {\n                EmptyBorder border = new EmptyBorder(0, 3, 0, 3);\n                return border;\n            }\n        });\n        return textField;\n    }\n}\n</code></pre>\n<h1>Test #1</h1>\n<p>Run it as is and set the cursor in the field.</p>\n<p>Swing keeps infinitely updating the field for no apparent reason (maybe, it's the caret, idk)...</p>\n<pre><code>UPDATING 26...\nUPDATING 27...\nUPDATING 28...\nUPDATING 29...\nUPDATING 30...\n</code></pre>\n<p>...but the CPU is doing fine:</p>\n<p><a href=\"https://i.sstatic.net/9QS0sR6K.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/9QS0sR6K.png\" alt=\"CPU usage is zero\" /></a></p>\n<p>Shifting the focus stops the updates.</p>\n<h1>Test #2</h1>\n<p>If I uncomment the other line, on the other hand:</p>\n<pre class=\"lang-java prettyprint-override\"><code>//                textField.setBorder(textField.getBorder());\n                textField.setBorder(getBorder());\n</code></pre>\n<p>it's going to wreak havoc on my machine. Updates are much more frequent...</p>\n<pre><code>UPDATING 39745...\nUPDATING 39746...\nUPDATING 39747...\nUPDATING 39748...\n</code></pre>\n<p>...taking a toll on my CPU:</p>\n<p><a href=\"https://i.sstatic.net/4aAzwuCL.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/4aAzwuCL.png\" alt=\"CPU usage is 20+\" /></a></p>\n<p>Interestingly, if I shift the focus to another window, updates do <strong>not</strong> stop, and CPU usage gets even worse (30+).</p>\n<p>My understanding is if I set a new border instance in UI's updating method, it'll enter an infinite loop: the setting would call <code>repaint()</code> which would, in turn, call the updating method:</p>\n<pre class=\"lang-java prettyprint-override\"><code>// javax.swing.JComponent#setBorder\n    public void setBorder(Border border) {\n        Border         oldBorder = this.border;\n\n        this.border = border;\n        firePropertyChange(&quot;border&quot;, oldBorder, border);\n        if (border != oldBorder) {\n            if (border == null || oldBorder == null ||\n                !(border.getBorderInsets(this).equals(oldBorder.getBorderInsets(this)))) {\n                revalidate();\n            }\n            repaint();\n        }\n    }\n</code></pre>\n<p>My questions are:</p>\n<ol>\n<li>Why does that performance hit happen, is my guess correct?</li>\n<li>Why don't I get a <code>StackOverflowError</code>?</li>\n</ol>\n",
    "tags" : [ "java", "swing" ],
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2681,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "is_answered" : false,
    "view_count" : 81,
    "answer_count" : 0,
    "score" : 1,
    "last_activity_date" : 1748939030,
    "creation_date" : 1748939030,
    "link" : "https://stackoverflow.com/questions/79650880/performance-nosedive-on-swing-updates",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140483952,
    "post_id" : 79650880,
    "body" : "Well, there’s also the option of implementing a dynamic border by just implementing a dynamic border, i.e. a border that paints itself in a way reflecting the property as intended. Apparently, the property in question does already trigger a repaint on changes, so as long as the border’s size does not change, it’s enough to have the appropriate <code>paintBorder</code> implementation. Why bother with the different degrees of “how south will it go” of an entirely inappropriate approach? When running though a hail of bullets it doesn’t matter which one hit you.",
    "score" : 4,
    "owner" : {
      "account_id" : 3211603,
      "reputation" : 300981,
      "user_id" : 2711488,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
      "display_name" : "Holger",
      "link" : "https://stackoverflow.com/users/2711488/holger"
    },
    "creation_date" : 1748964392,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140483804,
    "post_id" : 79650880,
    "body" : "@Holger we have a component with a dynamic border that depends on its other property. Of course, this could (and should) be achieved otherwise, e.g. by listening to the property change or overriding the property setter. It&#39;s not a question <i>&quot;how do I do X&quot;</i> but rather <i>&quot;why does it all go south when I do Y&quot;</i>",
    "score" : 0,
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2681,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "creation_date" : 1748962090,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140483571,
    "post_id" : 79650880,
    "body" : "What’s the point of this? The <code>update</code> method is supposed to <i>draw</i> the component, not to modify the component. There’s not even a point in messing around with the Look&amp;Feel implementation class <code>BasicTextFieldUI</code>. If you want a custom border, just set the border on the component once with <code>setBorder</code> and you’re done.",
    "score" : 6,
    "owner" : {
      "account_id" : 3211603,
      "reputation" : 300981,
      "user_id" : 2711488,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
      "display_name" : "Holger",
      "link" : "https://stackoverflow.com/users/2711488/holger"
    },
    "creation_date" : 1748958279,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140483362,
    "post_id" : 79650880,
    "body" : "Yes, the exact same behavior as you describe. In both cases. If you really wanna dig deeper, use the debugger and check the variables and stack traces. On the other hand, why do you care so much about a problem that exists only due to a bad design choice? Why not simply improve the design?",
    "score" : 5,
    "owner" : {
      "account_id" : 2182934,
      "reputation" : 2660,
      "user_id" : 1932011,
      "user_type" : "registered",
      "accept_rate" : 71,
      "profile_image" : "https://www.gravatar.com/avatar/612163480a1ccb4785fd647a003eefbb?s=256&d=identicon&r=PG",
      "display_name" : "JayC667",
      "link" : "https://stackoverflow.com/users/1932011/jayc667"
    },
    "creation_date" : 1748955232,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140483081,
    "post_id" : 79650880,
    "body" : "@JayC667 but you, too, can reproduce it, can&#39;t you?",
    "score" : 0,
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2681,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "creation_date" : 1748950218,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140483024,
    "post_id" : 79650880,
    "body" : "But I don&#39;t know why that <code>revalidate()</code> happens on the subsequent calls, too (re-assigning the identical border). Might have to do something with Swings desire not to have <i>identical</i> JComponents displayed in different locations, or some intrinsic aftereffect of the call to <code>firePropertyChange(&quot;border&quot;, oldBorder, border);</code>. So because I cannot exhaustively answer, I don&#39;t find it justified to designate this as an answer.",
    "score" : 2,
    "owner" : {
      "account_id" : 2182934,
      "reputation" : 2660,
      "user_id" : 1932011,
      "user_type" : "registered",
      "accept_rate" : 71,
      "profile_image" : "https://www.gravatar.com/avatar/612163480a1ccb4785fd647a003eefbb?s=256&d=identicon&r=PG",
      "display_name" : "JayC667",
      "link" : "https://stackoverflow.com/users/1932011/jayc667"
    },
    "creation_date" : 1748948859,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140483013,
    "post_id" : 79650880,
    "body" : "I&#39;m not posting that as an answer, because: a) I do NOT know about the phenomenons, where Test #1 and Test #2 differ in regards to focus. This <i>might</i> have to do something with displayability (was the window minimized / in the background?) or with repaint priorities. b) Test #2 &#39;wreaking havoc&#39; -as opposed to the first: <a href=\"https://github.com/frohoff/jdk8u-jdk/blob/master/src/share/classes/javax/swing/JComponent.java#L1792\" rel=\"nofollow noreferrer\">Component.setBorder()</a> show us, that in re-assigning the identical border causes a <code>repaint()</code>, while assigning different borders causes a <code>revalidate()</code>.",
    "score" : 1,
    "owner" : {
      "account_id" : 2182934,
      "reputation" : 2660,
      "user_id" : 1932011,
      "user_type" : "registered",
      "accept_rate" : 71,
      "profile_image" : "https://www.gravatar.com/avatar/612163480a1ccb4785fd647a003eefbb?s=256&d=identicon&r=PG",
      "display_name" : "JayC667",
      "link" : "https://stackoverflow.com/users/1932011/jayc667"
    },
    "creation_date" : 1748948701,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140482924,
    "post_id" : 79650880,
    "body" : "@JayC667 why does Swing keep updating the field if it&#39;s in focus, because of the caret?",
    "score" : 0,
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2681,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "creation_date" : 1748947066,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140482895,
    "post_id" : 79650880,
    "body" : "@JayC667 you should post",
    "score" : 0,
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2681,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "creation_date" : 1748946490,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140482789,
    "post_id" : 79650880,
    "body" : "@JayC667 This sounds like an answer, not a comment.",
    "score" : 2,
    "owner" : {
      "account_id" : 108033,
      "reputation" : 20099,
      "user_id" : 286934,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f16a184d26b72795ff243464d715cffe?s=256&d=identicon&r=PG",
      "display_name" : "Progman",
      "link" : "https://stackoverflow.com/users/286934/progman"
    },
    "creation_date" : 1748943924,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140482603,
    "post_id" : 79650880,
    "body" : "1) Yes, you get an infinite loop, for exactly the same reasons you&#39;re mentioning. 2) In simple terms: You will not get a <code>StackOverflow</code>, because UI handling in Swing is done via messaging/event queues, and the EDT (Event Dispatch Thread), NOT via recursive calls. The EDT processes those queued events one after the other (see <code>SwingUtilities.invokeX()</code>. If you had multiple calls to <code>setBorder()</code>, you <b>might</b> create more events than consumed, at some point run out of mem for the queue. <i>Might</i>, because the repaint/update events can also get skipped, if there are newer requests in the queue.",
    "score" : 5,
    "owner" : {
      "account_id" : 2182934,
      "reputation" : 2660,
      "user_id" : 1932011,
      "user_type" : "registered",
      "accept_rate" : 71,
      "profile_image" : "https://www.gravatar.com/avatar/612163480a1ccb4785fd647a003eefbb?s=256&d=identicon&r=PG",
      "display_name" : "JayC667",
      "link" : "https://stackoverflow.com/users/1932011/jayc667"
    },
    "creation_date" : 1748940478,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}