{
  "question" : {
    "question_id" : 79640669,
    "title" : "Why does getEngineByName(&quot;JavaScript&quot;) returns null",
    "body" : "<p>I'm using GraalVM to execute JavaScript code in Java. I included the following Maven dependencies:</p>\n<pre class=\"lang-xml prettyprint-override\"><code>&lt;dependency&gt;\n  &lt;groupId&gt;org.graalvm.js&lt;/groupId&gt;\n  &lt;artifactId&gt;js&lt;/artifactId&gt;\n  &lt;version&gt;24.1.2&lt;/version&gt;\n  &lt;type&gt;pom&lt;/type&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.graalvm.polyglot&lt;/groupId&gt;\n  &lt;artifactId&gt;polyglot&lt;/artifactId&gt;\n  &lt;version&gt;24.1.2&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.graalvm.js&lt;/groupId&gt;\n  &lt;artifactId&gt;js-scriptengine&lt;/artifactId&gt;\n  &lt;version&gt;24.1.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>I'm trying to get the JavaScript engine like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>ScriptEngine engine = new ScriptEngineManager().getEngineByName(&quot;JavaScript&quot;);\n</code></pre>\n<p>But for some users or environments, this returns <code>null</code>, while for others it works as expected.\nWhy is this happening, and how can I ensure the JavaScript engine is available consistently?</p>\n",
    "tags" : [ "java", "proxy", "graalvm" ],
    "owner" : {
      "account_id" : 21482951,
      "reputation" : 57,
      "user_id" : 15830011,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/900267ce2fb516516cfdd41d18351e19?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "chwbr",
      "link" : "https://stackoverflow.com/users/15830011/chwbr"
    },
    "is_answered" : true,
    "view_count" : 116,
    "answer_count" : 1,
    "score" : 2,
    "last_activity_date" : 1748462012,
    "creation_date" : 1748355657,
    "link" : "https://stackoverflow.com/questions/79640669/why-does-getenginebynamejavascript-returns-null",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79640752,
    "question_id" : 79640669,
    "body" : "<p><code>ScriptEngine</code> in GraalVM is part of the legacy Java Scripting API (JSR-223),  which relies on the standard SPI (Service Provider Interface) mechanism to discover available scripting engines. In well-configured environments, this mechanism works reliably. However, in some modern setups - such as shaded\n(&quot;fat&quot;) JARs, modular applications, or when using GraalVM native image - service discovery can silently fail due to how metadata like\n<code>META-INF/services/javax.script.ScriptEngineFactory</code> is handled or omitted.</p>\n<p>This file must be present in the correct location inside the JAR for the engine to be discovered. If it's missing or not correctly merged during packaging, <code>getEngineByName(&quot;JavaScript&quot;)</code> can return <code>null</code>.</p>\n<p>As per the <a href=\"https://www.graalvm.org/latest/reference-manual/js/ScriptEngine\" rel=\"nofollow noreferrer\">official GraalVM documentation</a>:</p>\n<blockquote>\n<p>GraalJS provides a JSR-223 compliant javax.script.ScriptEngine implementation for running JavaScript. Note that this feature is provided for legacy reasons to allow easier migration for implementations currently based on a ScriptEngine. We strongly encourage users to use the org.graalvm.polyglot.Context interface to control many of the settings directly and benefit from finer-grained security settings in GraalVM.</p>\n</blockquote>\n<p>So, for a more stable and portable setup (especially when using native image or modular runtimes), it's recommended to use the <code>org.graalvm.polyglot.Context</code> API directly, which doesn't rely on SPI and is fully supported.</p>\n<p>Example:</p>\n<pre><code>import org.graalvm.polyglot.Context;\nimport org.graalvm.polyglot.Value;\n\npublic class JsExample {\n    public static void main(String[] args) {\n        try (Context context = Context.newBuilder(&quot;js&quot;).allowAllAccess(true).build()) {\n            Value result = context.eval(&quot;js&quot;, &quot;const name = 'JS'; `Hello, ${name}!`&quot;);\n            System.out.println(result.asString()); // Output: Hello, JS!\n        }\n    }\n}\n</code></pre>\n<p>This approach is reliable across all environments where GraalJS is properly included.</p>\n",
    "score" : 4,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 38931631,
      "reputation" : 671,
      "user_id" : 29023248,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/WxoZEuKw.png?s=256",
      "display_name" : "Aleksey Bykov",
      "link" : "https://stackoverflow.com/users/29023248/aleksey-bykov"
    },
    "creation_date" : 1748358630,
    "last_activity_date" : 1748462012,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79640752" : [ {
      "comment_id" : 140467339,
      "post_id" : 79640752,
      "body" : "Thanks for the clarification - you&#39;re absolutely right that SPI works reliably in standard Java runtimes when used correctly. My point was more about the practical issues that often arise in modern setups (fat JARs, modules, GraalVM native image), where SPI can silently fail. I&#39;ll reword the answer to make that clearer and avoid giving the wrong impression. Appreciate the input!",
      "score" : 0,
      "owner" : {
        "account_id" : 38931631,
        "reputation" : 671,
        "user_id" : 29023248,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/WxoZEuKw.png?s=256",
        "display_name" : "Aleksey Bykov",
        "link" : "https://stackoverflow.com/users/29023248/aleksey-bykov"
      },
      "creation_date" : 1748461563,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140467228,
      "post_id" : 79640752,
      "body" : "Your description of the SPI mechanism as “unreliable” is misleading.  In any normal Java runtime, it is completely reliable.  Shaded jars (a.k.a “fat jars”) are a hack that was never supported, for exactly the reason you mention:  they often don’t properly incorporate non-class data like META-INF/services from various other .jars.  (It gets even more complicated with modular jars, which don’t use META-INF/services at all.)",
      "score" : 1,
      "owner" : {
        "account_id" : 2053598,
        "reputation" : 44936,
        "user_id" : 1831987,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/38b1c37530189ec4471a43a618e33f67?s=256&d=identicon&r=PG",
        "display_name" : "VGR",
        "link" : "https://stackoverflow.com/users/1831987/vgr"
      },
      "creation_date" : 1748458686,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}