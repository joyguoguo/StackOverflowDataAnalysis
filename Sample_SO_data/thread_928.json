{
  "question" : {
    "question_id" : 79759286,
    "title" : "When to use Gatherers.fold over Stream.reduce?",
    "body" : "<h3>Prelude</h3>\n<p>Java 24 introduced <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Gatherer.html\" rel=\"nofollow noreferrer\">Stream Gatherers</a> as a full-fledged feature.</p>\n<p>These Gatherers allow the user to declare custom intermediate operations on streams; also, the standard library provides a few implementations in <code>java.util.stream.Gatherers</code>.</p>\n<p>There is a static factory method called <code>Gatherers.fold</code>, which creates a Gatherer that performs a sequential, possibly type-altering reduction operation. Its doc comment reads as follows:</p>\n<blockquote>\n<p>Returns a Gatherer that performs an ordered, <i>reduction-like</i>, transformation for scenarios where no combiner-function can be implemented, or for reductions which are intrinsically order-dependent.</p>\n</blockquote>\n<p>As of Java 25, there are also 3 different &quot;native&quot; declarations of the <code>reduce</code>-method on <code>Stream</code>:</p>\n<ul>\n<li><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code></li>\n<li><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</code></li>\n<li><code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</code></li>\n</ul>\n<h3>Question</h3>\n<p>When should one use the new <code>fold</code>-Gatherer over the classic <code>reduce</code>-method?</p>\n<h3>Thoughts</h3>\n<p>The JavaDoc comment of <code>fold</code> mentions two scenarios, in which the Gatherer should be used:</p>\n<blockquote>\n<p>Returns a Gatherer that performs an ordered, [...] transformation [...] for reductions which are intrinsically order-dependent.</p>\n</blockquote>\n<p>But reduction on a sequential Stream is already ordered:</p>\n<pre class=\"lang-java prettyprint-override\"><code>void main() {\n    var res = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n            .reduce(0, (a, b) -&gt; {\n                System.out.println(b);\n                return a + b;\n            });\n    System.out.println(res);\n}\n</code></pre>\n<p>Output: 1 2 3 4 5 6 7 8 9 10 55</p>\n<hr />\n<blockquote>\n<p>Returns a Gatherer that performs [a], transformation for scenarios where no combiner-function can be implemented [...]</p>\n</blockquote>\n<p><s>The first and second reduce-Implementation already omit the combiner-function.</s></p>\n<p><sup><i>As the <a href=\"/a/79759297/18197654\">answer of Louis Wasserman</a> correctly mentioned: In the two cases where no explicit combiner method is provided, <code>reduce</code> uses the accumulator as a combiner.</i></sup></p>\n<hr />\n<p>The only use case I can imagine is if you want to perform an ordered reduction on a parallel stream. But when would you do this? Doesn't that defeat the purpose of parallel?</p>\n",
    "tags" : [ "java", "java-stream", "java-22" ],
    "owner" : {
      "account_id" : 23646042,
      "reputation" : 997,
      "user_id" : 18197654,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/dSgqg.png?s=256",
      "display_name" : "xtay2",
      "link" : "https://stackoverflow.com/users/18197654/xtay2"
    },
    "is_answered" : true,
    "view_count" : 234,
    "answer_count" : 1,
    "score" : 9,
    "last_activity_date" : 1757508726,
    "creation_date" : 1757360820,
    "link" : "https://stackoverflow.com/questions/79759286/when-to-use-gatherers-fold-over-stream-reduce",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79759297,
    "question_id" : 79759286,
    "body" : "<blockquote>\n<p>But reduction on a sequential Stream is already ordered:</p>\n</blockquote>\n<p>That's not specified in the documentation, and subject to change.</p>\n<blockquote>\n<p>The first and second reduce-Implementation already omit the combiner-function.</p>\n</blockquote>\n<p>What gives you that idea?  <code>accumulator</code> <em>is</em> a perfectly valid combiner and is used as such.  On parallel streams, the stream may be broken into chunks, each of which get reduced separately, then the reduced results from each chunk may be reduced with <code>accumulator</code> as a group.</p>\n<p>This is guaranteed to be equivalent, assuming you satisfy <code>accumulator</code>'s contract: the identity (if provided) must <em>be</em> an identity, and <code>accumulator</code> must be associative; with those constraints, that implementation is valid.</p>\n<blockquote>\n<p>The only use case I can imagine is if you want to perform an ordered reduction on a parallel stream. But when would you do this? Doesn't that defeat the purpose of parallel?</p>\n</blockquote>\n<p>When some operations in a stream chain can be done in parallel and some can't.</p>\n<p><code>fold</code> drops the restrictions that the combiner function must be associative, and works on arbitrary streams (sequential or parallel) in that context.  It is a little strange in that it is used to get a stream with one element, which would normally be a reason to drop out of streams entirely, but it is perfectly reasonable if that's fine.  I would generally consider it appropriate to use in that circumstance -- when there is no associative combining operation.</p>\n",
    "score" : 6,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 465573,
      "reputation" : 200423,
      "user_id" : 869736,
      "user_type" : "registered",
      "accept_rate" : 82,
      "profile_image" : "https://www.gravatar.com/avatar/ae7bb06b9a23a4dd7eea69e853d47d12?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Louis Wasserman",
      "link" : "https://stackoverflow.com/users/869736/louis-wasserman"
    },
    "creation_date" : 1757361570,
    "last_activity_date" : 1757362012,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140870125,
    "post_id" : 79759286,
    "body" : "You may <b>fold</b>-gather streams to <code>flatMap</code> them?",
    "score" : 0,
    "owner" : {
      "account_id" : 370994,
      "reputation" : 36639,
      "user_id" : 719263,
      "user_type" : "registered",
      "accept_rate" : 100,
      "profile_image" : "https://www.gravatar.com/avatar/7feab598abfc27783641fe2b796a0155?s=256&d=identicon&r=PG",
      "display_name" : "Jean-Baptiste Yun&#232;s",
      "link" : "https://stackoverflow.com/users/719263/jean-baptiste-yun%c3%a8s"
    },
    "creation_date" : 1763987492,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79759297" : [ {
      "comment_id" : 140724575,
      "post_id" : 79759297,
      "body" : "@BrittneyLeigh while it is possible to implement a combiner working the way you have in mind, the <code>windowFixed(N).andThen(fold(..))</code> won’t work that way. The <code>windowFixed</code> produces a sequence of <code>List</code>s of the specified size, but the subsequent <code>fold</code> would have to fold those lists into a single result, still producing a stream of size one.",
      "score" : 5,
      "owner" : {
        "account_id" : 3211603,
        "reputation" : 300981,
        "user_id" : 2711488,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
        "display_name" : "Holger",
        "link" : "https://stackoverflow.com/users/2711488/holger"
      },
      "creation_date" : 1757424543,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140723419,
      "post_id" : 79759297,
      "body" : "That would be an interesting way you can compose gatherers.",
      "score" : 0,
      "owner" : {
        "account_id" : 465573,
        "reputation" : 200423,
        "user_id" : 869736,
        "user_type" : "registered",
        "accept_rate" : 82,
        "profile_image" : "https://www.gravatar.com/avatar/ae7bb06b9a23a4dd7eea69e853d47d12?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Louis Wasserman",
        "link" : "https://stackoverflow.com/users/869736/louis-wasserman"
      },
      "creation_date" : 1757391336,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140723052,
      "post_id" : 79759297,
      "body" : "fold isn’t about “one value then keep streaming.” It’s useful when combined with other gatherers: e.g. windowFixed(N).andThen(fold(..)) emits per-chunk results you can still map/filter downstream. That keeps pipelines lazy and composable, unlike doing a terminal reduce and then result.stream().",
      "score" : 5,
      "owner" : {
        "user_type" : "does_not_exist",
        "display_name" : "user20752285"
      },
      "creation_date" : 1757367370,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140723041,
      "post_id" : 79759297,
      "body" : "@BrittneyLeigh It is not obvious to me what value that adds.  Once you have one and only one value, why would you <i>want</i> to keep going with stream operations, in a way that wouldn&#39;t just amount to <code>result.stream()</code> or something equivalent?  I&#39;m not aware of anything built-in that lets you compose gatherers in interesting ways or do something meaningful with &quot;per-chunk&quot; operations.",
      "score" : 0,
      "owner" : {
        "account_id" : 465573,
        "reputation" : 200423,
        "user_id" : 869736,
        "user_type" : "registered",
        "accept_rate" : 82,
        "profile_image" : "https://www.gravatar.com/avatar/ae7bb06b9a23a4dd7eea69e853d47d12?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Louis Wasserman",
        "link" : "https://stackoverflow.com/users/869736/louis-wasserman"
      },
      "creation_date" : 1757366843,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140723029,
      "post_id" : 79759297,
      "body" : "Fold also buys you composability (mid-pipeline, per-chunk reductions), not only “sequential reduction on a parallel stream.”",
      "score" : 1,
      "owner" : {
        "user_type" : "does_not_exist",
        "display_name" : "user20752285"
      },
      "creation_date" : 1757366306,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}