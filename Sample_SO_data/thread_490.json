{
  "question" : {
    "question_id" : 79800110,
    "title" : "Zoom-by-slider goes awry when binding the slider to the scale property",
    "body" : "<h2>Intro</h2>\n<p>The following code demonstrates the <code>Zoom</code> and <code>Drag</code> functionalities of an <a href=\"https://openjfx.io/javadoc/25/javafx.graphics/javafx/scene/image/ImageView.html\" rel=\"noreferrer\">ImageView</a> in a viewport. Zoom can be adjusted either by scrolling the mouse wheel or through a <a href=\"https://openjfx.io/javadoc/25/javafx.controls/javafx/scene/control/Slider.html\" rel=\"noreferrer\">Slider</a>. Meanwhile, dragging is performed by clicking the right mouse button and moving the mouse.</p>\n<p>To combine these transformations, I am using the <a href=\"https://openjfx.io/javadoc/25/javafx.graphics/javafx/scene/transform/Affine.html\" rel=\"noreferrer\">Affine</a> transform. <code>scale</code>, <code>tx</code>, and <code>ty</code> are <a href=\"https://openjfx.io/javadoc/25/javafx.base/javafx/beans/property/DoubleProperty.html\" rel=\"noreferrer\">double properties</a> with listeners so that whenever a new value is set, a transformation occurs.</p>\n<h2>Events &amp; Transformations</h2>\n<p>The <code>viewport.setOnMousePressed</code> will capture the <code>(x,y)</code> coordinates of where the click happens in the viewport, and save them using a <code>Delta</code> object.</p>\n<p>The <code>viewport.setOnMouseDragged</code> method calculates the new coordinates <code>(dx, dy)</code>. It then updates <code>tx</code> and <code>ty</code> by adding <code>dx</code> and <code>dy</code>, respectively. This triggers the transformation, which moves the image to the new position.</p>\n<p>The <code>viewport.setOnMouseClicked</code> is used to detect double clicks. When triggered, <code>centerFit</code> is called with <code>scale = 1</code>, <code>tx = 0</code>, and <code>ty = 0</code>, centering the image again.</p>\n<p>The <code>viewport.addEventFilter(ScrollEvent.SCROLL, e -&gt;</code> detects whether the scroll is inward or outward. It then clamps the scale between <code>MIN_SCALE</code>, <code>MAX_SCALE</code>, and  <code>oldScale</code> using the <code>clamp</code> function. Finally, it shifts and scales the image, ensuring the mouse remains over the point being zoomed.</p>\n<p>The <code>slider.valueProperty().addListener</code> functions similarly to zoom-by-wheel-scroll, but it zooms in and out around the center of the image.</p>\n<p>So in summary this is how it work:</p>\n<blockquote>\n<p>EventHandler ---&gt; update properties ---&gt; create an affine transform</p>\n</blockquote>\n<h2>Code</h2>\n<p>The class <code>ZoomAndShiftImage</code>, implements all that have been explained above</p>\n<pre><code>import javafx.application.Application;\nimport javafx.beans.property.DoubleProperty;\nimport javafx.beans.property.SimpleDoubleProperty;\nimport javafx.geometry.Point2D;\nimport javafx.scene.Scene;\nimport javafx.scene.image.Image;\nimport javafx.scene.image.ImageView;\nimport javafx.scene.input.MouseButton;\nimport javafx.scene.input.ScrollEvent;\nimport javafx.scene.layout.BorderPane;\nimport javafx.scene.layout.Pane;\nimport javafx.scene.paint.Color;\nimport javafx.scene.shape.Rectangle;\nimport javafx.scene.transform.Affine;\nimport javafx.stage.Stage;\nimport javafx.scene.control.Slider;\nimport javafx.util.StringConverter;\n\nimport java.util.Objects;\n\npublic class ZoomAndShiftImage extends Application {\n    private final double MIN_SCALE = 0.25;\n    private final double MAX_SCALE = 8.0;\n    private static double DEFAULT_SCALE;\n\n    @Override\n    public void start(Stage stage) {\n        Image image = new Image(Objects.requireNonNull(Objects.requireNonNull(getClass().getResourceAsStream(&quot;path/to/image&quot;))));\n        ImageView imageView = new ImageView(image);\n        imageView.setPreserveRatio(true);\n        imageView.setSmooth(true);\n\n        Affine affine = new Affine();\n        imageView.getTransforms().add(affine);\n\n        Pane viewport = new Pane(imageView);\n        Rectangle clip = new Rectangle();\n\n        clip.widthProperty().bind(viewport.widthProperty());\n        clip.heightProperty().bind(viewport.heightProperty());\n\n        viewport.setClip(clip);\n        viewport.setStyle(&quot;-fx-background-color: #1d2026;&quot;); \n\n        // --- Model properties for transform- zoom(scale) and shift(translate)\n        DoubleProperty scale = new SimpleDoubleProperty(1.0); // zoom\n        DoubleProperty tx = new SimpleDoubleProperty(0); // shift at the x-axis\n        DoubleProperty ty = new SimpleDoubleProperty(0); // shift at the y-axis\n\n        Runnable applyTransform = () -&gt; {\n            affine.setToTransform(scale.get(), 0, tx.get(), 0, scale.get(), ty.get());\n        };\n\n        // Apply transformation whe the property is changed\n        scale.addListener((_, _, _) -&gt; applyTransform.run());\n        tx.addListener((_, _, _) -&gt; applyTransform.run());\n        ty.addListener((_, _, _) -&gt; applyTransform.run());\n\n        applyTransform.run();\n\n        final Delta drag = new Delta();\n        Slider slider = getSlider();\n        slider.valueProperty().bindBidirectional(scale);\n\n        viewport.setOnMousePressed(e -&gt; {\n            if (e.getButton() == MouseButton.PRIMARY) {\n                // Save the current coordinates of the click\n                drag.x = e.getX();\n                drag.y = e.getY();\n            }\n        });\n\n        viewport.setOnMouseDragged(e -&gt; {\n            double dx = e.getX() - drag.x;\n            double dy = e.getY() - drag.y;\n\n            drag.x = e.getX();\n            drag.y = e.getY();\n\n            tx.set(tx.get() + dx);\n            ty.set(ty.get() + dy);\n        });\n\n        viewport.setOnMouseClicked(e -&gt; {\n            if (e.getClickCount() == 2 &amp;&amp; e.getButton() == MouseButton.PRIMARY) {\n                scale.set(1.0);\n                tx.set(0.0);\n                ty.set(0.0);\n\n                centerFit(imageView, viewport, scale, tx, ty);\n            }\n        });\n\n        viewport.addEventFilter(ScrollEvent.SCROLL, e -&gt; {\n            Point2D pivotOnImage = imageView.sceneToLocal(e.getSceneX(), e.getSceneY());\n\n            if (!imageView.getBoundsInLocal().contains(pivotOnImage))\n                return;\n\n            double direction = (e.getDeltaY() &gt; 0) ? 1.1 : (1 / 1.1);\n            double oldScale = scale.get();\n            double newScale = clamp(oldScale, direction);\n\n            if (newScale == 0) {\n                scale.set(1.0);\n                tx.set(0.0);\n                ty.set(0.0);\n\n                centerFit(imageView, viewport, scale, tx, ty);\n                return;\n            }\n\n            tx.set(tx.get() + (oldScale - newScale) * pivotOnImage.getX());\n            ty.set(ty.get() + (oldScale - newScale) * pivotOnImage.getY());\n            scale.set(newScale);\n\n            e.consume();\n        });\n\n        slider.valueProperty().addListener((_, _, newV) -&gt; {\n            double oldScale = scale.get();\n            double newScale = newV.doubleValue();\n\n            if (Math.abs(newScale - oldScale) &lt; 1e-12)\n                return;\n\n            Point2D centerInScene = viewport.localToScene(viewport.getWidth() / 2.0, viewport.getHeight() / 2.0);\n            Point2D pivotOnImage = imageView.sceneToLocal(centerInScene);\n\n            tx.set(tx.get() + (oldScale - newScale) * pivotOnImage.getX());\n            ty.set(ty.get() + (oldScale - newScale) * pivotOnImage.getY());\n            scale.set(newScale);\n        });\n\n        // Center the image whenever the window is resized\n        viewport.layoutBoundsProperty().addListener((_, _, _) -&gt;\n                centerFit(imageView, viewport, scale, tx, ty));\n\n        BorderPane root = new BorderPane(viewport);\n        root.setBottom(slider);\n\n        Scene scene = new Scene(root, 900, 600, Color.BLACK);\n        stage.setTitle(&quot;JavaFX ImageView: Zoom (wheel) + Pan (drag)&quot;);\n        stage.setScene(scene);\n        stage.show();\n\n        DEFAULT_SCALE = scale.get() * (1 / 1.1);\n    }\n\n    private Slider getSlider() {\n        Slider slider = new Slider(1, MAX_SCALE, 1.0);\n        slider.setBlockIncrement(0.1);\n        slider.setMajorTickUnit(1.0);\n        slider.setMinorTickCount(9);\n        slider.setShowTickMarks(true);\n        slider.setShowTickLabels(true);\n\n        slider.setLabelFormatter(new StringConverter&lt;&gt;() {\n            @Override\n            public String toString(Double v) {\n                if (Math.abs(v - 0.0) &lt; 1e-6) return &quot;0.25x&quot;;\n                if (Math.abs(v - 0.5) &lt; 1e-6) return &quot;0.5x&quot;;\n                if (Math.abs(v - 1.0) &lt; 1e-6) return &quot;1x&quot;;\n                if (Math.abs(v - 2.0) &lt; 1e-6) return &quot;2x&quot;;\n                if (Math.abs(v - 4.0) &lt; 1e-6) return &quot;4x&quot;;\n                if (Math.abs(v - 8.0) &lt; 1e-6) return &quot;8x&quot;;\n                return String.format(&quot;%.2fx&quot;, v);\n            }\n\n            @Override\n            public Double fromString(String s) {\n                return 1.0;\n            }\n        });\n        return slider;\n    }\n\n    private void centerFit(ImageView imageView, Pane viewport, DoubleProperty scale, DoubleProperty tx, DoubleProperty ty) {\n        Image image = imageView.getImage();\n        if (image == null || image.getWidth() &lt;= 0 || image.getHeight() &lt;= 0)\n            return;\n\n        double viewportWidth = viewport.getWidth();\n        double viewportHeight = viewport.getHeight();\n\n        if (viewportWidth &lt;= 0 || viewportHeight &lt;= 0)\n            return;\n\n        double sx = viewportWidth / image.getWidth();\n        double sy = viewportHeight / image.getHeight();\n        double fit = Math.min(sx, sy);\n\n        scale.set(fit);\n\n        double imageWidth = image.getWidth();\n        double imageHeight = image.getHeight();\n\n        double scaledW = imageWidth * fit;\n        double scaledH = imageHeight * fit;\n\n        tx.set((viewportWidth - scaledW) / 2.0);\n        ty.set((viewportHeight - scaledH) / 2.0);\n    }\n\n    private static double clamp(double oldScale, double direction) {\n        double d = Math.min(oldScale * direction, 8.0);\n\n        if (d &gt;= 2 * 0.25 || direction &gt; 1)\n            return d;\n        else if (d &lt;= (DEFAULT_SCALE + 0.02))\n            return 0;\n\n        return d;\n    }\n\n    private static class Delta {\n        double x, y;\n    }\n}\n\n</code></pre>\n<h2>The problem</h2>\n<p>The <code>zoom-by-wheel-scrolling</code> and <code>zoom-by-slider</code> are not synchronized and are not aware of each other. For example, when zooming with the wheel, the slider does not update and remains at its current setting, and the same applies vice versa.</p>\n<p>To reach this &quot;synchronization,&quot; I used <code>slider.valueProperty().bindBidirectional(scale)</code> to make the relation go both ways, and one will update itself when the other event occurs.</p>\n<p>However, this caused a peculiar problem with the zoom-by-slider. The issue lies in the translation, where the image scales correctly but shifts unexpectedly—moving to the top-left corner when zooming in and to the bottom-right when zoomed out.</p>\n<p>This is how the <a href=\"https://imgur.com/a/CewShZC\" rel=\"noreferrer\">right-zoom</a> looks like, and this is how the <a href=\"https://imgur.com/a/hWSjB6E\" rel=\"noreferrer\">strange</a> one looks like. I want to understand why the translation goes awry when using the slider, when its <code>valueProperty</code> is bound to the scale.</p>\n<p><strong>PS: The main purpose of this code is to achieve the same zoom and drag as in Windows 11, when opening an image with the default app.</strong></p>\n",
    "tags" : [ "java", "javafx", "transform", "scale" ],
    "owner" : {
      "account_id" : 12506291,
      "reputation" : 811,
      "user_id" : 9103039,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
      "display_name" : "Starnec",
      "link" : "https://stackoverflow.com/users/9103039/starnec"
    },
    "is_answered" : true,
    "view_count" : 265,
    "answer_count" : 2,
    "score" : 5,
    "last_activity_date" : 1761912750,
    "creation_date" : 1761489573,
    "link" : "https://stackoverflow.com/questions/79800110/zoom-by-slider-goes-awry-when-binding-the-slider-to-the-scale-property",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79803047,
    "question_id" : 79800110,
    "body" : "<p>The binding results in the <code>scale</code> changing when the slider value changes. Some simple logging demonstrates that this happens before the listener on the slider's <code>valueProperty</code> is invoked, but note that this is an implementation detail you shouldn't rely on.</p>\n<p>Consequently, in the listener for the slider's value property, <code>scale.get()</code> returns the <em>updated</em> scale value, not the old one, which is necessarily equal to the new slider value. So in your listener, <code>Math.abs(newScale - oldScale)</code> is always zero:</p>\n<pre><code>        slider.valueProperty().addListener((_, _, newV) -&gt; {\n            double oldScale = scale.get();\n            double newScale = newV.doubleValue();\n\n            if (Math.abs(newScale - oldScale) &lt; 1e-12) // always true\n                return;\n\n            // The remaining code here is never reached.\n\n            Point2D centerInScene = viewport.localToScene(viewport.getWidth() / 2.0, viewport.getHeight() / 2.0);\n            Point2D pivotOnImage = imageView.sceneToLocal(centerInScene);\n\n            tx.set(tx.get() + (oldScale - newScale) * pivotOnImage.getX());\n            ty.set(ty.get() + (oldScale - newScale) * pivotOnImage.getY());\n            scale.set(newScale);\n        });\n</code></pre>\n<p>So what actually happens when the slider is moved by the user is that it causes the <code>scale</code> to change (via the binding), which invokes the listener on the <code>scale</code> property. The listener on <code>scale</code> calls the <code>applyTransform</code> function</p>\n<pre><code>        Runnable applyTransform = () -&gt; {\n            affine.setToTransform(scale.get(), 0, tx.get(), 0, scale.get(), ty.get());\n        };\n</code></pre>\n<p>which then uses whatever the current values of <code>tx</code> and <code>ty</code> are as the pivot. Since these haven't been changed, they will correspond to the previous mouse click on the image (or 0 if there has not been a mouse click). So the zoom will not pivot on the center of the image, resulting in the incorrect behavior.</p>\n<p>An apparent fix is to use the correct old value for the scale. This will fix the immediate problem, because you recompute <code>tx</code> and <code>ty</code> after the scale listener is invoked, recomputing the transform that was computed by the scale listener.</p>\n<pre><code>        slider.valueProperty().addListener((_, oldV, newV) -&gt; {\n            double oldScale = oldV.doubleValue();\n            double newScale = newV.doubleValue();\n\n            if (Math.abs(newScale - oldScale) &lt; 1e-12)\n                return;\n\n            Point2D centerInScene = viewport.localToScene(viewport.getWidth() / 2.0, viewport.getHeight() / 2.0);\n            Point2D pivotOnImage = imageView.sceneToLocal(centerInScene);\n\n            tx.set(tx.get() + (oldScale - newScale) * pivotOnImage.getX());\n            ty.set(ty.get() + (oldScale - newScale) * pivotOnImage.getY());\n            scale.set(newScale);\n        });\n</code></pre>\n<p>However, this just inverts the issue. Now zooming via scrolling will not work correctly. The event handler for scroll:</p>\n<pre><code>        viewport.addEventFilter(ScrollEvent.SCROLL, e -&gt; {\n            Point2D pivotOnImage = imageView.sceneToLocal(e.getSceneX(), e.getSceneY());\n\n            if (!imageView.getBoundsInLocal().contains(pivotOnImage))\n                return;\n\n            double direction = (e.getDeltaY() &gt; 0) ? 1.1 : (1 / 1.1);\n            double oldScale = scale.get();\n            double newScale = clamp(oldScale, direction);\n\n            if (newScale == 0) {\n                scale.set(1.0);\n                tx.set(0.0);\n                ty.set(0.0);\n\n                centerFit(imageView, viewport, scale, tx, ty);\n                return;\n            }\n\n            tx.set(tx.get() + (oldScale - newScale) * pivotOnImage.getX());\n            ty.set(ty.get() + (oldScale - newScale) * pivotOnImage.getY());\n            scale.set(newScale);\n\n            e.consume();\n        });\n</code></pre>\n<p>first sets <code>tx</code> and <code>ty</code>, then sets <code>scale</code>. Setting <code>scale</code> causes the slider's value to change (via the binding), which then invokes the listener on the slider's <code>valueProperty()</code>, which then changes the values of <code>tx</code> and <code>ty</code> to values assuming you are pivoting the zoom at the center. So now the zoom via scrolling will not pivot correctly.</p>\n<p>You might be able to fix this by changing the order of setting the properties (set the scale before <code>tx</code> and <code>ty</code>) but at this point I would conclude that the overall method is simply not robust enough. It depends too much on the order of changing properties and is too easy to break.</p>\n<p>I would recommend two things here.</p>\n<ol>\n<li><p>Abandon the binding, and just use listeners on the model to update the UI (both the image layout and the slider value), and listeners on UI events (slider value changing, mouse events) to update the model. The JavaFX properties are smart enough that if a value is set to its current value, it is a no-op, so there is no risk of any kind of infinite recursion occurring here.</p>\n</li>\n<li><p>I would encapsulate the values needed for the transform into an immutable class, and hold instances of those in the model property. This means that changes to multiple values (i.e. <code>tx</code> and <code>ty</code>, or <code>tx</code>, <code>ty</code>, and <code>scale</code>) only result in computing one change to the transform, which is probably slightly more efficient. More importantly, you can only change all three properties &quot;atomically&quot;, with respect to listeners. So there is no more concern about the order in which you change these values. If you had a separate model class, you could actually encapsulate all the functionality there (<code>public void translate(double deltaX, double deltaY)</code>, <code>public void scaleAndTranslate(double scale, double deltaX, double deltaY)</code>, etc. etc.).</p>\n</li>\n</ol>\n<p>Here is a version using these changes (I also changed it to use an open source image, so it is a complete MRE).</p>\n<pre><code>\nimport javafx.application.Application;\nimport javafx.beans.property.ObjectProperty;\nimport javafx.beans.property.SimpleObjectProperty;\nimport javafx.geometry.Point2D;\nimport javafx.scene.Scene;\nimport javafx.scene.image.Image;\nimport javafx.scene.image.ImageView;\nimport javafx.scene.input.MouseButton;\nimport javafx.scene.input.ScrollEvent;\nimport javafx.scene.layout.BorderPane;\nimport javafx.scene.layout.Pane;\nimport javafx.scene.paint.Color;\nimport javafx.scene.shape.Rectangle;\nimport javafx.scene.transform.Affine;\nimport javafx.stage.Stage;\nimport javafx.scene.control.Slider;\nimport javafx.util.StringConverter;\n\npublic class ZoomAndShiftImage extends Application {\n    private final double MIN_SCALE = 0.25;\n    private final double MAX_SCALE = 8.0;\n    private static double DEFAULT_SCALE;\n\n    private static final String IMAGE_URL = &quot;https://images.pdimagearchive.org/collections/hi-res-images-from-the-apollo-missions/21977917882_ffae88748b_o.jpg&quot;;\n\n    @Override\n    public void start(Stage stage) {\n        Image image = new Image(IMAGE_URL);\n        ImageView imageView = new ImageView(image);\n        imageView.setPreserveRatio(true);\n        imageView.setSmooth(true);\n\n        Affine affine = new Affine();\n        imageView.getTransforms().add(affine);\n\n        Pane viewport = new Pane(imageView);\n        Rectangle clip = new Rectangle();\n\n        clip.widthProperty().bind(viewport.widthProperty());\n        clip.heightProperty().bind(viewport.heightProperty());\n\n        viewport.setClip(clip);\n        viewport.setStyle(&quot;-fx-background-color: #1d2026;&quot;);\n\n        // --- Model properties for transform- zoom(scale) and shift(translate)\n//        DoubleProperty scale = new SimpleDoubleProperty(1.0); // zoom\n//        DoubleProperty tx = new SimpleDoubleProperty(0); // shift at the x-axis\n//        DoubleProperty ty = new SimpleDoubleProperty(0); // shift at the y-axis\n        ObjectProperty&lt;TransformValues&gt; transformValues = new SimpleObjectProperty&lt;&gt;(new TransformValues(1, 0, 0));\n\n        Runnable applyTransform = () -&gt; {\n            affine.setToTransform(\n                    transformValues.get().scale,\n                    0,\n                    transformValues.get().tx,\n                    0,\n                    transformValues.get().scale,\n                    transformValues.get().ty\n            );\n        };\n\n        // Apply transformation whe the property is changed\n        transformValues.addListener((_, _, _) -&gt; {\n            applyTransform.run();\n        });\n\n        applyTransform.run();\n\n        final Delta drag = new Delta();\n        Slider slider = getSlider();\n\n        // update slider value if transform changes:\n        transformValues.addListener((_, _, newTransformValues) -&gt; {\n            slider.setValue(newTransformValues.scale);\n        });\n\n        viewport.setOnMousePressed(e -&gt; {\n            if (e.getButton() == MouseButton.PRIMARY) {\n                // Save the current coordinates of the click\n                drag.x = e.getX();\n                drag.y = e.getY();\n            }\n        });\n\n        viewport.setOnMouseDragged(e -&gt; {\n            double dx = e.getX() - drag.x;\n            double dy = e.getY() - drag.y;\n\n            drag.x = e.getX();\n            drag.y = e.getY();\n\n            TransformValues currentT = transformValues.get();\n            transformValues.set(new TransformValues(currentT.scale, currentT.tx + dx, currentT.ty + dy));\n        });\n\n        viewport.setOnMouseClicked(e -&gt; {\n            if (e.getClickCount() == 2 &amp;&amp; e.getButton() == MouseButton.PRIMARY) {\n                transformValues.set(new TransformValues(1, 0, 0));\n\n                centerFit(imageView, viewport, transformValues);\n            }\n        });\n\n        viewport.addEventFilter(ScrollEvent.SCROLL, e -&gt; {\n            Point2D pivotOnImage = imageView.sceneToLocal(e.getSceneX(), e.getSceneY());\n\n            if (!imageView.getBoundsInLocal().contains(pivotOnImage))\n                return;\n\n            double direction = (e.getDeltaY() &gt; 0) ? 1.1 : (1 / 1.1);\n            double oldScale = transformValues.get().scale;\n            double newScale = clamp(oldScale, direction);\n\n            if (newScale == 0) {\n                transformValues.set(new TransformValues(1, 0, 0));\n                centerFit(imageView, viewport, transformValues);\n                return;\n            }\n\n            TransformValues tv = transformValues.get();\n            transformValues.set(new TransformValues(\n                    newScale,\n                    tv.tx + (oldScale - newScale) * pivotOnImage.getX(),\n                    tv.ty + (oldScale - newScale) * pivotOnImage.getY()\n            ));\n\n            e.consume();\n        });\n\n        slider.valueProperty().addListener((_, _, newV) -&gt; {\n            double oldScale = transformValues.get().scale;\n            double newScale = newV.doubleValue();\n\n            if (Math.abs(newScale - oldScale) &lt; 1e-12)\n                return;\n\n            Point2D centerInScene = viewport.localToScene(viewport.getWidth() / 2.0, viewport.getHeight() / 2.0);\n            Point2D pivotOnImage = imageView.sceneToLocal(centerInScene);\n\n            TransformValues currentT = transformValues.get();\n            transformValues.set(new TransformValues(\n                    newScale,\n                    currentT.tx + (oldScale - newScale) * pivotOnImage.getX(),\n                    currentT.ty + (oldScale - newScale) * pivotOnImage.getY()\n            ));\n        });\n\n        // Center the image whenever the window is resized\n        viewport.layoutBoundsProperty().addListener((_, _, _) -&gt;\n                centerFit(imageView, viewport, transformValues));\n\n        BorderPane root = new BorderPane(viewport);\n        root.setBottom(slider);\n\n        Scene scene = new Scene(root, 900, 600, Color.BLACK);\n        stage.setTitle(&quot;JavaFX ImageView: Zoom (wheel) + Pan (drag)&quot;);\n        stage.setScene(scene);\n        stage.show();\n\n        DEFAULT_SCALE = transformValues.get().scale * (1 / 1.1);\n    }\n\n    private Slider getSlider() {\n        Slider slider = new Slider(1, MAX_SCALE, 1.0);\n        slider.setBlockIncrement(0.1);\n        slider.setMajorTickUnit(1.0);\n        slider.setMinorTickCount(9);\n        slider.setShowTickMarks(true);\n        slider.setShowTickLabels(true);\n\n        slider.setLabelFormatter(new StringConverter&lt;&gt;() {\n            @Override\n            public String toString(Double v) {\n                if (Math.abs(v - 0.0) &lt; 1e-6) return &quot;0.25x&quot;;\n                if (Math.abs(v - 0.5) &lt; 1e-6) return &quot;0.5x&quot;;\n                if (Math.abs(v - 1.0) &lt; 1e-6) return &quot;1x&quot;;\n                if (Math.abs(v - 2.0) &lt; 1e-6) return &quot;2x&quot;;\n                if (Math.abs(v - 4.0) &lt; 1e-6) return &quot;4x&quot;;\n                if (Math.abs(v - 8.0) &lt; 1e-6) return &quot;8x&quot;;\n                return String.format(&quot;%.2fx&quot;, v);\n            }\n\n            @Override\n            public Double fromString(String s) {\n                return 1.0;\n            }\n        });\n        return slider;\n    }\n\n    private void centerFit(ImageView imageView, Pane viewport, ObjectProperty&lt;TransformValues&gt; tv) {\n        Image image = imageView.getImage();\n        if (image == null || image.getWidth() &lt;= 0 || image.getHeight() &lt;= 0)\n            return;\n\n        double viewportWidth = viewport.getWidth();\n        double viewportHeight = viewport.getHeight();\n\n        if (viewportWidth &lt;= 0 || viewportHeight &lt;= 0)\n            return;\n\n        double sx = viewportWidth / image.getWidth();\n        double sy = viewportHeight / image.getHeight();\n        double fit = Math.min(sx, sy);\n\n        double imageWidth = image.getWidth();\n        double imageHeight = image.getHeight();\n\n        double scaledW = imageWidth * fit;\n        double scaledH = imageHeight * fit;\n\n        tv.set(new TransformValues(fit, (viewportWidth - scaledW) / 2.0, (viewportHeight - scaledH) / 2.0));\n    }\n\n    private static double clamp(double oldScale, double direction) {\n        double d = Math.min(oldScale * direction, 8.0);\n\n        if (d &gt;= 2 * 0.25 || direction &gt; 1)\n            return d;\n        else if (d &lt;= (DEFAULT_SCALE + 0.02))\n            return 0;\n\n        return d;\n    }\n\n    private static class Delta {\n        double x, y;\n    }\n\n    private record TransformValues(double scale, double tx, double ty){}\n}\n</code></pre>\n<p>Just one further note: I get a slight &quot;bump&quot; the first time I move the slider. This is because the original image is larger that the space required to show it, so the <code>centerFit</code> method sets the zoom lower than the allowed value of the slider. This may not be an issue for your real application; if so I will leave it as an exercise as it was somewhat independent of the original question.</p>\n",
    "score" : 5,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 2518243,
      "reputation" : 210906,
      "user_id" : 2189127,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
      "display_name" : "James_D",
      "link" : "https://stackoverflow.com/users/2189127/james-d"
    },
    "creation_date" : 1761667763,
    "last_activity_date" : 1761673765,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79804886,
    "question_id" : 79800110,
    "body" : "<p><a href=\"https://stackoverflow.com/a/79803047/6395627\">The answer</a> by <a href=\"https://stackoverflow.com/users/2189127/james-d\">James_D</a> addresses the problem you were having. I would just like to add two things:</p>\n<ol>\n<li><p>You don't have to use a separate <code>Affine</code>. You can use the <code>scale[X|Y]</code> and <code>translate[X|Y]</code> properties of the <code>ImageView</code>. Note the scale transform will now be around the node's untransformed center point instead of <code>(0, 0)</code>. That slightly changes the zoom-on-mouse calculation from:</p>\n<pre class=\"lang-none prettyprint-override\"><code>tx = tx + (oldScale - newScale) * mouseX\n</code></pre>\n<p>To:</p>\n<pre class=\"lang-none prettyprint-override\"><code>tx = tx + (oldScale - newScale) * (mouseX - centerX)\n</code></pre>\n<p>And similar for <code>ty</code>. But it may also make it more straightforward to work with non-input ways of zooming the image, such as a <code>Slider</code>, because it implicitly pivots on the center.</p>\n</li>\n<li><p>I know your question is just an example, but I would suggest encapsulating this into your own custom node. Either a subclass of <code>Region</code> or <code>Control</code> (the latter would involve creating a <code>Skin</code> implementation).</p>\n</li>\n</ol>\n<p>Here's a proof-of-concept that behaves similar to Windows 10's built-in photos app. Like that app, the zoom-on-mouse only truly works once the image is larger than the viewing area (it keeps the image centered in the dimensions that are smaller than the viewing area). Also, you can only pan the image when the image is larger than the viewing area, and then only in the direction that's larger.</p>\n<p>One difference is that I added a <code>fitImage</code> property that leads to the <code>fitWidth</code> and <code>fitHeight</code> properties being set so that the image is scaled to always fit within the viewing area (pre-zoom). Any zoom on the image is applied <em>after</em> this fitting occurs. In contrast, the Windows app simply opens the image <em>zoomed out</em> enough to see the entire image if needed. You can modify the code to work more like the Windows app if desired.</p>\n<p>Note the shortcut key (e.g., <kbd>Ctrl</kbd> on Windows) must be down when scrolling to zoom the image.</p>\n<p>Tested with Java 25 and JavaFX 25.</p>\n<pre class=\"lang-java prettyprint-override\"><code>import javafx.beans.binding.Bindings;\nimport javafx.beans.binding.BooleanBinding;\nimport javafx.beans.property.BooleanProperty;\nimport javafx.beans.property.DoubleProperty;\nimport javafx.beans.property.ObjectProperty;\nimport javafx.beans.property.SimpleBooleanProperty;\nimport javafx.beans.property.SimpleDoubleProperty;\nimport javafx.beans.property.SimpleObjectProperty;\nimport javafx.css.PseudoClass;\nimport javafx.geometry.HPos;\nimport javafx.geometry.Point2D;\nimport javafx.geometry.VPos;\nimport javafx.scene.image.Image;\nimport javafx.scene.image.ImageView;\nimport javafx.scene.input.MouseEvent;\nimport javafx.scene.input.ScrollEvent;\nimport javafx.scene.layout.Region;\nimport javafx.scene.shape.Rectangle;\n\npublic class ImageDisplay extends Region {\n\n  private static final PseudoClass PANNABLE = PseudoClass.getPseudoClass(&quot;pannable&quot;);\n  private static final PseudoClass PANNING = PseudoClass.getPseudoClass(&quot;panning&quot;);\n\n  // Consider making these values configurable via properties\n  private static final double ZOOM_FACTOR = 1.05;\n  private static final double MIN_IMAGE_ZOOM = 0.1;\n  private static final double MAX_IMAGE_ZOOM = 8.0;\n\n  private final ViewContainer container = new ViewContainer();\n\n  /**\n   * Constructs a new {@code ImageDisplay}.\n   */\n  public ImageDisplay() {\n    getChildren().add(container);\n    getStyleClass().add(&quot;image-display&quot;);\n  }\n\n  /**\n   * Constructs a new {@code ImageDisplay} initialized with the given image.\n   * \n   * @param image the initial image of the {@code ImageDisplay}; may be {@code null}\n   */\n  public ImageDisplay(Image image) {\n    this();\n    setImage(image);\n  }\n\n  @Override\n  public String getUserAgentStylesheet() {\n    // Return stylesheet as a Data URI (JavaFX 17+)\n    return &quot;&quot;&quot;\n        data:text/css,\n\n        .image-display:pannable &gt; .container &gt; .image-view {\n          -fx-cursor: OPEN_HAND;\n        }\n\n        .image-display:panning &gt; .container &gt; .image-view {\n          -fx-cursor: CLOSED_HAND;\n        }\n        &quot;&quot;&quot;;\n  }\n\n  /* *****************************************************************************\n   *                                                                             *\n   * Layout                                                                      *\n   *                                                                             *\n   *******************************************************************************/\n\n  @Override\n  protected void layoutChildren() {\n    double x = snappedLeftInset();\n    double y = snappedTopInset();\n    double w = snapSizeX(getWidth() - snappedRightInset() - x);\n    double h = snapSizeY(getHeight() - snappedBottomInset() - y);\n\n    container.resize(w, h);\n    positionInArea(container, x, y, w, h, -1, HPos.CENTER, VPos.CENTER);\n  }\n\n  @Override\n  protected double computePrefWidth(double height) {\n    double prefWidth = getInsets().getLeft() + getInsets().getRight();\n    var image = getImage();\n    if (image != null) {\n      prefWidth += image.getWidth();\n    }\n    return prefWidth;\n  }\n\n  @Override\n  protected double computePrefHeight(double width) {\n    double prefHeight = getInsets().getTop() + getInsets().getBottom();\n    var image = getImage();\n    if (image != null) {\n      prefHeight += image.getHeight();\n    }\n    return prefHeight;\n  }\n\n  /* *****************************************************************************\n   *                                                                             *\n   * Properties                                                                  *\n   *                                                                             *\n   *******************************************************************************/\n\n  // -- image property\n\n  /** The image to display. */\n  private final ObjectProperty&lt;Image&gt; image = new SimpleObjectProperty&lt;&gt;(this, &quot;image&quot;) {\n    @Override\n    protected void invalidated() {\n      container.view.setImage(get());\n    }\n  };\n\n  public final void setImage(Image image) {\n    this.image.set(image);\n  }\n\n  public final Image getImage() {\n    return image.get();\n  }\n\n  public final ObjectProperty&lt;Image&gt; imageProperty() {\n    return image;\n  }\n\n  // -- fitImage property\n\n  /**\n   * Whether or not to fit the displayed image within this region's content area. If {@code true}\n   * and the image is larger than the content area then the image will be scaled down so that its\n   * larger dimension fits within the content area. The image's aspect ratio will be preserved. If\n   * {@code false}, or the image is smaller than the content area, then the image won't be scaled.\n   *\n   * &lt;p&gt;&lt;b&gt;Default value:&lt;/b&gt; {@code true}\n   */\n  private final BooleanProperty fitImage = new SimpleBooleanProperty(this, &quot;fitImage&quot;, true) {\n    @Override\n    protected void invalidated() {\n      container.requestLayout();\n    }\n  };\n\n  public final void setFitImage(boolean fitImage) {\n    this.fitImage.set(fitImage);\n  }\n\n  public final boolean isFitImage() {\n    return fitImage.get();\n  }\n\n  public final BooleanProperty fitImageProperty() {\n    return fitImage;\n  }\n\n  // -- imageZoom property\n\n  /**\n   * The amount the image is zoomed in or out. A value less than {@code 1.0} will zoom out the\n   * image, a value greater than {@code 1.0} will zoom in the image, and a value of {@code 1.0} will\n   * keep the image at its original size. The zoom of the image is applied after any scaling done\n   * due to {@link #fitImageProperty() fitImage} being {@code true}.\n   *\n   * &lt;p&gt;The zoom of the image will be clamped to the range {@code [0.10, 8.0]}, regardless of the\n   * value of this property.\n   *\n   * &lt;p&gt;If this property is bound then the user will not be able to change the zoom via scrolling.\n   *\n   * &lt;p&gt;&lt;b&gt;Default value:&lt;/b&gt; {@code 1.0}\n   */\n  private final DoubleProperty imageZoom = new SimpleDoubleProperty(this, &quot;imageZoom&quot;, 1) {\n    @Override\n    protected void invalidated() {\n      double clampedImageZoom = Math.clamp(get(), MIN_IMAGE_ZOOM, MAX_IMAGE_ZOOM);\n      container.view.setScaleX(clampedImageZoom);\n      container.view.setScaleY(clampedImageZoom);\n      container.ensureImageInBounds();\n    }\n  };\n\n  public final void setImageZoom(double imageZoom) {\n    this.imageZoom.set(imageZoom);\n  }\n\n  public final double getImageZoom() {\n    return imageZoom.get();\n  }\n\n  public final DoubleProperty imageZoomProperty() {\n    return imageZoom;\n  }\n\n  /* *****************************************************************************\n   *                                                                             *\n   * ViewContainer inner class                                                   *\n   *                                                                             *\n   *******************************************************************************/\n\n  private class ViewContainer extends Region {\n\n    // A binding to ease updating the PANNABLE pseudo-class\n    private final BooleanBinding isViewLargerThanContentArea;\n\n    private final Rectangle clip = new Rectangle();\n    final ImageView view = new ImageView();\n\n    // In ViewContainer's local coordinate space\n    private Point2D panOrigin;\n\n    ViewContainer() {\n      isViewLargerThanContentArea = Bindings.createBooleanBinding(\n          this::computeViewLargerThanContentArea,\n          view.boundsInParentProperty(),\n          boundsInLocalProperty());\n      isViewLargerThanContentArea.subscribe(\n          value -&gt; ImageDisplay.this.pseudoClassStateChanged(PANNABLE, value));\n\n      view.setPreserveRatio(true);\n      view.setOnScroll(this::handleScrollOnImageView);\n\n      this.setOnMousePressed(this::handleMousePressedOnViewContainer);\n      this.setOnMouseDragged(this::handleMouseDraggedOnViewContainer);\n      this.setOnMouseReleased(this::handleMouseReleasedOnViewContainer);\n\n      setClip(clip);\n      getChildren().add(view);\n      getStyleClass().add(&quot;container&quot;);\n    }\n\n    private boolean computeViewLargerThanContentArea() {\n      var viewBounds = view.getBoundsInParent();\n      var containerBounds = getBoundsInLocal();\n      return viewBounds.getWidth() &gt; containerBounds.getWidth()\n          || viewBounds.getHeight() &gt; containerBounds.getHeight();\n    }\n\n    /* *****************************************************************************\n     *                                                                             *\n     * ViewContainer: Layout                                                       *\n     *                                                                             *\n     *******************************************************************************/\n\n    @Override\n    protected void layoutChildren() {\n      var image = getImage();\n      if (image == null) return;\n\n      // ignore insets - content area is entire region\n      double x = snapPositionX(0);\n      double y = snapPositionY(0);\n      double w = snapSizeX(getWidth());\n      double h = snapSizeY(getHeight());\n\n      clip.setX(x);\n      clip.setY(y);\n      clip.setWidth(w);\n      clip.setHeight(h);\n\n      if (isFitImage()) {\n        view.setFitWidth(image.getWidth() &gt; w ? w : 0);\n        view.setFitHeight(image.getHeight() &gt; h ? h : 0);\n      } else {\n        view.setFitWidth(0);\n        view.setFitHeight(0);\n      }\n\n      positionInArea(view, x, y, w, h, -1, HPos.CENTER, VPos.CENTER);\n      ensureImageInBounds();\n    }\n\n    @Override\n    protected double computeMinWidth(double height) {\n      return 0; // ignore insets\n    }\n\n    @Override\n    protected double computeMinHeight(double width) {\n      return 0; // ignore insets\n    }\n\n    @Override\n    protected double computePrefWidth(double height) {\n      return view.prefWidth(height); // ignore insets\n    }\n\n    @Override\n    protected double computePrefHeight(double width) {\n      return view.prefHeight(width); // ignore insets\n    }\n\n    /* *****************************************************************************\n     *                                                                             *\n     * ViewContainer: Event handlers                                               *\n     *                                                                             *\n     *******************************************************************************/\n\n    // In ImageView's local coordinate space\n    private void handleScrollOnImageView(ScrollEvent event) {\n      if (!imageZoom.isBound() &amp;&amp; panOrigin == null &amp;&amp; isZoomEvent(event)) {\n        event.consume();\n\n        if (event.getDeltaY() &lt; 0) {\n          zoomOut(event.getX(), event.getY());\n        } else {\n          zoomIn(event.getX(), event.getY());\n        }\n      }\n    }\n\n    private boolean isZoomEvent(ScrollEvent event) {\n      return event.isShortcutDown() &amp;&amp; event.getDeltaY() != 0;\n    }\n\n    // In ViewContainer's local coordinate space\n    private void handleMousePressedOnViewContainer(MouseEvent event) {\n      if (isViewLargerThanContentArea.get()) {\n        event.consume();\n        panOrigin = new Point2D(event.getX(), event.getY());\n        ImageDisplay.this.pseudoClassStateChanged(PANNING, true);\n      }\n    }\n\n    // In ViewContainer's local coordinate space\n    private void handleMouseDraggedOnViewContainer(MouseEvent event) {\n      if (panOrigin != null) {\n        event.consume();\n\n        move(event.getX() - panOrigin.getX(), event.getY() - panOrigin.getY());\n        panOrigin = new Point2D(event.getX(), event.getY());\n        ensureImageInBounds();\n      }\n    }\n\n    // In ViewContainer's local coordinate space\n    private void handleMouseReleasedOnViewContainer(MouseEvent event) {\n      if (panOrigin != null) {\n        event.consume();\n        panOrigin = null;\n        ImageDisplay.this.pseudoClassStateChanged(PANNING, false);\n      }\n    }\n\n    /* *****************************************************************************\n     *                                                                             *\n     * ViewContainer: Zoom &amp; Move API                                              *\n     *                                                                             *\n     *******************************************************************************/\n\n    private void zoomIn(double pivotX, double pivotY) {\n      zoom(ZOOM_FACTOR, pivotX, pivotY);\n    }\n\n    private void zoomOut(double pivotX, double pivotY) {\n      zoom(1.0 / ZOOM_FACTOR, pivotX, pivotY);\n    }\n\n    private void zoom(double scaleFactor, double pivotX, double pivotY) {\n      double oldScale = Math.clamp(getImageZoom(), MIN_IMAGE_ZOOM, MAX_IMAGE_ZOOM);\n      double newScale = Math.clamp(oldScale * scaleFactor, MIN_IMAGE_ZOOM, MAX_IMAGE_ZOOM);\n\n      if (Math.abs(newScale - oldScale) &lt; 1e-12) {\n        return; // no change in scale\n      }\n\n      double cx = view.getBoundsInLocal().getCenterX();\n      double cy = view.getBoundsInLocal().getCenterY();\n      move((oldScale - newScale) * (pivotX - cx), (oldScale - newScale) * (pivotY - cy));\n      setImageZoom(newScale); // causes 'ensureImageInBounds' to be called\n    }\n\n    private void move(double deltaX, double deltaY) {\n      view.setTranslateX(view.getTranslateX() + deltaX);\n      view.setTranslateY(view.getTranslateY() + deltaY);\n    }\n\n    void ensureImageInBounds() {\n      /*\n       * Centers the image vertically and/or horizontally if the image is smaller than the content\n       * area in the respective dimension. Otherwise, if the image is larger in a dimension, then\n       * this ensures the image covers the entire content area in that dimension.\n       */\n      var viewBounds = view.getBoundsInParent();\n      var containerBounds = getBoundsInLocal();\n\n      if (viewBounds.getWidth() &lt; containerBounds.getWidth()) {\n        view.setTranslateX(0);\n      } else if (viewBounds.getMinX() &gt; containerBounds.getMinX()) {\n        move(containerBounds.getMinX() - viewBounds.getMinX(), 0);\n      } else if (viewBounds.getMaxX() &lt; containerBounds.getMaxX()) {\n        move(containerBounds.getMaxX() - viewBounds.getMaxX(), 0);\n      }\n\n      if (viewBounds.getHeight() &lt; containerBounds.getHeight()) {\n        view.setTranslateY(0);\n      } else if (viewBounds.getMinY() &gt; containerBounds.getMinY()) {\n        move(0, containerBounds.getMinY() - viewBounds.getMinY());\n      } else if (viewBounds.getMaxY() &lt; containerBounds.getMaxY()) {\n        move(0, containerBounds.getMaxY() - viewBounds.getMaxY());\n      }\n    }\n  }\n}\n</code></pre>\n<p>And a demo application (with a <code>Slider</code> that also controls the zoom):</p>\n<pre class=\"lang-java prettyprint-override\"><code>import javafx.application.Application;\nimport javafx.geometry.Insets;\nimport javafx.geometry.Orientation;\nimport javafx.scene.Scene;\nimport javafx.scene.control.CheckBox;\nimport javafx.scene.control.Label;\nimport javafx.scene.control.Separator;\nimport javafx.scene.control.Slider;\nimport javafx.scene.control.ToolBar;\nimport javafx.scene.image.Image;\nimport javafx.scene.layout.BorderPane;\nimport javafx.stage.Stage;\n\npublic class App extends Application {\n\n  public static void main(String[] args) {\n    launch(App.class, args);\n  }\n\n  @Override\n  public void start(Stage primaryStage) {\n    var display = new ImageDisplay(getImage());\n    display.setPadding(new Insets(10));\n\n    var fitBox = new CheckBox(&quot;Fit image&quot;);\n    fitBox.setSelected(true);\n    display.fitImageProperty().bind(fitBox.selectedProperty());\n    fitBox.selectedProperty().subscribe(() -&gt; display.setImageZoom(1));\n\n    var zoomSlider = new Slider(0.1, 8, 1);\n    zoomSlider.valueProperty().bindBidirectional(display.imageZoomProperty());\n\n    var zoomAmountLabel = new Label();\n    zoomAmountLabel\n        .textProperty()\n        .bind(display.imageZoomProperty().multiply(100).asString(&quot;(%6.2f%%)&quot;));\n\n    var toolbar = new ToolBar(\n        fitBox,\n        new Separator(Orientation.VERTICAL),\n        new Label(&quot;Zoom:&quot;),\n        zoomSlider,\n        zoomAmountLabel);\n\n    var root = new BorderPane();\n    root.setTop(toolbar);\n    root.setCenter(display);\n\n    primaryStage.setScene(new Scene(root, 1280, 720));\n    primaryStage.show();\n  }\n\n  private Image getImage() {\n    // TODO: Pass valid URI to Image constructor\n    var image = new Image(&quot;...&quot;, true);\n    image.exceptionProperty().subscribe(ex -&gt; {\n      if (ex != null) {\n        ex.printStackTrace();\n      }\n    });\n    return image;\n  }\n}\n</code></pre>\n<hr />\n<p>James_D also <a href=\"https://stackoverflow.com/questions/79800110/zoom-by-slider-goes-awry-when-binding-the-slider-to-the-scale-property/79804886#comment140825617_79803047\">mentions</a> this can be done by manipulating the <code>ImageView.viewport</code> property. You may find that better than using transformations.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49884,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1761835158,
    "last_activity_date" : 1761912750,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140820508,
    "post_id" : 79800110,
    "body" : "Guessing here; I haven&#39;t had time to run and investigate, but when the slider value changes is the scale changing (invoking the listener on the scale property) <i>before</i> the listener on the slider&#39;s value property is invoked? I think that would cause the zoom not to behave as expected. You should be able to check fairly easily with some simple logging on the values in the listener for the slider&#39;s value.",
    "score" : 0,
    "owner" : {
      "account_id" : 2518243,
      "reputation" : 210906,
      "user_id" : 2189127,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
      "display_name" : "James_D",
      "link" : "https://stackoverflow.com/users/2189127/james-d"
    },
    "creation_date" : 1761571685,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79803047" : [ {
      "comment_id" : 140833562,
      "post_id" : 79803047,
      "body" : "&quot;Zooming and panning is a form of cropping; you&#39;re choosing a portion of the image to display&quot;, simple yet genius. I hadn&#39;t thought of it this way. Thank you so much",
      "score" : 1,
      "owner" : {
        "account_id" : 12506291,
        "reputation" : 811,
        "user_id" : 9103039,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
        "display_name" : "Starnec",
        "link" : "https://stackoverflow.com/users/9103039/starnec"
      },
      "creation_date" : 1762173143,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140827364,
      "post_id" : 79803047,
      "body" : "@Slaw I think so. The <a href=\"https://stackoverflow.com/a/79784112/2189127\">example I linked above</a> has non-zero <code>fitWidth</code> and <code>fitHeight</code>. The two are managed essentially independently.",
      "score" : 2,
      "owner" : {
        "account_id" : 2518243,
        "reputation" : 210906,
        "user_id" : 2189127,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
        "display_name" : "James_D",
        "link" : "https://stackoverflow.com/users/2189127/james-d"
      },
      "creation_date" : 1761835574,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140827285,
      "post_id" : 79803047,
      "body" : "Does implementing this via <code>ImageView.viewport</code> play well with non-zero <code>fitWidth</code> and/or <code>fitHeight</code> values (e.g., when wanting to &quot;scale&quot; the image to fit within the region, but still want to be able to zoom the image)?",
      "score" : 1,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49884,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1761833840,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140827110,
      "post_id" : 79803047,
      "body" : "@Starnec <a href=\"https://stackoverflow.com/a/79784112/2189127\">This recent answer of mine</a> demonstrates cropping by setting the viewport. (Note that zooming and panning is a form of cropping; you&#39;re choosing a portion of the image to display.)",
      "score" : 1,
      "owner" : {
        "account_id" : 2518243,
        "reputation" : 210906,
        "user_id" : 2189127,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
        "display_name" : "James_D",
        "link" : "https://stackoverflow.com/users/2189127/james-d"
      },
      "creation_date" : 1761830508,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140826726,
      "post_id" : 79803047,
      "body" : "@James_D @James_D, @Slaw, thank you so much for your suggestions. I&#39;m happy to explore other approaches for implementing the <code>zoom-and-pan</code> features. I would appreciate it if you could share answers that explain the techniques you mentioned. I&#39;ll be waiting for your response :)",
      "score" : 0,
      "owner" : {
        "account_id" : 12506291,
        "reputation" : 811,
        "user_id" : 9103039,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
        "display_name" : "Starnec",
        "link" : "https://stackoverflow.com/users/9103039/starnec"
      },
      "creation_date" : 1761818519,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140825617,
      "post_id" : 79803047,
      "body" : "@Slaw And honestly, to zoom in on an image, I would update the ImageView&#39;s viewport instead of using transformations at all.",
      "score" : 2,
      "owner" : {
        "account_id" : 2518243,
        "reputation" : 210906,
        "user_id" : 2189127,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
        "display_name" : "James_D",
        "link" : "https://stackoverflow.com/users/2189127/james-d"
      },
      "creation_date" : 1761764332,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140825507,
      "post_id" : 79803047,
      "body" : "@Starnec Note you can use the <code>Node.scale[X|Y]</code> and <code>Node.translate[X|Y]</code> properties instead of a separate <code>Affine</code>. You would just have to account for the fact that the pivot of the scale transform is now around the node&#39;s untransformed center point instead of <code>(0, 0)</code>. Which should look something like, <code>tx = tx + (oldScale - newScale) * (mouseX - centerX)</code>, and similar for <code>ty</code>. The center point can be gotten with <code>node.getBoundsInLocal().getCenter[X|Y]()</code>. Whether or not you find that easier and/or more straightforward is up to you.",
      "score" : 2,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49884,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1761760056,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140823388,
      "post_id" : 79803047,
      "body" : "@Starnec Done. I had accidentally deleted a block of code in the zoom event handler.",
      "score" : 1,
      "owner" : {
        "account_id" : 2518243,
        "reputation" : 210906,
        "user_id" : 2189127,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
        "display_name" : "James_D",
        "link" : "https://stackoverflow.com/users/2189127/james-d"
      },
      "creation_date" : 1761675504,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140823307,
      "post_id" : 79803047,
      "body" : "I understand the idea of gathering the values into a single <code>class</code> and making all the updates without worrying about the order of the changes. However, in your example, the zoom by wheel is not working. Please update it so I can accept it.",
      "score" : 0,
      "owner" : {
        "account_id" : 12506291,
        "reputation" : 811,
        "user_id" : 9103039,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
        "display_name" : "Starnec",
        "link" : "https://stackoverflow.com/users/9103039/starnec"
      },
      "creation_date" : 1761673635,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140823248,
      "post_id" : 79803047,
      "body" : "@Starnec Added a comment there but also edited this answer to be more complete.",
      "score" : 0,
      "owner" : {
        "account_id" : 2518243,
        "reputation" : 210906,
        "user_id" : 2189127,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
        "display_name" : "James_D",
        "link" : "https://stackoverflow.com/users/2189127/james-d"
      },
      "creation_date" : 1761671999,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140823219,
      "post_id" : 79803047,
      "body" : "I would really appreciate it if you could take a look at my <a href=\"https://stackoverflow.com/questions/79803086/how-binding-the-slider-value-property-to-a-scale-property-makes-the-pivot-calcul\">post</a> explaining why the issue is coming from the pivot when binding and not just the scale itself.",
      "score" : 0,
      "owner" : {
        "account_id" : 12506291,
        "reputation" : 811,
        "user_id" : 9103039,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
        "display_name" : "Starnec",
        "link" : "https://stackoverflow.com/users/9103039/starnec"
      },
      "creation_date" : 1761670900,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140823217,
      "post_id" : 79803047,
      "body" : "Thank you. I have been making some checks and debugging over the last couple of days. Following your <a href=\"https://stackoverflow.com/questions/79800110/zoom-by-slider-goes-awry-when-binding-the-slider-to-the-scale-property#:~:text=Guessing%20here;%20I,%E2%80%93\">comment</a> yesterday, I wrote a post explaining the methodology of debugging, the issues, and the fixes made, just before posting the question. You posted your answer, which I will adopt, of course.",
      "score" : 0,
      "owner" : {
        "account_id" : 12506291,
        "reputation" : 811,
        "user_id" : 9103039,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
        "display_name" : "Starnec",
        "link" : "https://stackoverflow.com/users/9103039/starnec"
      },
      "creation_date" : 1761670891,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79804886" : [ {
      "comment_id" : 140833554,
      "post_id" : 79804886,
      "body" : "Sorry for the delayed response. I was sick over the last few days, and I wanted to ensure I responded only after understanding, testing, and implementing the answer you provided. First, thank you for your response. I appreciate the idea of splitting the <code>affine</code> transformation into two steps: <code>scale</code> and <code>translation</code>. The zoom occurs when the <code>imageZoom</code> property is <code>invalidated</code>, with the zoom implementation involving calling <code>move</code> and updating the imageZoom value. I also liked how <code>ensureImageInBounds</code> ensures that the image always stays within its container, as in the Windows default app.",
      "score" : 1,
      "owner" : {
        "account_id" : 12506291,
        "reputation" : 811,
        "user_id" : 9103039,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
        "display_name" : "Starnec",
        "link" : "https://stackoverflow.com/users/9103039/starnec"
      },
      "creation_date" : 1762173008,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}