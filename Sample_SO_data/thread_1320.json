{
  "question" : {
    "question_id" : 79719019,
    "title" : "In Apache Ignite the Replication mode and Partition mode does not work all together",
    "body" : "<p>Iâ€™m working with <strong>Apache Ignite 2.17.0</strong>. I load database tables into Ignite caches and run SQL queries using the SQLFieldsQuery API.</p>\n<p>Recently, I modified the cache configuration for some tables to use <code>CacheMode.REPLICATED instead of PARTITIONED</code> (for selected tables only).</p>\n<p>Now, I'm encountering an issue when querying across caches with different cache modes.</p>\n<p><strong>Example:</strong></p>\n<p><strong>Employee</strong> table is loaded into a <code>PARTITIONED</code> cache.</p>\n<p><strong>Company</strong> table is loaded into a <code>REPLICATED</code> cache.</p>\n<p>When I run a SQL query (with distributed joins enabled) that joins <code>Employee</code> with <code>Company</code>, using the <code>Employee cache</code> context (i.e., submitting the query from a compute task using the Employee cache reference), Ignite throws an error saying:</p>\n<blockquote>\n<p>Table 'Company' not found</p>\n</blockquote>\n<p>Even though the Company table is successfully loaded into its own cache, Ignite fails to recognize it during the query.</p>\n<p>Code Snippets how I configured cache</p>\n<pre><code>  private @NotNull CacheConfiguration&lt;Object, Object&gt; getCacheConfiguration(EntitySpec entitySpec, String cacheName,\n            Class&lt;?&gt; entityClass, Object compositeClassInstance, Field primaryKeyField, String pojoTableName) {\n        CacheConfiguration&lt;Object, Object&gt; cacheCfg = new CacheConfiguration&lt;&gt;(cacheName);\n        cacheCfg.setAtomicityMode(CacheAtomicityMode.ATOMIC);\n        if (replicateCaches.contains(cacheName)) {\n            cacheCfg.setCacheMode(CacheMode.REPLICATED);\n        } else {\n            cacheCfg.setCacheMode(CacheMode.PARTITIONED);\n        }\n        // Initially we disable write-through and then re-enable it after data loading\n        // has completed\n        cacheCfg.setWriteThrough(false);\n        cacheCfg.setReadThrough(false);\n        cacheCfg.setSqlSchema(schemaName);\n        cacheCfg.setQueryParallelism(queryParallelism);\n        // cacheCfg.setAffinity(new RendezvousAffinityFunction(false,\n        // CACHE_PARTITIONS));\n        cacheCfg.setOnheapCacheEnabled(enableOnHeapCache);\n        cacheCfg.setEventsDisabled(false);\n        cacheCfg.setStatisticsEnabled(true);\n        cacheCfg.setPartitionLossPolicy(PartitionLossPolicy.IGNORE);\n\n        if (enableOnHeapCache) {\n            log.warn(&quot;On-heap caching enabled for {}&quot;, entitySpec.getName());\n        } else {\n            log.info(&quot;Off-heap cache enabled for {}&quot;, entitySpec.getName());\n        }\n\n        if (cacheBackups &gt; 0) {\n            cacheCfg.setBackups(cacheBackups);\n            cacheCfg.setReadFromBackup(true);\n            cacheCfg.setWriteSynchronizationMode(CacheWriteSynchronizationMode.FULL_ASYNC);\n            log.info(&quot;Set cache backups to {}&quot;, cacheBackups);\n        } else {\n            log.info(&quot;Cache backups disabled&quot;);\n        }\n\n        // Configure JDBC POJO store factory\n        CacheJdbcPojoStoreFactory&lt;Object, Object&gt; jdbcPojoStoreFactory = jdbcPojoStoreConnectionFactoryProducer\n                .create();\n        jdbcPojoStoreFactory.setTypes(createJdbcType(entityClass, cacheName, schemaName, entitySpec.getName(),\n                Objects.isNull(compositeClassInstance) ? primaryKeyField.getName() : null,\n                Objects.isNull(compositeClassInstance) ? primaryKeyField.getType() : compositeClassInstance.getClass(),\n                Objects.isNull(compositeClassInstance) ? null : compositeClassInstance.getClass()));\n        cacheCfg.setCacheStoreFactory(jdbcPojoStoreFactory);\n        cacheCfg.setIndexedTypes(\n                Objects.isNull(compositeClassInstance) ? primaryKeyField.getType() : compositeClassInstance.getClass(),\n                entityClass);\n\n        // Set Query Entity\n        cacheCfg.setQueryEntities(Collections.singletonList(createQueryEntity(entityClass,\n                Objects.isNull(compositeClassInstance) ? primaryKeyField.getName() : null,\n                Objects.isNull(compositeClassInstance) ? primaryKeyField.getType() : compositeClassInstance.getClass(),\n                pojoTableName, Objects.isNull(compositeClassInstance) ? null : compositeClassInstance.getClass())));\n\n        return cacheCfg;\n    }\n</code></pre>\n<p>Now how I run the queries</p>\n<pre><code>QueryCursor&lt;List&lt;?&gt;&gt; getQueryCursor(String sql, IgniteCache&lt;Object, Object&gt; cache) {\n    SqlFieldsQuery query = new SqlFieldsQuery(sql);\n    query.setDistributedJoins(true);\n    query.setLazy(true);\n    query.setTimeout(0, TimeUnit.MILLISECONDS);\n    QueryCursor&lt;List&lt;?&gt;&gt; cursor = cache.query(query);\n    return cursor;\n}\n</code></pre>\n<p><strong>here the cache is the employee_cache</strong> so providing the employee_cache context we fire this query as soon as the database tables are loaded into cache.</p>\n<p>The query is the simple join of two tables one is in partitioned mode and other is in Replicated mode.</p>\n<p>For example <code>select employee e join company c on e.id=c.employee_id</code></p>\n<p>Here employee is loaded by partitioned way and company is loaded by replicated way we are ingesting data from Postgres via CacheJDBCPojoStore.</p>\n<p>We have the server and thick clients we run the compute task from thick clients on the server nodes we have set of 5 server nodes and 2 proxies that is thick client and we run this queries from the ComputeTask which extends ComputeTaskAdapter.</p>\n",
    "tags" : [ "java", "ignite", "distributed-computing", "gridgain" ],
    "owner" : {
      "account_id" : 10024548,
      "reputation" : 799,
      "user_id" : 7413086,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d4fb3298de0146214cd2a125f6b91dc7?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "kushal Baldev",
      "link" : "https://stackoverflow.com/users/7413086/kushal-baldev"
    },
    "is_answered" : true,
    "view_count" : 138,
    "answer_count" : 1,
    "score" : 3,
    "last_activity_date" : 1754520344,
    "creation_date" : 1753810300,
    "link" : "https://stackoverflow.com/questions/79719019/in-apache-ignite-the-replication-mode-and-partition-mode-does-not-work-all-toget",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79721887,
    "question_id" : 79719019,
    "body" : "<p>You can join between replicated and partitioned tables; changing the mode of your table is not going to change anything there. In fact, by changing one of your tables to be replicated, you can turn off distributed joins in your query.</p>\n<p>The most likely explanation is that your secondary table is in a different schema. By default, the scheme is the cache name, and the table name is your type name. You don't need to specify the schema for the leading table. So you query would become something like:</p>\n<pre><code>var employeeCache = ignite.cache(&quot;EMPLOYEE_CACHE&quot;);\nvar companyCache  = ignite.cache(&quot;COMPANY_CACHE&quot;);\n\nvar sql1 = &quot;select * from employee e join company_cache.company c on e.id=c.employee_id&quot;;\ntry (var c = employeeCache.query(new SqlFieldsQuery(sql1))) {\n...\n}\n\nvar sql2 = &quot;select * from employee_cache.employee e join company c on e.id=c.employee_id&quot;;\ntry (var c = companyCache.query(new SqlFieldsQuery(sql2))) {\n...\n}\n</code></pre>\n<p>sql1 and sql2 are basically equivalent.</p>\n<p>The number of server nodes in your cluster, the number and type of client nodes, whether the table is partition or replication, atomic or transactional, whether you deploy on bare metal or Kubernetes or Docker, are all not relevant to the SQL query.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2182,
      "reputation" : 52800,
      "user_id" : 2998,
      "user_type" : "registered",
      "accept_rate" : 69,
      "profile_image" : "https://www.gravatar.com/avatar/de1c8686d474f502849acbf1d19ac4b7?s=256&d=identicon&r=PG",
      "display_name" : "Stephen Darlington",
      "link" : "https://stackoverflow.com/users/2998/stephen-darlington"
    },
    "creation_date" : 1754000212,
    "last_activity_date" : 1754520344,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140628797,
    "post_id" : 79719019,
    "body" : "Hey @StephenDarlington, I have updated the question and included more info please find how I have configured the configuration and run the sql query this is exactly what I do.",
    "score" : 0,
    "owner" : {
      "account_id" : 10024548,
      "reputation" : 799,
      "user_id" : 7413086,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d4fb3298de0146214cd2a125f6b91dc7?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "kushal Baldev",
      "link" : "https://stackoverflow.com/users/7413086/kushal-baldev"
    },
    "creation_date" : 1753855796,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140628003,
    "post_id" : 79719019,
    "body" : "Please share how you created your tables and what SQL you&#39;re running.",
    "score" : 0,
    "owner" : {
      "account_id" : 2182,
      "reputation" : 52800,
      "user_id" : 2998,
      "user_type" : "registered",
      "accept_rate" : 69,
      "profile_image" : "https://www.gravatar.com/avatar/de1c8686d474f502849acbf1d19ac4b7?s=256&d=identicon&r=PG",
      "display_name" : "Stephen Darlington",
      "link" : "https://stackoverflow.com/users/2998/stephen-darlington"
    },
    "creation_date" : 1753819603,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79721887" : [ {
      "comment_id" : 140698009,
      "post_id" : 79721887,
      "body" : "Thanks @Stephen Darlington for the explanation the reason why I need distributed joins is because I am in scenario where I have more than two tables in the query and only one of them is replicated as it contains very less records now the thing is if I remove distributed joins then it may happen my value wont come accurate in some cases it comes to 0 in numeric columns so I was confused a little about this.",
      "score" : 0,
      "owner" : {
        "account_id" : 10024548,
        "reputation" : 799,
        "user_id" : 7413086,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/d4fb3298de0146214cd2a125f6b91dc7?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "kushal Baldev",
        "link" : "https://stackoverflow.com/users/7413086/kushal-baldev"
      },
      "creation_date" : 1756369780,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}