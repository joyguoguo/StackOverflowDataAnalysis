{
  "question" : {
    "question_id" : 79762280,
    "title" : "Make generated class implement my custom interface in Java",
    "body" : "<p>I have two classes generated from OpenAPI that I cannot modify:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class Foo {\n    public String getA() {\n        // ...\n    }\n\n    public String getB() {\n        // ...\n    }\n}\n</code></pre>\n<p>and:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class Bar {\n    public String getA() {\n        // ...\n    }\n\n    public String getB() {\n        // ...\n    }\n}\n</code></pre>\n<p>I want to write a utility method that will work for both classes.\nNormally, I would use an interface and make both classes implement it:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public interface FooBarable{\n    String getA();\n    String getB();\n}\n</code></pre>\n<p>and then write my utility method:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public static String calculate(FooBarable foo) {\n// ..\n}\n</code></pre>\n<p>I don't want to make two implementations for each of the classes.\nI wonder if there is a way to make those classes implement an interface, even though I can't modify them.</p>\n",
    "tags" : [ "java", "openapi" ],
    "owner" : {
      "account_id" : 112364,
      "reputation" : 26805,
      "user_id" : 296427,
      "user_type" : "registered",
      "accept_rate" : 91,
      "profile_image" : "https://www.gravatar.com/avatar/8692a55fc3524ed4e7cb85b0b3b4693c?s=256&d=identicon&r=PG",
      "display_name" : "pixel",
      "link" : "https://stackoverflow.com/users/296427/pixel"
    },
    "is_answered" : true,
    "view_count" : 140,
    "answer_count" : 3,
    "score" : 1,
    "last_activity_date" : 1758041843,
    "creation_date" : 1757616167,
    "link" : "https://stackoverflow.com/questions/79762280/make-generated-class-implement-my-custom-interface-in-java",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79762459,
    "question_id" : 79762280,
    "body" : "<p>You need a hacky workaround. Which leads to two answers:</p>\n<ol>\n<li><p>Proof that you will need a hacky workaround. Now, and forever. It is fundamental to java. What you want boils down to something java's very design abhors and will fight you every step of the way.</p>\n</li>\n<li><p>... taking all that into consideration, what's the hacky workaround?</p>\n</li>\n</ol>\n<h2>This is anti-java</h2>\n<p>Java is nominally typed to a fault. And types are a <strong>required</strong> basis for all names.</p>\n<p>Imagine the following 2 types, written by different authors at different times:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class Gun {\n  public void shoot(Person p) {}\n}\n\npublic class Camera {\n  public void shoot(Person p) {}\n}\n</code></pre>\n<p>And now imagine java would let you treat these 2 objects as being similar in some fashion. Imagine java would let you do the equivalent of: &quot;Take this thing.. gun, camera, whatever. Just shoot Jake over there please!&quot;</p>\n<p>That'd be terrible.</p>\n<p>Which is why java [A] does not let you and [B] never will. This is a fundamental design tenet you're running into. <strong>All</strong> things have a namespace, and that namespace is inherently bound to a type. Because types are in packages and packages are trusted to be unique. That's not <code>shoot</code> you're calling. No, you're calling <code>com.sony.consumerElectronics.Camera.shoot</code>. Obviously you're not calling <code>com.smithAndWesson.Gun.shoot</code> - that method has a completely different name, whyever would you confuse the two?</p>\n<h2>Hacky workaround 1 - reflection</h2>\n<p>Reflection is the basic answer:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public void justShootJakeAlready(Object whoKnows) throws Exception {\n  Method m = whoKnows.getClass().getMethod(&quot;shoot&quot;, Person.class);\n  m.invoke(whoKnows, jake);\n}\n</code></pre>\n<p>Will make a picture of jake. Or kill him. Who knows?</p>\n<p>The problem is, you now need to 'stringlify' up a lot of code, where you stick method names in string literals, and code analysis tools will lose the plot. They have no idea that the above code invokes <em>any</em> shoot method anywhere. Your editor will think that both <code>Gun.shoot</code> and <code>Camera.shoot</code> exist but aren't invoked <em>at all</em>. If you for example ask your IDE to find all places where this code is called, it won't find any, even though <code>justShootJakeAlready</code> is capable of invoking both Camera.shoot as well as Gun.shoot, and any other type's <code>shoot(Person p)</code> method, were it to ever exist, now or in the future.</p>\n<p>If you have loads of methods this would be bad.</p>\n<h2>Hacky workaround 2 - proxy</h2>\n<p>You can make a proxy object that implements an interface and use this to at least slightly reduce the exception and stringlified gymnastics. It's still pretty bad. It involves making an interface to describe the common ground, <em>getting absolutely no guarantee in any way at write/compile time that you did it right</em>, but then you do get to 'treat' anything you want as that interface:</p>\n<pre class=\"lang-java prettyprint-override\"><code>interface Shooter {\n  void shoot(Person p);\n}\n\nShooter s = (Shooter) Proxy.newProxyInstance(Shooter.class.getClassLoader(), new Class&lt;?&gt;[] {Shooter.class}, (shootyThing, method, args) -&gt; {\n  return shootyThing.getClass().getMethod(method.getName(), method.getParameterTypes()).invoke(shootyThing, args);\n});\n</code></pre>\n<p>As long as the signatures match up exactly this should work. But, <em>please realize</em>, somebody's going to lose an eye here. Or probably more. This is a stupid idea and you should only resort to this after writing documentation that features a lot of all-caps and exclamation points, and only after you've exhausted every other option you have.</p>\n<h2>The true answer</h2>\n<p>Figure out whatever code gen platform you have and how you can tell it to generate an <code>implements</code> clause. If it can't, ditch it, or fix it. It is not suitable for what you are attempting to make it do here.</p>\n",
    "score" : 3,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107186,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1757638097,
    "last_activity_date" : 1757638097,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79766492,
    "question_id" : 79762280,
    "body" : "<p>Another way to implement this is to extend the classes in question with our “wrappers” and have them implement the interface.</p>\n<pre><code>class Foo {\n   public String getA() {\n      return &quot;foo a&quot;;\n   }\n   public String getB() {\n      return &quot;foo b&quot;;\n   }\n}\n\nclass Bar {\n   public String getA() {\n      return &quot;bar a&quot;;\n   }\n   public String getB() {\n      return &quot;bar b&quot;;\n   }\n}\n\nclass FooAlternative extends Foo implements FooBarable { }\n\nclass BarAlternative extends Bar implements FooBarable { }\n\ninterface FooBarable {\n   String getA();\n   String getB();\n}\n\npublic void ini() {\n   FooBarable foBas[] = { new FooAlternative(), new BarAlternative() };\n   for( FooBarable foBa : foBas ) {\n      System.out.println( &quot;  Father = &quot; + foBa.getClass().getSuperclass().getSimpleName() );\n      System.out.println( &quot;  Class  = &quot; + foBa.getClass().getSimpleName() );\n      System.out.println( foBa.getA() );\n      System.out.println( foBa.getB() );\n   }\n\n}\n</code></pre>\n<p>This prints:</p>\n<pre><code>  Father = Foo\n  Class  = FooAlternative\nfoo a\nfoo b\n  Father = Bar\n  Class  = BarAlternative\nbar a\nbar b\n</code></pre>\n<p>Now, I can't know what's behind your implementation, so I can't say that it's wrong, but I strongly recommend that you read rzwitserloot's answer to make sure that what you're doing won't lead to code with undefined behavior.</p>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 10843443,
      "reputation" : 916,
      "user_id" : 20882864,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/CCQCy.jpg?s=256",
      "display_name" : "Marce Puente",
      "link" : "https://stackoverflow.com/users/20882864/marce-puente"
    },
    "creation_date" : 1758041843,
    "last_activity_date" : 1758041843,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79762440,
    "question_id" : 79762280,
    "body" : "<p>You can wrap your classes and make your wrappers implement FooBarable:</p>\n<pre><code>final class FooWrapper implements FooBarable {\n  private final Foo delegate;\n\n  FooWrapper(Foo delegate) {\n    this.delegate = delegate;\n  }\n\n  @Override\n  public String getA() {\n    return delegate.getA();\n  }\n\n  @Override\n  public String getB() {\n    return delegate.getB();\n  }\n}\n</code></pre>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1544842,
      "reputation" : 635,
      "user_id" : 6036446,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/-v4u_YcpdVno/AAAAAAAAAAI/AAAAAAAAKXc/ITrtXij-cec/s256-rj/photo.jpg",
      "display_name" : "Juan C Nuno",
      "link" : "https://stackoverflow.com/users/6036446/juan-c-nuno"
    },
    "creation_date" : 1757633650,
    "last_activity_date" : 1757633650,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140730669,
    "post_id" : 79762280,
    "body" : "Specify your code generator utility. Provide link or tag.",
    "score" : 0,
    "owner" : {
      "account_id" : 322981,
      "reputation" : 346951,
      "user_id" : 642706,
      "user_type" : "registered",
      "accept_rate" : 58,
      "profile_image" : "https://i.sstatic.net/ZWEI3.jpg?s=256",
      "display_name" : "Basil Bourque",
      "link" : "https://stackoverflow.com/users/642706/basil-bourque"
    },
    "creation_date" : 1757644293,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140730425,
    "post_id" : 79762280,
    "body" : "<code>calculate(Object)</code> would work, but I understand your point.  What&#39;s wrong with two separate <code>calculate()</code> methods (overloading the method)?",
    "score" : 1,
    "owner" : {
      "account_id" : 2709823,
      "reputation" : 11069,
      "user_id" : 2338547,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/QT3fG.png?s=256",
      "display_name" : "markspace",
      "link" : "https://stackoverflow.com/users/2338547/markspace"
    },
    "creation_date" : 1757627667,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140730355,
    "post_id" : 79762280,
    "body" : "You could also create subclasses that implement a common interface, or write wrapper classes that do, but neither of these makes the <code>Foo</code> and <code>Bar</code> classes themselves implement the wanted interface.",
    "score" : 0,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1757624371,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140730349,
    "post_id" : 79762280,
    "body" : "If the classes do not implement a particular interface then making them implement it is a modification.  You can&#39;t do that if you can&#39;t modify them.  However, you could conceivably modify them via bytecode manipulation, perhaps even at runtime, as opposed to via source code manipulation.",
    "score" : 2,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1757624161,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140730116,
    "post_id" : 79762280,
    "body" : "I beleive (though I can&#39;t test this myself and don&#39;t know for sure) that one way to do so would be use a transformer to hack it at runtime - see <a href=\"https://stackoverflow.com/a/79497087/23162960\">this SO answer</a> on how to do that (though that might require odd-loking cast ops like <code>FooBarable item = (FooBarable)(Object) someFooInstance</code> if you create those objects yourself)",
    "score" : 0,
    "owner" : {
      "account_id" : 30223964,
      "reputation" : 252,
      "user_id" : 23162960,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/2451acfac254a6fc75757ecf89d75f9a?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Jannik S.",
      "link" : "https://stackoverflow.com/users/23162960/jannik-s"
    },
    "creation_date" : 1757616796,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140730104,
    "post_id" : 79762280,
    "body" : "This question is similar to: <a href=\"https://stackoverflow.com/questions/54731415/structural-typing-in-java-adhering-to-interface-without-having-to-import-it\">Structural typing in Java - adhering to interface without having to import it</a>. If you believe it’s different, please <a href=\"https://stackoverflow.com/posts/79762280/edit\">edit</a> the question, make it clear how it’s different and/or how the answers on that question are not helpful for your problem.",
    "score" : 0,
    "owner" : {
      "account_id" : 32732911,
      "reputation" : 2842,
      "user_id" : 25441514,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/93e525004722e57d9c1352d5f8c9630b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Anerdw",
      "link" : "https://stackoverflow.com/users/25441514/anerdw"
    },
    "creation_date" : 1757616403,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}