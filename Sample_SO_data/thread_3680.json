{
  "question" : {
    "question_id" : 79532027,
    "title" : "Why does increasing my thread count decrease the performance of my Java program?",
    "body" : "<p>I have a little software based 3d-renderer I am working on in Java. In an effort to increase the rate that my program can update the display area, I tried splitting the display area into sections and rendering each section in a separate thread. The result of this was a decrease in the render rate, which was unexpected. I understand that creating more threads than processors on my machine would in fact hinder the performance of my program, but I am only creating a few threads and I have a 12-core processor.</p>\n<p>This is the method that calls the execute() method in my RenderThread, it is contained within the super-class of the RenderThread class</p>\n<pre><code>public final void run() {\n\n        long now = System.nanoTime();\n        long prev = now;\n        long next = now;\n\n        long delta = 0;\n\n        int updates = 0;\n\n        while (running) {\n            prev = now;\n            now = System.nanoTime();\n            delta += now - prev;\n\n            if (delta &gt;= NANOS_PER_SECOND) {\n                delta -= NANOS_PER_SECOND;\n                System.out.println(&quot;updates:&quot; + updates);\n                updates = 0;\n            }\n\n            if (next &lt;= now) {\n                execute();\n                updates++;\n                //getting behind update immediately\n                if (updates*interval &lt; delta) {\n                    next = now;\n                } \n                //update at the next interval\n                else {\n                    next = now + interval;\n                }\n            }\n\n            long sleep = Math.max(0, next - System.nanoTime());\n            long millis = sleep / NANOS_PER_MILLI;\n\n            int nanos = (int) (sleep - millis * NANOS_PER_MILLI);\n            try {\n                Thread.sleep(millis, nanos);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n        }\n\n    }\n</code></pre>\n<p>This is my RenderThread class.</p>\n<pre><code>public class RenderThread extends TimedThread {\n\n    public RenderThread(int rate, JavaForge ref) {\n        super(rate, ref);\n\n    }\n\n    // called by the super-class run method a set number of times per second\n    @Override\n    protected void execute() {\n\n        //width of the display image (using Canvas ref)\n        int w = ref.getWidth();\n        //height of the display image\n        int h = ref.getHeight();\n\n        \n        \n        // the sub-thread list\n        ArrayList&lt;RenderSubThread&gt; threads = new ArrayList&lt;RenderSubThread&gt;();\n        \n        //the number of partitions across the width of the display area\n        int partitionsWidth = 2;\n        //the number of partitions across the height of the display area\n        int partitionsHeight = 1;\n\n        //the width in pixels of each section\n        int pw = w / partitionsWidth;\n        //the height in pixels of each section\n        int ph = h / partitionsHeight;\n\n        //the color data used to create the BufferedImage\n        int[] data = new int[w * h];\n\n        // partition the display area of the program and create a sub-thread for each division\n        for (int y = 0; y &lt; partitionsHeight; y++) {\n            for (int x = 0; x &lt; partitionsWidth; x++) {\n                //create and start the sub-thread\n                threads.add(new RenderSubThread(x * pw, y * ph, pw, ph));\n                threads.getLast().start();\n            }\n        }\n\n        //wait for each sub-thread to finish and put its data into the main data array\n        int index = 0;\n        for (RenderSubThread thread : threads) {\n            try {\n                //wait to stop\n                thread.join();\n                //collect data\n                for (int i = 0; i &lt; thread.data.length; i++) {\n                    data[index++] = thread.data[i];\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        \n        //create display image\n        BufferedImage img = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n        \n        //put color data into display image\n        System.arraycopy(data, 0, ((DataBufferInt) img.getRaster().getDataBuffer()).getData(), 0, data.length);\n        \n        //render image onto screen\n        ref.render(img);\n    }\n\n\n\n}\n</code></pre>\n<p>Below is the method that gets called at the end of each execution() call. This method is contained within the main class which extends Canvas</p>\n<pre><code>public final void render(BufferedImage rendered) {\n\n        BufferStrategy bs = getBufferStrategy();\n        if (bs == null) {\n            createBufferStrategy(3);\n            bs = getBufferStrategy();\n        }\n\n        Graphics2D g = (Graphics2D) bs.getDrawGraphics();\n        g.setColor(Color.BLACK);\n        g.fillRect(0, 0, getWidth(), getHeight());\n        g.drawImage(rendered, 0, 0, null);\n\n        bs.show();\n\n    }\n</code></pre>\n<p>This is the class that handles the sections of the display area.</p>\n<pre><code>public class RenderSubThread extends Thread {\n\n    int x;\n    int y;\n    int w;\n    int h;\n    int[] data;\n\n    public RenderSubThread(int x, int y, int w, int h) {\n        this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n    }\n\n    @Override\n    public void run() {\n        //initialize the sub-thread's data\n        data = new int[h * w];\n\n        //assign a random color for each pixel\n        for (int i = 0; i &lt; data.length; i++) {\n            data[i] = (int) (Math.random() * Integer.MAX_VALUE);\n        }\n\n    }\n\n}\n</code></pre>\n",
    "tags" : [ "java", "multithreading" ],
    "owner" : {
      "account_id" : 18026647,
      "reputation" : 48,
      "user_id" : 13102408,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/-ZP1yD9KPvt8/AAAAAAAAAAI/AAAAAAAAAAA/AKF05nDz5yVrUzCin0X1vKDBfWX5t4gkpg/s256-rj/photo.jpg",
      "display_name" : "Ethan",
      "link" : "https://stackoverflow.com/users/13102408/ethan"
    },
    "is_answered" : true,
    "view_count" : 117,
    "answer_count" : 1,
    "score" : 2,
    "last_activity_date" : 1742950504,
    "creation_date" : 1742845879,
    "link" : "https://stackoverflow.com/questions/79532027/why-does-increasing-my-thread-count-decrease-the-performance-of-my-java-program",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ ],
  "answer_comments" : { }
}