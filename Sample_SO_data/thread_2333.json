{
  "question" : {
    "question_id" : 79628387,
    "title" : "Spring Cloud Gateway - Request Body Consumed in Filter, Response Not Returned to Client (Empty Response Body)",
    "body" : "<p>I'm building a Spring Cloud Gateway filter that reads the request body to validate a payload signature before forwarding the request to downstream services (like an account service for login).</p>\n<p>The flow works correctly when using a blocking call (.block() to retrieve a record from the repository), but when I switch to a fully reactive non-blocking implementation, the gateway no longer returns the response body to the client — even though I can see the response from the downstream service in the logs.</p>\n<p>⚙️ What I’m Doing:\nI read the request body using DataBufferUtils.join(...).</p>\n<p>I validate the signature based on the request body.</p>\n<p>I wrap the body into a ServerHttpRequestDecorator.</p>\n<p>I mutate the ServerWebExchange with the new request and call chain.filter(...).</p>\n<p>❌ The Problem:\nWith the reactive version, the downstream service is called, and I see the correct response body logged — but the client (e.g., Postman) receives an empty body.</p>\n<p>✅ What Works:\nIf I use a blocking call (.blockOptional() on the DB call), everything works end-to-end — the downstream service is called, and the client receives the expected response.</p>\n<p>❓ My Question:\nWhy does the blocking version return the downstream response correctly, but the reactive version does not?\nHow can I read and restore the request body reactively without breaking the body stream or interfering with the downstream response?</p>\n<pre><code>  @Override\n    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        boolean excludeFromAuth = validateRouteExclusions(exchange);\n\n        List&lt;String&gt; payloadSignature = exchange.getRequest().getHeaders().get(&quot;X-Sign&quot;);\n        List&lt;String&gt; timeStamp = exchange.getRequest().getHeaders().get(&quot;T-S&quot;);\n        List&lt;String&gt; userAgent = exchange.getRequest().getHeaders().get(&quot;X-U-A&quot;);\n        List&lt;String&gt; contentType = exchange.getRequest().getHeaders().get(HttpHeaders.CONTENT_TYPE);\n\n        if (excludeFromAuth) {\n            return chain.filter(exchange);\n        }\n\n        if (userAgent == null || userAgent.isEmpty()) {\n            return onError(exchange, HttpStatus.FORBIDDEN);\n        }\n\n        if (timeStamp == null || timeStamp.isEmpty()) {\n            return onError(exchange, HttpStatus.FORBIDDEN);\n        }\n\n        if (payloadSignature == null || payloadSignature.isEmpty()) {\n            return onError(exchange, HttpStatus.FORBIDDEN);\n        }\n\n        String requestHash = payloadSignature.get(0);\n        paddedTimeStamp = &quot;&quot;;\n\n        if (!isTimeStampValid(timeStampHeader)) {// validate time stamp\n            return onError(exchange, HttpStatus.FORBIDDEN);\n        }\n\n        Optional&lt;Signature&gt; signatureRecord = repository\n                .findByAgentKey(userAgent.get(0)).blockOptional();\n\n        if (signatureRecord.isPresent()) {\n            // Assign or use the signatureRecord here\n            signature = signatureRecord.get();\n\n            boolean hasApplicationJsonHeader = hasApplicationJsonHeader(contentType);\n\n            if (!hasApplicationJsonHeader) {\n                return isValidUrl(requestHash, exchange.getRequest().getURI().toString())\n                        ? chain.filter(exchange)\n                        : onError(exchange, HttpStatus.FORBIDDEN);\n            }\n\n            return validateSignaturesV3(requestHash, exchange, chain);\n        }\n\n        return onError(exchange, HttpStatus.FORBIDDEN);\n    }\n</code></pre>\n<p>above is the blocking call which is bad yes because it defeats the reactive process but it works as when I test from postman the gateway calls the account service logs the user in and returns the login response</p>\n<p>the below is the full reactive code that does not return the login response to my postman client but an empty body but I can see the login response in the logs</p>\n<pre><code>    @Override\n    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        boolean excludeFromAuth = validateRouteExclusions(exchange);\n\n        List&lt;String&gt; payloadSignature = exchange.getRequest().getHeaders().get(&quot;X-Payload-Signature&quot;);\n        List&lt;String&gt; timeStamp = exchange.getRequest().getHeaders().get(&quot;T-SP&quot;);\n        List&lt;String&gt; userAgent = exchange.getRequest().getHeaders().get(&quot;X-U-A&quot;);\n        List&lt;String&gt; contentType = exchange.getRequest().getHeaders().get(HttpHeaders.CONTENT_TYPE);\n\n        if (excludeFromAuth) {\n            return chain.filter(exchange);\n        }\n\n        if (userAgent == null || userAgent.isEmpty()) {\n            return onError(exchange, HttpStatus.FORBIDDEN);\n        }\n\n        if (timeStamp == null || timeStamp.isEmpty()) {\n            return onError(exchange, HttpStatus.FORBIDDEN);\n        }\n\n        if (payloadSignature == null || payloadSignature.isEmpty()) {\n            return onError(exchange, HttpStatus.FORBIDDEN);\n        }\n\n        String requestHash = payloadSignature.get(0);\n        paddedTimeStamp = &quot;&quot;;\n\n        if (!isTimeStampValid(timeStampHeader)) {// validate time stamp\n            return onError(exchange, HttpStatus.FORBIDDEN);\n        }\n\n        return repository.findByAgentKey(userAgent.get(0))\n                .flatMap(signatureRecord -&gt; {\n                    // Assign or use the signatureRecord here\n                    signature = signatureRecord;\n\n                    boolean hasApplicationJsonHeader = hasApplicationJsonHeader(contentType);\n\n                    if (hasApplicationJsonHeader) {\n                        return validateSignaturesV3(requestHash, exchange, chain);\n                    } else {\n                        if (isValidUrl(requestHash, exchange.getRequest().getURI().toString())) {\n                            return chain.filter(exchange); // Continue chain if valid\n                        }\n                        return onError(exchange, HttpStatus.FORBIDDEN);\n                    }\n\n                }).switchIfEmpty(onError(exchange, HttpStatus.FORBIDDEN));\n    }\n</code></pre>\n<p>why does the first on work and the second one does not work</p>\n",
    "tags" : [ "java", "spring", "reactive-programming" ],
    "owner" : {
      "account_id" : 2568640,
      "reputation" : 670,
      "user_id" : 6760934,
      "user_type" : "registered",
      "accept_rate" : 38,
      "profile_image" : "https://lh4.googleusercontent.com/-wRA5nZTkUwo/AAAAAAAAAAI/AAAAAAAAAA0/cxcvLoblK1I/s256-rj/photo.jpg",
      "display_name" : "DaviesTobi alex",
      "link" : "https://stackoverflow.com/users/6760934/daviestobi-alex"
    },
    "is_answered" : false,
    "view_count" : 65,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1747648606,
    "creation_date" : 1747644421,
    "link" : "https://stackoverflow.com/questions/79628387/spring-cloud-gateway-request-body-consumed-in-filter-response-not-returned-to",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140884609,
    "post_id" : 79628387,
    "body" : "Please be aware, that all <a href=\"https://meta.stackoverflow.com/q/421831/16805423\">usages of generative AI are banned</a>",
    "score" : 0,
    "owner" : {
      "account_id" : 22627540,
      "reputation" : 1166,
      "user_id" : 16805423,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/LA3Jp.jpg?s=256",
      "display_name" : "Brentspine",
      "link" : "https://stackoverflow.com/users/16805423/brentspine"
    },
    "creation_date" : 1764734798,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}