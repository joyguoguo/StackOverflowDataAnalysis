{
  "question" : {
    "question_id" : 79589774,
    "title" : "Java Swing Issue (While true loop having a burst effect)",
    "body" : "<h1><strong>Main.java:</strong></h1>\n<pre><code>import javax.swing.*;\nimport javax.swing.border.EmptyBorder;\nimport java.awt.*;\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.io.IOException;\nimport java.security.Key;\nimport java.util.HashSet;\nimport java.util.Set;\n\nclass GameLoop implements Runnable\n{\n    public boolean running;\n\n    public GameLoop() {\n        running = true;\n    }\n\n    @Override\n    public void run() {\n        int counter = 1;\n        while (running) {\n            // Task that runs in the separate thread\n            System.out.println(&quot;Separate thread counter: &quot; + counter);\n            counter++;\n\n            try {\n                Thread.sleep(1);  // Sleep for 1 second\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void stopThread() {\n        running = false;\n    }\n}\n\npublic class Main extends JFrame implements KeyListener // H: 23, W: 24\n{\n    private int backgroundTileSize = 24;\n    private int backgroundTileSpace = 1;\n    private int backgroundTileCount = 26;\n    private int objectTileSize = 18;\n    private int objectTileSpace = 1;\n    private int WIDTH = backgroundTileSize * backgroundTileCount - (int) (backgroundTileSize * 1.65);\n    private int HEIGHT = backgroundTileSize * backgroundTileCount - (int) (backgroundTileSize * 1.65);\n    Background background;\n    Player player;\n    Objects objects;\n    JLayeredPane layeredPane;\n    private KeyEvent key = null;\n    private final Set&lt;Integer&gt; keysPressed = new HashSet&lt;&gt;();\n    private boolean keyPressed = false;\n    private final int targetFPS = 60;\n    private final int frameTime = 1000 / targetFPS;\n\n    /*\n            objects = new Objects(objectTileSize, objectTileSpace, HEIGHT, WIDTH);\n        player = new Player(300, 300, &quot;assets/kenney_pixel-platformer/Tiles/Characters/tile_0000.png&quot;);\n     */\n    public Main() throws IOException {\n        super(&quot;Game&quot;);\n\n\n        setSize(WIDTH, HEIGHT);\n        setResizable(false);\n\n        addKeyListener(this);\n        setFocusable(true);\n        requestFocusInWindow();\n\n\n        layeredPane = new JLayeredPane();\n        layeredPane.setBounds(0, 0, WIDTH, HEIGHT);\n\n        //layeredPane.setPreferredSize(new Dimension(WIDTH, HEIGHT));\n        //layeredPane.setLayout(null);\n\n        background = new Background(backgroundTileSize, backgroundTileSpace, WIDTH, HEIGHT);\n        objects = new Objects(objectTileSize, objectTileSpace, WIDTH, HEIGHT);\n        player = new Player(400, 400, &quot;assets/kenney_pixel-platformer/Tiles/Characters/tile_0000.png&quot;, WIDTH, HEIGHT);\n\n        System.out.println(WIDTH + &quot;, &quot; + HEIGHT);\n\n        layeredPane.add(background, Integer.valueOf(0));\n        layeredPane.add(objects, Integer.valueOf(1));\n        layeredPane.add(player, Integer.valueOf(2));\n\n        getContentPane().add(layeredPane);\n        layeredPane.repaint();\n        setVisible(true);\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        //startGameLoop();\n        GameLoop gameLoop = new GameLoop();\n        Thread thread = new Thread(gameLoop);\n        thread.start();\n    }\n\n    private void startGameLoop() {\n        new Thread(() -&gt; {\n            while (true) {\n                long startTime = System.currentTimeMillis();\n\n                System.out.println(1);\n                handleMovement();\n                layeredPane.repaint();\n\n                long elapsedTime = System.currentTimeMillis() - startTime;\n                long sleepTime = frameTime - elapsedTime;\n                if (sleepTime &lt; 0) sleepTime = 0;\n\n                try {\n                    Thread.sleep(sleepTime);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }).start();\n    }\n\n    private void handleMovement() {\n        if (!keysPressed.isEmpty()) {\n            if (keysPressed.contains(KeyEvent.VK_W)) {\n                player.move(0, -1);\n            }\n            if (keysPressed.contains(KeyEvent.VK_A)) {\n                player.move(-1, 0);\n            }\n            if (keysPressed.contains(KeyEvent.VK_D)) {\n                player.move(1, 0);\n            }\n        }\n    }\n\n\n    public static void main(String[] args) throws IOException {\n        Main main = new Main();\n    }\n\n    @Override\n    public void keyTyped(KeyEvent keyEvent) {\n\n    }\n\n    @Override\n    public void keyPressed(KeyEvent keyEvent) {\n        keysPressed.add(keyEvent.getKeyCode());\n    }\n\n    @Override\n    public void keyReleased(KeyEvent keyEvent) {\n        keysPressed.remove(keyEvent.getKeyCode());\n    }\n}\n</code></pre>\n<h1><strong>Background.java:</strong></h1>\n<pre><code>import javax.imageio.ImageIO;\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.Canvas;\nimport java.awt.event.KeyListener;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.awt.event.KeyEvent;\nimport java.util.*;\nimport java.awt.KeyboardFocusManager;\nimport java.awt.event.KeyEvent;\n\n\npublic class Background extends JPanel {\n    private int backgroundTileSize;\n    private int backgroundTileSpace;\n    private int HEIGHT;\n    private int WIDTH;\n    private String level1Path = &quot;levels/level1.txt&quot;;\n    private int[][] level1 = new int[24][24];\n    private Graphics window_;\n    private Objects objects;\n    private Player player;\n\n\n    public Background(int bgTileSize, int bgTileSpace, int h, int w) throws IOException {\n        setOpaque(true);\n\n        backgroundTileSize = bgTileSize;\n        backgroundTileSpace = bgTileSpace;\n        HEIGHT = h;\n        WIDTH = w;\n\n\n        try (Scanner scan = new Scanner(new File(level1Path))) {\n            int i = 0;\n            int j = 0;\n            while (scan.hasNext()) {\n                if (i &gt;= 24) {\n                    i = 0;\n                    j++;\n                }\n                level1[j][i] = Integer.parseInt(scan.next());\n                i++;\n            }\n        } catch (FileNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n\n\n        setBackground(Color.WHITE);\n        setBounds(0, 0, WIDTH, HEIGHT);\n    }\n\n    @Override\n    public void paintComponent(Graphics window) {\n        super.paintComponent(window);\n        drawLevel1(window);\n        window_ = window;\n\n        /*\n        try {\n            objects.draw(window);\n            player.draw(window);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n         */\n    }\n\n\n    public void drawLevel1(Graphics window) {\n        for (int i = 0; i &lt; level1.length; i++) {\n            for (int j = 0; j &lt; level1[i].length; j++) {\n                int[] pos = {j * 24, i * 23};\n\n\n                if (level1[i][j] == 0)\n                    drawTile(window, &quot;assets/kenney_pixel-platformer/Tilemap/tilemap-backgrounds.png&quot;, 1, 1, pos);\n\n\n                if (level1[i][j] == 1)\n                    drawTile(window, &quot;assets/kenney_pixel-platformer/Tilemap/tilemap-backgrounds.png&quot;, 3, 1, pos);\n            }\n        }\n    }\n\n\n    public void drawTile(Graphics window, String tilemap, int row, int col, int[] pos) {\n        BufferedImage image = null;\n        try {\n            image = ImageIO.read(new File(tilemap));\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n\n        int x = (backgroundTileSize * (col - backgroundTileSpace)) + (col - backgroundTileSpace);\n        int y = (backgroundTileSize * (row - backgroundTileSpace)) + (row - backgroundTileSpace);\n        BufferedImage croppedImge = image.getSubimage(x, y, backgroundTileSize, backgroundTileSize);\n        window.drawImage(croppedImge, pos[0], pos[1], null);\n    }\n}\n</code></pre>\n<h1><strong>Objects.java:</strong></h1>\n<pre><code>import javax.imageio.ImageIO;\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.Canvas;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class Objects extends JPanel {\n    private int objectTileSize;\n    private int objectTileSpace;\n    private int HEIGHT;\n    private int WIDTH;\n    private String level1Path = &quot;levels/level1Objects.txt&quot;;\n    private int[][] level1 = new int[32][32];\n    ArrayList&lt;int[]&gt; levers;\n\n\n    public ArrayList&lt;int[]&gt; getLevers() {\n        return levers;\n    }\n    public Objects(int objTileSize, int objTileSpace, int h, int w) {\n        setOpaque(false);\n\n        levers = new ArrayList&lt;&gt;();\n\n        objectTileSize = objTileSize;\n        objectTileSpace = objTileSpace;\n        HEIGHT = h;\n        WIDTH = w;\n\n        try (Scanner scan = new Scanner(new File(level1Path))) {\n            int i = 0;\n            int j = 0;\n            while (scan.hasNext()) {\n                if (i&gt;=32) {\n                    i = 0;\n                    j++;\n                }\n                level1[j][i] = Integer.parseInt(scan.next());\n                i++;\n            }\n        } catch (FileNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n\n        setBackground(Color.WHITE);\n        setBounds(0, 0, WIDTH, HEIGHT);\n    }\n\n    @Override\n    public void paintComponent(Graphics window) {\n        super.paintComponent(window);\n        try {\n            drawLevel1(window);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public void drawLevel1(Graphics window) throws IOException {\n        for (int i = 0; i &lt; level1.length; i++) {\n            for (int j = 0; j &lt; level1[i].length; j++) {\n                int[] pos = {j * objectTileSize, (i * objectTileSize) - objectTileSize + 6};\n\n\n                if (level1[i][j] == 1) {\n                    Image img = ImageIO.read(new File(&quot;assets/kenney_pixel-platformer/Tiles/tile_0021.png&quot;));\n                    window.drawImage(img, pos[0], pos[1], null);\n                }\n\n\n                if (level1[i][j] == 2) {\n                    Image img = ImageIO.read(new File(&quot;assets/kenney_pixel-platformer/Tiles/tile_0023.png&quot;));\n                    window.drawImage(img, pos[0], pos[1], null);\n                }\n\n\n                if (level1[i][j] == 3) {\n                    Image img = ImageIO.read(new File(&quot;assets/kenney_pixel-platformer/Tiles/tile_0022.png&quot;));\n                    window.drawImage(img, pos[0], pos[1], null);\n                }\n\n\n                if (level1[i][j] == 4) {\n                    Image img = ImageIO.read(new File(&quot;assets/kenney_pixel-platformer/Tiles/tile_0020.png&quot;));\n                    window.drawImage(img, pos[0], pos[1], null);\n                }\n\n\n                if (level1[i][j] == 5) {\n                    if (!levers.isEmpty()) {\n                        for (int[] lever : levers) {\n                            if (lever[0] != pos[0] &amp;&amp; lever[1] != pos[1]) {\n                                int[] lever_ = {pos[0], pos[1], -1};\n                                levers.add(lever_);\n                            }\n                        }\n                    } else {\n                        int[] lever = {pos[0], pos[1], -1};\n                        levers.add(lever);\n                    }\n\n\n                    Image img = ImageIO.read(new File(&quot;assets/kenney_pixel-platformer/Tiles/tile_0064.png&quot;));\n                    window.drawImage(img, pos[0], pos[1], null);\n                }\n\n\n                if (level1[i][j] == 6) {\n                    if (!levers.isEmpty()) {\n                        for (int[] lever : levers) {\n                            if (lever[0] != pos[0] &amp;&amp; lever[1] != pos[1]) {\n                                int[] lever_ = {pos[0], pos[1], 1};\n                                levers.add(lever_);\n                            }\n                        }\n                    } else {\n                        int[] lever = {pos[0], pos[1], 1};\n                        levers.add(lever);\n                    }\n\n\n                    Image img = ImageIO.read(new File(&quot;assets/kenney_pixel-platformer/Tiles/tile_0066.png&quot;));\n                    window.drawImage(img, pos[0], pos[1], null);\n                }\n\n\n                if (level1[i][j] == 7) {\n                    Image img = ImageIO.read(new File(&quot;assets/kenney_pixel-platformer/Tiles/tile_0053.png&quot;));\n                    window.drawImage(img, pos[0], pos[1], null);\n                }\n            }\n        }\n    }\n\n\n    public void flipLever(int px, int py) { // player pos will be centered x and at the bottom of the img\n        for (int[] lever : levers) {\n            if ( (px &gt;= lever[0] &amp;&amp; px &lt;= lever[0] + objectTileSize) &amp;&amp; (py &gt;= lever[1] + objectTileSize &amp;&amp; py &lt;= lever[1]) ) {\n                System.out.println(1);\n            }\n        }\n    }\n}\n</code></pre>\n<h1><strong>Player.java:</strong></h1>\n<pre><code>import java.awt.*;\nimport java.io.*;\nimport javax.imageio.ImageIO;\nimport javax.swing.*;\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport javax.imageio.ImageIO;\nimport java.io.File;\nimport java.io.IOException;\n\nclass PlayerImg extends Canvas {\n    private BufferedImage img;\n    private int x, y;\n\n    public PlayerImg(int x_, int y_, String path) throws IOException {\n        try {\n            img = ImageIO.read(new File(path)); // Update the path\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        this.x = x_;\n        this.y = y_;\n    }\n\n    public void render(Graphics window) {\n        window.drawImage(img, x, y, null);\n    }\n\n    public void move(int x_, int y_) {\n        x += x_;\n        y += y_;\n    }\n\n    public int getX() {\n        return x;\n    }\n\n    public int getY() {\n        return y;\n    }\n}\n\npublic class Player extends JPanel {\n    PlayerImg playerImg;\n    private int WIDTH, HEIGHT;\n\n    public Player(int x, int y, String path, int w, int h) throws IOException {\n        setOpaque(false);\n\n        playerImg = new PlayerImg(x, y, path);\n\n        WIDTH = w;\n        HEIGHT = h;\n\n        setBackground(Color.WHITE);\n        setBounds(0, 0, WIDTH, HEIGHT);\n    }\n\n    @Override\n    public void paintComponent(Graphics window) {\n        super.paintComponent(window);\n        playerImg.render(window);\n    }\n\n    public void move(int x, int y) {\n        playerImg.move(x, y);\n        repaint();\n    }\n}\n</code></pre>\n<hr />\n<p>I make a seperate thread, yet my code looks to be affected by my other code. That is a theory I have, but I really just don't know. I print 1's in a while true loop in my thread, and it prints it in a burst pattern. Oh, and I need this for player movement.</p>\n<p>Example Output:</p>\n<pre><code>1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n</code></pre>\n<p>----&gt; .1 Second delay</p>\n<pre><code>1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n</code></pre>\n<p>----&gt; .1 Second delay</p>\n<pre><code>1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n</code></pre>\n<p>I make this inside the main class and I tried using Booleans. For Booleans, I just hopped it would use its toggle effect to fix it, but that was before I learned the problem was just in the thread itself.</p>\n",
    "tags" : [ "java", "swing" ],
    "owner" : {
      "account_id" : 30619352,
      "reputation" : 13,
      "user_id" : 23472189,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f1fa571b869c9123c450590ac32344b2?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "ineedhelppls",
      "link" : "https://stackoverflow.com/users/23472189/ineedhelppls"
    },
    "is_answered" : true,
    "view_count" : 60,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1745490065,
    "creation_date" : 1745465648,
    "link" : "https://stackoverflow.com/questions/79589774/java-swing-issue-while-true-loop-having-a-burst-effect",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79589818,
    "question_id" : 79589774,
    "body" : "<p>I think you're running into a classic Swing threading issue. The &quot;burst effect&quot; you're seeing is likely related to how threads are scheduled and prioritized by the JVM. Here are a few suggestions:</p>\n<p>Your GameLoop thread is using Thread.sleep(1) which is too small - the OS can't reliably honor 1ms sleeps. Try increasing this to at least 10-16ms for smoother timing.\nYou're creating the GameLoop but not actually using it for game updates - it's just printing numbers. Consider hooking this up to your actual game state updates.\nMake sure all Swing UI updates happen on the Event Dispatch Thread (EDT) using SwingUtilities.invokeLater().\nLook into using a proper game loop pattern like &quot;fixed timestep&quot; that can handle variations in execution time.\nSince this is for player movement, consider using javax.swing.Timer instead of raw threads - it's designed to work with Swing and runs on the EDT.</p>\n<p>I had a similar issue in a Swing project and found that implementing proper delta timing and being careful about which thread handles UI updates fixed the stuttering/burst effect.</p>\n",
    "score" : 1,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 18698797,
      "reputation" : 249,
      "user_id" : 13631451,
      "user_type" : "registered",
      "profile_image" : "https://lh4.googleusercontent.com/-VHoslIX8yyU/AAAAAAAAAAI/AAAAAAAAAAA/AMZuuclV4n2YC7BSLszYF1svXAvyDybcBw/s256-rj/photo.jpg",
      "display_name" : "dadasese",
      "link" : "https://stackoverflow.com/users/13631451/dadasese"
    },
    "creation_date" : 1745469010,
    "last_activity_date" : 1745469010,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140367658,
    "post_id" : 79589774,
    "body" : "<code>Thread.sleep(1);  &#47;&#47; Sleep for 1 second</code> - not correct.",
    "score" : 1,
    "owner" : {
      "account_id" : 2673407,
      "reputation" : 44872,
      "user_id" : 2310289,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/PO7Uz.jpg?s=256",
      "display_name" : "Scary Wombat",
      "link" : "https://stackoverflow.com/users/2310289/scary-wombat"
    },
    "creation_date" : 1745549086,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140364820,
    "post_id" : 79589774,
    "body" : "Remove your <code>run()</code> method, and remove all uses of <code>while</code> from the body of your <code>startGameLoop</code> method.  Use <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.desktop/javax/swing/Timer.html\" rel=\"nofollow noreferrer\">javax.swing.Timer</a> (not java.util.Timer!) instead.  The run() method is gobbling up your CPU, and the while loop in startGameLoop is violating <a href=\"https://docs.oracle.com/javase/tutorial/uiswing/concurrency/\" rel=\"nofollow noreferrer\">Swing threading rules</a>.",
    "score" : 1,
    "owner" : {
      "account_id" : 2053598,
      "reputation" : 44936,
      "user_id" : 1831987,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/38b1c37530189ec4471a43a618e33f67?s=256&d=identicon&r=PG",
      "display_name" : "VGR",
      "link" : "https://stackoverflow.com/users/1831987/vgr"
    },
    "creation_date" : 1745490285,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}