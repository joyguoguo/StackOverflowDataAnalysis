{
  "question" : {
    "question_id" : 79756748,
    "title" : "Is this piece of code correctly synchronized? Java synchronization and memory visibility question",
    "body" : "<p>Here is a Java class that writes messages in a parallel thread to a stream. When the <code>stop()</code> method is called, the <code>mCloseWriter</code> flag is set and the thread that writes the messages to the stream is notified of this. It also starts a thread called <code>mTimeoutThread</code>, which waits for the specified time and if the thread that writes the messages has not completed its execution, it is interrupted.</p>\n<p>In parallel, the <code>mThread</code> thread waits for the completion of <code>mWriterThread</code> and <code>mTimeoutThread</code> and then notifies <code>mListener</code> about the completion of writing.</p>\n<p>The question is, is it safe to access <code>mTimeoutThread</code> from thread <code>mThread</code> without a synchronized block in this specific case? Will <code>mThread</code> see the latest value of <code>mTimeoutThread</code>?</p>\n<p>Based on my understanding of Java, this is safe because:</p>\n<p>a) when we reach the commented line of code, the value of <code>mTimeoutThread</code> seen by <code>mThread</code> is equal to the value of <code>mTimeoutThread</code> seen by <code>mWriterThread</code> because <code>mWriterThread</code> has already completed its execution (we called <code>mWriterThread.join()</code> from <code>mThread</code>) and according to Java rules all actions in a thread happen-before any other thread successfully returns from a <code>join()</code> on that thread.</p>\n<p>b) <code>mWriterThread</code> can finish its execution in two cases:</p>\n<ol>\n<li>If the <code>stop()</code> method has set the <code>mCloseWriter</code> flag and <code>mWriterThread</code> has written all messages and sees from the <code>synchronized(mObject)</code> block that <code>mCloseWriter</code> is set to true. Here, the <code>synchronized(mObject)</code> block also guarantees that <code>mThread</code> will see the the value of <code>mTimeoutThread</code> initialized  by the <code>stop()</code> method.</li>\n<li>An exception is thrown in the <code>loopWriter()</code> method. In this case, the exception will be caught and the <code>terminate()</code> method will be called.\nSince <code>terminate()</code> is synchronized by the <code>synchronized(mObject)</code> block, after <code>terminate()</code> completes, <code>mWriterThread</code> will see the current value of <code>mTimeoutThread</code>. And since <code>terminate()</code> also sets the value of <code>mException</code>, which prevents the value of <code>mTimeoutThread</code> from being changed by the <code>stop()</code> method, <code>mWriterThread</code> will observe the last possible value of <code>mTimeoutThread</code>.</li>\n</ol>\n<p>And based on the above sequence of events, <code>mThread</code> will see the current value of <code>mTimeoutThread</code> even without the <code>synchronized(mObject)</code> block and this class has no synchronization problems. However, I loaded this code into ChatGPT and it thinks there is a data race. So, is the code below properly synchronized?</p>\n<pre><code>public class MessageWriter {\n    private final OutputStream mStream;\n    private Thread mWriterThread;\n    private Thread mTimeoutThread;\n    private boolean mCloseWriter;\n    private Thread mThread;\n    private final Object mObject = new Object();\n    private Exception mException;\n    private final Listener mListener;\n    private final LinkedList&lt;byte[]&gt; mMessageQueue = new LinkedList&lt;&gt;();\n\n    public MessageWriter(OutputStream stream, Listener listener) {\n        mStream = stream;\n        mListener = listener;\n        start();\n    }\n\n    private void start() {\n        synchronized (mObject) {\n            mThread = new Thread(() -&gt; {\n                    startWriterThread();\n                    joinThread(mWriterThread);\n                    \n                    /*Is it safe to access mTimeoutThread without \n                      a synchronized block here?*/\n                    if (mTimeoutThread != null) {      \n                        joinThread(mTimeoutThread);\n                    }\n                    mListener.onClosed(mException);\n                });\n           mThread.start();\n        }\n    }\n\n    private void startWriterThread() {\n        synchronized (mObject) {\n            mWriterThread = new Thread(() -&gt; {\n                try {\n                    loopWriter();\n                } catch (Exception e) {\n                    terminate(e);\n                }\n            });\n            mWriterThread.start();\n        }\n    }\n\n    public void stop() {\n        synchronized (mObject) {\n            if (!mCloseWriter &amp;&amp; mException == null) {\n                mCloseWriter = true;\n                mTimeoutThread = new Thread(() -&gt; {\n                    try {\n                        waitAndThrow(5000);\n                    } catch(InterruptedException ignored){\n                    } catch (Exception e) {\n                        terminate(e);\n                    }\n                });\n                mTimeoutThread.start();\n\n                mObject.notifyAll();\n            }\n        }\n    }\n\n\n    private void terminate(Exception exception) {\n        synchronized (mObject) {\n            if (mException == null) {\n                mException = exception;\n                mWriterThread.interrupt();\n                mTimeoutThread.interrupt();\n                mThread.interrupt();\n            }\n        }\n    }\n\n    private static void joinThread(Thread thread) {\n        do {\n            try { thread.join(); } catch (InterruptedException ignored) {}\n        } while (thread.isAlive());\n    }\n\n    private byte[] nextMessage() throws InterruptedException {\n        synchronized (mObject) {\n            while (mMessageQueue.isEmpty()) {\n                if (mCloseWriter) return null;\n                mObject.wait();\n            }\n            return mMessageQueue.remove();\n        }\n    }\n    private void loopWriter() throws InterruptedException, IOException {\n        while (true) {\n            final byte[] message = nextMessage();\n            if (message == null) {\n                synchronized (mObject) {\n                   mTimeoutThread.interrupt();\n                }\n                return;\n            }\n            mStream.write(message);\n        }\n    }\n    \n    public void writeMessage(byte[] message) {\n        synchronized (mObject) {\n            if (mCloseWriter || mException != null) {\n                return;\n            }\n            if (mMessageQueue.isEmpty()) {\n                mObject.notifyAll();\n            }\n            mMessageQueue.add(message);\n        }\n    }\n\n    private static void waitAndThrow(long timeoutMillis) throws InterruptedException {\n        for (long deadline = System.currentTimeMillis() + timeoutMillis;;) {\n            final long currentUptime = System.currentTimeMillis();\n\n            if (currentUptime &lt;= deadline) {\n                throw new RuntimeException(&quot;Timeout!!!&quot;);\n            }\n            Thread.sleep(deadline - currentUptime);\n        }\n    }\n\n    public interface Listener {\n        void onClosed(Exception exception);\n    }\n}\n</code></pre>\n",
    "tags" : [ "java", "multithreading", "synchronization", "memory-visibility" ],
    "owner" : {
      "account_id" : 9300980,
      "reputation" : 77,
      "user_id" : 6906471,
      "user_type" : "registered",
      "profile_image" : "https://lh5.googleusercontent.com/-CGpoNP2vH00/AAAAAAAAAAI/AAAAAAAAFnM/txdGmmntWLE/s256-rj/photo.jpg",
      "display_name" : "Igor Yarmolyk",
      "link" : "https://stackoverflow.com/users/6906471/igor-yarmolyk"
    },
    "is_answered" : true,
    "view_count" : 113,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1757088628,
    "creation_date" : 1757073848,
    "link" : "https://stackoverflow.com/questions/79756748/is-this-piece-of-code-correctly-synchronized-java-synchronization-and-memory-vi",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79756991,
    "question_id" : 79756748,
    "body" : "<p>This is almost always a Bad Idea:</p>\n<pre><code>startWriterThread();\njoinThread(mWriterThread);\n</code></pre>\n<p>The only reason why some thread, A, should ever start a new thread, B, is so that thread B can go off and do one thing, while thread A <em>concurrently does some other thing.</em></p>\n<p>In your example, Thread A is the one that you assign to local var, <code>mThread</code> in your <code>start()</code> method. It creates thread B, which it assigns to member var, <code>mWriterThread</code>, and then it does absolutely nothing at all until the <code>mWriterThread</code> is finished. There is no concurrency. Your <code>mWriterThread</code> literally serves no purpose.</p>\n<p><code>mWriterThread</code> makes one call to <code>loopWriter()</code>, and then it does some shutdown logic. The program would be simpler, and its behavior would be unchanged if you got rid of the <code>mWriterThread</code> and just let the <code>mThread</code> thread call <code>loopWriter()</code> and  do the shutdown logic.</p>\n",
    "score" : 4,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 14247365,
      "reputation" : 453,
      "user_id" : 10291999,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/1yd1F.png?s=256",
      "display_name" : "Ohm&#39;s Lawman",
      "link" : "https://stackoverflow.com/users/10291999/ohms-lawman"
    },
    "creation_date" : 1757088628,
    "last_activity_date" : 1757088628,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140717860,
    "post_id" : 79756748,
    "body" : "It is possible that <i>for your specific use case</i>, every way that termination can happen so happens to result in &#39;safe&#39; handling, but that doesn&#39;t really make it safe. The code would need a heck of a lot of comments to indicate what you can and cannot do.",
    "score" : 1,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107186,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1757098559,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140717850,
    "post_id" : 79756748,
    "body" : "To answer your question in a single word: <b>No</b>, it is <b>not</b> safe to access it there. If you want a longer anwer: The entire approach seems terrible. Hard to maintain, slower than it needs to be (though I doubt performance is going to be an issue even with this over-synchronized mess.. just, if you care, this isn&#39;t the answer), and not using the tools that exist to do this sort of thing (things like BlockingQueues and ThreadPools). Also, this makes threads to do a job whilst the thread-maker just waits, which is pointless (just do the job yourself).",
    "score" : 1,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107186,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1757098215,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140717537,
    "post_id" : 79756748,
    "body" : "Never, <i>never,</i> <i>*never*</i> ignore an exception. If you are forced by the language to write a handler for some exception, and you are <i>sure</i> that the exception can never be thrown, then your handler should log a message and terminate the program. Sometimes we&#39;re wrong when we&#39;re sure about something. This way, if you <i>are</i> wrong, you&#39;ll find out sooner rather than later, and you&#39;ll know immediately what you were wrong about instead of having to spend hours of debugging and asking other people for help to figure it out.",
    "score" : 4,
    "owner" : {
      "account_id" : 14247365,
      "reputation" : 453,
      "user_id" : 10291999,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/1yd1F.png?s=256",
      "display_name" : "Ohm&#39;s Lawman",
      "link" : "https://stackoverflow.com/users/10291999/ohms-lawman"
    },
    "creation_date" : 1757087086,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140717533,
    "post_id" : 79756748,
    "body" : "If you&#39;re concerned regarding memory visibility between threads, consider using the <code>volatile</code> keyword: you can read more about that <a href=\"https://stackoverflow.com/a/106787\">here</a>. Also as @VGR mentioned, I would avoid using the C/C++ naming conventions and drop the &quot;m&quot;",
    "score" : 1,
    "owner" : {
      "account_id" : 19854183,
      "reputation" : 1,
      "user_id" : 14544017,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/WgtLb.jpg?s=256",
      "display_name" : "avaerian",
      "link" : "https://stackoverflow.com/users/14544017/avaerian"
    },
    "creation_date" : 1757086891,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140717356,
    "post_id" : 79756748,
    "body" : "This seems a lot more complicated than it needs to be.  Is there a reason you are not just using a <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/BlockingQueue.html\" rel=\"nofollow noreferrer\">BlockingQueue</a> and a single thread that takes elements from that BlockingQueue?  (Side note:  Do not start every field name with the same letter.  That is known as Hunagarian notation, and it is well documented as being more harmful than helpful.)",
    "score" : 1,
    "owner" : {
      "account_id" : 2053598,
      "reputation" : 44936,
      "user_id" : 1831987,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/38b1c37530189ec4471a43a618e33f67?s=256&d=identicon&r=PG",
      "display_name" : "VGR",
      "link" : "https://stackoverflow.com/users/1831987/vgr"
    },
    "creation_date" : 1757081758,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79756991" : [ {
      "comment_id" : 140717844,
      "post_id" : 79756991,
      "body" : "Thanks for the answer! I would like to point out that this code is just a very simplified version of the code used in the real application, written to more clearly demonstrate my question about synchronizing access to mTimeoutThread. In the code I use in the real application, the mThread thread starts many other threads and also does some work itself.",
      "score" : 0,
      "owner" : {
        "account_id" : 9300980,
        "reputation" : 77,
        "user_id" : 6906471,
        "user_type" : "registered",
        "profile_image" : "https://lh5.googleusercontent.com/-CGpoNP2vH00/AAAAAAAAAAI/AAAAAAAAFnM/txdGmmntWLE/s256-rj/photo.jpg",
        "display_name" : "Igor Yarmolyk",
        "link" : "https://stackoverflow.com/users/6906471/igor-yarmolyk"
      },
      "creation_date" : 1757098091,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}