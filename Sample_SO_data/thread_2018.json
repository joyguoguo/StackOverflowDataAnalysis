{
  "question" : {
    "question_id" : 79654831,
    "title" : "Spring boot connection pool size with custom datasource",
    "body" : "<p>I have multiple Spring Boot 3.4.4 applications, connecting to various databases. Mostly I'm using the default spring datasource configuration in the application.yml, and I could setup the connection pool size like so:</p>\n<pre><code>spring:\n  datasource:\n    hikari:\n      maximum-pool-size: 10\n      idle-timeout: 20000\n      minimum-idle: 1\n    driver-class-name: org.postgresql.Driver\n    url: jdbc:postgresql://ip:port/dbname\n    username: user1\n    password: password1\n</code></pre>\n<p>This works as expected when using the default spring datasource. However for some apps I need access to multiple databases, and this doesn't work. In such cases I use the default spring datasource yaml config (same as above) for one datasource, and another similar yaml structure for another datasource, e.g:</p>\n<pre><code>spring:\n  datasource:\n    hikari:\n      maximum-pool-size: 10\n      idle-timeout: 20000\n      minimum-idle: 1\n    driver-class-name: org.postgresql.Driver\n    url: jdbc:postgresql://ip:port/dbname\n    username: user1\n    password: password1\n\n  datasource2:\n    hikari:\n      maximum-pool-size: 10\n      idle-timeout: 20000\n      minimum-idle: 1\n    driver-class-name: org.postgresql.Driver\n    url: jdbc:postgresql://ip:port/dbname2\n    username: user2\n    password: password2\n</code></pre>\n<p>I initialize these from Java with a custom class:</p>\n<pre><code>@Configuration\n@EnableJpaRepositories(\n        basePackages = {&quot;my.packages.repository.datasource1&quot;},\n        entityManagerFactoryRef = &quot;myEntityManagerFactory&quot;,\n        transactionManagerRef = &quot;myTransactionManager&quot;\n)\n@EnableTransactionManagement\n@RequiredArgsConstructor\npublic class MyDbConfig {\n\n    @Primary\n    @Bean(&quot;myDataSourceProperties&quot;)\n    @ConfigurationProperties(&quot;spring.datasource&quot;)\n    DataSourceProperties myDataSourceProperties() {\n        return new DataSourceProperties();\n    }\n\n    @Primary\n    @Bean(name = &quot;myDataSource&quot;)\n    DataSource myDataSource(@Qualifier(&quot;myDataSourceProperties&quot;) DataSourceProperties myDataSourceProperties) {\n        return myDataSourceProperties.initializeDataSourceBuilder().build();\n    }\n\n    @Primary\n    @Bean(name = &quot;myEntityManagerFactory&quot;)\n    LocalContainerEntityManagerFactoryBean myEntityManagerFactory(\n            final EntityManagerFactoryBuilder builder,\n            @Qualifier(&quot;myDataSource&quot;) DataSource dataSource,\n            JpaProperties jpaProperties) {\n        return builder.dataSource(dataSource)\n                .packages(&quot;my.packages.domain.datasource1&quot;)\n                .jta(false)\n                .persistenceUnit(&quot;my-datasource1&quot;)\n                .properties(jpaProperties.getProperties())\n                .properties(Map.of(\n                        &quot;hibernate.physical_naming_strategy&quot;, &quot;org.hibernate.boot.model.naming.CamelCaseToUnderscoresNamingStrategy&quot;,\n                        &quot;hibernate.implicit_naming_strategy&quot;, &quot;org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy&quot;,\n                        &quot;hibernate.id.new_generator_mappings&quot;, &quot;true&quot;,\n                        &quot;hibernate.transaction.jta.platform&quot;, &quot;org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform&quot;\n                ))\n                .build();\n    }\n\n    @Primary\n    @Bean(name = &quot;myTransactionManager&quot;)\n    PlatformTransactionManager myTransactionManager(@Qualifier(&quot;myEntityManagerFactory&quot;)\n                                                            EntityManagerFactory entityManagerFactory) {\n        return new JpaTransactionManager(entityManagerFactory);\n    }\n}\n</code></pre>\n<p>I have multiple versions of the above class, one for each datasource. I separate my repository and entity classes into different packages for each datasource, and then I assign the appropriate package to each datasource definition. It works correctly, but it keeps opening the default 10 connections, not respecting the minimum-idle 1 setting from the configuration. The default for HikariCP is that the minimum is same as maximum, so that's why, I assume.</p>\n<p>I read through multiple articles and stackoverflow questions, but almost exclusively everyone always focuses on the default settings, which is understandable, but that works for me too. I need help for these custom datasources, and I haven't found it so far.</p>\n<p>This is the relevant logs that I get when the app is starting:</p>\n<pre><code>[           main] c.z.h.HikariDataSource                   : HikariPool-1 - Starting...\n[           main] c.z.h.p.HikariPool                       : HikariPool-1 - Added connection org.postgresql.jdbc.PgConnection@20a9fb01\n[           main] c.z.h.HikariDataSource                   : HikariPool-1 - Start completed.\n[           main] o.h.j.i.u.LogHelper                      : HHH000204: Processing PersistenceUnitInfo [name: my-datasource1]\n[           main] o.h.Version                              : HHH000412: Hibernate ORM core version 6.6.11.Final\n[           main] o.h.c.i.RegionFactoryInitiator           : HHH000026: Second-level cache disabled\n[           main] o.s.b.w.e.t.TomcatWebServer              : Tomcat initialized with port 8080 (http)\n[           main] o.a.c.c.StandardService                  : Starting service [Tomcat]\n[           main] o.a.c.c.StandardEngine                   : Starting Servlet engine: [Apache Tomcat/10.1.39]\n[           main] o.a.c.c.C.[.[.[/]                        : Initializing Spring embedded WebApplicationContext\n[           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 19839 ms\n[           main] o.s.o.j.p.SpringPersistenceUnitInfo      : No LoadTimeWeaver setup: ignoring JPA class transformer\n[           main] o.h.o.c.pooling                          : HHH10001005: Database info:\n    Database JDBC URL [Connecting through datasource 'HikariDataSource (HikariPool-1)']\n    Database driver: undefined/unknown\n    Database version: 17.0\n    Autocommit mode: undefined/unknown\n    Isolation level: undefined/unknown\n    Minimum pool size: undefined/unknown\n    Maximum pool size: undefined/unknown\n</code></pre>\n<p>And of course similar for HikariPool-2 for the other datasource.</p>\n",
    "tags" : [ "java", "spring-boot", "datasource", "connection-pooling" ],
    "owner" : {
      "account_id" : 4736785,
      "reputation" : 486,
      "user_id" : 3830952,
      "user_type" : "registered",
      "accept_rate" : 62,
      "profile_image" : "https://graph.facebook.com/100004201022811/picture?type=large",
      "display_name" : "G&#225;bor Major",
      "link" : "https://stackoverflow.com/users/3830952/g%c3%a1bor-major"
    },
    "is_answered" : true,
    "view_count" : 215,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1749141830,
    "creation_date" : 1749139554,
    "link" : "https://stackoverflow.com/questions/79654831/spring-boot-connection-pool-size-with-custom-datasource",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79654855,
    "question_id" : 79654831,
    "body" : "<p>Note: If the bean name is the same as the method name, you can just use <code>@Bean</code></p>\n<p>I tend to use <code>HikariConfig</code> instead of <code>DataSourceProperties</code> eg:</p>\n<pre class=\"lang-java prettyprint-override\"><code>import com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\n\n@Configuration\npublic class MyConfiguration() {\n\n   @Bean\n   @ConfigurationProperties(&quot;spring.datasource1&quot;)\n   public HikariConfig datasource1Config() {\n      return new HikariConfig();\n   }\n\n   @Bean\n   public DataSource datasource1(@Qualifier(&quot;datasource1Config&quot;) HikariConfig config1) {\n      return new HikariDataSource(config1);\n   }\n\n   @Bean\n   @ConfigurationProperties(&quot;spring.datasource2&quot;)\n   public HikariConfig datasource2Config() {\n      return new HikariConfig();\n   }\n\n   @Bean\n   public DataSource datasource2(@Qualifier(&quot;datasource2Config&quot;) HikariConfig config2) {\n      return new HikariDataSource(config1);\n   }\n}\n</code></pre>\n<p>Then your yaml would look something like</p>\n<pre class=\"lang-yaml prettyprint-override\"><code>spring:\n  datasource1:\n    maximum-pool-size: 10\n    idle-timeout: 20000\n    minimum-idle: 1\n    driver-class-name: org.postgresql.Driver\n    jdbc-url: jdbc:postgresql://ip:port/dbname\n    username: user1\n    password: password1\n  datasource2:\n    maximum-pool-size: 10\n    idle-timeout: 20000\n    minimum-idle: 1\n    driver-class-name: org.postgresql.Driver\n    jdbc-url: jdbc:postgresql://ip:port/dbname2\n    username: user2\n    password: password2\n</code></pre>\n<p>Note also that if you have lots of datasources the <code>@Qualifier</code> annotations start getting quite unwieldy to maintain. In these cases you can make your own custom qualifier annotations. Eg:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Target({FIELD, PARAMETER, TYPE, METHOD})\n@Retention(RUNTIME)\n@Qualifier\npublic @interface Datasource1 { }\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>@Target({FIELD, PARAMETER, TYPE, METHOD})\n@Retention(RUNTIME)\n@Qualifier\npublic @interface Datasource2 { }\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import com.zaxxer.hikari.HikariConfig;\nimport com.zaxxer.hikari.HikariDataSource;\n\n@Configuration\npublic class MyConfiguration() {\n\n   @Bean\n   @Datasource1 \n   @ConfigurationProperties(&quot;spring.datasource1&quot;)\n   public HikariConfig datasource1Config() {\n      return new HikariConfig();\n   }\n\n   @Bean\n   @Datasource1\n   public DataSource datasource1(@Datasource1 HikariConfig config) {\n      return new HikariDataSource(config);\n   }\n\n   @Bean\n   @Datasource1\n   public MyService service1(@Datasource1 datasource) {\n      return new MyService(datasource);\n   }\n\n   @Bean\n   @Datasource2 \n   @ConfigurationProperties(&quot;spring.datasource2&quot;)\n   public HikariConfig datasource2Config() {\n      return new HikariConfig();\n   }\n\n   @Bean\n   @Datasource2\n   public DataSource datasource2(@Datasource2 HikariConfig config) {\n      return new HikariDataSource(config);\n   }\n\n   @Bean\n   @Datasource2\n   public MyService service2(@Datasource2 datasource) {\n      return new MyService(datasource);\n   }\n}\n</code></pre>\n<p>See also <a href=\"https://www.javabyexamples.com/spring-custom-qualifier-annotation\" rel=\"nofollow noreferrer\">https://www.javabyexamples.com/spring-custom-qualifier-annotation</a></p>\n",
    "score" : 1,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 1096470,
      "reputation" : 29414,
      "user_id" : 1089967,
      "user_type" : "registered",
      "accept_rate" : 59,
      "profile_image" : "https://www.gravatar.com/avatar/1f256b904ff621d678598d8fa49f86c5?s=256&d=identicon&r=PG",
      "display_name" : "lance-java",
      "link" : "https://stackoverflow.com/users/1089967/lance-java"
    },
    "creation_date" : 1749140533,
    "last_activity_date" : 1749141830,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79654855" : [ {
      "comment_id" : 140492429,
      "post_id" : 79654855,
      "body" : "thanks, working correctly. I have a maximum of 3 datasources in a single project, but usually only 2, so the amount of annotations is manageable, but thanks for the heads up",
      "score" : 0,
      "owner" : {
        "account_id" : 4736785,
        "reputation" : 486,
        "user_id" : 3830952,
        "user_type" : "registered",
        "accept_rate" : 62,
        "profile_image" : "https://graph.facebook.com/100004201022811/picture?type=large",
        "display_name" : "G&#225;bor Major",
        "link" : "https://stackoverflow.com/users/3830952/g%c3%a1bor-major"
      },
      "creation_date" : 1749197215,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}