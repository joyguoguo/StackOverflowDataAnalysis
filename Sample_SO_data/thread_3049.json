{
  "question" : {
    "question_id" : 79575108,
    "title" : "What happens when different ThreadLocals refer to the same object?",
    "body" : "<p>If I have (napkin) code that looks like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public static SomeClass someInstance;\nThreadLocal&lt;HashMap&lt;Integer, SomeClass&gt;&gt; locals = new ThreadLocal&lt;&gt;(){\n    @Override protected HashMap&lt;Integer, SomeClass&gt; initialValue() {\n        return new HashMap&lt;Integer,SomeClass&gt;(){{put(5,someInstance);}};\n    }\n\n}\n</code></pre>\n<p>What does it actually do? If thread1 mutates someClass by accessing it through its threadlocal hashmap, will those changes be visible to thread2 (eventually)?</p>\n<p>It's fine for my use if there's a race condition between when the data is written to someClass and when another thread observes the change, but it won't be fine if the reader thread will never see the change even after a long time has passed.</p>\n",
    "tags" : [ "java" ],
    "owner" : {
      "account_id" : 10271117,
      "reputation" : 132,
      "user_id" : 7579456,
      "user_type" : "registered",
      "profile_image" : "https://lh4.googleusercontent.com/-GFXE8yagVvw/AAAAAAAAAAI/AAAAAAAAAkI/V9xL5b4jPJY/s256-rj/photo.jpg",
      "display_name" : "Hex_27",
      "link" : "https://stackoverflow.com/users/7579456/hex-27"
    },
    "is_answered" : true,
    "view_count" : 95,
    "answer_count" : 1,
    "score" : 2,
    "last_activity_date" : 1745002302,
    "creation_date" : 1744718980,
    "link" : "https://stackoverflow.com/questions/79575108/what-happens-when-different-threadlocals-refer-to-the-same-object",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79575139,
    "question_id" : 79575108,
    "body" : "<p>Your concern is not specifically related to using <code>ThreadLocal</code>; the problems you envision will also occur if you share a mutable object with multiple threads through other means, and modify that object.</p>\n<p>For changes to be guaranteed to be visible (eventually or not), you need to implement <code>SomeClass</code> to be properly <a href=\"https://en.wikipedia.org/wiki/Thread_safety\" rel=\"nofollow noreferrer\">thread safe</a>, otherwise there is no guarantee that those changes will be seen or not by other threads. And to be thread safe, as defined in the <a href=\"https://en.wikipedia.org/wiki/Java_memory_model\" rel=\"nofollow noreferrer\">Java Memory Model (JMM)</a>, you need to use synchronization primitives, locks and other publication mechanisms that establish a happens-before between the write by one thread and the subsequent read by another thread (and also with writes performed by other threads).</p>\n",
    "score" : 2,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 213468,
      "reputation" : 110282,
      "user_id" : 466862,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d873f397779db38cd510d9ee5416fd43?s=256&d=identicon&r=PG",
      "display_name" : "Mark Rotteveel",
      "link" : "https://stackoverflow.com/users/466862/mark-rotteveel"
    },
    "creation_date" : 1744719802,
    "last_activity_date" : 1745002302,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140338323,
    "post_id" : 79575108,
    "body" : "Unrelated to the question, but you can use <code>ThreadLocal.withInitial(() -&gt; ...)</code> to prevent having to create a sub class.",
    "score" : 0,
    "owner" : {
      "account_id" : 1211967,
      "reputation" : 9964,
      "user_id" : 1180351,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
      "display_name" : "Rob Spoor",
      "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
    },
    "creation_date" : 1744745354,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140337180,
    "post_id" : 79575108,
    "body" : "I meant: change the code to <code>sleep</code> in that block, then have another thread access <code>someInstance</code>, then see what happens. Of course you won&#39;t see much interesting when you don&#39;t try to provoke any special cases or errors. But this should give you an idea of what could happen / go wrong.",
    "score" : 0,
    "owner" : {
      "account_id" : 1535561,
      "reputation" : 9056,
      "user_id" : 1431720,
      "user_type" : "registered",
      "accept_rate" : 89,
      "profile_image" : "https://www.gravatar.com/avatar/f5a1388d4d3b2bf03b11bb5658c68c29?s=256&d=identicon&r=PG",
      "display_name" : "Robert",
      "link" : "https://stackoverflow.com/users/1431720/robert"
    },
    "creation_date" : 1744726426,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140336811,
    "post_id" : 79575108,
    "body" : "@Robert I did try it, it worked. But knowing threads, that&#39;s not good enough, so I asked anyway.",
    "score" : 0,
    "owner" : {
      "account_id" : 10271117,
      "reputation" : 132,
      "user_id" : 7579456,
      "user_type" : "registered",
      "profile_image" : "https://lh4.googleusercontent.com/-GFXE8yagVvw/AAAAAAAAAAI/AAAAAAAAAkI/V9xL5b4jPJY/s256-rj/photo.jpg",
      "display_name" : "Hex_27",
      "link" : "https://stackoverflow.com/users/7579456/hex-27"
    },
    "creation_date" : 1744721230,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140336704,
    "post_id" : 79575108,
    "body" : "@Robert If <code>SomeClass</code> is not thread safe, the JMM (Java Memory Model) provides no such guarantees, while most (maybe even all) JVM implementations will probably eventually make those changes visible. A change to the underlying platform, JVM implementation or JIT implementation might invalidate such assumptions based on observed behaviour, instead of reasoned following the JMM.",
    "score" : 0,
    "owner" : {
      "account_id" : 213468,
      "reputation" : 110282,
      "user_id" : 466862,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d873f397779db38cd510d9ee5416fd43?s=256&d=identicon&r=PG",
      "display_name" : "Mark Rotteveel",
      "link" : "https://stackoverflow.com/users/466862/mark-rotteveel"
    },
    "creation_date" : 1744719546,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140336691,
    "post_id" : 79575108,
    "body" : "You could try it and see what happens?",
    "score" : 0,
    "owner" : {
      "account_id" : 1535561,
      "reputation" : 9056,
      "user_id" : 1431720,
      "user_type" : "registered",
      "accept_rate" : 89,
      "profile_image" : "https://www.gravatar.com/avatar/f5a1388d4d3b2bf03b11bb5658c68c29?s=256&d=identicon&r=PG",
      "display_name" : "Robert",
      "link" : "https://stackoverflow.com/users/1431720/robert"
    },
    "creation_date" : 1744719411,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140336674,
    "post_id" : 79575108,
    "body" : "Don&#39;t ever use double brace initialization like this. In any case, your concern is not specifically related to using <code>ThreadLocal</code>; it would also occur if you share a mutable object with multiple threads through other means. And if <code>SomeClass</code> is not properly thread safe, there is <b>no guarantee</b> that those changes will be seen or not by other threads.",
    "score" : 4,
    "owner" : {
      "account_id" : 213468,
      "reputation" : 110282,
      "user_id" : 466862,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d873f397779db38cd510d9ee5416fd43?s=256&d=identicon&r=PG",
      "display_name" : "Mark Rotteveel",
      "link" : "https://stackoverflow.com/users/466862/mark-rotteveel"
    },
    "creation_date" : 1744719292,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79575139" : [ {
      "comment_id" : 140337043,
      "post_id" : 79575139,
      "body" : "@Holger Indeed. Also, code that worked like you expected before JIT, might no longer works that way after JIT, and could be back to the working behaviour if it gets deoptimized or reoptimized, inlined, etc., because according to the JMM it could apply optimizations that eliminated reads, etc.",
      "score" : 2,
      "owner" : {
        "account_id" : 213468,
        "reputation" : 110282,
        "user_id" : 466862,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/d873f397779db38cd510d9ee5416fd43?s=256&d=identicon&r=PG",
        "display_name" : "Mark Rotteveel",
        "link" : "https://stackoverflow.com/users/466862/mark-rotteveel"
      },
      "creation_date" : 1744724825,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140336981,
      "post_id" : 79575139,
      "body" : "@Hex_27 the phrase “after the each core flushes local caches” exhibits a wrong mindset. The JMM is not just about caches. It’s also about the limitations for the JVM’s optimizer, for example. A loop without synchronization primitives, like <code>while(x) {}</code> may get compiled to code performing no memory access at all after the loop has been entered. Whether the thread writing to x flushes caches or not, is irrelevant then. And since code can have a different optimization level or different benefits, it’s even possible that a thread observes the new value in one read of x but the old in another read",
      "score" : 3,
      "owner" : {
        "account_id" : 3211603,
        "reputation" : 300981,
        "user_id" : 2711488,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
        "display_name" : "Holger",
        "link" : "https://stackoverflow.com/users/2711488/holger"
      },
      "creation_date" : 1744723999,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140336856,
      "post_id" : 79575139,
      "body" : "@Hex_27 And that is because in a lot of cases, synchronization, locking, etc on other unrelated things will in practice also establish happens-before and thus provide an eventual visibility, but as that is accidental, weird things can happen if you rely on it. Also, the way most JVM implementations establish things like memory fence and other visibility guarantees are a lot more coarse than what the JMM describes.",
      "score" : 1,
      "owner" : {
        "account_id" : 213468,
        "reputation" : 110282,
        "user_id" : 466862,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/d873f397779db38cd510d9ee5416fd43?s=256&d=identicon&r=PG",
        "display_name" : "Mark Rotteveel",
        "link" : "https://stackoverflow.com/users/466862/mark-rotteveel"
      },
      "creation_date" : 1744721994,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140336847,
      "post_id" : 79575139,
      "body" : "@Hex_27 There are some - I believe - weaker guarantees with some of the <code>setXXX</code> and <code>weakCompareAndSet</code> methods of <code>AtomicReference</code>, but I&#39;ve never really used those. In any case the problem is that while usually things will in practice become eventually visible, if you don&#39;t use things according to the JMM, there is no <b>guarantee</b> those will happen. Things like hardware, OS, JVM vendor and version, JIT implementation (or whether JIT even tried to optimize code referencing fields of <code>SomeClass</code>) could all invalidate such &quot;but it works&quot; assumptions.",
      "score" : 3,
      "owner" : {
        "account_id" : 213468,
        "reputation" : 110282,
        "user_id" : 466862,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/d873f397779db38cd510d9ee5416fd43?s=256&d=identicon&r=PG",
        "display_name" : "Mark Rotteveel",
        "link" : "https://stackoverflow.com/users/466862/mark-rotteveel"
      },
      "creation_date" : 1744721820,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140336833,
      "post_id" : 79575139,
      "body" : "Does that mean that the JMM provides no weaker guarantee than volatile for memory consistency? I was hoping that there was at least a baseline guarantee that writes would be eventually readable from main memory after the each core flushes local caches",
      "score" : 0,
      "owner" : {
        "account_id" : 10271117,
        "reputation" : 132,
        "user_id" : 7579456,
        "user_type" : "registered",
        "profile_image" : "https://lh4.googleusercontent.com/-GFXE8yagVvw/AAAAAAAAAAI/AAAAAAAAAkI/V9xL5b4jPJY/s256-rj/photo.jpg",
        "display_name" : "Hex_27",
        "link" : "https://stackoverflow.com/users/7579456/hex-27"
      },
      "creation_date" : 1744721538,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}