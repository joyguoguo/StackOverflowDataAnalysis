{
  "question" : {
    "question_id" : 79586351,
    "title" : "Hibernate N + 1 queries after explictly setting FetchType.LAZY",
    "body" : "<p>Being very concise:</p>\n<p>I have the following use case for my app, where I update an entity named <code>Turno</code> (which represents a shift in a factory)</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Service\npublic class PausarTurnoUseCase {\n    private final ITurnoRepository turnoRepository;\n    private final ITurnoMapper turnoMapper;\n\n    public PausarTurnoUseCase(ITurnoRepository turnoRepository, ITurnoMapper turnoMapper) {\n        this.turnoRepository = turnoRepository;\n        this.turnoMapper = turnoMapper;\n    }\n\n    @Transactional\n    public Result&lt;ShowTurnoDto&gt; execute(UUID turnoId) {\n        try {\n            Optional&lt;Turno&gt; turnoOpt = turnoRepository.findById(turnoId);\n            if (turnoOpt.isEmpty()) {\n                return Result.failure(&quot;El turno no existe&quot;);\n            }\n            \n            Turno turno = turnoOpt.get();\n            \n            if (turno.getEstado() == Estado.PAUSADO &amp;&amp; turno.getFechaFin() == null) {\n                return Result.failure(&quot;El turno ya está pausado&quot;);\n            }\n            \n            turno.pause(); \n            \n            Turno savedTurno = turnoRepository.save(turno);\n            \n            ShowTurnoDto turnoDto = turnoMapper.toShowTurnoDto(savedTurno);\n            return Result.success(turnoDto, &quot;Turno pausado con éxito&quot;);\n        } catch (Exception e) {\n            return Result.failure(&quot;Error al pausar el turno: &quot; + e.getMessage());\n        }\n    }\n} \n</code></pre>\n<p>These are my entities:</p>\n<p><code>Turno</code> (shift):</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Data\n@Entity\n@Table(name = &quot;turnos&quot;)\n@NoArgsConstructor\n@AllArgsConstructor\n@EqualsAndHashCode(callSuper = false, onlyExplicitlyIncluded = true)\npublic class Turno extends BaseEntity&lt;UUID&gt; {\n    @Id\n    @EqualsAndHashCode.Include\n    @GeneratedValue(strategy = GenerationType.UUID)\n    @Column(name = &quot;turno_id&quot;, updatable = false, nullable = false)\n    private UUID turnoId;\n    \n    @ManyToOne\n    @JoinColumn(name = &quot;mesa_id&quot;, nullable = true)\n    private Mesa mesa;\n    \n    @Column(name = &quot;fecha_inicio&quot;, nullable = false)\n    private LocalDateTime fechaInicio;\n    \n    @Column(name = &quot;fecha_fin&quot;)\n    private LocalDateTime fechaFin;\n    \n    @Enumerated(EnumType.STRING)\n    @Column(name = &quot;estado&quot;, nullable = false)\n    private Estado estado = Estado.ACTIVO;\n\n    @Column(name = &quot;etapa&quot;, nullable = false)\n    private Etapa etapa;\n    \n    @ManyToMany(fetch = FetchType.LAZY )\n    @JoinTable(\n        name = &quot;turnos_usuarios&quot;,\n        joinColumns = @JoinColumn(name = &quot;turno_id&quot;),\n        inverseJoinColumns = @JoinColumn(name = &quot;usuario_id&quot;)\n    )\n    private Set&lt;Usuario&gt; usuarios = new HashSet&lt;&gt;();\n} \n</code></pre>\n<p><code>Usuario</code> (user):</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Data\n@NoArgsConstructor\n@AllArgsConstructor\n@Entity\n@Table(name = &quot;USUARIOS&quot;)\npublic class Usuario extends BaseEntity&lt;UUID&gt; {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.UUID)\n    @Column(name = &quot;USUARIO_ID&quot;, updatable = false, nullable = false)\n    private UUID usuarioId;\n\n    @Column(name = &quot;NOMBRE_USUARIO&quot;, nullable = false, unique = true, length = 50)\n    private String nombreUsuario;\n\n    @Column(name = &quot;NOMBRES&quot;, nullable = false, length = 30)\n    private String nombres;\n\n    @Column(name = &quot;APELLIDOS&quot;, nullable = false, length = 30)\n    private String apellidos;\n\n    @Column(name = &quot;CEDULA&quot;, length = 11)\n    private String cedula;\n\n    @Column(name = &quot;PASSWORD_HASH&quot;, nullable = false)\n    private String passwordHash;\n\n    @Column(name = &quot;FECHA_CREACION&quot;, nullable = false)\n    private LocalDateTime fechaCreacion;\n\n    @Column(name = &quot;FECHA_VIGENCIA&quot;, nullable = false)\n    private LocalDateTime fechaVigencia;\n\n    @Column(name = &quot;CORREO&quot;, unique = true, length = 100)\n    private String correo;\n\n    @Column(name = &quot;ACTIVO&quot;, nullable = false)\n    private boolean activo = false;\n\n    @Column(name = &quot;FOTO_PERFIL&quot;, length = 300)\n    private String fotoPerfil;\n\n    @Column(name = &quot;CELULAR&quot;, length = 10)\n    private String celular;\n\n    @Column(name = &quot;cambiar_contrasena&quot;, nullable = false)\n    private boolean cambiarContrasena;\n\n    @Column(name = &quot;FECHA_ULTIMO_ACCESO&quot;, nullable = true)\n    private LocalDateTime fechaUltimoAcceso;\n}\n</code></pre>\n<p>I have worked with other ORMs and I don't think this should be a tricky case, I just need to retrieve the entity, update one of it's atributtes and then save and that's it, it should only take 1 <code>select</code> and 1 <code>update</code>, no?</p>\n<p>Well, here's what Hibernate does:</p>\n<pre class=\"lang-sql prettyprint-override\"><code>Hibernate: select t1_0.turno_id,t1_0.estado,t1_0.etapa,t1_0.fecha_creacion,t1_0.fecha_fin,t1_0.fecha_inicio,m1_0.mesa_id,m1_0.capacidad_maxima,m1_0.numero_mesa,m1_0.tipo_extendido,t1_0.usuario_creador_id,uc1_0.usuario_id,uc1_0.activo,uc1_0.apellidos,uc1_0.cambiar_contrasena,uc1_0.cedula,uc1_0.celular,uc1_0.correo,uc1_0.fecha_creacion,uc1_0.fecha_ultimo_acceso,uc1_0.fecha_vigencia,uc1_0.foto_perfil,uc1_0.nombre_usuario,uc1_0.nombres,uc1_0.password_hash from turnos t1_0 left join mesas m1_0 on m1_0.mesa_id=t1_0.mesa_id join usuarios uc1_0 on uc1_0.usuario_id=t1_0.usuario_creador_id where t1_0.turno_id=?\nHibernate: select u1_0.turno_id,u1_1.usuario_id,u1_1.activo,u1_1.apellidos,u1_1.cambiar_contrasena,u1_1.cedula,u1_1.celular,u1_1.correo,u1_1.fecha_creacion,u1_1.fecha_ultimo_acceso,u1_1.fecha_vigencia,u1_1.foto_perfil,u1_1.nombre_usuario,u1_1.nombres,u1_1.password_hash from turnos_usuarios u1_0 join usuarios u1_1 on u1_1.usuario_id=u1_0.usuario_id where u1_0.turno_id=?\nHibernate: select ome1_0.usuario_id,ome1_0.orden_maestra_etapa_id,ome1_0.activo,ome1_0.estado,ome1_0.etapa,ome1_0.fecha_fin,ome1_0.fecha_inicio,om1_0.orden_maestra_id,om1_0.ajustar_tela,om1_0.ano_temporada,om1_0.aprobacion_consumo,om1_0.clase_orden,om1_0.codigo_marca,om1_0.coleccion,ed1_0.orden_maestra_id,ed1_0.direccion,ed1_0.muestra_fisica,ed1_0.plantillas,ed1_0.talla_base,om1_0.fecha_actualizacion,om1_0.fecha_creacion,om1_0.fecha_inicio_trazo,om1_0.justificacion_consumo,l1_0.linea_id,l1_0.nombre_linea,l1_0.numero_linea,l1_0.precio,l1_0.valor_auxiliar,om1_0.material_anterior,om1_0.material_generico,om1_0.metros_tela_principal,om1_0.nt_telas,om1_0.nombre_marca,odt1_0.orden_maestra_id,odt1_0.bloques,odt1_0.fecha_actualizacion,odt1_0.fecha_creacion,odt1_0.fecha_elaboracion,odt1_0.observaciones,odt1_0.sesgos_json,odt1_0.tipo_prenda,oe1_0.orden_maestra_id,oe1_0.fecha_ingreso_papeleria,oe1_0.fecha_ingreso_trazo,oe1_0.incluye_muestra_fisica,oe1_0.metros,oe1_0.numero_piezas,oe1_0.precio_pieza,oe1_0.responsable_ingreso_papeleria,t1_0.id_tercero,t1_0.activo,t1_0.codigo,t1_0.direccion,t1_0.email,t1_0.fecha_creacion,t1_0.identificacion,t1_0.nombre,t1_0.telefono,t1_0.tipo_identificacion,t1_0.tipo_tercero,oe1_0.ubicacion_tela,om1_0.promedio_diseno,om1_0.reproceso,s1_0.sam_id,l2_0.linea_id,l2_0.nombre_linea,l2_0.numero_linea,l2_0.precio,l2_0.valor_auxiliar,s1_0.metros,s1_0.tipo_tejido,om1_0.segmento_stock,om1_0.temporada,om1_0.tipo_orden,om1_0.tipo_prenda,om1_0.unidad_medida,u1_0.usuario_id,u1_0.activo,u1_0.apellidos,u1_0.cambiar_contrasena,u1_0.cedula,u1_0.celular,u1_0.correo,u1_0.fecha_creacion,u1_0.fecha_ultimo_acceso,u1_0.fecha_vigencia,u1_0.foto_perfil,u1_0.nombre_usuario,u1_0.nombres,u1_0.password_hash,om1_0.utilizacion,ome1_0.posicion,ome1_0.prioridad from ordenes_maestras_etapas ome1_0 left join ordenes_maestras om1_0 on om1_0.orden_maestra_id=ome1_0.orden_maestra_id left join espigas_detalles ed1_0 on om1_0.orden_maestra_id=ed1_0.orden_maestra_id left join lineas l1_0 on l1_0.linea_id=om1_0.linea_id left join ordenes_de_trazo odt1_0 on om1_0.orden_maestra_id=odt1_0.orden_maestra_id left join ordenes_maestras_extendidas oe1_0 on om1_0.orden_maestra_id=oe1_0.orden_maestra_id left join terceros t1_0 on t1_0.id_tercero=oe1_0.id_tercero left join sams s1_0 on s1_0.sam_id=om1_0.sam_id left join lineas l2_0 on l2_0.linea_id=s1_0.linea_id left join usuarios u1_0 on u1_0.usuario_id=om1_0.usuario_id where ome1_0.usuario_id=?\n[Skipped another 13 super long, useless queries]\n</code></pre>\n<p>I kind of understand that it is loading all the related entities, since <code>Turno</code> is related to <code>Usuario</code>, and <code>Usuario</code> is related to many other entities, but I have explicitly set all <code>Usuario</code> relations to be FetchType.LAZY, same with the <code>Turno-Usuario</code> (Shift-User) relation.</p>\n<p>Is there a simple way to fix this? I think this is getting out of hand...</p>\n<p>I've worked with .NET and never had this kind of issue with EFC (Microsoft's ORM) since to access related entities I had to explicitly use <code>.Include(e =&gt; e.Relation)</code>, but in SpringBoot this seems to be happening every time, with every entity even after I declare the fetch type to be lazy.</p>\n<p>I tried configuring <code>FetchType.LAZY</code>, using DTO and interface projections (but not a real fan of how projections work on SpringBoot to be honest)</p>\n<p>I have read many others <em>solutions</em> for this problem, but none have solved it for me, am I missing something?</p>\n",
    "tags" : [ "java", "spring-boot", "hibernate", "orm", "backend" ],
    "owner" : {
      "account_id" : 25286457,
      "reputation" : 13,
      "user_id" : 19113341,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a-/AOh14Gi7FjrC9OreV6ys1zD7IyuMdsXi_NbASxCWJ1rsaQ=k-s256",
      "display_name" : "Samuel Rend&#243;n",
      "link" : "https://stackoverflow.com/users/19113341/samuel-rend%c3%b3n"
    },
    "is_answered" : true,
    "view_count" : 112,
    "answer_count" : 1,
    "score" : 1,
    "last_activity_date" : 1745830480,
    "creation_date" : 1745321649,
    "link" : "https://stackoverflow.com/questions/79586351/hibernate-n-1-queries-after-explictly-setting-fetchtype-lazy",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79596092,
    "question_id" : 79586351,
    "body" : "<p>I believe the culprit here is not Hibernate but Lombok, lombok @Data annotation, which generates an unnecessary toString() and @EqualsAndHashCode and these methods use relational data. To resolve this, I suggest removing the @Data annotation and instead using the @Getter, @Setter, @NoArgsConstructor, @AllArgsConstructor and @EqualsAndHashCode(onlyExplicitlyIncluded = true)  annotations. Alternatively, you could completely ditch using Lombok and rely on ide-generated getters and setters instead.</p>\n<p>If you only want to update one field, use the update query directly. The save method in Spring Data JPA functions both as an update and a persist, which can sometimes lead to unexpected behavior.</p>\n",
    "score" : 1,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 29231405,
      "reputation" : 163,
      "user_id" : 22395035,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f29a6c01cf0e794be1f7eba72fa48149?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "kush parsaniya",
      "link" : "https://stackoverflow.com/users/22395035/kush-parsaniya"
    },
    "creation_date" : 1745830480,
    "last_activity_date" : 1745830480,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140367250,
    "post_id" : 79586351,
    "body" : "@kushparsaniya you were right!!!!! thank you very much.  if you post it as an answer I can mark it as correct if you want...  didn&#39;t know that about Lombok. I used IntelliJ but must have missed the warning.  thank you very much again, my project was getting slower and slower",
    "score" : 0,
    "owner" : {
      "account_id" : 25286457,
      "reputation" : 13,
      "user_id" : 19113341,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a-/AOh14Gi7FjrC9OreV6ys1zD7IyuMdsXi_NbASxCWJ1rsaQ=k-s256",
      "display_name" : "Samuel Rend&#243;n",
      "link" : "https://stackoverflow.com/users/19113341/samuel-rend%c3%b3n"
    },
    "creation_date" : 1745530620,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140360438,
    "post_id" : 79586351,
    "body" : "If you only want to update one field, use the update query directly. The save method in Spring Data JPA functions both as an update and a persist, which can sometimes lead to unexpected behavior.",
    "score" : 0,
    "owner" : {
      "account_id" : 29231405,
      "reputation" : 163,
      "user_id" : 22395035,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f29a6c01cf0e794be1f7eba72fa48149?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "kush parsaniya",
      "link" : "https://stackoverflow.com/users/22395035/kush-parsaniya"
    },
    "creation_date" : 1745393449,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140360406,
    "post_id" : 79586351,
    "body" : "Also if you are using IntelliJ IDEA it will give a warning for <code>@Data</code> like this : Using @Data for JPA entities is not recommended. It can cause severe performance and memory consumption issues.",
    "score" : 0,
    "owner" : {
      "account_id" : 29231405,
      "reputation" : 163,
      "user_id" : 22395035,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f29a6c01cf0e794be1f7eba72fa48149?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "kush parsaniya",
      "link" : "https://stackoverflow.com/users/22395035/kush-parsaniya"
    },
    "creation_date" : 1745392956,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140360372,
    "post_id" : 79586351,
    "body" : "I believe the culprit here is not Hibernate but Lombok,  lombok <code>@Data</code>  annotation, which generates an unnecessary <code>toString()</code>  and <code>@EqualsAndHashCode</code> and these methods use relational data. To resolve this, I suggest removing the <code>@Data</code> annotation and instead using the <code>@Getter</code>, <code>@Setter</code>, <code>@NoArgsConstructor</code>, <code>@AllArgsConstructor</code>   and <code>@EqualsAndHashCode(onlyExplicitlyIncluded = true) </code> annotations. Alternatively, you could completely avoid using Lombok and rely on ide-generated getters and setters instead.",
    "score" : 0,
    "owner" : {
      "account_id" : 29231405,
      "reputation" : 163,
      "user_id" : 22395035,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f29a6c01cf0e794be1f7eba72fa48149?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "kush parsaniya",
      "link" : "https://stackoverflow.com/users/22395035/kush-parsaniya"
    },
    "creation_date" : 1745392359,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}