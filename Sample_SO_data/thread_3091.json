{
  "question" : {
    "question_id" : 79572583,
    "title" : "Why can&#39;t JVM trigger GC when the system is idle but can only trigger GC when object allocation fails?",
    "body" : "<p>Whether it is G1, ZGC or SGC, it seems that GC can only be triggered when the allocation of a new object fails. If I do not allocate objects, then my space will always be occupied, even if my system is not used temporarily until the next allocation fails. If GC can be triggered when the system is idle, it can greatly save the used memory space and reduce the impact of STW on application threads. So how do you define system idleness? Maybe it is the number of active threads, maybe it is the CPU usage of the current process, or it may be left to the user to define.</p>\n",
    "tags" : [ "java", "jvm", "garbage-collection" ],
    "owner" : {
      "account_id" : 16067610,
      "reputation" : 21,
      "user_id" : 11596821,
      "user_type" : "registered",
      "profile_image" : "https://lh4.googleusercontent.com/-A6QqU3cqZiU/AAAAAAAAAAI/AAAAAAAAAAA/ACHi3rdgwWQEBjLWeHntX05hlI_DourDmA/mo/s256-rj/photo.jpg",
      "display_name" : "liudaolunhuiboluo",
      "link" : "https://stackoverflow.com/users/11596821/liudaolunhuiboluo"
    },
    "is_answered" : true,
    "view_count" : 162,
    "closed_date" : 1744796665,
    "answer_count" : 1,
    "score" : -1,
    "last_activity_date" : 1744624180,
    "creation_date" : 1744616007,
    "link" : "https://stackoverflow.com/questions/79572583/why-cant-jvm-trigger-gc-when-the-system-is-idle-but-can-only-trigger-gc-when-ob",
    "closed_reason" : "Needs details or clarity"
  },
  "answers" : [ {
    "answer_id" : 79572761,
    "question_id" : 79572583,
    "body" : "<blockquote>\n<p>Why can't JVM trigger GC when the system is idle but can only trigger GC when object allocation fails?</p>\n</blockquote>\n<p>In fact ... it can!!</p>\n<p>For the G1 garbage collector, you can configure the GC to run periodically, and set a CPU load threshold for triggering.  For example, the <a href=\"https://docs.oracle.com/en/java/javase/21/gctuning/garbage-first-garbage-collector-tuning.html\" rel=\"nofollow noreferrer\">Java 21 GC tuning guide</a> lists these options for the G1 collector.</p>\n<blockquote>\n<p><code>-XX:G1PeriodicGCInterval=0</code> - The interval in ms to check whether G1 should trigger a periodic garbage collection. Set to zero to disable.</p>\n<p><code>-XX:+G1PeriodicGCInvokesConcurrent</code> - If set, periodic garbage collections trigger a concurrent marking or continue the existing collection cycle, otherwise trigger a Full GC.</p>\n<p><code>-XX:G1PeriodicGCSystemLoadThreshold=0.0</code> - Threshold for the current system load as returned by the hosts <code>getloadavg()</code> call to determine whether a periodic garbage collection should be triggered. A current system load higher than this value prevents periodic garbage collections. A value of zero indicates that this threshold check is disabled.</p>\n</blockquote>\n<p>The Java 21 documentation doesn't list equivalent options for other collectors.</p>\n",
    "score" : 4,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 47283,
      "reputation" : 723428,
      "user_id" : 139985,
      "user_type" : "registered",
      "accept_rate" : 69,
      "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
      "display_name" : "Stephen C",
      "link" : "https://stackoverflow.com/users/139985/stephen-c"
    },
    "creation_date" : 1744621961,
    "last_activity_date" : 1744624180,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140332442,
    "post_id" : 79572583,
    "body" : "In fact, there is a similar optimization in: <a href=\"https://openjdk.org/jeps/346\" rel=\"nofollow noreferrer\">openjdk.org/jeps/346</a>",
    "score" : 0,
    "owner" : {
      "account_id" : 16067610,
      "reputation" : 21,
      "user_id" : 11596821,
      "user_type" : "registered",
      "profile_image" : "https://lh4.googleusercontent.com/-A6QqU3cqZiU/AAAAAAAAAAI/AAAAAAAAAAA/ACHi3rdgwWQEBjLWeHntX05hlI_DourDmA/mo/s256-rj/photo.jpg",
      "display_name" : "liudaolunhuiboluo",
      "link" : "https://stackoverflow.com/users/11596821/liudaolunhuiboluo"
    },
    "creation_date" : 1744627333,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140332094,
    "post_id" : 79572583,
    "body" : "&quot;By releasing the memory, other services can utilize it.&quot; - Java GCs are reluctant to release memory back to the OS for other applications to request.  The rationale is that the JVM is liable to ask for the memory back again as the heap re-fills.  The resulting &quot;churning&quot; of releasing and reacquiring is likely to increase system load.  (The typical strategy that JVMs take is to only release memory / downsize the heap if it is &quot;too large&quot; after a number of successive full collections.  This can be tuned.)",
    "score" : 4,
    "owner" : {
      "account_id" : 47283,
      "reputation" : 723428,
      "user_id" : 139985,
      "user_type" : "registered",
      "accept_rate" : 69,
      "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
      "display_name" : "Stephen C",
      "link" : "https://stackoverflow.com/users/139985/stephen-c"
    },
    "creation_date" : 1744621401,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140332034,
    "post_id" : 79572583,
    "body" : "Here, I mean the idle state is not the idle of the machine itself. It could be that there are other services running on the machine. By releasing the memory, other services can utilize it. Secondly, during the idle period, the Garbage Collection (GC) process can reduce the frequency or duration of GC when the services are busy.",
    "score" : 0,
    "owner" : {
      "account_id" : 16067610,
      "reputation" : 21,
      "user_id" : 11596821,
      "user_type" : "registered",
      "profile_image" : "https://lh4.googleusercontent.com/-A6QqU3cqZiU/AAAAAAAAAAI/AAAAAAAAAAA/ACHi3rdgwWQEBjLWeHntX05hlI_DourDmA/mo/s256-rj/photo.jpg",
      "display_name" : "liudaolunhuiboluo",
      "link" : "https://stackoverflow.com/users/11596821/liudaolunhuiboluo"
    },
    "creation_date" : 1744620488,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140331923,
    "post_id" : 79572583,
    "body" : "But there is no worth in having a low memory usage. The memory chips are always there whether you use them or not. High memory usage only is a problem if memory is needed for other purposes. That’s why an idle system is usually not cleaned up; there is no need for free memory. For an idle system, that’s just a number.",
    "score" : 4,
    "owner" : {
      "account_id" : 3211603,
      "reputation" : 300981,
      "user_id" : 2711488,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
      "display_name" : "Holger",
      "link" : "https://stackoverflow.com/users/2711488/holger"
    },
    "creation_date" : 1744618616,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140331889,
    "post_id" : 79572583,
    "body" : "I&#39;m sorry that I overlooked this situation. In fact, what I intended was that although the memory was not exhausted, there were still some garbage. So, when my system was not in use or when the usage frequency was low, I could clean them up. In this way, the memory usage rate of my entire machine would be reduced.",
    "score" : 0,
    "owner" : {
      "account_id" : 16067610,
      "reputation" : 21,
      "user_id" : 11596821,
      "user_type" : "registered",
      "profile_image" : "https://lh4.googleusercontent.com/-A6QqU3cqZiU/AAAAAAAAAAI/AAAAAAAAAAA/ACHi3rdgwWQEBjLWeHntX05hlI_DourDmA/mo/s256-rj/photo.jpg",
      "display_name" : "liudaolunhuiboluo",
      "link" : "https://stackoverflow.com/users/11596821/liudaolunhuiboluo"
    },
    "creation_date" : 1744618135,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140331813,
    "post_id" : 79572583,
    "body" : "You named concurrent garbage collectors. Those collectors start their work way before the memory is exhausted. They do not wait for a failed object allocation.",
    "score" : 1,
    "owner" : {
      "account_id" : 3211603,
      "reputation" : 300981,
      "user_id" : 2711488,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
      "display_name" : "Holger",
      "link" : "https://stackoverflow.com/users/2711488/holger"
    },
    "creation_date" : 1744617191,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79572761" : [ {
      "comment_id" : 140332439,
      "post_id" : 79572761,
      "body" : "Yes, you are correct. With this optimization included in JEP 346, I might have only focused on the source code of JDK 11 before. Thank you very much.",
      "score" : 0,
      "owner" : {
        "account_id" : 16067610,
        "reputation" : 21,
        "user_id" : 11596821,
        "user_type" : "registered",
        "profile_image" : "https://lh4.googleusercontent.com/-A6QqU3cqZiU/AAAAAAAAAAI/AAAAAAAAAAA/ACHi3rdgwWQEBjLWeHntX05hlI_DourDmA/mo/s256-rj/photo.jpg",
        "display_name" : "liudaolunhuiboluo",
        "link" : "https://stackoverflow.com/users/11596821/liudaolunhuiboluo"
      },
      "creation_date" : 1744627295,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}