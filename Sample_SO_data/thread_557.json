{
  "question" : {
    "question_id" : 79793926,
    "title" : "Best way to flatmap before sending to a producer stream?",
    "body" : "<p>I have a serialized object similar to classA like below:</p>\n<pre><code>public ClassA {\n  String prop1;\n  List&lt;ClassB&gt; classBList;\n}\n\npublic ClassB {\n  String prop2;\n  List&lt;Integer&gt; indexList;\n  List&lt;Integer&gt; valueList;\n}\n\npublic ClassC{\n  String prop1;\n  String prop2;\n  Integer index;\n  Integer value;\n}\n</code></pre>\n<p>We get millions of objects of classA in a Kafka stream. I want to convert that classA into a classC list and send each of the classC back to a Kafka stream.</p>\n<p>Say I have a nobject of ClassA</p>\n<pre><code>List&lt;ClassC&gt; flattenedList = classA.getClassBList().stream()\n            .flatMap(e-&gt;{\n       List&lt;ClassC&gt; tempList = new ArrayList&lt;&gt;();\n       for(int i=0;i&lt;e.getIndexList().size();i++)\n       {\n          ClassC temp = new ClassC(classA.getProp1(),e.getProp2(),e.getIndexList().get(i),e.getValueList().get(i));\n          tempList.add(temp);\n       }\n     return tempList;\n}).collect(Collectors.toList());\n</code></pre>\n<p>Now, I have to send this list of classC to a producer. At a given point of time, there can be close to 10-20 million of classA objects which need flatmapping.  Is a stream's flatMap inefficient in this way?</p>\n<p>I want to improve the performance time of the above operation. The order of flatmapping should be in the range of millions per second (running on AWS or Azure).</p>\n<p>I'm open to custom serialization and deserialization as well. The app is a Spring application.</p>\n<p>Processing one million of the above classA objects which translate to close to 860 million classC objects (ratio of 1:860) is taking close to 1 hour [64 consumer threads and partitions on a 128Vcpu machine]. I need to improve this. Increasing the number of partitions is not helping for some reason.</p>\n",
    "tags" : [ "java", "apache-kafka", "java-stream" ],
    "owner" : {
      "account_id" : 5606695,
      "reputation" : 173,
      "user_id" : 4441019,
      "user_type" : "registered",
      "accept_rate" : 62,
      "profile_image" : "https://www.gravatar.com/avatar/143e3e91ffa7c14cf1eeca5f33ac679b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Don Woodward",
      "link" : "https://stackoverflow.com/users/4441019/don-woodward"
    },
    "is_answered" : false,
    "view_count" : 120,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1761671035,
    "creation_date" : 1760814092,
    "link" : "https://stackoverflow.com/questions/79793926/best-way-to-flatmap-before-sending-to-a-producer-stream",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79795430,
    "question_id" : 79793926,
    "body" : "<p>I'll start by saying that it is unfortunate and unclear why your <code>ClassB</code> has 2 <code>List&lt;Integer&gt;</code> when it could have instead created an intermediate object with a domain name, like <code>record IndexValue(int index, int value) {}</code>. Not only would this have taken up less space, make your code faster, and unlock more future optimizations, but you could also have written less code, as your current situation demands safety checks or for you to handle cases like the lists being different sizes.</p>\n<p>But that aside, there's another way to accomplish what you are doing. Consider this solution (assuming that you can compile and run Java &gt;=16).</p>\n<pre class=\"lang-java prettyprint-override\"><code>final List&lt;ClassC&gt; flattenedList =\n    classA\n        .getClassBList()\n        .stream()\n        .mapMulti\n        (\n            (final ClassB e, final Consumer&lt;ClassC&gt; consumer) -&gt;\n            {\n                for(int i=0;i&lt;e.getIndexList().size();i++)\n                {\n                    final ClassC temp = \n                        new ClassC\n                        (\n                            classA.getProp1(),\n                            e.getProp2(),\n                            e.getIndexList().get(i),\n                            e.getValueList().get(i)\n                        )\n                        ;\n                    consumer.accept(temp);\n                }\n            }\n        )\n        .toList() \n        ;\n</code></pre>\n<p>Instead of aggregating results into a <code>List&lt;ClassC&gt;</code> and sending down that list once all the results are calculated, I am creating instances of <code>ClassC</code>, and sending it down as each one is made -- no more waiting for a full list to be created beforehand.</p>\n<p>This is nice, as you get a healthy performance boost -- streams can process results downstream immediately as they become ready, which is especially useful if you have a <code>forEach()</code> at the end of your stream.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 14010051,
      "reputation" : 250,
      "user_id" : 10118965,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/61afd55894624ae8f6e4189b68db1f30?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "davidalayachew",
      "link" : "https://stackoverflow.com/users/10118965/davidalayachew"
    },
    "creation_date" : 1761013990,
    "last_activity_date" : 1761013990,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140823218,
    "post_id" : 79793926,
    "body" : "None of those require a schema registry",
    "score" : 0,
    "owner" : {
      "account_id" : 2671330,
      "reputation" : 192983,
      "user_id" : 2308683,
      "user_type" : "registered",
      "accept_rate" : 90,
      "profile_image" : "https://www.gravatar.com/avatar/fb8f5877d244f223b4b6d29e0afb3a4e?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "OneCricketeer",
      "link" : "https://stackoverflow.com/users/2308683/onecricketeer"
    },
    "creation_date" : 1761670894,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140804971,
    "post_id" : 79793926,
    "body" : "@SamPaul Issac, but all those options require schema registry. Want one without schema registry",
    "score" : 0,
    "owner" : {
      "account_id" : 5606695,
      "reputation" : 173,
      "user_id" : 4441019,
      "user_type" : "registered",
      "accept_rate" : 62,
      "profile_image" : "https://www.gravatar.com/avatar/143e3e91ffa7c14cf1eeca5f33ac679b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Don Woodward",
      "link" : "https://stackoverflow.com/users/4441019/don-woodward"
    },
    "creation_date" : 1760884039,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140804552,
    "post_id" : 79793926,
    "body" : "Streams themselves aren’t slow, but using flatMap with new ArrayList() and then collect(toList()) creates massive intermediate lists and forces you to wait until everything is processed. It’s usually better to stream each ClassC directly to Kafka (or in small batches) as you go and parallelize where possible. Also, switching to a compact serialization format like Avro, Protobuf or Kryo can cut CPU, memory and network overhead compared to Java’s default serialization.",
    "score" : 0,
    "owner" : {
      "account_id" : 25113755,
      "reputation" : 228,
      "user_id" : 19801993,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/Fgtbc.jpg?s=256",
      "display_name" : "SamPaul Isaac",
      "link" : "https://stackoverflow.com/users/19801993/sampaul-isaac"
    },
    "creation_date" : 1760856811,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140804183,
    "post_id" : 79793926,
    "body" : "Streams dont have to inefficient but they way you use might be. Collecting with <code>new ArrayList()</code> means you will reallocate many times with large inputs, and collecting <code>toList()</code> means you cannot start a response until you have finished processing everything.",
    "score" : 0,
    "owner" : {
      "account_id" : 5998820,
      "reputation" : 16283,
      "user_id" : 4712734,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f6e922a2cb7e2da59286f27b162aaca5?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "DuncG",
      "link" : "https://stackoverflow.com/users/4712734/duncg"
    },
    "creation_date" : 1760818591,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79795430" : [ {
      "comment_id" : 140808645,
      "post_id" : 79795430,
      "body" : "Thank you for the response @davidalayachew . The defintion of classB to answer your question comes from the input serialized message of the inbound message from the data partner. I have no control on their schema and I simply use jackson mapper  to deserialize the inbound message and get a nested structure similar like one above. Will try to implement this multimap and see how it goes .....",
      "score" : 0,
      "owner" : {
        "account_id" : 5606695,
        "reputation" : 173,
        "user_id" : 4441019,
        "user_type" : "registered",
        "accept_rate" : 62,
        "profile_image" : "https://www.gravatar.com/avatar/143e3e91ffa7c14cf1eeca5f33ac679b?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Don Woodward",
        "link" : "https://stackoverflow.com/users/4441019/don-woodward"
      },
      "creation_date" : 1761053415,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}