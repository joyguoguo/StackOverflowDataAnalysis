{
  "question" : {
    "question_id" : 79740377,
    "title" : "Wrong Android UI elements found after rotating phone when Biometric prompt is active",
    "body" : "<p>I am trying to deal with this new Landscape requirement nonsense. I also have this problem is also with a more complicated fragment but I noticed it happens with this as well and it is much easier to describe and recreate.</p>\n<p>If the phone is rotated while the system biometric prompt is active, once the authentication succeeds, the UI cannot be updated from the onAuthenticationSucceeded callback.</p>\n<p>The test is very simple, a text view, one button to show the prompt, and one button to change the text as a control. In the onAuthenticationSucceeded callback, it also changes the text.</p>\n<p>Test 1: Show the prompt and authenticate. Result: Text changes.\nTest 2: Show the prompt, rotate phone, and then authenticate. Result: The text does not change (but it does try).</p>\n<p>Looking at the text view's instance ID (by just printing the element) before doing anything, it is d8fe4ae, when it tries to update the text in either test, the ID is still d8fe4ae. After test 1 if I manually change the text, the ID is still d8fe4ae.\nHowever, if after test 2 I manually change the text, the ID is now 4200ade.</p>\n<p>So after rotation, the original text view no longer exists and has been recreated, however, the process that was active at the time does not have access to the newly created view instance and is still looking for the old one.</p>\n<p>I have tried explicitly running both with runOnUiThread, and not storing any reference to any of the view or anything else and using findViewByID every time.</p>\n",
    "tags" : [ "java", "android", "android-fragments", "android-orientation", "android-biometric-prompt" ],
    "owner" : {
      "account_id" : 11799798,
      "reputation" : 572,
      "user_id" : 8633758,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/e14e86a668116b0882a3cd15144fba00?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Notsileous",
      "link" : "https://stackoverflow.com/users/8633758/notsileous"
    },
    "is_answered" : true,
    "view_count" : 59,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1755656363,
    "creation_date" : 1755635220,
    "link" : "https://stackoverflow.com/questions/79740377/wrong-android-ui-elements-found-after-rotating-phone-when-biometric-prompt-is-ac",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79740564,
    "question_id" : 79740377,
    "body" : "<p>I think you shoud be able to solve the issue with a ViewModel.</p>\n<p>The problem is, as you have already guessed, that you're trying to modify a View that it's already been destroyed with the Activity lifecycle on the rotation event, so anything that you store or refer in that Activity gets destroyed too (also the runOnUiThread method).</p>\n<p>A ViewModel on the other hand has a lifetime on it's own, it survives the onDestroy event (if it's not the one triggered by onFinish), the point is to store every data in the ViewModel and to make every View point to it.<br />\nI've tried this simple following code and it's working fine:</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n    private MyViewModel viewmodel;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        viewmodel = new ViewModelProvider(this).get(MyViewModel.class);\n\n        EditText editText = findViewById(R.id.editTextText);\n\n        //the text is set only with the value of the viewmodel\n        viewmodel.mutableText.observe(this, textValue -&gt; {\n            if (!editText.getText().toString().equals(textValue))\n                editText.setText(textValue);\n        });\n\n        editText.addTextChangedListener(new TextWatcher() {\n            @Override\n            public void beforeTextChanged(CharSequence s, int start, int count, int after) {}\n\n            @Override\n            public void onTextChanged(CharSequence newText, int start, int before, int count) {\n                //storing the written text in the viewmodel\n                viewmodel.mutableText.setValue(newText.toString());\n            }\n\n            @Override\n            public void afterTextChanged(Editable s) {}\n        });\n\n        Button button = findViewById(R.id.login);\n        button.setOnClickListener(v -&gt; showBiometricPrompt());\n    }\n\n\n    public void showBiometricPrompt() {\n        Executor executor = ContextCompat.getMainExecutor(this);\n\n        BiometricPrompt biometricPrompt = new BiometricPrompt(this, executor, new BiometricPrompt.AuthenticationCallback() {\n            @Override\n            public void onAuthenticationSucceeded(@NonNull BiometricPrompt.AuthenticationResult result) {\n                super.onAuthenticationSucceeded(result);\n                //calling the method in the view model, it will update the text that consequently will be pushed onto the observer\n                viewmodel.onAuthenticationSuccess();\n            }\n\n            @Override\n            public void onAuthenticationError(int errorCode, @NonNull CharSequence errString) {\n                super.onAuthenticationError(errorCode, errString);\n                //same\n                viewmodel.onAuthenticationError(errString);\n            }\n        });\n\n        BiometricPrompt.PromptInfo promptInfo = new BiometricPrompt.PromptInfo.Builder()\n            .setTitle(&quot;Android is complicated!&quot;)\n            .setNegativeButtonText(&quot;Cancel&quot;)\n            .build();\n\n        biometricPrompt.authenticate(promptInfo);\n    }\n}\n</code></pre>\n<pre><code>public class MyViewModel extends ViewModel {\n\n    MutableLiveData&lt;String&gt; mutableText = new MutableLiveData&lt;&gt;(&quot;&quot;);\n\n    public void onAuthenticationError(CharSequence errString) {\n        mutableText.setValue(errString.toString()); // error message\n    }\n\n    public void onAuthenticationSuccess() {\n        mutableText.setValue(&quot;Success&quot;);\n    }\n}\n</code></pre>\n<p>Let me know if I wasn't clear or if I misunderstood something!</p>\n",
    "score" : 0,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 13234468,
      "reputation" : 16,
      "user_id" : 9556998,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/-XdUIqdMkCWA/AAAAAAAAAAI/AAAAAAAAAAA/4252rscbv5M/s256-rj/photo.jpg",
      "display_name" : "Frank",
      "link" : "https://stackoverflow.com/users/9556998/frank"
    },
    "creation_date" : 1755656363,
    "last_activity_date" : 1755656363,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79740564" : [ {
      "comment_id" : 140682367,
      "post_id" : 79740564,
      "body" : "Thanks that works. It seems like an unnecessary amount of work to fix something that should be handled better by Android.",
      "score" : 1,
      "owner" : {
        "account_id" : 11799798,
        "reputation" : 572,
        "user_id" : 8633758,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e14e86a668116b0882a3cd15144fba00?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Notsileous",
        "link" : "https://stackoverflow.com/users/8633758/notsileous"
      },
      "creation_date" : 1755786441,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}