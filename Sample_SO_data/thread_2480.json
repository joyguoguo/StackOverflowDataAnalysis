{
  "question" : {
    "question_id" : 79617955,
    "title" : "Usage of apiElements and runtimeElements configurations with Gradle java-library plugin",
    "body" : "<p>The Gradle <code>java-library</code> plugin lists various <a href=\"https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_configurations_graph\" rel=\"nofollow noreferrer\">configurations</a> that can be used to declare dependencies.</p>\n<pre><code>Table 2. Java Library plugin — configurations used by consumers\n+--------------------+------------------------------------+-------------+-------------+------------------------------------------------------------------------------------------------------------------------------+\n| Configuration name |                Role                | Consumable? | Resolvable? |                                                         Description                                                          |\n+--------------------+------------------------------------+-------------+-------------+------------------------------------------------------------------------------------------------------------------------------+\n| apiElements        | For compiling against this library | yes         | no          | This configuration is meant to be used by consumers, to retrieve all the elements necessary to compile against this library. |\n| runtimeElements    | For executing this library         | yes         | no          | This configuration is meant to be used by consumers, to retrieve all the elements necessary to run against this library.     |\n+--------------------+------------------------------------+-------------+-------------+------------------------------------------------------------------------------------------------------------------------------+\n</code></pre>\n<p>The only reference I was able to find regarding the usage of these configurations is a <a href=\"https://discuss.gradle.org/t/example-of-apielements-and-runtimeelements-with-java-library/25639\" rel=\"nofollow noreferrer\">question</a> in the Gradle forum, which received a curt response in passing.</p>\n<blockquote>\n<p><code>apiElements</code> and <code>runtimeElements</code> are not important for end users, they are mostly there for plugin authors to wire in custom Configurations.</p>\n</blockquote>\n<p>This is just as useless as the Table 2 in the docs, because neither show any real-world use cases for these configurations.</p>\n<p>Can folks here shed some light?</p>\n",
    "tags" : [ "java", "gradle", "dependencies" ],
    "owner" : {
      "account_id" : 446597,
      "reputation" : 25249,
      "user_id" : 839733,
      "user_type" : "registered",
      "accept_rate" : 69,
      "profile_image" : "https://i.sstatic.net/2s6lO.jpg?s=256",
      "display_name" : "Abhijit Sarkar",
      "link" : "https://stackoverflow.com/users/839733/abhijit-sarkar"
    },
    "is_answered" : false,
    "view_count" : 78,
    "answer_count" : 1,
    "score" : -1,
    "last_activity_date" : 1757166115,
    "creation_date" : 1747056812,
    "link" : "https://stackoverflow.com/questions/79617955/usage-of-apielements-and-runtimeelements-configurations-with-gradle-java-library",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79757589,
    "question_id" : 79617955,
    "body" : "<p>Gradle uses several levels of indirection for flexibility, but this makes things quite complex under the hood.</p>\n<p>A Gradle project may produce several 'outgoing configurations', also known as 'variants'. (I am going to use the term variant because it's less ambiguous than configuration which is used for 'incoming' configurations as well). A variant is zero or more artifacts plus zero or more dependencies, plus at least one attribute. Attributes come into play later.</p>\n<p><code>apiElements</code> is the variant that you consume to compile against this library. Its artifacts will include either the library JAR or some kind of API-only JAR. Its dependencies are compile-time dependencies of the library that should be visible to its consumers (so called <code>api</code> configuration). Implementation and runtime-only dependencies will not be included.</p>\n<p><code>runtimeElements</code> is the variant that you consume to run your code compiled against the library. It will include the library JAR itself, its implementation and runtime-only dependencies. Compile-only dependencies will not be included.</p>\n<p>You consume a variant by declaring a <em>resolvable configuration</em> that contains a dependency on the project. However, you do not specify which variant you want directly by name. Instead, you specify attributes on the resolvable configuration. These attributes specify what variants you are requesting from the dependencies. Gradle has a special attribute called Usage (org.gradle.usage) and values <code>java-api</code> meaning &quot;everything necessary to compile against this library&quot; and <code>java-runtime</code> meaning &quot;everything that has to be on classpath to run code compiled against this library&quot;</p>\n<p>So <code>apiElements</code> specifies usage value of <code>java-api</code> and <code>runtimeElements</code> specifies usage value of <code>java-runtime</code>.</p>\n<p>On the consumer side there is another level of indirection: you have configurations such as <code>api</code> and <code>implementation</code> which are not resolvable directly but instead are mere <em>dependency scopes</em>: sets of  dependencies. As such, they themselves do not specify any attributes. The resolvable configurations are e.g. <code>compileClasspath</code> and <code>runtimeClasspath</code>. <code>compileClasspath</code> extends from <code>implementation</code> (which extends from <code>api</code>) and specifies usage <code>java-api</code>. <code>runtimeClasspath</code> extends from <code>implementation</code> as well but specifies usage <code>java-runtime</code>. (They both also extend from some specific configurations, in case you need some dependency to be present only during compilation or only at run time). So while they mostly contain the same direct dependencies, they will pick different variants because of the attributes, leading to potentially different transitive dependencies and different artifacts.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 328341,
      "reputation" : 790,
      "user_id" : 651236,
      "user_type" : "registered",
      "accept_rate" : 75,
      "profile_image" : "https://www.gravatar.com/avatar/2ffe0023d1387ae89a99939f8ef55466?s=256&d=identicon&r=PG",
      "display_name" : "Sergej Koščejev",
      "link" : "https://stackoverflow.com/users/651236/sergej-ko%c5%a1%c4%8dejev"
    },
    "creation_date" : 1757166115,
    "last_activity_date" : 1757166115,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}