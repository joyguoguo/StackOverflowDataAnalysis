{
  "question" : {
    "question_id" : 79655689,
    "title" : "How to ensure file system is updated when modifying files on a USB drive",
    "body" : "<p>I've been working on an Android app that moves files on and off a connected USB drive. For moving, the basic code I'm using is:</p>\n<pre class=\"lang-kotlin prettyprint-override\"><code>file.copyRecursively(File(target, file.name), overwrite = true)\nfile.deleteRecursively()\n</code></pre>\n<p>An interesting quirk of the device I'm targeting is that it does not show the standard notification for a drive being connected which has the &quot;Eject&quot; button. I show a progress state in the UI while the files are moved (with the above code) to signal that the disk shouldn't be pulled out, but if I eject quickly after, I often end up with 0B files on the USB drive (for files being moved from the local disk to the drive). I've managed to fix this (as far as I can tell), by writing a modified version of <code>copyRecursively</code> that uses <code>fsync</code> after the copy (after hunting around and finding <a href=\"https://android-developers.googleblog.com/2010/12/saving-data-safely.html\" rel=\"nofollow noreferrer\">this post</a>):</p>\n<pre class=\"lang-kotlin prettyprint-override\"><code>this.inputStream().use { input -&gt;\n    target.outputStream().use { output -&gt;\n        input.copyTo(output, bufferSize)\n        output.flush()\n        output.fd.sync()\n   }\n}\n</code></pre>\n<p>Now the UI progress state is shown long enough that if the USB drive is pulled out immediately after the app stops showing it, the files are intact on the drive.</p>\n<p>However, after moving from testing with a FAT32 to an ExFAT USB drive, I've noticed that I regularly run into a related problem: files moved from the USB drive to the local disk are not deleted on from the USB drive. My assumption is that this will be down to a difference in how deletes are &quot;committed&quot; in ExFAT (as opposed to FAT32). To solve this I've tried:</p>\n<ul>\n<li>to <code>fsync</code> the deleted file (via a <code>FileDescriptor</code>) after deletion</li>\n<li>switching to using Java's <code>Files.move</code></li>\n<li>using <code>FileChannel#force</code> on the parent directory of the deleted file</li>\n</ul>\n<p>I've confirmed that <code>deleteRecursively</code> works as expected if I wait for ~30s before pulling the drive out or if I eject through settings (accessible by starting an<code>ACTION_MEMORY_CARD_SETTINGS</code> Intent).</p>\n<p>Is there a way using Java/Kotlin I'm missing to ensure that the disk is up to date so I can display the progress UI for the appropriate time or to force the drive's file system to update? Would this require diving into native code? Is this something only the OS's &quot;eject&quot; process (which is not available to apps on Android) can handle?</p>\n",
    "tags" : [ "java", "android", "linux", "kotlin", "filesystems" ],
    "owner" : {
      "account_id" : 116140,
      "reputation" : 4227,
      "user_id" : 304674,
      "user_type" : "registered",
      "accept_rate" : 97,
      "profile_image" : "https://www.gravatar.com/avatar/b87152c4f0f695bc98280b32e8350a99?s=256&d=identicon&r=PG",
      "display_name" : "seadowg",
      "link" : "https://stackoverflow.com/users/304674/seadowg"
    },
    "is_answered" : false,
    "view_count" : 340,
    "answer_count" : 1,
    "score" : 6,
    "last_activity_date" : 1750153073,
    "creation_date" : 1749201307,
    "link" : "https://stackoverflow.com/questions/79655689/how-to-ensure-file-system-is-updated-when-modifying-files-on-a-usb-drive",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79660114,
    "question_id" : 79655689,
    "body" : "<p>I don't think there's a way to have that information.<br />\nThe reason is, that the filesystem does not necessarily support that notion. Typically, how would a NFS drive work with that ? It would need to redirect the calls to the remote server.</p>\n<p>A problem can be, that the physical drive has internal caches that are NOT flushed on request, and therefore data is still NOT actually written after the OS made the flush request.<br />\nIn other cases, one drive is replicated into 2 others, with them being used as check, so if the data is written in the first one but not yet in the replicate, then the data is not actually stored.</p>\n<p>This notion is the base of the &quot;durability&quot; issue in databases. That's why DB system are so difficult to manage, and some system show huge performance gain â€¦ simply because they ignore it.</p>\n<p>More info : <a href=\"https://en.wikipedia.org/wiki/Durability_(database_systems)\" rel=\"nofollow noreferrer\">https://en.wikipedia.org/wiki/Durability_(database_systems)</a></p>\n",
    "score" : -2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 4751899,
      "reputation" : 182,
      "user_id" : 3841737,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/ce20bf22d2c5b85420f935226bacf571?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "guigolum",
      "link" : "https://stackoverflow.com/users/3841737/guigolum"
    },
    "creation_date" : 1749545813,
    "last_activity_date" : 1749545813,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140517288,
    "post_id" : 79655689,
    "body" : "One does not simply <code>umount</code> a busy drive. There are <a href=\"https://stackoverflow.com/questions/7878707/how-to-unmount-a-busy-device\">ways around this</a>. I would expect clean behavior, if you do <code>sync &amp;&amp; umount</code> before unplugging the drive.",
    "score" : 1,
    "owner" : {
      "account_id" : 28516977,
      "reputation" : 2087,
      "user_id" : 21826195,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/8MOtvndT.jpg?s=256",
      "display_name" : "Mo_",
      "link" : "https://stackoverflow.com/users/21826195/mo"
    },
    "creation_date" : 1750078275,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140508937,
    "post_id" : 79655689,
    "body" : "Also, I was pretty sure that calling <code>umount</code> from an app wouldn&#39;t work, but I gave it a try anyway (using <code>Runtime#exec</code>). I get non-zero exit code and the drive remains mounted.",
    "score" : 0,
    "owner" : {
      "account_id" : 116140,
      "reputation" : 4227,
      "user_id" : 304674,
      "user_type" : "registered",
      "accept_rate" : 97,
      "profile_image" : "https://www.gravatar.com/avatar/b87152c4f0f695bc98280b32e8350a99?s=256&d=identicon&r=PG",
      "display_name" : "seadowg",
      "link" : "https://stackoverflow.com/users/304674/seadowg"
    },
    "creation_date" : 1749739153,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140508898,
    "post_id" : 79655689,
    "body" : "I imagine what I mean by &quot;eject&quot; (from the Android UI) here is just exactly or something similar to <code>umount</code> under the hood. Every operating system I&#39;ve used refers to this as &quot;eject&quot; in the GUI (even though I get that that&#39;s not physically what&#39;s happening). I&#39;ll update the question so that&#39;s hopefully clearer.",
    "score" : 0,
    "owner" : {
      "account_id" : 116140,
      "reputation" : 4227,
      "user_id" : 304674,
      "user_type" : "registered",
      "accept_rate" : 97,
      "profile_image" : "https://www.gravatar.com/avatar/b87152c4f0f695bc98280b32e8350a99?s=256&d=identicon&r=PG",
      "display_name" : "seadowg",
      "link" : "https://stackoverflow.com/users/304674/seadowg"
    },
    "creation_date" : 1749738097,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140508790,
    "post_id" : 79655689,
    "body" : "I would think that not eject but <code>umount</code> is critical to be done before an external drive is removed. Eject could just additionally trigger a physical ejection (e.g. for a floppy disk or CD ROM drive or similar, but that&#39;s not relevant here). <code>umount</code> is available in Android (as CLI program, don&#39;t know if you can access it via an App)",
    "score" : 0,
    "owner" : {
      "account_id" : 3391382,
      "reputation" : 5360,
      "user_id" : 2846138,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/2sp68.png?s=256",
      "display_name" : "cyberbrain",
      "link" : "https://stackoverflow.com/users/2846138/cyberbrain"
    },
    "creation_date" : 1749735818,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79660114" : [ {
      "comment_id" : 140503163,
      "post_id" : 79660114,
      "body" : "Right. I&#39;m asking if there&#39;s anything I can do from an Android app to make sure the OS has done as much as it can to ensure a delete operation has got to disk to account for the user not having access to the normal Android &quot;eject&quot; workflow.",
      "score" : 0,
      "owner" : {
        "account_id" : 116140,
        "reputation" : 4227,
        "user_id" : 304674,
        "user_type" : "registered",
        "accept_rate" : 97,
        "profile_image" : "https://www.gravatar.com/avatar/b87152c4f0f695bc98280b32e8350a99?s=256&d=identicon&r=PG",
        "display_name" : "seadowg",
        "link" : "https://stackoverflow.com/users/304674/seadowg"
      },
      "creation_date" : 1749572538,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140503055,
      "post_id" : 79660114,
      "body" : "@seadowg yes, the OS can flush its own buffer. Does not mean the drive has actually flushed its own. I guess USB devices don&#39;t have intermediate caches ? Makes sense since they can access data directly.",
      "score" : 0,
      "owner" : {
        "account_id" : 4751899,
        "reputation" : 182,
        "user_id" : 3841737,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/ce20bf22d2c5b85420f935226bacf571?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "guigolum",
        "link" : "https://stackoverflow.com/users/3841737/guigolum"
      },
      "creation_date" : 1749570572,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140502439,
      "post_id" : 79660114,
      "body" : "Just to be clear when I say the OS must have a way to &quot;commit changes to disk&quot;, I mean at least flush its own buffer.",
      "score" : 0,
      "owner" : {
        "account_id" : 116140,
        "reputation" : 4227,
        "user_id" : 304674,
        "user_type" : "registered",
        "accept_rate" : 97,
        "profile_image" : "https://www.gravatar.com/avatar/b87152c4f0f695bc98280b32e8350a99?s=256&d=identicon&r=PG",
        "display_name" : "seadowg",
        "link" : "https://stackoverflow.com/users/304674/seadowg"
      },
      "creation_date" : 1749560665,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140502239,
      "post_id" : 79660114,
      "body" : "There must be a way for the OS itself to commit changes to disk when going through the &quot;eject&quot; flow though right?",
      "score" : 1,
      "owner" : {
        "account_id" : 116140,
        "reputation" : 4227,
        "user_id" : 304674,
        "user_type" : "registered",
        "accept_rate" : 97,
        "profile_image" : "https://www.gravatar.com/avatar/b87152c4f0f695bc98280b32e8350a99?s=256&d=identicon&r=PG",
        "display_name" : "seadowg",
        "link" : "https://stackoverflow.com/users/304674/seadowg"
      },
      "creation_date" : 1749557023,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}