{
  "question" : {
    "question_id" : 79840826,
    "title" : "Encrypt data on client side using cryptoJs and decrypt on server side SFCC (Java) Cipher",
    "body" : "<p>My project requires several storefront network requests to be encrypted and sent over, so thats its not interpreted by any outsider and pose a threat to the system or user. Typically sensitive or customer specific data shouldn`t be sent over as clear text.</p>\n<p>My request occurs through front end (client side) ajax and processed at the back end. The back end logic involves submitting the received data to an external API. But since the external API supports data only in clear text format, the data has to be encrypted at client side, consecutively received and decrypted back to clear text froamt at the server side. Thereafter forwarding it to the API from server side itself.</p>\n<p>My back end is based out SFCC (Salesforce Commerce Cloud built on Java having SFCC API`s for server side logics) and I need suitable API`s do the job communicating betwee client and server side.</p>\n",
    "tags" : [ "java", "encryption", "cryptojs", "salesforce-commerce-cloud", "cleartext" ],
    "owner" : {
      "account_id" : 5114104,
      "reputation" : 662,
      "user_id" : 4099837,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/gbdCn.jpg?s=256",
      "display_name" : "techloris_109",
      "link" : "https://stackoverflow.com/users/4099837/techloris-109"
    },
    "is_answered" : false,
    "view_count" : 82,
    "answer_count" : 2,
    "score" : 0,
    "last_activity_date" : 1765278855,
    "creation_date" : 1765189496,
    "link" : "https://stackoverflow.com/questions/79840826/encrypt-data-on-client-side-using-cryptojs-and-decrypt-on-server-side-sfcc-java",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79841852,
    "question_id" : 79840826,
    "body" : "<p>you can’t securely encrypt on the client if the key lives in the frontend. Anyone can open DevTools, grab your key, and decrypt or forge whatever they want. That said, if you just need to obfuscate data in transit (and you’re already on HTTPS—right?), here’s how to make CryptoJS and SFCC play nice:<br />\nKey gotchas:</p>\n<p>SFCC uses Rhino, so no javax.crypto.Cipher—stick to dw.crypto.</p>\n<p>Key must be 32 bytes (AES-256). IV must be 16 bytes.</p>\n<p>Always use HTTPS—this &quot;encryption&quot; is useless without it.</p>\n<p>Never trust decrypted data. Sanitize like it’s user input (because it is). Use <a href=\"https://data-encoder.com/blog/\" rel=\"nofollow noreferrer\">advanced encryption software</a> patterns.</p>\n<p>Honestly, if you’re not doing this just for compliance theater, rethink the flow. Real security happens server-side. But if you gotta ship it—this’ll work.</p>\n<p>Frontend (CryptoJS) and SFCC Backend (Rhino JS – not Java!):</p>\n<pre><code>const key = CryptoJS.enc.Utf8.parse('32-byte-long-hardcoded-key-here'); // ← 32 chars, no excuses\nconst iv = CryptoJS.lib.WordArray.random(16);\n\nconst encrypted = CryptoJS.AES.encrypt(JSON.stringify(payload), key, {\n  iv: iv,\n  mode: CryptoJS.mode.CBC,\n  padding: CryptoJS.pad.Pkcs7\n});\n\n// Send BOTH\nfetch('/your-endpoint', {\n  method: 'POST',\n  body: JSON.stringify({\n    data: encrypted.toString(),\n    iv: CryptoJS.enc.Base64.stringify(iv)\n  })\n});\n\nSFCC Backend (Rhino JS – not Java!):\n</code></pre>\n<pre><code>var Cipher = require('dw/crypto/Cipher');\nvar Encoding = require('dw/util/Encoding');\n\nvar key = '32-byte-long-hardcoded-key-here';\nvar encryptedData = req.form.data;\nvar iv = Encoding.toBytes(Encoding.fromBase64(req.form.iv)); // IV from client\n\nvar decrypted = Cipher.decrypt(\n  encryptedData,\n  Cipher.getCipher(Cipher.CIPHER_AES_256_CBC, key, iv)\n);\n\n// decrypted.text is your original payload\n\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 44955021,
      "reputation" : 1,
      "user_id" : 32022835,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/835849134d6e852c313ff63c66088507?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Gerdona Mendez",
      "link" : "https://stackoverflow.com/users/32022835/gerdona-mendez"
    },
    "creation_date" : 1765278855,
    "last_activity_date" : 1765278855,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79840827,
    "question_id" : 79840826,
    "body" : "<h1>Snippet on encryption using CryptoJs and decryption at SFCC</h1>\n<p>Encrypt at client side using CryptJS node modules. Install this module and require on front end</p>\n<p>*In Javascript padding uses default Pkcs7 as similar in Java which is Pkcs5 and mode is ECB</p>\n<pre class=\"lang-js prettyprint-override\"><code>var data = 'Hello SFCC !';\nvar key = CryptoJS.enc.Utf8.parse(1234567890123456); // 16 bit\nvar iv = CryptoJS.enc.Utf8.parse('6543210987654321'); // 16 bit\nvar encrypted = CryptoJS.AES.encrypt(data, key, {\n    iv: iv,\n    mode: CryptoJS.mode.CBC,\n    padding: CryptoJS.pad.Pkcs7\n});\nvar encryptedCardDetails = encrypted.toString();\nconst CryptoJS = require('crypto-js');\n</code></pre>\n<p>Decrypt at SFCC server side</p>\n<pre class=\"lang-js prettyprint-override\"><code>var encryptedStrubg = data; // data received from client side through ajax request\n\nvar Encoding = require('dw/crypto/Encoding');\nvar Bytes = require('dw/util/Bytes');\nvar Cipher = require('dw/crypto/Cipher');\nvar ALGORITHM = 'AES/CBC/PKCS5Padding';\nvar key = '1234567890123456';\nvar iv = keyStr.substr(0, 16);\nvar key = Encoding.toBase64(new Bytes(key, 'UTF-8'));\nvar IV = Encoding.toBase64(new Bytes(iv, 'UTF-8'));\nvar ciph = new Cipher();\ndecryptedString = ciph.decrypt(encryptedStrubg, Encoding.toBase64(new Bytes(key, 'UTF8')), ALGORITHM, IV, 0);\n</code></pre>\n",
    "score" : -1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 5114104,
      "reputation" : 662,
      "user_id" : 4099837,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/gbdCn.jpg?s=256",
      "display_name" : "techloris_109",
      "link" : "https://stackoverflow.com/users/4099837/techloris-109"
    },
    "creation_date" : 1765189496,
    "last_activity_date" : 1765208424,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140892990,
    "post_id" : 79840826,
    "body" : "Really, just use TLS (Https). Any reasonable API should support it. If you really must, maybe instead of creating a custom communication, have a look at the <code>jose</code> npm library creating a <code>JWE</code> encrypted message",
    "score" : 0,
    "owner" : {
      "account_id" : 1809323,
      "reputation" : 12249,
      "user_id" : 1645712,
      "user_type" : "registered",
      "accept_rate" : 73,
      "profile_image" : "https://www.gravatar.com/avatar/48781792c1fb7d61086b4fb612938c13?s=256&d=identicon&r=PG",
      "display_name" : "gusto2",
      "link" : "https://stackoverflow.com/users/1645712/gusto2"
    },
    "creation_date" : 1765214152,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140892912,
    "post_id" : 79840826,
    "body" : "This is more a consultancy question than a concise, KB type of question. Things I would ask is about TLS, why end-to-end encryption is needed, what kind of key management should be performed etc. The API is honestly the least important thing and would depend on the other components.",
    "score" : 1,
    "owner" : {
      "account_id" : 288696,
      "reputation" : 94628,
      "user_id" : 589259,
      "user_type" : "registered",
      "accept_rate" : 82,
      "profile_image" : "https://i.sstatic.net/vJbKg.jpg?s=256",
      "display_name" : "Maarten Bodewes",
      "link" : "https://stackoverflow.com/users/589259/maarten-bodewes"
    },
    "creation_date" : 1765210891,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79840827" : [ {
      "comment_id" : 140892939,
      "post_id" : 79840827,
      "body" : "CryptoJS has been <a href=\"https://github.com/brix/crypto-js/blob/4.2.0/README.md#discontinued\" rel=\"nofollow noreferrer\">discontinued</a> for more than two years. Both browsers and NodeJS have native cryptographic APIs that should be used nowadays (the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API\" rel=\"nofollow noreferrer\">WebCrypto API</a> for browsers/NodeJS or the <a href=\"https://nodejs.org/docs/latest-v25.x/api/crypto.html\" rel=\"nofollow noreferrer\"><i>crypto</i></a>  module for NodeJS).",
      "score" : 0,
      "owner" : {
        "account_id" : 12359353,
        "reputation" : 50593,
        "user_id" : 9014097,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/Y9EVM.jpg?s=256",
        "display_name" : "Topaco",
        "link" : "https://stackoverflow.com/users/9014097/topaco"
      },
      "creation_date" : 1765211904,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}