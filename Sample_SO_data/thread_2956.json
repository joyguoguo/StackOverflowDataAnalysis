{
  "question" : {
    "question_id" : 79582697,
    "title" : "How do I avoid Jetty 12 to leak the last message in an active web-socket?",
    "body" : "<p>The last message sent by the server is kept in memory by the deflater object until a new message is sent or the web-socket is closed.</p>\n<p>The same issue is not present when the &quot;permessage-deflate&quot; is not active.</p>\n<p>I managed to reproduce it modifying this simple example:</p>\n<p><a href=\"https://github.com/jetty/jetty-examples/blob/12.0.x/embedded/ee10-websocket-jetty-api/src/main/java/examples/annotated/EchoServer.java\" rel=\"nofollow noreferrer\">https://github.com/jetty/jetty-examples/blob/12.0.x/embedded/ee10-websocket-jetty-api/src/main/java/examples/annotated/EchoServer.java</a></p>\n<p>First, let's return a big message to amplified the effect. Here it is returning 10Mbytes of random data (EchoWebSocket.java).</p>\n<pre><code>@OnWebSocketMessage\npublic void onWebSocketText(String message)\n{\n    LOG.info(&quot;Echoing back text message [{}]&quot;, message);\n    byte[] b = new byte[10000000];\n    for (int i = 0; i &lt; b.length; i++) {\n        b[i] = (byte)rand.nextInt(10);\n    }\n    this.session.sendText(new String(b), Callback.NOOP);\n}\n</code></pre>\n<p>And to allow a bit more time to check the result I increased the time-out to 10 minutes:</p>\n<pre><code>@OnWebSocketOpen\npublic void onWebSocketOpen(Session session)\n{\n    this.session = session;\n    this.session.setIdleTimeout(Duration.of(10, ChronoUnit.MINUTES));\n    LOG.info(&quot;WebSocket Open: {}&quot;, session);\n    this.session.sendText(&quot;You are now connected to &quot; + this.getClass().getName(), Callback.NOOP);\n}\n</code></pre>\n<p>Then, I am limiting the memory pool to 50Mb. In EchoServer.java I added:</p>\n<pre><code> public static Server newServer(int port) {\n     Server server = new Server(port);\n     server.addBean(new ArrayByteBufferPool(0, -1, -1, Integer.MAX_VALUE, 50_000_000, 50_000_000));\n     ...\n</code></pre>\n<p>I opened,7 web-sockets using postman and I took a memory dump of the server, this is the Memory Analyzer report:</p>\n<p><a href=\"https://i.sstatic.net/MBfLNzGp.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/MBfLNzGp.png\" alt=\"enter image description here\" /></a></p>\n<p>Selecting one of the byte array and getting the incoming reference we have:</p>\n<p><a href=\"https://i.sstatic.net/m9EE2kDs.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/m9EE2kDs.png\" alt=\"enter image description here\" /></a></p>\n<p>The same byte[] is referenced by two distinct HeapByteBuffer, one is the payload of the frame and the other is inside the deflater object.</p>\n<p>To verify my suspicious, I run the same test, but I configured the server to ignore the &quot;permessage-deflate&quot; header (EchoServer.java):</p>\n<pre><code>    JettyWebSocketServletContainerInitializer.configure(context, (c, container) -&gt;\n    {\n        WebSocketComponents components = WebSocketServerComponents.getWebSocketComponents(context);\n        components.getExtensionRegistry().unregister(&quot;permessage-deflate&quot;);\n    });\n</code></pre>\n<p>I ran the same test and took another memory dump, now the 10 Mbyte byte arrays are gone:</p>\n<p><a href=\"https://i.sstatic.net/GwZZrvQE.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/GwZZrvQE.png\" alt=\"enter image description here\" /></a></p>\n<p>The deflater input is only set when a new message is publish on the same web-socket or when the web-socket is closed.</p>\n<p>I tried to tweak the setting of the deflater pool but with no difference.</p>\n<p>I believe the issue is present in other version of Jetty (I have experienced it on 9.5x and 11).</p>\n<p>And finally, the question:</p>\n<ul>\n<li><strong>is there a way to force the release of the memory?</strong> We use Jetty for an application where 1000+ web-sockets are not uncommon. Some of the message are of significant size putting quite a lot of stress on the overall memory consumption. Disabled the compression will incur in significant increase of network traffic and we will try to avoid it.</li>\n</ul>\n<p><strong>UPDATE</strong></p>\n<p>I raised the issue with Jetty <a href=\"https://github.com/jetty/jetty.project/issues/13029\" rel=\"nofollow noreferrer\">https://github.com/jetty/jetty.project/issues/13029</a> and it has been fixed and committed in 12.0.20. I don't think there is any plan to merge the fix in any of the previous versions.</p>\n",
    "tags" : [ "java", "jetty-9", "jetty-12", "jetty-11" ],
    "owner" : {
      "account_id" : 238931,
      "reputation" : 3978,
      "user_id" : 508175,
      "user_type" : "registered",
      "accept_rate" : 89,
      "profile_image" : "https://www.gravatar.com/avatar/301e56d2d8c6f65bcfb6212df464685e?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Alessandro Teruzzi",
      "link" : "https://stackoverflow.com/users/508175/alessandro-teruzzi"
    },
    "is_answered" : false,
    "view_count" : 84,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1745826741,
    "creation_date" : 1745086947,
    "link" : "https://stackoverflow.com/questions/79582697/how-do-i-avoid-jetty-12-to-leak-the-last-message-in-an-active-web-socket",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140353071,
    "post_id" : 79582697,
    "body" : "@aled Yes, the buffers stays in memory until the web-socket is close or a new message is sent to the client on the same web-socket. We experience this issue in our production application and I have analyzed dozen of memory dump showing the same behavior.",
    "score" : 0,
    "owner" : {
      "account_id" : 238931,
      "reputation" : 3978,
      "user_id" : 508175,
      "user_type" : "registered",
      "accept_rate" : 89,
      "profile_image" : "https://www.gravatar.com/avatar/301e56d2d8c6f65bcfb6212df464685e?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Alessandro Teruzzi",
      "link" : "https://stackoverflow.com/users/508175/alessandro-teruzzi"
    },
    "creation_date" : 1745183184,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140352865,
    "post_id" : 79582697,
    "body" : "After you finish a stress test, are there multiple buffers remaining in memory?",
    "score" : 0,
    "owner" : {
      "account_id" : 372682,
      "reputation" : 26512,
      "user_id" : 721855,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/vZiox.png?s=256",
      "display_name" : "aled",
      "link" : "https://stackoverflow.com/users/721855/aled"
    },
    "creation_date" : 1745175975,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140352809,
    "post_id" : 79582697,
    "body" : "@aled when the last frame of the response is sent, the deflater input should be reset to release the underlying memory either resetting the input or calling end() method.",
    "score" : 0,
    "owner" : {
      "account_id" : 238931,
      "reputation" : 3978,
      "user_id" : 508175,
      "user_type" : "registered",
      "accept_rate" : 89,
      "profile_image" : "https://www.gravatar.com/avatar/301e56d2d8c6f65bcfb6212df464685e?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Alessandro Teruzzi",
      "link" : "https://stackoverflow.com/users/508175/alessandro-teruzzi"
    },
    "creation_date" : 1745174106,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140352792,
    "post_id" : 79582697,
    "body" : "@aled Ultimately, because the memory analyzer is showing the byte[] to be an alive object. At that point in time, there is no reason to keep the array in memory, because the message has already been sent over the wire. When the deflater is not part of the equation, the byte[] is correctly released. The deflater is only released when the web-socket is closed. The input of the deflater is set inside onFrame:                 PerMessageDeflateExtension.this.getDeflater().setInput(frame&zwnj;&#8203;.getPayload().slice(&zwnj;&#8203;)); slice is creating a new HeapByteArray which contains a reference of the original array",
    "score" : 0,
    "owner" : {
      "account_id" : 238931,
      "reputation" : 3978,
      "user_id" : 508175,
      "user_type" : "registered",
      "accept_rate" : 89,
      "profile_image" : "https://www.gravatar.com/avatar/301e56d2d8c6f65bcfb6212df464685e?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Alessandro Teruzzi",
      "link" : "https://stackoverflow.com/users/508175/alessandro-teruzzi"
    },
    "creation_date" : 1745173689,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140352260,
    "post_id" : 79582697,
    "body" : "Why do you think the buffer memory is leaked?",
    "score" : 0,
    "owner" : {
      "account_id" : 372682,
      "reputation" : 26512,
      "user_id" : 721855,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/vZiox.png?s=256",
      "display_name" : "aled",
      "link" : "https://stackoverflow.com/users/721855/aled"
    },
    "creation_date" : 1745153885,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}