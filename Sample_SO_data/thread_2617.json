{
  "question" : {
    "question_id" : 79608645,
    "title" : "Spring Authorization Server ~ How to unregister default AuthenticationProviders",
    "body" : "<p>I am trying to implement OAuth2 authentication for an App in a Spring Boot backend using Spring Authorization Server. My problem is that I have custom logic that uses its own AuthenticationProviders, yet Spring Authentication Server automatically adds a whole bunch of default providers which can't handle my custom logic, and then crash. What I want is to figure out how I can get rid of the default AuthenticationProviders so that no crashes will occur.</p>\n<p>Now, this is very abstract, so here's the concrete thing. In my own refresh token AuthenticationProvider, I have a bit that checks if the device_id (a custom field we use) matches the saved device_id and throws an OAuth2AuthenticationException if it doesn't.</p>\n<pre><code>        if (!providedDeviceId.equals(storedDeviceId)) {\n            String errorMessage = &quot;Provided device ID '&quot; + providedDeviceId\n                + &quot;' did not match stored device ID '&quot; + storedDeviceId\n                + &quot;' for refresh token '&quot; + refreshTokenValue + &quot;'&quot;;\n            log.warn(errorMessage);\n            throw new OAuth2AuthenticationException(\n                new OAuth2Error(OAuth2ErrorCodes.INVALID_GRANT, errorMessage, null)\n            );\n        }\n</code></pre>\n<p>That logic works just fine. However, in the framework class <code>org.springframework.security.authentication.ProviderManager</code>, the authentication method works like this:</p>\n<pre><code>    @Override\n    public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n        [...]\n        for (AuthenticationProvider provider : getProviders()) {\n            if (!provider.supports(toTest)) {\n                continue;\n            }\n            [...]\n            try {\n                result = provider.authenticate(authentication);\n                if (result != null) {\n                    copyDetails(authentication, result);\n                    break;\n                }\n            }\n            catch (AccountStatusException | InternalAuthenticationServiceException ex) {\n                prepareException(ex, authentication);\n                // SEC-546: Avoid polling additional providers if auth failure is due to\n                // invalid account status\n                throw ex;\n            }\n            catch (AuthenticationException ex) {\n                lastException = ex;\n            }\n        }\n</code></pre>\n<p>That is, it iterates over all AuthenticationProviders that support an authentication type, and only breaks if it succeeds, or an AccountStatusException or InternalAuthenticationServiceException is thrown. Note that it does not break on an AuthenticationException, which is how I would have expected it to work. Instead, it continues iterating over the remaining AuthenticationProviders that support an authentication type. And that leads me to my problem:</p>\n<p><code>getProviders()</code> returns not one but two providers that nominally support OAuth2RefreshTokenAuthenticationToken: My own custom <code>OAuth2RefreshTokenAuthProvider</code>, and the default <code>org.springframework.security.oauth2.server.authorization.authentication.OAuth2RefreshTokenAuthenticationProvider</code>. On the plus side, my own provider is called first and correctly throws its OAuth2AuthenticationException if the device_id mismatches. Unfortunately, however, the Spring OAuth2RefreshTokenAuthenticationProvider is called next, and runs into this error:</p>\n<pre><code>java.lang.IllegalArgumentException: value cannot be null\n    at org.springframework.util.Assert.notNull(Assert.java:181)\n    at org.springframework.security.oauth2.server.authorization.token.OAuth2TokenContext$AbstractBuilder.put(OAuth2TokenContext.java:219)\n    at org.springframework.security.oauth2.server.authorization.token.OAuth2TokenContext$AbstractBuilder.principal(OAuth2TokenContext.java:152)\n    at org.springframework.security.oauth2.server.authorization.authentication.OAuth2RefreshTokenAuthenticationProvider.authenticate(OAuth2RefreshTokenAuthenticationProvider.java:171)\n    at org.springframework.security.authentication.ProviderManager.authenticate(ProviderManager.java:182)\n    at org.springframework.security.authentication.ObservationAuthenticationManager.lambda$authenticate$1(ObservationAuthenticationManager.java:54)\n    at io.micrometer.observation.Observation.observe(Observation.java:564)\n    at org.springframework.security.authentication.ObservationAuthenticationManager.authenticate(ObservationAuthenticationManager.java:53)\n</code></pre>\n<p>I could get into detail as to why this Assert.notNull fails. The short version is that the Spring OAuth2RefreshTokenAuthenticationProvider can't check the device_id because it's a custom field, and that causes issues further down the line. But really, that is not the point. The main issue in my eyes here is that the Spring OAuth2RefreshTokenAuthenticationProvider is called at all. What I want is that my custom OAuth2RefreshTokenAuthProvider is called instead, and not in addition to the default provider, since that's what I wrote it for.</p>\n<p>And that wraps us back to my initial question: How can I configure Spring Authorization Server to not add the default providers?</p>\n<hr />\n<h1>Addendum</h1>\n<p>My OAuth2Config looks like this:</p>\n<pre><code>@Configuration\npublic class OAuth2Config {\n    @Bean\n    public SecurityFilterChain oAuth2FilterChain(\n        HttpSecurity http,\n        OAuth2PasswordGrantAuthProvider passwordAuthProvider,\n        OAuth2RefreshTokenAuthProvider refreshTokenAuthProvider,\n        PasswordGrantAuthenticationConverter passwordGrantAuthenticationConverter,\n        RefreshTokenAuthenticationConverter refreshTokenAuthenticationConverter\n    ) throws Exception {\n        OAuth2AuthorizationServerConfigurer configurer =\n            new OAuth2AuthorizationServerConfigurer();\n\n        configurer.tokenEndpoint(token -&gt; token\n            .accessTokenRequestConverter(\n                new DelegatingAuthenticationConverter(List.of(\n                    passwordGrantAuthenticationConverter,\n                    refreshTokenAuthenticationConverter\n                )))\n            .authenticationProvider(passwordAuthProvider)\n            .authenticationProvider(refreshTokenAuthProvider)\n        );\n\n        http\n            .securityMatcher(&quot;/oauth2/**&quot;)\n            .with(configurer, (authorizationServer) -&gt;\n                authorizationServer.oidc(Customizer.withDefaults()))\n            .authorizeHttpRequests(\n                auth -&gt; auth\n                    .requestMatchers(&quot;/oauth2/token&quot;).permitAll()\n                    .anyRequest().authenticated())\n            .csrf(csrf -&gt; csrf.ignoringRequestMatchers(&quot;/oauth2/**&quot;));\n\n        return http.build();\n    }\n\n    @Bean\n    public RegisteredClientRepository registeredClientRepository(\n        OAuth2Properties oAuth2Properties\n    ) {\n        TokenSettings tokenSettings = TokenSettings.builder()\n            .accessTokenTimeToLive(Duration.ofMinutes(\n                oAuth2Properties.getFirstScope().getAccessTokenTimeToLiveInMinutes()))\n            .refreshTokenTimeToLive(Duration.ofDays(\n                oAuth2Properties.getFirstScope().getRefreshTokenTimeToLiveInDays()))\n            .reuseRefreshTokens(false)\n            .build();\n        RegisteredClient firstClient = RegisteredClient.withId(\n                UUID.randomUUID().toString())\n            .clientId(MyOAuth2.FIRST_CLIENT_ID)\n            .clientAuthenticationMethod(ClientAuthenticationMethod.NONE)\n            .authorizationGrantType(AuthorizationGrantType.PASSWORD)\n            .authorizationGrantType(AuthorizationGrantType.REFRESH_TOKEN)\n            .scope(MyOAuth2.FIRST_SCOPE)\n            .tokenSettings(tokenSettings)\n            .build();\n        return new InMemoryRegisteredClientRepository(firstClient);\n    }\n\n    @Bean\n    public OAuth2AuthorizationService authorizationService(\n        JdbcTemplate jdbcTemplate,\n        RegisteredClientRepository registeredClientRepository\n    ) {\n        return new JdbcOAuth2AuthorizationService(\n            jdbcTemplate, registeredClientRepository);\n    }\n}\n</code></pre>\n",
    "tags" : [ "java", "spring", "spring-boot", "oauth-2.0", "spring-authorization-server" ],
    "owner" : {
      "account_id" : 12296207,
      "reputation" : 2550,
      "user_id" : 8971773,
      "user_type" : "registered",
      "accept_rate" : 25,
      "profile_image" : "https://i.sstatic.net/tFcJU.png?s=256",
      "display_name" : "Kira Resari",
      "link" : "https://stackoverflow.com/users/8971773/kira-resari"
    },
    "is_answered" : true,
    "view_count" : 117,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1747979414,
    "creation_date" : 1746532384,
    "link" : "https://stackoverflow.com/questions/79608645/spring-authorization-server-how-to-unregister-default-authenticationproviders",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79634902,
    "question_id" : 79608645,
    "body" : "<p>Thanks to the comment of @ChinHuang I was able to figure out how to do it. Here is how the `OAuth2Config` needs to be configured in order to exclude a default provider:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Configuration\npublic class OAuth2Config {\n    @Bean\n    public SecurityFilterChain oAuth2FilterChain(\n        HttpSecurity http,\n        OAuth2PasswordGrantAuthProvider passwordAuthProvider,\n        OAuth2RefreshTokenAuthProvider refreshTokenAuthProvider,\n        PasswordGrantAuthenticationConverter passwordGrantAuthenticationConverter,\n        RefreshTokenAuthenticationConverter refreshTokenAuthenticationConverter\n    ) throws Exception {\n        OAuth2AuthorizationServerConfigurer configurer = new OAuth2AuthorizationServerConfigurer();\n\n        configurer.tokenEndpoint(token -&gt; token\n            .accessTokenRequestConverter(\n                    new DelegatingAuthenticationConverter(List.of(\n                            passwordGrantAuthenticationConverter,\n                            refreshTokenAuthenticationConverter\n                    )))\n            .authenticationProviders(providers -&gt; {\n                providers.removeIf(OAuth2RefreshTokenAuthenticationProvider.class::isInstance);\n                providers.add(passwordAuthProvider);\n                providers.add(refreshTokenAuthProvider);\n            })\n        );\n\n        http.securityMatcher(&quot;/oauth2/**&quot;)\n            .with(configurer, (authorizationServer) -&gt;authorizationServer.oidc(Customizer.withDefaults()))\n            .authorizeHttpRequests(auth -&gt; auth\n                .requestMatchers(&quot;/oauth2/token&quot;).permitAll()\n                .anyRequest().authenticated())\n            .csrf(csrf -&gt; csrf.ignoringRequestMatchers(&quot;/oauth2/**&quot;));\n\n        return http.build();\n    }\n}\n</code></pre>\n<p>The key part is the <code>providers.removeIf</code> inside the <code>authenticationProviders</code>.</p>\n",
    "score" : 0,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 12296207,
      "reputation" : 2550,
      "user_id" : 8971773,
      "user_type" : "registered",
      "accept_rate" : 25,
      "profile_image" : "https://i.sstatic.net/tFcJU.png?s=256",
      "display_name" : "Kira Resari",
      "link" : "https://stackoverflow.com/users/8971773/kira-resari"
    },
    "creation_date" : 1747979097,
    "last_activity_date" : 1747979414,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140438365,
    "post_id" : 79608645,
    "body" : "In OAuth2Config, invoke <a href=\"https://docs.spring.io/spring-authorization-server/docs/current/api/org/springframework/security/oauth2/server/authorization/config/annotation/web/configurers/OAuth2TokenEndpointConfigurer.html#authenticationProviders(java.util.function.Consumer)\" rel=\"nofollow noreferrer\"><code>.authenticationProviders(</code></a> and remove the problematic AuthenticationProvider from the list of AuthenticationProvider&#39;s passed to the consumer.",
    "score" : 1,
    "owner" : {
      "account_id" : 23128,
      "reputation" : 14130,
      "user_id" : 57719,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/m2xJ2.png?s=256",
      "display_name" : "Chin Huang",
      "link" : "https://stackoverflow.com/users/57719/chin-huang"
    },
    "creation_date" : 1747641176,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140438288,
    "post_id" : 79608645,
    "body" : "@ChinHuang the problem there is that these exceptions don&#39;t enable me to throw an <code>OAuth2AuthenticationException</code>, which contains an <code>OAuth2Error</code> that I can pass the <code>OAuth2ErrorCodes.INVALID_GRANT</code> to. And the end result will then be that the request with a wrong device ID fails with 401 and &quot;invalid_client&quot; instead of 400 and &quot;invalid_token&quot; as it should, according to the OAuth2 specification",
    "score" : 0,
    "owner" : {
      "account_id" : 12296207,
      "reputation" : 2550,
      "user_id" : 8971773,
      "user_type" : "registered",
      "accept_rate" : 25,
      "profile_image" : "https://i.sstatic.net/tFcJU.png?s=256",
      "display_name" : "Kira Resari",
      "link" : "https://stackoverflow.com/users/8971773/kira-resari"
    },
    "creation_date" : 1747639682,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140438158,
    "post_id" : 79608645,
    "body" : "@AndrewS I added my OAuth2Config above. Since the idea is to use as many of Spring&#39;s built-in standard features, I can&#39;t just use the &quot;simple&quot; Spring Security config you linked. But at the same time, I need the custom providers to switch over the different scopes, which use different authentication mechanisms, unless there&#39;s a better way. And the default provider that I&#39;d like to get rid of is registered in <code>OAuth2TokenEndpointConfigurer#init</code>, and I haven&#39;t been able to find a way to disable that.",
    "score" : 0,
    "owner" : {
      "account_id" : 12296207,
      "reputation" : 2550,
      "user_id" : 8971773,
      "user_type" : "registered",
      "accept_rate" : 25,
      "profile_image" : "https://i.sstatic.net/tFcJU.png?s=256",
      "display_name" : "Kira Resari",
      "link" : "https://stackoverflow.com/users/8971773/kira-resari"
    },
    "creation_date" : 1747636995,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140401139,
    "post_id" : 79608645,
    "body" : "Can your AuthenticationProvider throw AccountStatusException or InternalAuthenticationServiceException instead, so ProviderManager does not poll subsequent providers?",
    "score" : 0,
    "owner" : {
      "account_id" : 23128,
      "reputation" : 14130,
      "user_id" : 57719,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/m2xJ2.png?s=256",
      "display_name" : "Chin Huang",
      "link" : "https://stackoverflow.com/users/57719/chin-huang"
    },
    "creation_date" : 1746547441,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140400558,
    "post_id" : 79608645,
    "body" : "How is the custom <code>AuthenticationProvider</code> registered?  <a href=\"https://www.baeldung.com/spring-security-authentication-provider#java\" rel=\"nofollow noreferrer\">This</a> might help.",
    "score" : 0,
    "owner" : {
      "account_id" : 8909811,
      "reputation" : 2861,
      "user_id" : 6650475,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/fe85994d05ad7aaaa1c47d638b37bc45?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Andrew S",
      "link" : "https://stackoverflow.com/users/6650475/andrew-s"
    },
    "creation_date" : 1746537604,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}