{
  "question" : {
    "question_id" : 79830440,
    "title" : "Force full expression evaluation or disable short-circuiting logic in SpEL expressions",
    "body" : "<p>I am working on an application where it dynamically generates and executes some Spring Expression Language (SpEL) expressions.</p>\n<p>I am facing a few performance issues, and after tracking it down a bit, I found out it was happening because the SpEL compiler refuses to compile an expression if the whole thing hasn't been run normally (this part is expected). In my case this was happening because of a logical operator.</p>\n<p>I noticed that in case of logical or <code>( || )</code></p>\n<ol>\n<li>when you use a logical <code>( || )</code> operator separating two expressions in SpEL.</li>\n<li>The first half of the expression is true most of the time; the second half doesn't execute.</li>\n<li>This leads to the compiler not having enough info about the second half of the expression to compile it.</li>\n</ol>\n<p>Similarly for logical <code>( &amp;&amp; )</code> if the first half is <code>false</code>.</p>\n<p>I have a minimal example of this behavior.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package org.example;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.expression.Expression;\nimport org.springframework.expression.ExpressionParser;\nimport org.springframework.expression.spel.SpelCompilerMode;\nimport org.springframework.expression.spel.SpelParserConfiguration;\nimport org.springframework.expression.spel.standard.SpelExpressionParser;\nimport org.springframework.expression.spel.support.StandardEvaluationContext;\nimport org.springframework.scheduling.annotation.EnableAsync;\n\n\n@EnableAsync\n@Configuration\n@SpringBootApplication\npublic class Main {\n    public static void main(String[] args) {\n        SpringApplication.run(Main.class, args);\n        ExpressionParser parser = new SpelExpressionParser(\n                new SpelParserConfiguration(SpelCompilerMode.IMMEDIATE, Main.class.getClassLoader())\n        );\n\n        Expression expression = parser.parseExpression(&quot;(#var1) || (#var2)&quot;);\n\n        StandardEvaluationContext context = new StandardEvaluationContext();\n\n\n        for (int i = 0; i &lt; 10000; i++) {\n            context.setVariable(&quot;var1&quot;, true);\n            context.setVariable(&quot;var2&quot;, false);\n            expression.getValue(context, Object.class);\n        }\n\n        System.out.println(&quot;End&quot;);\n    }\n}\n</code></pre>\n<p>If you have</p>\n<pre class=\"lang-ini prettyprint-override\"><code>logging.level.org.springframework.expression=TRACE\n</code></pre>\n<p>You will see the logs say</p>\n<pre class=\"lang-none prettyprint-override\"><code>2025-11-26T12:58:18.891+05:30 DEBUG 20156 --- [           main] o.s.e.spel.standard.SpelCompiler         : SpEL: unable to compile (#var1 or #var2)\n2025-11-26T12:58:18.891+05:30 DEBUG 20156 --- [           main] o.s.e.spel.standard.SpelCompiler         : SpEL: unable to compile (#var1 or #var2)\n2025-11-26T12:58:18.891+05:30 DEBUG 20156 --- [           main] o.s.e.spel.standard.SpelCompiler         : SpEL: unable to compile (#var1 or #var2)\n2025-11-26T12:58:18.891+05:30 DEBUG 20156 --- [           main] o.s.e.spel.standard.SpelCompiler         : SpEL: unable to compile (#var1 or #var2)\n2025-11-26T12:58:18.891+05:30 DEBUG 20156 --- [           main] o.s.e.spel.standard.SpelCompiler         : SpEL: unable to compile (#var1 or #var2)\n2025-11-26T12:58:18.891+05:30 DEBUG 20156 --- [           main] o.s.e.spel.standard.SpelCompiler         : SpEL: unable to compile (#var1 or #var2)\n2025-11-26T12:58:18.891+05:30 DEBUG 20156 --- [           main] o.s.e.spel.standard.SpelCompiler         : SpEL: unable to compile (#var1 or #var2)\nEnd\n</code></pre>\n<p>But if <code>var1</code> is <code>false</code> or sometimes <code>false</code>, the expression gets compiled.</p>\n<p>Are there ways to write the expressions so that both halves are computed and thus the expression gets compiled? Or any other workarounds?</p>\n",
    "tags" : [ "java", "spring", "spring-el" ],
    "owner" : {
      "account_id" : 35375431,
      "reputation" : 43,
      "user_id" : 27167673,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/de31a37798720c4fc1698e886a943496?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Manas Ranjan Das",
      "link" : "https://stackoverflow.com/users/27167673/manas-ranjan-das"
    },
    "is_answered" : true,
    "view_count" : 94,
    "answer_count" : 1,
    "score" : 2,
    "last_activity_date" : 1764237438,
    "creation_date" : 1764142761,
    "link" : "https://stackoverflow.com/questions/79830440/force-full-expression-evaluation-or-disable-short-circuiting-logic-in-spel-expre",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ ],
  "answer_comments" : { }
}