{
  "question" : {
    "question_id" : 79753653,
    "title" : "Efficiency difference between different ways of finding min &amp; max in a Java list",
    "body" : "<p>I've found questions similar to this one, such as <a href=\"https://stackoverflow.com/questions/2103606/is-math-maxa-b-or-abab-faster-in-java\">this</a> but I haven't found one answering this exact question.  I have a list of numbers and I want to iterate through them to find the minimum and maximum values.  I am wondering if there would be any performance difference between using <code>if</code>/<code>else</code> statements and <code>Math.min</code>/<code>Math.max</code>.</p>\n<p>So if I start with the following:</p>\n<pre><code>List&lt;Integer&gt; list = null;\nint min = Integer.MAX_VALUE;\nint max = Integer.MIN_VALUE;\n</code></pre>\n<p>I could then use <code>if</code>/<code>else</code> like this:</p>\n<pre class=\"lang-kotlin prettyprint-override\"><code>for (int currentNum : list) {\n    if (currentNum &lt; min) {\n        min = currentNum;\n    }\n    if (currentNum &gt; max) {\n        max = currentNum;\n    }\n}\n</code></pre>\n<p>or <code>Math.max</code> &amp; <code>Math.min</code> like this:</p>\n<pre class=\"lang-kotlin prettyprint-override\"><code>for (int currentNum : list) {\n    min = Math.min(min, currentNum);\n    max = Math.max(max, currentNum);\n}\n</code></pre>\n<p>I like the second one because it feels more expressive (and it's shorter).  But one might think it could be slower because it's doing variable assignment every time, even if it's being set to the same value.  Then again, I've been told the JVM's JIT compiler is very smart and perhaps can optimize this.</p>\n<p>So could there a performance difference?</p>\n",
    "tags" : [ "java", "optimization" ],
    "owner" : {
      "account_id" : 1198610,
      "reputation" : 9194,
      "user_id" : 1169781,
      "user_type" : "registered",
      "accept_rate" : 80,
      "profile_image" : "https://www.gravatar.com/avatar/33bd72f2b70ae4839b006a1568399f3e?s=256&d=identicon&r=PG",
      "display_name" : "J-bob",
      "link" : "https://stackoverflow.com/users/1169781/j-bob"
    },
    "is_answered" : true,
    "view_count" : 222,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1757620055,
    "creation_date" : 1756825608,
    "link" : "https://stackoverflow.com/questions/79753653/efficiency-difference-between-different-ways-of-finding-min-max-in-a-java-list",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79753736,
    "question_id" : 79753653,
    "body" : "<h2>tl;dr</h2>\n<p>By far the best performance in this case, on a multi-core machine, is a parallel stream to generate <code>IntSummaryStatistics</code> object.</p>\n<pre class=\"lang-java prettyprint-override\"><code>IntSummaryStatistics stats = \n    integers                              // Your `List` of `Integer` objects. \n        .stream()                         // Make a stream of the `Integer` objects.\n        .mapToInt( Integer :: intValue )  // Convert each `Integer` object into an `int` primitive value, via an `IntStream`. \n        .parallel()                       // Process the `IntStream` broken up into parallel tasks to leverage multiple CPU cores. \n        .summaryStatistics();             // Examine every `int` element in the `IntStream` while calculating min, max, sum, average, and count stored in an `IntSummaryStatistics` object.\n\nint min = stats.getMin() ;                // Interrogate the `IntSummaryStatistics` object. \nint max = stats.getMax() ;\n</code></pre>\n<h2>Examine source code</h2>\n<p>Look at the <a href=\"https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/lang/Math.java\" rel=\"nofollow noreferrer\"><code>Math.java</code></a> source code of Java implementations based on the OpenJDK codebase.</p>\n<pre class=\"lang-java prettyprint-override\"><code>@IntrinsicCandidate\npublic static long min(long a, long b) {\n    return (a &lt;= b) ? a : b;\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>@IntrinsicCandidate\npublic static long max(long a, long b) {\n    return (a &gt;= b) ? a : b;\n}\n</code></pre>\n<p>Those methods use a <a href=\"https://www.baeldung.com/java-ternary-operator\" rel=\"nofollow noreferrer\">ternary operator</a>, a briefer alternative to an <code>if</code> statement.</p>\n<p>So we see that calling these methods is basically doing the same work as your <code>if</code> code.</p>\n<p>Technically your second code does a bit more. Your second code always assigns a value to the primitive variable whether it needs to or not. But I cannot imagine that a primitive value assignment would ever be a bottleneck in your app.</p>\n<p>\uD83D\uDC49\uD83C\uDFFD Beware of falling into the trap of <em>premature optimization</em>. Before any optimization attempt, measure performance empirically.</p>\n<h3><code>Collections.min</code> &amp; <code>Collections.max</code></h3>\n<p>Personally, I would just use the utility methods <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/Collections.html#min(java.util.Collection)\" rel=\"nofollow noreferrer\">min</a> &amp; <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/Collections.html#max(java.util.Collection)\" rel=\"nofollow noreferrer\">max</a> provided on the <code>Collections</code> class. Clean, simple, fool-proof.</p>\n<pre><code>int min = Collections.min( myNumbers ) ;\nint max = Collections.max( myNumbers ) ;\n</code></pre>\n<p>See the <a href=\"https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/Collections.java\" rel=\"nofollow noreferrer\">source code</a> for the OpenJDK implementation. That code uses as <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/Iterator.html\" rel=\"nofollow noreferrer\"><code>Iterator</code></a>. That may explain why this approach seems to be over three times slower than the other two approaches tested in code below.</p>\n<h3>Stream</h3>\n<p>See <a href=\"https://stackoverflow.com/questions/79753653/efficiency-difference-between-different-ways-of-finding-min-max-in-a-java-list/79753736#comment140709823_79753653\">Comment by g00se</a> for yet another approach using Java streams with <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Collectors.html#summarizingInt(java.util.function.ToIntFunction)\" rel=\"nofollow noreferrer\"><code>Collectors.summarizingInt</code></a> to produce <code>IntSummaryStatistics</code>.</p>\n<pre><code>System.out.println( list.stream().collect(Collectors.summarizingInt(n-&gt;n)) );\n</code></pre>\n<h2>Example code</h2>\n<p>Let's try each of those approaches.</p>\n<p>Get some sample data. We use a collection of twenty million numbers as input.</p>\n<pre class=\"lang-java prettyprint-override\"><code>List &lt; Integer &gt; integers =\n        IntStream\n                .generate(\n                        ( ) -&gt; ThreadLocalRandom.current().nextInt( 1 , 1_000_000 )\n                )\n                .limit( 20_000_000 )\n                .boxed()\n                .toList();\n</code></pre>\n<p>Try each of our three approaches, multiple times. And let's put a spin on the last of those three, trying it parallelized with a call to <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/BaseStream.html#parallel()\" rel=\"nofollow noreferrer\"><code>parallel</code></a> on this 10-core machine.</p>\n<pre class=\"lang-java prettyprint-override\"><code>for ( int index = 0 ; index &lt; 10 ; index++ )\n{\n    System.out.println( &quot;Loop ordinal &quot; + ( index + 1 ) );\n\n    long x = System.nanoTime();\n    // ➡️ Approach used in Question.\n    int min = Integer.MAX_VALUE;\n    int max = Integer.MIN_VALUE;\n    for ( int currentNum : integers )\n    {\n        if ( currentNum &lt; min ) min = currentNum;\n        if ( currentNum &gt; max ) max = currentNum;\n    }\n    Duration xDuration = Duration.ofNanos( System.nanoTime() - x );\n    IO.println( &quot;min = &quot; + min + &quot; | max = &quot; + max + &quot; | xDuration = &quot; + xDuration );\n\n    long y = System.nanoTime();\n    // ➡️ Simplest approach, using utility class bundled with Java.\n    min = Collections.min( integers );\n    max = Collections.max( integers );\n    Duration yDuration = Duration.ofNanos( System.nanoTime() - y );\n    IO.println( &quot;min = &quot; + min + &quot; | max = &quot; + max + &quot; | yDuration = &quot; + yDuration );\n\n    long z = System.nanoTime();\n    // ➡️ Using Java streams approach suggested by g00se.\n    // IntSummaryStatistics stats = integers.stream().mapToInt( Integer :: intValue ).summaryStatistics();\n    IntSummaryStatistics stats = integers.stream().collect( Collectors.summarizingInt( n -&gt; n ) );\n    min = stats.getMin();\n    max = stats.getMax();\n    Duration zDuration = Duration.ofNanos( System.nanoTime() - z );\n    IO.println( &quot;min = &quot; + min + &quot; | max = &quot; + max + &quot; | zDuration = &quot; + zDuration );\n}\n\n    long zParallel = System.nanoTime();\n    // ➡️ Using Java streams approach suggested by g00se, like the approach above, but adding parallelization.\n    // IntSummaryStatistics statsParallel = integers.stream().mapToInt( Integer :: intValue ).parallel().summaryStatistics();\n    IntSummaryStatistics statsParallel = integers.stream().parallel().collect( Collectors.summarizingInt( n -&gt; n ) );\n    min = statsParallel.getMin();\n    max = statsParallel.getMax();\n    Duration zDurationParallel = Duration.ofNanos( System.nanoTime() - zParallel );\n    IO.println( &quot;min = &quot; + min + &quot; | max = &quot; + max + &quot; | zDurationParallel = &quot; + zDurationParallel );\n</code></pre>\n<p>This is <em>not</em> a very good benchmark test. But it is likely valid, in the ballpark, if we omit the first run.</p>\n<p>I ran this code with Java 25, on macOS Sequoia, on MacBook Pro with Apple Silicon M1 Pro chip, 16 gigs RAM.</p>\n<p>Results show that all three approaches take tens of milliseconds for our list of twenty million elements. I am surprised to see:</p>\n<ul>\n<li>The non-parallel streams approach seems to be the fastest, by a significant amount. Even more amazing is that the streams approach with <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/IntSummaryStatistics.html\" rel=\"nofollow noreferrer\"><code>IntSummaryStatistics</code></a> does the most work, calculating count, average, and sum along with min &amp; max.</li>\n<li>Parallelizing the streams approach makes a huge impact, pushing the resulting fractional second time over by a decimal place! We go from streams taking about .02S to dropping to only about .004S. Parallelizing does not always make a great improvement with streams, but it does here in this case. (Using 10-core, 2 efficiency + 8 performance, in Apple Silicon <a href=\"https://en.wikipedia.org/wiki/Apple_M1#M1_Pro_and_M1_Max\" rel=\"nofollow noreferrer\">M1 Pro</a> chip.)</li>\n</ul>\n<pre class=\"lang-none prettyprint-override\"><code>…\nLoop ordinal 9\nmin = 1 | max = 999999 | xDuration = PT0.043894791S\nmin = 1 | max = 999999 | yDuration = PT0.078488875S\nmin = 1 | max = 999999 | zDuration = PT0.020022583S\nmin = 1 | max = 999999 | zDurationParallel = PT0.004057375S\nLoop ordinal 10\nmin = 1 | max = 999999 | xDuration = PT0.046943083S\nmin = 1 | max = 999999 | yDuration = PT0.081117334S\nmin = 1 | max = 999999 | zDuration = PT0.019126125S\nmin = 1 | max = 999999 | zDurationParallel = PT0.003920666S\n</code></pre>\n<p>Again, (a) this is not an excellent benchmark test, and (b) do not worry about looping a list in Java. Surely you must have bigger fish to fry in your app’s real-world performance.</p>\n",
    "score" : 3,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 322981,
      "reputation" : 346842,
      "user_id" : 642706,
      "user_type" : "registered",
      "accept_rate" : 58,
      "profile_image" : "https://i.sstatic.net/ZWEI3.jpg?s=256",
      "display_name" : "Basil Bourque",
      "link" : "https://stackoverflow.com/users/642706/basil-bourque"
    },
    "creation_date" : 1756830218,
    "last_activity_date" : 1757620055,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140725628,
    "post_id" : 79753653,
    "body" : "@bruno Even more surprising is to see how much better improved are results when parallelizing the stream. I just tried that, and edited my Answer with additional results. If convenient, please verify that I did not screw up some aspect of the test.",
    "score" : 0,
    "owner" : {
      "account_id" : 322981,
      "reputation" : 346842,
      "user_id" : 642706,
      "user_type" : "registered",
      "accept_rate" : 58,
      "profile_image" : "https://i.sstatic.net/ZWEI3.jpg?s=256",
      "display_name" : "Basil Bourque",
      "link" : "https://stackoverflow.com/users/642706/basil-bourque"
    },
    "creation_date" : 1757463763,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140725032,
    "post_id" : 79753653,
    "body" : "@BasilBourque yes I already see it (and UV it) when you post it, I was also very surprised.",
    "score" : 0,
    "owner" : {
      "account_id" : 2864397,
      "reputation" : 34338,
      "user_id" : 2458991,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/WWDzI.jpg?s=256",
      "display_name" : "bruno",
      "link" : "https://stackoverflow.com/users/2458991/bruno"
    },
    "creation_date" : 1757437135,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140724970,
    "post_id" : 79753653,
    "body" : "@bruno Actually, <code>Collections.max(list)</code> and <code>Collections.min(list)</code> are <i>not</i> faster. They are slower, three and a half times slower. See the test results in <a href=\"https://stackoverflow.com/a/79753736/642706\">my Answer</a>. Those results surprised me, though I’ve not yet looked at the source code for these methods. (Of course that slowness may not matter in a real app.)",
    "score" : 0,
    "owner" : {
      "account_id" : 322981,
      "reputation" : 346842,
      "user_id" : 642706,
      "user_type" : "registered",
      "accept_rate" : 58,
      "profile_image" : "https://i.sstatic.net/ZWEI3.jpg?s=256",
      "display_name" : "Basil Bourque",
      "link" : "https://stackoverflow.com/users/642706/basil-bourque"
    },
    "creation_date" : 1757434961,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140714079,
    "post_id" : 79753653,
    "body" : "may be you can use parallel stream, it will be more faster.",
    "score" : 0,
    "owner" : {
      "account_id" : 4412703,
      "reputation" : 1,
      "user_id" : 3595122,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/99e4ac83a3c3b095d1da2e76d6917b72?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Shashishekar",
      "link" : "https://stackoverflow.com/users/3595122/shashishekar"
    },
    "creation_date" : 1756980025,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140711319,
    "post_id" : 79753653,
    "body" : "btw, also consider that the last snippet is doing two methods calls, which <i>can</i> be worse than the assignments. But then we have the JIT-compiler, <i>messing up</i> such single observations",
    "score" : 0,
    "owner" : {
      "account_id" : 31180,
      "reputation" : 29752,
      "user_id" : 85421,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/kKvXH.gif?s=256",
      "display_name" : "user85421",
      "link" : "https://stackoverflow.com/users/85421/user85421"
    },
    "creation_date" : 1756892075,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140710492,
    "post_id" : 79753653,
    "body" : "J-bob, you need to use JMH to performance test the two versions. I wouldn&#39;t be surprised if you end up at &#39;there is no meaningful difference&#39;. Here&#39;s a <a href=\"https://www.baeldung.com/java-microbenchmark-harness\" rel=\"nofollow noreferrer\">tutorial on how to use JMH to get a meaningful performance measurement of algorithms exactly like this</a>.",
    "score" : 3,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107136,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1756851915,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140709974,
    "post_id" : 79753653,
    "body" : "Do not worry about performance if you can&#39;t measure it.",
    "score" : 6,
    "owner" : {
      "account_id" : 372682,
      "reputation" : 26502,
      "user_id" : 721855,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/vZiox.png?s=256",
      "display_name" : "aled",
      "link" : "https://stackoverflow.com/users/721855/aled"
    },
    "creation_date" : 1756835515,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140709927,
    "post_id" : 79753653,
    "body" : "These are going to get optimized by Java to exactly the same thing.",
    "score" : 0,
    "owner" : {
      "account_id" : 465573,
      "reputation" : 200423,
      "user_id" : 869736,
      "user_type" : "registered",
      "accept_rate" : 82,
      "profile_image" : "https://www.gravatar.com/avatar/ae7bb06b9a23a4dd7eea69e853d47d12?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Louis Wasserman",
      "link" : "https://stackoverflow.com/users/869736/louis-wasserman"
    },
    "creation_date" : 1756833876,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140709823,
    "post_id" : 79753653,
    "body" : "Just saying but you can of course do <code>System.out.println(list.stream().collect(Collectors.summariz&zwnj;&#8203;ingInt(n-&gt;n))); </code> and you&#39;ll get max, min and more",
    "score" : 1,
    "owner" : {
      "account_id" : 22124137,
      "reputation" : 4244,
      "user_id" : 16376827,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/1ImPw.png?s=256",
      "display_name" : "g00se",
      "link" : "https://stackoverflow.com/users/16376827/g00se"
    },
    "creation_date" : 1756830604,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140709707,
    "post_id" : 79753653,
    "body" : "@life888888 can you explain the interest to do with a 20,000,000 elements ? I don&#39;t see any ...",
    "score" : 0,
    "owner" : {
      "account_id" : 2864397,
      "reputation" : 34338,
      "user_id" : 2458991,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/WWDzI.jpg?s=256",
      "display_name" : "bruno",
      "link" : "https://stackoverflow.com/users/2458991/bruno"
    },
    "creation_date" : 1756827817,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140709689,
    "post_id" : 79753653,
    "body" : "because <code>Collection.min</code>and <code>Collection.max</code> are built in they are very probably faster. But again, do each of the 3 ways in a loop and measure execution times",
    "score" : 0,
    "owner" : {
      "account_id" : 2864397,
      "reputation" : 34338,
      "user_id" : 2458991,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/WWDzI.jpg?s=256",
      "display_name" : "bruno",
      "link" : "https://stackoverflow.com/users/2458991/bruno"
    },
    "creation_date" : 1756827454,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140709687,
    "post_id" : 79753653,
    "body" : "you do not need to have a long list, just do your <code>for</code> in a loop",
    "score" : 2,
    "owner" : {
      "account_id" : 2864397,
      "reputation" : 34338,
      "user_id" : 2458991,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/WWDzI.jpg?s=256",
      "display_name" : "bruno",
      "link" : "https://stackoverflow.com/users/2458991/bruno"
    },
    "creation_date" : 1756827378,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140709686,
    "post_id" : 79753653,
    "body" : "Because that would require two iterations through the list, which would surely be less efficient than a single iteration.",
    "score" : 0,
    "owner" : {
      "account_id" : 1198610,
      "reputation" : 9194,
      "user_id" : 1169781,
      "user_type" : "registered",
      "accept_rate" : 80,
      "profile_image" : "https://www.gravatar.com/avatar/33bd72f2b70ae4839b006a1568399f3e?s=256&d=identicon&r=PG",
      "display_name" : "J-bob",
      "link" : "https://stackoverflow.com/users/1169781/j-bob"
    },
    "creation_date" : 1756827377,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140709684,
    "post_id" : 79753653,
    "body" : "Apart of that why do you not use <code>Collections.max(list)</code>and <code>Collections.min(list)</code> which is very surely faster ?",
    "score" : 0,
    "owner" : {
      "account_id" : 2864397,
      "reputation" : 34338,
      "user_id" : 2458991,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/WWDzI.jpg?s=256",
      "display_name" : "bruno",
      "link" : "https://stackoverflow.com/users/2458991/bruno"
    },
    "creation_date" : 1756827340,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140709682,
    "post_id" : 79753653,
    "body" : "I tried but each one only took a few milliseconds so I feel like there could be noise from other factors.  I tried increasing the list beyond <code>1E9</code> elements to make it take longer and I got an <code>OutOfMemoryError</code> .",
    "score" : 0,
    "owner" : {
      "account_id" : 1198610,
      "reputation" : 9194,
      "user_id" : 1169781,
      "user_type" : "registered",
      "accept_rate" : 80,
      "profile_image" : "https://www.gravatar.com/avatar/33bd72f2b70ae4839b006a1568399f3e?s=256&d=identicon&r=PG",
      "display_name" : "J-bob",
      "link" : "https://stackoverflow.com/users/1169781/j-bob"
    },
    "creation_date" : 1756827319,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140709676,
    "post_id" : 79753653,
    "body" : "Have you done any performance measurements to compare the two versions?",
    "score" : 2,
    "owner" : {
      "account_id" : 2864397,
      "reputation" : 34338,
      "user_id" : 2458991,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/WWDzI.jpg?s=256",
      "display_name" : "bruno",
      "link" : "https://stackoverflow.com/users/2458991/bruno"
    },
    "creation_date" : 1756827099,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}