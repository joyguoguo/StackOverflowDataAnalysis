{
  "question" : {
    "question_id" : 79827809,
    "title" : "How can I apply &quot;organize imports&quot; action programmatically in an Eclipse batch application?",
    "body" : "<p>I'm creating an Eclipse batch application that applies source cleanups (equivalent of right-click menu <code>Source -&gt; Clean Up</code>) from a profile file. It's an XML file listing the rules and whether they're activated or not. It can be exported from <code>Window -&gt; Preferences</code> and then <code>Java -&gt; Code Style -&gt; Clean Up</code>.</p>\n<p>It seems to give good results but one of the cleanups, <code>Organize Imports</code>, fails with an exception.</p>\n<p>It can be turned on and off in this line of the profile file :</p>\n<pre class=\"lang-xml prettyprint-override\"><code>&lt;setting id=&quot;cleanup.organize_imports&quot; value=&quot;false&quot;/&gt; &lt;!-- fails if set to true --&gt;\n</code></pre>\n<p>The project tree is:</p>\n<pre><code>C:\\USERS\\xxxxx\\GIT\\REFACTORING-CLI\n│   .classpath\n│   .gitignore\n│   .project\n│   build.properties\n│   LICENSE\n│   plugin.xml\n│   pom.xml\n│\n├───META-INF\n│       MANIFEST.MF\n│\n└───src\n    └───main\n        └───java\n            └───io\n                └───github\n                    └───xxxxxxxxx\n                        └───refactoring\n                            └───cli\n                                    Activator.java\n                                    CleanupRunner.java\n                                    HeadlessCleanupApp.java\n</code></pre>\n<p>Here's the root <code>pom.xml</code> file:</p>\n<pre class=\"lang-xml prettyprint-override\"><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;\n           http://maven.apache.org/POM/4.0.0\n           https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n\n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n  &lt;groupId&gt;io.github.xxxxxxxxx&lt;/groupId&gt;\n  &lt;artifactId&gt;io.github.xxxxxxxxx.refactoring.cli&lt;/artifactId&gt;\n  &lt;version&gt;1.0.0&lt;/version&gt;\n  &lt;packaging&gt;eclipse-plugin&lt;/packaging&gt;\n  &lt;properties&gt;\n    &lt;tycho.version&gt;5.0.0&lt;/tycho.version&gt;\n    &lt;eclipse.release.repo&gt;https://download.eclipse.org/releases/2025-09&lt;/eclipse.release.repo&gt;\n    &lt;maven.compiler.source&gt;21&lt;/maven.compiler.source&gt;\n    &lt;maven.compiler.target&gt;21&lt;/maven.compiler.target&gt;\n    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n  &lt;/properties&gt;\n\n  &lt;repositories&gt;\n    &lt;repository&gt;\n      &lt;id&gt;eclipse-release&lt;/id&gt;\n      &lt;url&gt;${eclipse.release.repo}&lt;/url&gt;\n      &lt;layout&gt;p2&lt;/layout&gt;\n    &lt;/repository&gt;\n  &lt;/repositories&gt;\n\n  &lt;build&gt;\n    &lt;extensions&gt;\n      &lt;extension&gt;\n        &lt;groupId&gt;org.eclipse.tycho&lt;/groupId&gt;\n        &lt;artifactId&gt;tycho-maven-plugin&lt;/artifactId&gt;\n        &lt;version&gt;${tycho.version}&lt;/version&gt;\n      &lt;/extension&gt;\n    &lt;/extensions&gt;\n\n    &lt;plugins&gt;\n      &lt;plugin&gt;\n        &lt;groupId&gt;org.eclipse.tycho&lt;/groupId&gt;\n        &lt;artifactId&gt;tycho-p2-director-plugin&lt;/artifactId&gt;\n        &lt;version&gt;${tycho.version}&lt;/version&gt;\n      &lt;/plugin&gt;\n    &lt;/plugins&gt;\n  &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre>\n<p>Here's the <code>plugin.xml</code> file:</p>\n<pre class=\"lang-xml prettyprint-override\"><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;plugin&gt;\n  &lt;extension id=&quot;app&quot; point=&quot;org.eclipse.core.runtime.applications&quot;&gt;\n    &lt;application&gt;\n      &lt;run class=&quot;io.github.xxxxxxxxx.refactoring.cli.HeadlessCleanupApp&quot;/&gt;\n    &lt;/application&gt;\n  &lt;/extension&gt;\n&lt;/plugin&gt;\n</code></pre>\n<p>Here's the <code>build.properties</code> file:`</p>\n<pre class=\"lang-xml prettyprint-override\"><code>bin.includes = META-INF/,\\\n               .,\\\n               plugin.xml\nsource.. = src/\noutput.. = bin/\n</code></pre>\n<p>Here's the <code>META-INF/MANIFEST.MF</code> file:</p>\n<pre><code>Manifest-Version: 1.0\nBundle-ManifestVersion: 2\nBundle-Name: Refactoring CLI\nBundle-SymbolicName: io.github.xxxxxxxxx.refactoring.cli;singleton:=true\nBundle-Version: 1.0.0\nBundle-Activator: io.github.xxxxxxxxx.refactoring.cli.Activator\nBundle-RequiredExecutionEnvironment: JavaSE-21\nAutomatic-Module-Name: io.github.xxxxxxxxx.refactoring.cli\nBundle-ActivationPolicy: lazy\nRequire-Bundle: \n org.eclipse.core.runtime,\n org.eclipse.core.resources,\n org.eclipse.jdt.core,\n org.eclipse.jdt.ui,\n org.eclipse.jdt.core.manipulation,\n org.eclipse.ltk.core.refactoring,\n org.eclipse.text,\n org.eclipse.jface,\n org.eclipse.equinox.app\n</code></pre>\n<p>Here's the entry point of the application <code>HeadlessCleanupApp</code> :</p>\n<pre class=\"lang-java prettyprint-override\"><code>package io.github.xxxxxxxxx.refactoring.cli;\n\nimport org.eclipse.equinox.app.*;\nimport java.nio.file.*;\nimport java.util.*;\n\npublic class HeadlessCleanupApp implements IApplication {\n\n    @Override\n    public Object start(IApplicationContext context) throws Exception {\n        String[] args = (String[]) context.getArguments().get(IApplicationContext.APPLICATION_ARGS);\n\n        if (args == null || args.length == 0) {\n            System.err.println(&quot;Missing arguments. Usage:&quot;);\n            System.err.println(&quot;  --source &lt;level&gt; --profile &lt;file&gt; &lt;projectRoot&gt; [--classpath &lt;entries&gt;]&quot;);\n            return Integer.valueOf(1);\n        }\n\n        String sourceLevel = null;\n        String profilePath = null;\n        String projectRootPath = null;\n        List&lt;String&gt; extraClasspath = new ArrayList&lt;&gt;();\n\n        int i = 0;\n        while (i &lt; args.length) {\n            String arg = args[i];\n            if (&quot;--source&quot;.equals(arg) &amp;&amp; i + 1 &lt; args.length) {\n                sourceLevel = args[++i];\n            } else if (&quot;--profile&quot;.equals(arg) &amp;&amp; i + 1 &lt; args.length) {\n                profilePath = args[++i];\n            } else if (&quot;--classpath&quot;.equals(arg) &amp;&amp; i + 1 &lt; args.length) {\n                String[] cpEntries = args[++i].split(System.getProperty(&quot;path.separator&quot;));\n                for (String entry : cpEntries) {\n                    extraClasspath.add(entry);\n                }\n            } else {\n                projectRootPath = arg;\n            }\n            i++;\n        }\n\n        if (sourceLevel == null || profilePath == null || projectRootPath == null) {\n            System.err.println(&quot;Missing required parameters.&quot;);\n            return Integer.valueOf(1);\n        }\n\n        Path projectRoot = Paths.get(projectRootPath);\n        Path profileFile = Paths.get(profilePath);\n\n        CleanupRunner runner =\n                new CleanupRunner(projectRoot, profileFile, sourceLevel, extraClasspath);\n\n        runner.run();\n\n        return Integer.valueOf(0);\n    }\n\n    @Override\n    public void stop() {\n        // no-op\n    }\n}\n</code></pre>\n<p>The class applying the cleanups is <code>CleanupRunner</code> as follows :</p>\n<pre class=\"lang-java prettyprint-override\"><code>package io.github.xxxxxxxxx.refactoring.cli;\n\nimport java.io.*;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.*;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.*;\n\nimport javax.xml.parsers.*;\n\nimport org.eclipse.core.resources.*;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.ProgressMonitorWrapper;\nimport org.eclipse.jdt.core.*;\nimport org.eclipse.jdt.core.dom.*;\nimport org.eclipse.jdt.internal.corext.fix.*;\nimport org.eclipse.jdt.internal.ui.JavaPlugin;\nimport org.eclipse.jdt.internal.ui.fix.MapCleanUpOptions;\nimport org.eclipse.jdt.ui.cleanup.ICleanUp;\nimport org.eclipse.ltk.core.refactoring.*;\nimport org.eclipse.text.edits.TextEdit;\nimport org.w3c.dom.*;\n\npublic class CleanupRunner {\n\n    private final Path projectRoot;\n    private final Path profileFile;\n    private final String sourceLevel;\n    private final List&lt;String&gt; extraClasspath;\n\n    public CleanupRunner(Path projectRoot, Path profileFile, String sourceLevel, List&lt;String&gt; extraClasspath) {\n        this.projectRoot = projectRoot;\n        this.profileFile = profileFile;\n        this.sourceLevel = sourceLevel;\n        this.extraClasspath = extraClasspath;\n    }\n\n    public List&lt;Path&gt; run() throws Exception {\n\n        LoggingMonitor monitor = new LoggingMonitor();\n\n        System.out.println(&quot;=== Starting cleanup ===&quot;);\n        System.out.println(&quot;Project root: &quot; + projectRoot);\n        System.out.println(&quot;Profile file: &quot; + profileFile);\n        System.out.println(&quot;Source level: &quot; + sourceLevel);\n\n        IWorkspace workspace = ResourcesPlugin.getWorkspace();\n        IWorkspaceRoot wsRoot = workspace.getRoot();\n\n        System.out.println(&quot;Creating temporary workspace project...&quot;);\n        IProject project = wsRoot.getProject(&quot;refactoring-cli-project&quot;);\n        if (!project.exists()) {\n            project.create(monitor);\n        }\n        project.open(monitor);\n\n        addJavaNature(project);\n        System.out.println(&quot;Java nature enabled.&quot;);\n\n        System.out.println(&quot;Detecting source folders...&quot;);\n        Set&lt;Path&gt; sourceFolders = detectSourceFolders(projectRoot);\n        System.out.println(&quot;Detected &quot; + sourceFolders.size() + &quot; source folders.&quot;);\n\n        System.out.println(&quot;Linking source folders...&quot;);\n        Map&lt;IPath, IFolder&gt; linkedFolders = linkSourceFolders(project, sourceFolders);\n\n        project.refreshLocal(IResource.DEPTH_INFINITE, monitor);\n        System.out.println(&quot;Workspace refreshed.&quot;);\n\n        IJavaProject javaProject = JavaCore.create(project);\n\n        setEncoding(project);\n        System.out.println(&quot;Encoding set to UTF-8.&quot;);\n\n        System.out.println(&quot;Configuring classpath...&quot;);\n        configureClasspath(javaProject, linkedFolders);\n\n        System.out.println(&quot;Configuring compiler options...&quot;);\n        configureCompilerOptions(javaProject);\n\n        System.out.println(&quot;Collecting compilation units...&quot;);\n        List&lt;ICompilationUnit&gt; units = collectCompilationUnits(javaProject);\n        System.out.println(&quot;Found &quot; + units.size() + &quot; compilation units.&quot;);\n\n        if (units.isEmpty()) {\n            System.out.println(&quot;Nothing to clean.&quot;);\n            return new ArrayList&lt;&gt;();\n        }\n\n        System.out.println(&quot;Loading cleanup settings...&quot;);\n        Map&lt;String, String&gt; cleanupSettings = loadCleanupSettingsFromProfile(profileFile);\n\n        System.out.println(&quot;Loading available cleanups...&quot;);\n        CleanUpRegistry registry = JavaPlugin.getDefault().getCleanUpRegistry();\n        ICleanUp[] cleanUps = registry.createCleanUps(null);\n        System.out.println(&quot;Loaded &quot; + cleanUps.length + &quot; cleanup modules.&quot;);\n\n        MapCleanUpOptions options = new MapCleanUpOptions(cleanupSettings);\n\n        for (ICleanUp cleanUp : cleanUps) {\n            cleanUp.setOptions(options);\n        }\n\n        System.out.println(&quot;Preparing refactoring...&quot;);\n        CleanUpRefactoring refactoring = new CleanUpRefactoring();\n\n        for (ICompilationUnit unit : units) {\n            refactoring.addCompilationUnit(unit);\n        }\n\n        for (ICleanUp cleanUp : cleanUps) {\n            refactoring.addCleanUp(cleanUp);\n        }\n\n        System.out.println(&quot;Checking initial conditions...&quot;);\n        RefactoringStatus initStatus = refactoring.checkInitialConditions(monitor);\n        System.out.println(&quot;Initial condition status: &quot; + initStatus);\n\n        if (initStatus.hasFatalError()) {\n            System.err.println(&quot;Fatal error during initial conditions.&quot;);\n            return new ArrayList&lt;&gt;();\n        }\n\n        System.out.println(&quot;Checking final conditions...&quot;);\n        RefactoringStatus finalStatus = refactoring.checkFinalConditions(monitor);\n        System.out.println(&quot;Final condition status: &quot; + finalStatus);\n\n        if (finalStatus.hasFatalError()) {\n            System.err.println(&quot;Fatal error during final conditions.&quot;);\n            return new ArrayList&lt;&gt;();\n        }\n\n        System.out.println(&quot;Creating change...&quot;);\n        Change change = refactoring.createChange(monitor);\n        if (change == null) {\n            System.out.println(&quot;No changes generated.&quot;);\n            return new ArrayList&lt;&gt;();\n        }\n\n        System.out.println(&quot;Collecting changed files...&quot;);\n        List&lt;Path&gt; changed = collectChangedFiles(change);\n        System.out.println(&quot;Pending changes: &quot; + changed.size());\n\n        for (Path p : changed) {\n            System.out.println(&quot;Will modify: &quot; + p);\n        }\n\n        System.out.println(&quot;Initializing change...&quot;);\n        change.initializeValidationData(monitor);\n\n        System.out.println(&quot;Validating change...&quot;);\n        RefactoringStatus status = change.isValid(monitor);\n        System.out.println(&quot;Validation result: &quot; + status);\n\n        if (status.hasFatalError()) {\n            System.err.println(&quot;Change validation failed.&quot;);\n            return changed;\n        }\n\n        System.out.println(&quot;Applying change...&quot;);\n        change.perform(monitor);\n\n        System.out.println(&quot;Saving workspace...&quot;);\n        ResourcesPlugin.getWorkspace().save(true, monitor);\n\n        System.out.println(&quot;=== Cleanup complete ===&quot;);\n        System.out.println(&quot;Modified &quot; + changed.size() + &quot; files.&quot;);\n\n        return changed;\n    }\n\n    private void addJavaNature(IProject project) throws CoreException {\n        IProjectDescription desc = project.getDescription();\n        String[] natures = desc.getNatureIds();\n        boolean hasJavaNature = false;\n        for (String n : natures) {\n            if (JavaCore.NATURE_ID.equals(n)) {\n                hasJavaNature = true;\n                break;\n            }\n        }\n        if (!hasJavaNature) {\n            String[] newNatures = new String[natures.length + 1];\n            System.arraycopy(natures, 0, newNatures, 0, natures.length);\n            newNatures[natures.length] = JavaCore.NATURE_ID;\n            desc.setNatureIds(newNatures);\n            project.setDescription(desc, null);\n        }\n    }\n\n    private Set&lt;Path&gt; detectSourceFolders(Path root) throws IOException {\n        Set&lt;Path&gt; sourceFolders = new LinkedHashSet&lt;&gt;();\n\n        Files.walkFileTree(root, new FileVisitor&lt;Path&gt;() {\n            @Override\n            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n                return FileVisitResult.CONTINUE;\n            }\n\n            @Override\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n                if (!file.toString().endsWith(&quot;.java&quot;)) {\n                    return FileVisitResult.CONTINUE;\n                }\n\n                Path parent = file.getParent();\n                if (parent == null) {\n                    return FileVisitResult.CONTINUE;\n                }\n\n                for (Path src : sourceFolders) {\n                    if (parent.startsWith(src)) {\n                        return FileVisitResult.CONTINUE;\n                    }\n                }\n\n                String packageName = readPackageName(file);\n                Path sourceFolder = inferSourceFolder(file, packageName);\n\n                if (sourceFolder != null &amp;&amp; Files.isDirectory(sourceFolder)) {\n                    sourceFolders.add(sourceFolder.normalize());\n                }\n\n                return FileVisitResult.CONTINUE;\n            }\n\n            @Override\n            public FileVisitResult visitFileFailed(Path file, IOException exc) {\n                throw new UncheckedIOException(exc);\n            }\n\n            @Override\n            public FileVisitResult postVisitDirectory(Path dir, IOException exc) {\n                if (exc != null) {\n                    throw new UncheckedIOException(exc);\n                }\n                return FileVisitResult.CONTINUE;\n            }\n        });\n\n        return sourceFolders;\n    }\n\n    private String readPackageName(Path file) throws IOException {\n        char[] source = Files.readString(file, StandardCharsets.UTF_8).toCharArray();\n        ASTParser parser = ASTParser.newParser(AST.getJLSLatest());\n        parser.setSource(source);\n        parser.setKind(ASTParser.K_COMPILATION_UNIT);\n\n        CompilationUnit unit = (CompilationUnit) parser.createAST(null);\n\n        if (unit.getPackage() != null) {\n            return unit.getPackage().getName().getFullyQualifiedName();\n        }\n\n        return &quot;&quot;;\n    }\n\n    private Path inferSourceFolder(Path file, String packageName) {\n        Path parent = file.getParent();\n        if (parent == null) {\n            return null;\n        }\n\n        if (packageName == null || packageName.isEmpty()) {\n            return parent;\n        }\n\n        String[] segments = packageName.split(&quot;\\\\.&quot;);\n        Path pkgPath = parent;\n\n        for (int i = segments.length - 1; i &gt;= 0; i--) {\n            if (pkgPath == null || pkgPath.getFileName() == null || !pkgPath.getFileName().toString().equals(segments[i])) {\n                break;\n            }\n            pkgPath = pkgPath.getParent();\n        }\n\n        return pkgPath;\n    }\n\n    private Map&lt;IPath, IFolder&gt; linkSourceFolders(IProject project, Set&lt;Path&gt; folders) throws CoreException {\n        LinkedHashMap&lt;IPath, IFolder&gt; links = new LinkedHashMap&lt;&gt;();\n        int index = 0;\n        for (Path folder : folders) {\n            String linkName = &quot;src_&quot; + index;\n            index = index + 1;\n            IFolder linked = project.getFolder(linkName);\n            if (!linked.exists()) {\n                linked.createLink(new org.eclipse.core.runtime.Path(folder.toString()), IResource.REPLACE, null);\n            }\n            links.put(new org.eclipse.core.runtime.Path(folder.toString()), linked);\n        }\n        return links;\n    }\n\n    private void configureClasspath(IJavaProject javaProject, Map&lt;IPath, IFolder&gt; linkedFolders) throws CoreException {\n        List&lt;IClasspathEntry&gt; entries = new ArrayList&lt;&gt;();\n\n        for (IFolder folder : linkedFolders.values()) {\n            entries.add(JavaCore.newSourceEntry(folder.getFullPath()));\n        }\n\n        entries.add(JavaCore.newContainerEntry(\n                new org.eclipse.core.runtime.Path(&quot;org.eclipse.jdt.launching.JRE_CONTAINER&quot;)));\n\n        for (String cp : extraClasspath) {\n            org.eclipse.core.runtime.Path path = new org.eclipse.core.runtime.Path(cp);\n            entries.add(JavaCore.newLibraryEntry(path, null, null));\n        }\n\n        javaProject.setRawClasspath(entries.toArray(new IClasspathEntry[0]), null);\n    }\n\n    private void configureCompilerOptions(IJavaProject javaProject) {\n        Map&lt;String, String&gt; options = javaProject.getOptions(false);\n        options.put(JavaCore.COMPILER_SOURCE, sourceLevel);\n        options.put(JavaCore.COMPILER_COMPLIANCE, sourceLevel);\n        options.put(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, sourceLevel);\n        javaProject.setOptions(options);\n    }\n\n    private void setEncoding(IProject project) throws CoreException {\n        project.setDefaultCharset(StandardCharsets.UTF_8.name(), null);\n    }\n\n    private List&lt;ICompilationUnit&gt; collectCompilationUnits(IJavaProject javaProject) throws CoreException {\n        List&lt;ICompilationUnit&gt; result = new ArrayList&lt;&gt;();\n        IPackageFragmentRoot[] roots = javaProject.getPackageFragmentRoots();\n        for (IPackageFragmentRoot root : roots) {\n            if (root.getKind() == IPackageFragmentRoot.K_SOURCE) {\n                IJavaElement[] children = root.getChildren();\n                for (IJavaElement el : children) {\n                    if (el instanceof IPackageFragment pkg) {\n                        ICompilationUnit[] units = pkg.getCompilationUnits();\n                        Collections.addAll(result, units);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    private Map&lt;String, String&gt; loadCleanupSettingsFromProfile(Path profile) throws IOException {\n        Map&lt;String, String&gt; settings = new LinkedHashMap&lt;&gt;();\n\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(false);\n            factory.setIgnoringComments(true);\n            factory.setIgnoringElementContentWhitespace(true);\n\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            try (InputStream in = Files.newInputStream(profile)) {\n                Document document = builder.parse(in);\n\n                NodeList nodes = document.getElementsByTagName(&quot;setting&quot;);\n                for (int i = 0; i &lt; nodes.getLength(); i++) {\n                    Node node = nodes.item(i);\n                    if (node.getNodeType() == Node.ELEMENT_NODE) {\n                        Element element = (org.w3c.dom.Element) node;\n\n                        String id = element.getAttribute(&quot;id&quot;);\n                        String value = element.getAttribute(&quot;value&quot;);\n\n                        if (id != null &amp;&amp; !id.isEmpty()) {\n                            settings.put(id, value);\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            throw new IOException(&quot;Failed to parse cleanup profile XML: &quot; + profile, e);\n        }\n\n        return settings;\n    }\n\n\n    private List&lt;Path&gt; collectChangedFiles(Change change) throws CoreException {\n        List&lt;Path&gt; result = new ArrayList&lt;&gt;();\n        if (change instanceof CompositeChange composite) {\n            Change[] children = composite.getChildren();\n            for (Change child : children) {\n                result.addAll(collectChangedFiles(child));\n            }\n        } else if (change instanceof TextFileChange tfc) {\n            TextEdit edit = tfc.getEdit();\n            if (edit != null &amp;&amp; edit.hasChildren()) {\n                IFile file = tfc.getFile();\n                result.add(Paths.get(file.getLocation().toOSString()));\n            }\n        }\n        return result;\n    }\n\n\n    private static class LoggingMonitor extends ProgressMonitorWrapper {\n\n        public LoggingMonitor() {\n            super(new NullProgressMonitor());\n        }\n\n        @Override\n        public void beginTask(String name, int totalWork) {\n            System.out.println(&quot;BEGIN: &quot; + name + &quot; (&quot; + totalWork + &quot;)&quot;);\n        }\n\n        @Override\n        public void worked(int work) {\n            System.out.println(&quot;WORK: &quot; + work);\n        }\n\n        @Override\n        public void done() {\n            System.out.println(&quot;DONE&quot;);\n        }\n    }\n\n}\n</code></pre>\n<p>There's a minimal <code>Activator</code> class :</p>\n<pre class=\"lang-java prettyprint-override\"><code>package io.github.xxxxxxxxx.refactoring.cli;\n\nimport org.eclipse.core.runtime.Plugin;\n\npublic class Activator extends Plugin {\n}\n</code></pre>\n<p>In Eclipse RCP, in the MANIFEST GUI, I choose &quot;Launch an Eclipse application in Debug mode&quot;.</p>\n<p><a href=\"https://i.sstatic.net/IYaFr0tW.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/IYaFr0tW.png\" alt=\"Launch an Eclipse application in Debug mode\" /></a></p>\n<p>Alternatively, after building with <code>mvn package</code>, and dropping the jar into <code>dropins</code> folder of Eclipse, I launch :</p>\n<pre><code>eclipsec -nosplash -clean -data C:\\Users\\xxxxx\\.refactoring-workspace -application io.github.xxxxxxxxx.refactoring.cli.app --source 21 --profile C:\\Users\\xxxxx\\Downloads\\source_cleanup_profile.xml C:\\Users\\xxxxx\\git\\codebase_to_cleanup\n</code></pre>\n<p>Here's the log from <code>C:\\Users\\xxxxx\\.refactoring-workspace\\.metadata\\.log</code> :</p>\n<pre><code>!SESSION 2025-11-23 11:01:57.007 -----------------------------------------------\neclipse.buildId=4.37.0.20250905-1455\njava.version=21.0.9\njava.vendor=Eclipse Adoptium\nBootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=fr_FR\n\n!ENTRY org.eclipse.osgi 4 0 2025-11-23 11:01:57.264\n!MESSAGE The -clean (osgi.clean) option was not successful. Unable to clean the storage area: C:\\Users\\xxxxx\\Downloads\\eclipse-rcp-2025-09-R-win32-x86_64\\eclipse\\configuration\\org.eclipse.osgi\n\n!ENTRY ch.qos.logback.classic 1 0 2025-11-23 11:02:04.343\n!MESSAGE Activated before the state location was initialized. Retry after the state location is initialized.\n\n!ENTRY org.eclipse.lemminx.uber-jar 4 0 2025-11-23 11:02:04.704\n!MESSAGE bundle org.eclipse.lemminx.uber-jar:0.31.0 (312) Component descriptor entry 'OSGI-INF/*.xml' not found\n\n!ENTRY org.eclipse.core.resources 2 10035 2025-11-23 11:02:08.875\n!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.\n\n!ENTRY ch.qos.logback.classic 1 0 2025-11-23 11:02:10.164\n!MESSAGE Logback config file: C:\\Users\\xxxxx\\.refactoring-workspace\\.metadata\\.plugins\\org.eclipse.m2e.logback\\logback.2.7.100.20250418-1315.xml\n\n!ENTRY org.eclipse.osgi 4 0 2025-11-23 11:02:18.608\n!MESSAGE Application error\n!STACK 1\njava.lang.RuntimeException: Error on /refactoring-cli-project/src_0/DecompilerPreferenceAction.java\n    at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:999)\n    at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:731)\n    at org.eclipse.jdt.core.dom.CompilationUnitResolver$ECJCompilationUnitResolver.resolve(CompilationUnitResolver.java:103)\n    at org.eclipse.jdt.core.dom.ASTParser.createASTs(ASTParser.java:1004)\n    at org.eclipse.jdt.internal.corext.dom.ASTBatchParser.createASTs(ASTBatchParser.java:83)\n    at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpFixpointIterator.next(CleanUpRefactoring.java:410)\n    at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.cleanUpProject(CleanUpRefactoring.java:706)\n    at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.checkFinalConditions(CleanUpRefactoring.java:666)\n    at io.github.xxxxxxxxx.refactoring.cli.CleanupRunner.run(CleanupRunner.java:174)\n    at io.github.xxxxxxxxx.refactoring.cli.HeadlessCleanupApp.start(HeadlessCleanupApp.java:58)\n    at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:219)\n    at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:149)\n    at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:115)\n    at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:467)\n    at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:298)\n    at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)\n    at java.base/java.lang.reflect.Method.invoke(Method.java:580)\n    at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:627)\n    at org.eclipse.equinox.launcher.Main.basicRun(Main.java:575)\n    at org.eclipse.equinox.launcher.Main.run(Main.java:1431)\nCaused by: java.lang.IllegalStateException: Workbench has not been created yet.\n    at org.eclipse.ui.PlatformUI.getWorkbench(PlatformUI.java:119)\n    at org.eclipse.jdt.internal.corext.fix.ImportsFix.runUsingProgressService(ImportsFix.java:85)\n    at org.eclipse.jdt.internal.corext.fix.ImportsFix.createCleanUp(ImportsFix.java:63)\n    at org.eclipse.jdt.internal.ui.fix.ImportsCleanUp.createFix(ImportsCleanUp.java:62)\n    at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring.calculateChange(CleanUpRefactoring.java:796)\n    at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.calculateSolutions(CleanUpRefactoring.java:303)\n    at org.eclipse.jdt.internal.corext.fix.CleanUpRefactoring$CleanUpASTRequestor.acceptAST(CleanUpRefactoring.java:281)\n    at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:997)\n    ... 19 more\n\n!ENTRY org.eclipse.core.resources 2 10035 2025-11-23 11:02:19.594\n!MESSAGE The workspace will exit with unsaved changes in this session.\n</code></pre>\n<p>The class that is being cleaned up is the following (it is part of a forked project <a href=\"https://github.com/nbauma109/ecd\" rel=\"nofollow noreferrer\">ECD</a>) :</p>\n<pre class=\"lang-java prettyprint-override\"><code>package org.sf.feeling.decompiler.actions;\n\nimport org.eclipse.jface.action.Action;\nimport org.eclipse.swt.widgets.Display;\nimport org.eclipse.ui.dialogs.PreferencesUtil;\nimport org.sf.feeling.decompiler.editor.JavaDecompilerClassFileEditor;\nimport org.sf.feeling.decompiler.i18n.Messages;\nimport org.sf.feeling.decompiler.util.UIUtil;\n\npublic class DecompilerPreferenceAction extends Action {\n\n    public DecompilerPreferenceAction() {\n        super(Messages.getString(&quot;JavaDecompilerActionBarContributor.Action.Preferences&quot;)); //$NON-NLS-1$\n    }\n\n    @Override\n    public void run() {\n        JavaDecompilerClassFileEditor editor = UIUtil.getActiveDecompilerEditor();\n\n        String showId = &quot;org.sf.feeling.decompiler.Main&quot;; //$NON-NLS-1$\n\n        if (editor != null) {\n            PreferencesUtil.createPreferenceDialogOn(Display.getDefault().getActiveShell(), showId, // $NON-NLS-1$\n                    editor.collectContextMenuPreferencePages(), null).open();\n        } else {\n            PreferencesUtil.createPreferenceDialogOn(Display.getDefault().getActiveShell(), showId, // $NON-NLS-1$\n                    new String[] { showId // $NON-NLS-1$\n                    }, null).open();\n        }\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n</code></pre>\n",
    "tags" : [ "java", "eclipse", "eclipse-plugin", "eclipse-rcp" ],
    "owner" : {
      "account_id" : 11342171,
      "reputation" : 1656,
      "user_id" : 8315843,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/c355a6bc9f775ba7e74329d02984e52f?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Sybuser",
      "link" : "https://stackoverflow.com/users/8315843/sybuser"
    },
    "is_answered" : true,
    "view_count" : 92,
    "answer_count" : 1,
    "score" : 2,
    "last_activity_date" : 1764830664,
    "creation_date" : 1763893667,
    "link" : "https://stackoverflow.com/questions/79827809/how-can-i-apply-organize-imports-action-programmatically-in-an-eclipse-batch-a",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ ],
  "answer_comments" : { }
}