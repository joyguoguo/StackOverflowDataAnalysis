{
  "question" : {
    "question_id" : 79579420,
    "title" : "Eagerly load nested lazy collections in Spring Batch with parallel chunk processing and an aggregate ItemReader",
    "body" : "<p>I’m working with a Spring Batch step that processes chunks in <strong>parallel</strong>. The step uses a custom <strong>aggregate</strong> <code>ItemReader</code> that returns a <code>List</code> of entities to the ItemProcessor.</p>\n<p>Each entity contains nested <code>@ElementCollection</code> lists. These collections are lazily loaded by default.</p>\n<p>I’m using a <code>JpaTransactionManager</code> for transaction management and <code>SimpleAsyncTaskExecutor</code> for parallel execution.</p>\n<p>The issue is that the nested lazy collections are not initialized when accessed in the <code>ItemProcessor</code>, leading to a <code>LazyInitializationException</code>.</p>\n<p><strong>Example:</strong></p>\n<p><strong>CustomerOrder entity:</strong></p>\n<pre class=\"lang-java prettyprint-override\"><code>@Entity\npublic class CustomerOrder {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n\n    @ManyToOne\n    @JoinColumn(name = &quot;order_id&quot;)\n    private Order order;\n\n    private boolean processed;\n\n    // Getters and setters omitted for brevity\n}\n</code></pre>\n<p><strong>Order entity:</strong></p>\n<p>The <code>@ElementCollection</code> associations are lazily loaded by default.</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Entity\npublic class Order {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @ElementCollection\n    @CollectionTable(name = &quot;order_dates&quot;, joinColumns = @JoinColumn(name = &quot;order_id&quot;))\n    @Column(name = &quot;date&quot;)\n    private List&lt;LocalDate&gt; dates = new ArrayList&lt;&gt;();\n\n    @ElementCollection\n    @CollectionTable(name = &quot;order_sizes&quot;, joinColumns = @JoinColumn(name = &quot;order_id&quot;))\n    @Column(name = &quot;size&quot;)\n    private List&lt;Double&gt; sizes = new ArrayList&lt;&gt;();\n\n    // Getters and setters omitted for brevity\n}\n</code></pre>\n<p><strong>Item reader (aggregate):</strong></p>\n<p><em>Bean</em>:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Bean\npublic AggregatePagingItemReader&lt;CustomerOrder&gt; customerOrderAggregateItemReader(\n        EntityManagerFactory entityManagerFactory) {\n    JpaPagingItemReader&lt;CustomerOrder&gt; itemReader = new JpaPagingItemReaderBuilder&lt;CustomerOrder&gt;()\n            .name(&quot;customerOrderItemReader&quot;)\n            .entityManagerFactory(entityManagerFactory)\n            .queryString(&quot;SELECT co FROM CustomerOrder co&quot;)\n            .pageSize(100)\n            .build();\n    return new AggregatePagingItemReader&lt;&gt;(itemReader);\n}\n</code></pre>\n<p><em>Class:</em></p>\n<pre class=\"lang-java prettyprint-override\"><code>public class AggregatePagingItemReader&lt;T&gt; implements ItemStreamReader&lt;List&lt;T&gt;&gt; {\n    // Wraps a JpaPagingItemReader to return a full page as List&lt;T&gt; instead of one item at a time.\n}\n</code></pre>\n<p><strong>Item processor:</strong></p>\n<pre class=\"lang-java prettyprint-override\"><code>@Component\n@StepScope\npublic class CustomerOrderItemProcessor implements ItemProcessor&lt;List&lt;CustomerOrder&gt;, List&lt;CustomerOrder&gt;&gt; {\n\n    @Override\n    public List&lt;CustomerOrder&gt; process(List&lt;CustomerOrder&gt; customerOrders) throws Exception {\n        List&lt;CustomerOrder&gt; newCustomerOrders = new ArrayList&lt;&gt;();\n        for (CustomerOrder customerOrder : customerOrders) {\n            CustomerOrder newCustomerOrder = new CustomerOrder();\n            newCustomerOrder.setName(customerOrder.getName());\n            newCustomerOrder.setProcessed(true);\n\n            Order order = customerOrder.getOrder();\n\n            Order newOrder = new Order();\n            newOrder.setDates(order.getDates()); // This line throws LazyInitializationException\n            newOrder.setSizes(order.getSizes());\n\n            newCustomerOrder.setOrder(newOrder);\n\n            newCustomerOrders.add(newCustomerOrder);\n        }\n        return newCustomerOrders;\n    }\n}\n</code></pre>\n<p><strong>Item writer:</strong></p>\n<pre class=\"lang-java prettyprint-override\"><code>@Component\n@StepScope\npublic class CustomerOrderItemWriter implements ItemWriter&lt;List&lt;CustomerOrder&gt;&gt; {\n\n    private final JpaItemWriter&lt;CustomerOrder&gt; jpaItemWriter;\n\n    public CustomerOrderItemWriter(EntityManagerFactory entityManagerFactory) {\n        jpaItemWriter = new JpaItemWriterBuilder&lt;CustomerOrder&gt;()\n                .entityManagerFactory(entityManagerFactory)\n                .build();\n    }\n\n    @Override\n    public void write(Chunk&lt;? extends List&lt;CustomerOrder&gt;&gt; chunk) {\n        List&lt;CustomerOrder&gt; customerOrders = chunk.getItems().stream().flatMap(List::stream).toList();\n        jpaItemWriter.write(new Chunk&lt;&gt;(customerOrders));\n    }\n}\n</code></pre>\n<p><strong>Step configuration:</strong></p>\n<pre class=\"lang-java prettyprint-override\"><code>@Configuration\npublic class CustomerOrderSetpConfig {\n\n    @Bean\n    public Step pocessCustomerOrderStep(JobRepository jobRepository, PlatformTransactionManager transactionManager,\n            AggregatePagingItemReader&lt;CustomerOrder&gt; customerOrderAggregateItemReader,\n            AsyncItemProcessor&lt;List&lt;CustomerOrder&gt;, List&lt;CustomerOrder&gt;&gt; customerOrderAsyncItemProcessor,\n            AsyncItemWriter&lt;List&lt;CustomerOrder&gt;&gt; customerOrderAsyncItemWriter) {\n        return new StepBuilder(&quot;pocessCustomerOrderStep&quot;, jobRepository)\n                .&lt;List&lt;CustomerOrder&gt;, Future&lt;List&lt;CustomerOrder&gt;&gt;&gt;chunk(1, transactionManager)\n                .reader(customerOrderAggregateItemReader)\n                .processor(customerOrderAsyncItemProcessor)\n                .writer(customerOrderAsyncItemWriter).build();\n    }\n\n    @Bean\n    public AsyncItemProcessor&lt;List&lt;CustomerOrder&gt;, List&lt;CustomerOrder&gt;&gt; customerOrderAsyncItemProcessor(\n            CustomerOrderItemProcessor customerOrderItemProcessor, TaskExecutor taskExecutor) {\n        AsyncItemProcessor&lt;List&lt;CustomerOrder&gt;, List&lt;CustomerOrder&gt;&gt; asyncItemProcessor = new AsyncItemProcessor&lt;&gt;();\n        asyncItemProcessor.setDelegate(customerOrderItemProcessor);\n        asyncItemProcessor.setTaskExecutor(taskExecutor);\n        return asyncItemProcessor;\n    }\n\n    @Bean\n    public AsyncItemWriter&lt;List&lt;CustomerOrder&gt;&gt; customerOrderAsyncItemWriter(\n            CustomerOrderItemWriter customerOrderItemWriter) {\n        AsyncItemWriter&lt;List&lt;CustomerOrder&gt;&gt; asyncItemWriter = new AsyncItemWriter&lt;&gt;();\n        asyncItemWriter.setDelegate(customerOrderItemWriter);\n        return asyncItemWriter;\n    }\n}\n</code></pre>\n<p><strong>What I’ve tried:</strong></p>\n<ol>\n<li>Default approach: Leads to <code>LazyInitializationException</code> when accessing the nested collections in the <code>ItemProcessor</code>.</li>\n<li>Using <code>JOIN FETCH</code> in the query: Attempting to fetch nested collections directly in the reader query causes a <code>MultipleBagFetchException</code>.</li>\n<li>Using <code>Hibernate.initialize()</code> in an <code>ItemReadListener</code>: This loads the collections in <code>afterRead()</code>, but causes an N+1 query problem.</li>\n</ol>\n<p><strong>Question:</strong></p>\n<p>How can I eagerly initialize nested lazy collections (such as <code>@ElementCollection</code>) in a Spring Batch step that uses parallel chunk processing and an aggregate <code>ItemReader</code> without running into <code>LazyInitializationException</code>, <code>MultipleBagFetchException</code>, or performance issues like N+1 selects?</p>\n<p>Is there a recommended performant way to batch-initialize nested collections in this context, possibly during the read phase, while still keeping the step thread-safe for parallel execution?</p>\n",
    "tags" : [ "java", "spring", "hibernate", "jpa", "spring-batch" ],
    "owner" : {
      "account_id" : 14179476,
      "reputation" : 2743,
      "user_id" : 10243634,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/BXR2N.png?s=256",
      "display_name" : "Oboe",
      "link" : "https://stackoverflow.com/users/10243634/oboe"
    },
    "is_answered" : true,
    "view_count" : 122,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1745539627,
    "creation_date" : 1744898015,
    "link" : "https://stackoverflow.com/questions/79579420/eagerly-load-nested-lazy-collections-in-spring-batch-with-parallel-chunk-process",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79591615,
    "question_id" : 79579420,
    "body" : "<p>After running into common pitfalls with JPA in a parallel Spring Batch step:</p>\n<ul>\n<li><code>LazyInitializationException</code> when accessing lazy collections in the <code>ItemProcessor</code> that runs outside the transaction scope</li>\n<li><code>MultipleBagFetchException</code> when trying to <code>JOIN FETCH</code> multiple collections in one query</li>\n<li>N+1 query problems when initializing collections per entity</li>\n</ul>\n<p>I implemented a custom paging <code>ItemReader</code> that eagerly loads the required collections using <strong>separate batch queries</strong> during the read phase.</p>\n<p>Here’s how it works:</p>\n<ol>\n<li>Loads a page of <code>CustomerOrder</code> entities</li>\n<li>Extracts related <code>Order</code> IDs</li>\n<li>Uses additional queries to preload <code>@ElementCollection</code> (<code>Order.dates</code>, <code>Order.sizes</code>) in batch</li>\n</ol>\n<pre class=\"lang-java prettyprint-override\"><code>public class CustomerOrderItemReader extends AbstractPagingItemReader&lt;CustomerOrder&gt; {\n\n    private final EntityManagerFactory entityManagerFactory;\n\n    private EntityManager entityManager;\n\n    public CustomerOrderItemReader(EntityManagerFactory entityManagerFactory, int pageSize) {\n        super();\n        this.entityManagerFactory = entityManagerFactory;\n        setPageSize(pageSize);\n        setName(&quot;customerOrderItemReader&quot;);\n    }\n    \n    @Override\n    public void afterPropertiesSet() throws Exception {\n        super.afterPropertiesSet();\n        Assert.state(entityManagerFactory != null, &quot;EntityManager cannot be null&quot;);\n    }\n\n    @Override\n    protected void doOpen() throws Exception {\n        super.doOpen();\n        entityManager = entityManagerFactory.createEntityManager();\n        if (entityManager == null) {\n            throw new DataAccessResourceFailureException(&quot;Unable to obtain an EntityManager&quot;);\n        }\n    }\n\n    @Override\n    protected void doReadPage() {\n        EntityTransaction tx = entityManager.getTransaction();\n        tx.begin();\n\n        entityManager.flush();\n        entityManager.clear();\n\n        if (results == null) {\n            results = new CopyOnWriteArrayList&lt;&gt;();\n        } else {\n            results.clear();\n        }\n\n        // Step 1: Fetch CustomerOrders and their Orders\n        List&lt;CustomerOrder&gt; customerOrders = entityManager.createQuery(&quot;&quot;&quot;\n                SELECT co FROM CustomerOrder co\n                LEFT JOIN co.order\n                ORDER BY co.id\n            &quot;&quot;&quot;, CustomerOrder.class)\n            .setFirstResult(getPage() * getPageSize())\n            .setMaxResults(getPageSize())\n            .getResultList();\n\n        if (customerOrders.isEmpty()) {\n            tx.commit();\n            return;\n        }\n\n        // Step 2: Fetch nested Order collections using IDs\n        List&lt;Long&gt; orderIds = customerOrders.stream()\n            .map(CustomerOrder::getOrder)\n            .map(Order::getId)\n            .distinct()\n            .toList();\n\n        // Step 3.1: Load Order.dates\n        entityManager.createQuery(&quot;&quot;&quot;\n                SELECT DISTINCT o FROM Order o\n                LEFT JOIN FETCH o.dates\n                WHERE o.id IN :orderIds\n            &quot;&quot;&quot;, Order.class)\n            .setParameter(&quot;orderIds&quot;, orderIds)\n            .getResultList();\n\n        // Step 3.2: Load Order.sizes\n        entityManager.createQuery(&quot;&quot;&quot;\n                SELECT DISTINCT o FROM Order o\n                LEFT JOIN FETCH o.sizes\n                WHERE o.id IN :orderIds\n            &quot;&quot;&quot;, Order.class)\n            .setParameter(&quot;orderIds&quot;, orderIds)\n            .getResultList();\n\n        tx.commit();\n\n        results.addAll(customerOrders);\n    }\n\n    @Override\n    protected void doClose() throws Exception {\n        entityManager.close();\n        super.doClose();\n    }\n}\n</code></pre>\n<p>Finally, register the <code>CustomerOrderItemReader</code> as an <code>AggregatePagingItemReader</code> bean:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Bean\npublic AggregatePagingItemReader&lt;CustomerOrder&gt; customerOrderAggregateItemReader(EntityManagerFactory entityManagerFactory) {\n    CustomerOrderItemReader itemReader = new CustomerOrderItemReader(entityManagerFactory, 100);\n    return new AggregatePagingItemReader&lt;&gt;(itemReader);\n}\n</code></pre>\n<p>This approach:</p>\n<ul>\n<li>Avoids <code>LazyInitializationException</code> — everything is loaded in the read phase</li>\n<li>Avoids <code>MultipleBagFetchException</code> — fetch collections in separate queries</li>\n<li>Avoids N+1 queries — batch fetch by <code>IN (:ids)</code></li>\n<li>Thread-safe for parallel chunk execution</li>\n</ul>\n",
    "score" : 1,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 14179476,
      "reputation" : 2743,
      "user_id" : 10243634,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/BXR2N.png?s=256",
      "display_name" : "Oboe",
      "link" : "https://stackoverflow.com/users/10243634/oboe"
    },
    "creation_date" : 1745539627,
    "last_activity_date" : 1745539627,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140349599,
    "post_id" : 79579420,
    "body" : "@vanOekel, as mentioned in the question, I’ve already tried using <code>JOIN FETCH</code>, but that leads to a <code>MultipleBagFetchException</code>. Changing the collections from <code>List</code> to <code>Set</code> does eliminate the exception, but it doesn’t prevent the underlying Cartesian product issue, as explained <a href=\"https://stackoverflow.com/questions/4334970/hibernate-throws-multiplebagfetchexception-cannot-simultaneously-fetch-multipl/5865605#5865605\">in this StackOverflow answer</a>. I agree that using multiple queries could be a good approach, but I’m not sure how to implement that effectively in this specific scenario.",
    "score" : 0,
    "owner" : {
      "account_id" : 14179476,
      "reputation" : 2743,
      "user_id" : 10243634,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/BXR2N.png?s=256",
      "display_name" : "Oboe",
      "link" : "https://stackoverflow.com/users/10243634/oboe"
    },
    "creation_date" : 1745027827,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140347792,
    "post_id" : 79579420,
    "body" : "The use of <code>JOIN FETCH</code> looks like the proper way to go. Turning a <code>List</code> to a <code>Set</code> or using multiple queries can solve the <code>MultipleBagFetchException</code> as described at <a href=\"https://www.baeldung.com/java-hibernate-multiplebagfetchexception\" rel=\"nofollow noreferrer\">baeldung.com/java-hibernate-multiplebagfetchexception</a>",
    "score" : 0,
    "owner" : {
      "account_id" : 3700031,
      "reputation" : 6623,
      "user_id" : 3080094,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/VDtbQ.jpg?s=256",
      "display_name" : "vanOekel",
      "link" : "https://stackoverflow.com/users/3080094/vanoekel"
    },
    "creation_date" : 1744978151,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}