{
  "question" : {
    "question_id" : 79534813,
    "title" : "Efficient way to remove unwanted characters from a string in Kotlin",
    "body" : "<p>I'm working on a kotlin project that needs to process some phone number data and convert it into a format suitable for a third party API to consume. The requirements are:</p>\n<ol>\n<li>No non-digit characters except in the case of international numbers</li>\n<li>International numbers may start with a '+' character</li>\n</ol>\n<p>It sounds simple, and in most cases it is. However there is one edge case I'm not sure how to solve. If there is a phone number with one or more unwanted characters before the '+' character, how do I filter those out without loosing the '+' as well? I could do the operation in two passes, but this is a time sensitive function that will need to be run on thousands of records. Is there a more efficient way to solve this?</p>\n<p><strong>My current function:</strong></p>\n<pre><code>fun String.convertPhoneNumber():String\n{\n    //trim leading/trailing space\n    return this.trim().filterIndexed{ index, value -&gt;\n        //trim any non-digit characters except for a leading '+'\n        (index == 0 &amp;&amp; value == '+') || value.isDigit()\n    }\n}\n</code></pre>\n<p><strong>Test code:</strong></p>\n<pre><code>@Test\nfun `test convert phone number`()\n{\n        //international numbers\n        val expectedInt = &quot;+15705554444&quot;\n        val phone7 = &quot;+15705554444&quot;\n        assertThat(phone7.convertPhoneNumber()).isEqualTo(expectedInt)\n\n        val phone8 = &quot; + 1 570-555 4444&quot;\n        assertThat(phone8.convertPhoneNumber()).isEqualTo(expectedInt)\n\n        //this test will fail\n        val phone9 = &quot; (+1)57055554444&quot;\n        assertThat(phone9.convertPhoneNumber()).isEqualTo(expectedInt)\n}\n</code></pre>\n",
    "tags" : [ "java", "regex", "string", "kotlin", "replace" ],
    "owner" : {
      "account_id" : 2090213,
      "reputation" : 1839,
      "user_id" : 1860222,
      "user_type" : "registered",
      "accept_rate" : 52,
      "profile_image" : "https://www.gravatar.com/avatar/dcd9cf0881ee1e7a5f28175308628e25?s=256&d=identicon&r=PG",
      "display_name" : "pbuchheit",
      "link" : "https://stackoverflow.com/users/1860222/pbuchheit"
    },
    "is_answered" : true,
    "view_count" : 101,
    "answer_count" : 2,
    "score" : 3,
    "last_activity_date" : 1742977079,
    "creation_date" : 1742934775,
    "link" : "https://stackoverflow.com/questions/79534813/efficient-way-to-remove-unwanted-characters-from-a-string-in-kotlin",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79535775,
    "question_id" : 79534813,
    "body" : "<p>This regex pattern keeps the first <code>+</code> (if located before any digits). Retains  all digits. Removes all non-digit characters, including <code>+</code> characters in between digits.</p>\n<p>REGEX PATTERN <em>(Java 8 regex flavor, flags: g)</em>:</p>\n<pre><code>(?:^[^\\d+]*(\\+))|\\D\n</code></pre>\n<p>REPLACEMENT STRING:</p>\n<pre><code>$1\n</code></pre>\n<p><em>Regex Demo:</em> <a href=\"https://regex101.com/r/y7esly/10\" rel=\"nofollow noreferrer\">https://regex101.com/r/y7esly/10</a>\n<em>(Note: In the multiline test string demo, added to the newline character (<code>\\n</code>) alternative into the pattern (<code>|\\n|</code>), and <code>$2</code> into the replacement (substitution) string, to keep the lines. <code>\\|n</code> and <code>$2</code> are removed from the actual response, where we are not dealing with multiline input.)</em></p>\n<p>TRY:</p>\n<pre><code># Syntax from comment to Question by @Wiktor Stribiżew:\nreturn this.replace(&quot;&quot;&quot;(?:^[^\\d+]*(\\+))|\\D&quot;&quot;&quot;.toRegex(), &quot;$1&quot;\n</code></pre>\n<p>TEST STRINGS:</p>\n<pre><code>+15705554444\n+15705554444\n+ 1 570-555 4444\n(+1)57055554444\n(+1)570555-54444\n(1)57055554444\n(1)5705555+4444\n(1)+5705555+4444\n(+1)(570)555 5+4444\n1570+555+4444\n15705554444+9\n</code></pre>\n<p>RETURNS:</p>\n<pre><code>+15705554444\n+15705554444\n+15705554444\n+157055554444\n+157055554444\n157055554444\n157055554444\n157055554444\n+157055554444\n15705554444\n157055544449\n</code></pre>\n<p>REGEX NOTES:</p>\n<ul>\n<li><code>(?:</code> Begin the <em>first alternative</em>. <em>Non-capturing group</em> <code>(?:...)</code> used to explicitly distinguish the <em>alternative</em> on the left side of the or (<code>|</code>).\n<ul>\n<li><code>^</code> Match the beginning of the string.</li>\n<li><code>[^\\d+]*</code> <em>Negated character class</em> <code>[^...]</code>. Matches any character that is not a digit <code>\\d</code> or literal <code>+</code> 0 or more times (<code>*</code>).</li>\n<li><code>(\\+)</code> First <em>capture group</em> <code>(...)</code>. The character(s) in this group are retrieved  with <code>$1</code> in the replacement string. Matches literal <code>+</code> (<code>+</code> is a special character in regex, so it should be escaped outside a character class, (<code>\\+</code>).</li>\n</ul>\n</li>\n<li><code>)</code> Close <em>first alternative</em>.</li>\n<li><code>|</code> <strong>OR</strong> in <em>alternation</em> <code>...|...</code>. Regex engine tries to match the alternatives from left to right.</li>\n<li><code>\\D</code> The <em>second alternative</em>. Matches any character that is NOT a digit (<code>\\d</code>). <em>(Note: <code>\\D</code> matches a newline character. This why in the regex demo (link) I added <code>|\\n</code> to the pattern and <code>$2</code> to the replacement string, to keep the lines separate for clarity.)</em></li>\n</ul>\n<p>REPLACEMENT STRING:</p>\n<ul>\n<li>Replacement string tells the regex engine how the match should be replaced.  In this case:\n<ul>\n<li>If we match the <em>first alternative</em>, we replace it with the characters stored in <em>capture group</em>, or <em>'group',</em> 1, <code>$1</code>. All other matched characters are replaced with nothing, i.e. deleted from the string.</li>\n<li>If we match the <em>second alternative</em>, we replace the match with nothing. This is how we remove the non-digit characters from the string.</li>\n<li>Note, we do not match (or replace, or touch) any digits <code>\\d</code>:</li>\n</ul>\n</li>\n<li>The first capture group reference, <code>$1</code>: If there is a match for the <em>first alternative</em>, all matched non-digit, non-plus characters before the first <code>+</code> are replaced with nothing (i.e. they are effectively deleted from the string). Only the <code>+</code> is kept, because the characters matched with the first capture group, <code>(\\+)</code>, are contained the <em>group 1</em>, <code>$1</code>.  If the <em>first alternative</em> does not match the first capture group <code>$1</code> represents and empty string, &quot;&quot;.</li>\n<li>When there is a match for the <em>second alternative</em>, i.e. a non-digit character <code>\\D</code>, replace it with <em>nothing</em>.  This effectively removes any non-digit characters from the string, except the first <code>+</code> located before any digits.</li>\n</ul>\n",
    "score" : 3,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 25794356,
      "reputation" : 846,
      "user_id" : 19537838,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/e2aecbb99a302f70f711caf20ba0e1fd?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "rich neadle",
      "link" : "https://stackoverflow.com/users/19537838/rich-neadle"
    },
    "creation_date" : 1742977079,
    "last_activity_date" : 1742977079,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79534827,
    "question_id" : 79534813,
    "body" : "<p>I'd implement it using regex</p>\n<pre><code>fun String.convertPhoneNumber(): String {\n    return this.replace(&quot;[^+\\\\d]&quot;.toRegex(), &quot;&quot;)\n}\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 11555562,
      "reputation" : 569,
      "user_id" : 8466853,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/cd7f72b426ce3c46739900b8ba014e26?s=256&d=identicon&r=PG",
      "display_name" : "Arno",
      "link" : "https://stackoverflow.com/users/8466853/arno"
    },
    "creation_date" : 1742935243,
    "last_activity_date" : 1742935243,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140265180,
    "post_id" : 79534813,
    "body" : "If performance really, really is an issue, iterate the string in a loop and set a bool flag (initialized to <code>false</code>) to <code>digitsStarted = digitsStarted or currentChar.isDigit()</code> in each iteration. Only allow a <code>+</code> if <code>digitsStarted</code> is <code>false</code>.",
    "score" : 0,
    "owner" : {
      "account_id" : 1013460,
      "reputation" : 8690,
      "user_id" : 1025555,
      "user_type" : "registered",
      "accept_rate" : 100,
      "profile_image" : "https://i.sstatic.net/GBIIj.png?s=256",
      "display_name" : "Good Night Nerd Pride",
      "link" : "https://stackoverflow.com/users/1025555/good-night-nerd-pride"
    },
    "creation_date" : 1742989025,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140262779,
    "post_id" : 79534813,
    "body" : "Yeah, try <code>return this.replace(&quot;&quot;&quot;^[^+]*(\\+)|\\D+&quot;&quot;&quot;.toRegex(), &quot;$1&quot;)</code>",
    "score" : 2,
    "owner" : {
      "account_id" : 4739783,
      "reputation" : 630987,
      "user_id" : 3832970,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/IFOp5.jpg?s=256",
      "display_name" : "Wiktor Stribiżew",
      "link" : "https://stackoverflow.com/users/3832970/wiktor-stribi%c5%bcew"
    },
    "creation_date" : 1742935348,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140262770,
    "post_id" : 79534813,
    "body" : "Thousands of records doesn&#39;t sound like a lot at all.  If you really need performance, I would never use any built-in functions, but thousands of records is nothing unless you&#39;re handling thousands of records many times per second.",
    "score" : 2,
    "owner" : {
      "account_id" : 465573,
      "reputation" : 200423,
      "user_id" : 869736,
      "user_type" : "registered",
      "accept_rate" : 82,
      "profile_image" : "https://www.gravatar.com/avatar/ae7bb06b9a23a4dd7eea69e853d47d12?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Louis Wasserman",
      "link" : "https://stackoverflow.com/users/869736/louis-wasserman"
    },
    "creation_date" : 1742935003,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}