{
  "question" : {
    "question_id" : 79622707,
    "title" : "Why doesn&#39;t my Gatherer short-circuit the Stream if the source is an IntStream?",
    "body" : "<p>I'm playing around with Stream Gatherers, which were introduced (or, at least, lost preview-status) in Java 24. As an exercise, I implemented my own version of the <code>limit</code> intermediate operation:</p>\n<pre><code>public class LimitDemo {\n\n    private static class State {\n        int count;\n    }\n\n    static &lt;T&gt; Gatherer&lt;T, ?, T&gt; limit(int size) {\n        Supplier&lt;State&gt; initializer = State::new;\n        Gatherer.Integrator&lt;State, T, T&gt; integrator = (state, element, downstream) -&gt; {\n            if (++state.count &gt; size) {\n                return false;\n            }\n            return downstream.push(element);\n        };\n        return Gatherer.ofSequential(initializer, integrator);\n    }\n\n    public static void main(String[] args) {\n        var rng = new Random();\n        var result = \n            Stream.generate(() -&gt; rng.nextInt(10)) // here\n            .gather(limit(10))\n            .toList();\n        System.out.println(result);\n    }\n}\n</code></pre>\n<p>This works very well: a list of 10 random numbers is printed on the screen, as I expected. The infinite stream of random Integers is short-circuited.</p>\n<p>However, if I generate the infinite stream in another way, it doesn't work anymore. If I replace the line marked <code>// here</code> with</p>\n<pre><code>rng.ints(0, 10).boxed()\n</code></pre>\n<p>then my program terminates with an OutOfMemoryException. Apparently, the IntStream generated by the <code>Random</code> instance doesn't notice that my Gatherer short-circuits. Of course, when I use the standard <code>limit</code> instead of my custom one, it works in both cases.</p>\n<p>What am I missing?</p>\n",
    "tags" : [ "java", "java-stream", "java-24" ],
    "owner" : {
      "account_id" : 5174533,
      "reputation" : 13154,
      "user_id" : 4142130,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/164f6e8d8691de95326965a42bfe8fab?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Hoopje",
      "link" : "https://stackoverflow.com/users/4142130/hoopje"
    },
    "is_answered" : true,
    "view_count" : 610,
    "answer_count" : 1,
    "score" : 17,
    "last_activity_date" : 1748502914,
    "creation_date" : 1747288948,
    "link" : "https://stackoverflow.com/questions/79622707/why-doesnt-my-gatherer-short-circuit-the-stream-if-the-source-is-an-intstream",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79643092,
    "question_id" : 79622707,
    "body" : "<p>As has been explained in the comments, this is definitely a bug. More\ninformation can be found at:</p>\n<ul>\n<li><a href=\"https://mail.openjdk.org/pipermail/core-libs-dev/2025-May/146592.html\" rel=\"nofollow noreferrer\">https://mail.openjdk.org/pipermail/core-libs-dev/2025-May/146592.html</a></li>\n<li><a href=\"https://bugs.openjdk.org/browse/JDK-8357647\" rel=\"nofollow noreferrer\">JDK-8357647 - Stream gatherers forward upstream size information to downstream</a></li>\n</ul>\n<p>The bug was created in response to the mailing list, which itself was created\nin response to this question. It was created by Viktor Klang who is the owner\nof <a href=\"https://openjdk.org/jeps/485\" rel=\"nofollow noreferrer\">JEP 485: Stream Gatherers</a>.</p>\n<p>As the title of the bug explains, the problem is that the gather operation\nforwards the upstream size to downstream. This shouldn't happen because a gatherer has no way to report ahead-of-time how many elements it's going to\npush downstream, if it even knows. Luckily, this bug has already been fixed for Java 25. See <a href=\"https://github.com/openjdk/jdk/commit/aea32ec5060a2e57947dc3e5d14613241e223ce4\" rel=\"nofollow noreferrer\">this commit</a>.</p>\n<p>Forwarding the size information downstream causes the stream operation in your example to\ntry to perform some optimizations. Mainly, it tries to allocate enough space\nfor the elements ahead-of-time to avoid having to resize some internal buffers.\nBut you have an infinite stream and so the upstream size, as reported by the\nsource <code>Spliterator</code>, is <code>Long.MAX_VALUE</code> (at least when the <code>Spliterator</code> has\nthe <code>SIZED</code> characteristic). And you don't have enough memory to allocate the\nbuffers needed to hold that number of elements.</p>\n<p>This means the problem isn't that the stream isn't short-circuiting. The stream\noperation is failing before it even starts processing the first element. It\ndoesn't have a chance to short-circuit.</p>\n<p>But the gatherer bug is independent of how the stream is created. So why do you\nonly see the <code>OutOfMemoryError</code> with <code>Random::ints(int,int)</code> and not\n<code>Stream::generate(Supplier)</code>? This has to do with the source <code>Spliterator</code>\nbeing used by each stream. In the former's case, the <code>Spliterator</code> reports\nitself as <code>SIZED</code>, whereas in the latter's case it does not. This is mentioned\nin the mailing list:</p>\n<blockquote>\n<p>However, there's an argument to be made that an unbounded Spliterator (as\nobtained by Random::ints(â€¦)) should not report the SIZED and SUBSIZED\ncharacteristics, as it is indeed not sized. I'll open a separate Issue for\nthat next week.</p>\n</blockquote>\n<p>That <em>separate</em> bug may have been created already, but I didn't see it.\nRegardless, I'd indeed argue an infinite <code>Spliterator</code> should not report itself\nas <code>SIZED</code> based on <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/Spliterator.html#SIZED\" rel=\"nofollow noreferrer\">the documentation</a> (<strong>emphasis</strong> mine):</p>\n<blockquote>\n<p>Characteristic value signifying that the value returned from <code>estimateSize()</code>\nprior to traversal or splitting represents a <strong>finite size</strong> that, in the\nabsence of structural source modification, represents an <strong>exact count of</strong> the\nnumber of elements that would be encountered by a complete traversal.</p>\n</blockquote>\n<p>You can see that the <code>Spliterator</code> having the <code>SIZED</code> characteristic combined\nwith the gatherer bug is what leads to the <code>OutOfMemoryError</code> by creating\nyour own version of <code>Stream::generate(Supplier)</code>. See the following example.</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.util.Objects;\nimport java.util.Random;\nimport java.util.Spliterator;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\nimport java.util.stream.Gatherer;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\npublic class Main {\n\n  public static void main(String[] args) {\n    var rng = new Random();\n\n    System.out.println(&quot;Using Stream::generate&quot;);\n    var list = Stream.generate(rng::nextInt).gather(limit(10L)).toList();\n    System.out.println(list);\n    System.out.println();\n\n    System.out.println(&quot;Using Main::sizedGenerate&quot;);\n    list = sizedGenerate(rng::nextInt).gather(limit(10L)).toList();\n    System.out.println(list);\n    System.out.println();\n  }\n\n  static &lt;T&gt; Gatherer&lt;T, ?, T&gt; limit(long limit) {\n    if (limit &lt; 0) throw new IllegalArgumentException();\n\n    class State { long count; }\n    Gatherer.Integrator&lt;State, T, T&gt; integrator =\n        Gatherer.Integrator.of(\n            (state, element, downstream) -&gt; {\n              if (++state.count &gt;= limit) return false;\n              return downstream.push(element);\n            });\n    return Gatherer.ofSequential(State::new, integrator);\n  }\n\n  static &lt;T&gt; Stream&lt;T&gt; sizedGenerate(Supplier&lt;? extends T&gt; supplier) {\n    return StreamSupport.stream(new GeneratingSpliterator&lt;&gt;(supplier), false);\n  }\n\n  // Essentially the same as the Spliterator used by Stream::generate(Supplier), but\n  // has IMMUTABLE and SIZED characteristics instead of just IMMUTABLE.\n  static class GeneratingSpliterator&lt;T&gt; implements Spliterator&lt;T&gt; {\n\n    private final Supplier&lt;? extends T&gt; supplier;\n    private long estimate;\n\n    GeneratingSpliterator(Supplier&lt;? extends T&gt; supplier) {\n      this.supplier = Objects.requireNonNull(supplier);\n      this.estimate = Long.MAX_VALUE;\n    }\n\n    private GeneratingSpliterator(Supplier&lt;? extends T&gt; supplier, long estimate) {\n      this.supplier = supplier;\n      this.estimate = estimate;\n    }\n\n    @Override\n    public boolean tryAdvance(Consumer&lt;? super T&gt; action) {\n      action.accept(supplier.get());\n      return true;\n    }\n\n    @Override\n    public Spliterator&lt;T&gt; trySplit() {\n      if (estimate == 0L) return null;\n      return new GeneratingSpliterator&lt;&gt;(supplier, estimate &gt;&gt;&gt;= 1);\n    }\n\n    @Override\n    public long estimateSize() {\n      return estimate;\n    }\n\n    @Override\n    public int characteristics() {\n      return IMMUTABLE | SIZED;\n    }\n  }\n}\n</code></pre>\n<p>Output:</p>\n<pre class=\"lang-none prettyprint-override\"><code>Using Stream::generate\n[1181200022, 1865178467, -727320699, 1587704041, -973737573, -868155800, -851856196, 781133979, 1084548654]\n\nUsing Main::sizedGenerate\nException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space\n        at java.base/java.util.stream.SpinedBuffer.ensureCapacity(SpinedBuffer.java:143)\n        at java.base/java.util.stream.Nodes$SpinedNodeBuilder.begin(Nodes.java:1281)\n        at java.base/java.util.stream.GathererOp$GatherSink.begin(GathererOp.java:153)\n        at java.base/java.util.stream.AbstractPipeline.copyIntoWithCancel(AbstractPipeline.java:587)\n        at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:574)\n        at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:560)\n        at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:636)\n        at java.base/java.util.stream.AbstractPipeline.evaluateToArrayNode(AbstractPipeline.java:291)\n        at java.base/java.util.stream.ReferencePipeline.toArray(ReferencePipeline.java:656)\n        at java.base/java.util.stream.ReferencePipeline.toArray(ReferencePipeline.java:662)\n        at java.base/java.util.stream.ReferencePipeline.toList(ReferencePipeline.java:667)\n        at com.gitlab.tkslaw.workshop.Main.main(Main.java:23)\n</code></pre>\n",
    "score" : 6,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49884,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1748472401,
    "last_activity_date" : 1748502914,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140475579,
    "post_id" : 79622707,
    "body" : "@VC.One I didn&#39;t know about the back and forth with Chen, all I know was that Chen was involved. But yes, glad that they were able to see and fix the bug. I have reported at least 2 other bugs in the past regarding Streams and Gatherers, and in both cases, Viktor was very kind and quick to identify the issue, so no surprise that this time around was quite similar. OpenJDK folks are good at their job.",
    "score" : 1,
    "owner" : {
      "account_id" : 14010051,
      "reputation" : 250,
      "user_id" : 10118965,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/61afd55894624ae8f6e4189b68db1f30?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "davidalayachew",
      "link" : "https://stackoverflow.com/users/10118965/davidalayachew"
    },
    "creation_date" : 1748717217,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140474567,
    "post_id" : 79622707,
    "body" : "PS: Initially I could not test the Gatherer API. Tested on a (no such API) online Java compiler. I saw that it <b>still</b> did an OOME for <code>ints()</code> even if <code>Gather</code> was replaced by a <code>For Each</code>. That&#39;s why I was adamant that we don&#39;t blame the Gatherer side as the main culprit. I was seeing that there&#39;s something inherent in the return of <code>ints()</code> that makes it unusable in the next step, especially if the next step was iterating (I suspect even to try adding a limit, might still be ignored). The nearest likely solution was to declare the <code>ints()</code> with a limit size eg: <code>ints( myLimit, 0 , 10 );</code>",
    "score" : 0,
    "owner" : {
      "account_id" : 2348025,
      "reputation" : 16157,
      "user_id" : 2057709,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/0R41X.png?s=256",
      "display_name" : "VC.One",
      "link" : "https://stackoverflow.com/users/2057709/vc-one"
    },
    "creation_date" : 1748679948,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140474562,
    "post_id" : 79622707,
    "body" : "@davidalayachew I&#39;ll tell you what happened... The community convinced Viktor he had coded a tool with a mistake. He (correctly) couldn&#39;t find a problem in his &quot;not broken&quot; system so he needed a second opinion from Chen Liang and etc. Kudos to him for accepting it. I would&#39;ve said &quot;futsek&quot; and &quot;Don&#39;t use  boxed IntStreams next time&quot;. All is good because a fix was found and so at least, one more thing in this world is made more robust and we cannot say no to that. Congrats for finding a bug.",
    "score" : 0,
    "owner" : {
      "account_id" : 2348025,
      "reputation" : 16157,
      "user_id" : 2057709,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/0R41X.png?s=256",
      "display_name" : "VC.One",
      "link" : "https://stackoverflow.com/users/2057709/vc-one"
    },
    "creation_date" : 1748679799,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140466395,
    "post_id" : 79622707,
    "body" : "@DuncG They might not want to use <code>AtomicInteger</code> as that conveys the semantic of it being supposed to be atomic.",
    "score" : 0,
    "owner" : {
      "account_id" : 15064163,
      "reputation" : 17100,
      "user_id" : 10871900,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/720202b6e19abc330dcd92e6a1254562?s=256&d=identicon&r=PG",
      "display_name" : "dan1st",
      "link" : "https://stackoverflow.com/users/10871900/dan1st"
    },
    "creation_date" : 1748442290,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140465946,
    "post_id" : 79622707,
    "body" : "Unrelated to the problem, you can shorten your limit() method to one line <code>return Gatherer.ofSequential(AtomicInteger::new, (state, element, downstream) -&gt; state.incrementAndGet() &lt;= size &amp;&amp; downstream.push(element))</code>",
    "score" : 1,
    "owner" : {
      "account_id" : 5998820,
      "reputation" : 16283,
      "user_id" : 4712734,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f6e922a2cb7e2da59286f27b162aaca5?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "DuncG",
      "link" : "https://stackoverflow.com/users/4712734/duncg"
    },
    "creation_date" : 1748435111,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140464480,
    "post_id" : 79622707,
    "body" : "@VC.One I already spoke with Viktor Klang himself, the man who <b><i>built</i></b> the <code>Gatherer</code> and <code>Gatherers</code> classes. Viktor confirmed that is indeed a bug, and he has already fixed it, with the help of Chen Liang (and maybe others). Here is the fix -- <a href=\"https://bugs.openjdk.org/browse/JDK-8357647\" rel=\"nofollow noreferrer\">bugs.openjdk.org/browse/JDK-8357647</a>. They fixed it after I offered the bounty. Before then, I had just wanted to create this bounty in order to get enough of the gurus eyes on it, so that they could sanity check if this was a bug. Now that they have confirmed that this is a bug, the bounty has more or less done its job even when unrewarded.",
    "score" : 5,
    "owner" : {
      "account_id" : 14010051,
      "reputation" : 250,
      "user_id" : 10118965,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/61afd55894624ae8f6e4189b68db1f30?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "davidalayachew",
      "link" : "https://stackoverflow.com/users/10118965/davidalayachew"
    },
    "creation_date" : 1748398421,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140463791,
    "post_id" : 79622707,
    "body" : "@VC.One No there&#39;s nothing wrong with using that method just like there&#39;s nothing wrong with using <code>ints()</code> there - streams are lazily evaluated and the <code>.limit()</code> as well as <code>.gather(limit())</code> should ensure that only the necessary elements are evaluated. The bug (as we already know) is that gatherers preserve the size information from the source which they shouldn&#39;t. See the PR linked above. The second limit shouldn&#39;t be needed. You can also just use a <code>filter(_ -&gt; true)</code> instead and it will work.",
    "score" : 3,
    "owner" : {
      "account_id" : 15064163,
      "reputation" : 17100,
      "user_id" : 10871900,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/720202b6e19abc330dcd92e6a1254562?s=256&d=identicon&r=PG",
      "display_name" : "dan1st",
      "link" : "https://stackoverflow.com/users/10871900/dan1st"
    },
    "creation_date" : 1748374163,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140463751,
    "post_id" : 79622707,
    "body" : "@dan1st correction: meant <i>&quot;second limit&quot;</i> not <i>&quot;second OOME&quot;</i>. Sorry to bother you but I&#39;m learning from you so... Do you think there&#39;s anything wrong with using <code>Stream&lt;Integer&gt; result = Stream.generate( () -&gt; rng.nextInt(10) ).limit(10);</code> as a way to get a boxed result of 10 random int values? The logic is that the Gatherer would not need a second limit for <code>ints()</code> and also <code>ints()</code> is really the wrong input for the expected output (of 10 random ints). Should we be checking why a second limit just somehow quietens the OOME? Feels strange to use it as a natural solution.",
    "score" : 0,
    "owner" : {
      "account_id" : 2348025,
      "reputation" : 16157,
      "user_id" : 2057709,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/0R41X.png?s=256",
      "display_name" : "VC.One",
      "link" : "https://stackoverflow.com/users/2057709/vc-one"
    },
    "creation_date" : 1748373220,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140463674,
    "post_id" : 79622707,
    "body" : "@dan1st I hear you. You&#39;re saying its <code>var result = rng.ints(0, 10).boxed()</code>. I mis-read it as meaning <code>Stream.generate(() -&gt; rng.ints(0, 10).boxed())</code>. Since <code>ints()</code> returns an IntStream, what does the OP want? <code>var result = 10 IntStreams;</code>? We think there is a bug because a result of 10 infinite IntStreams is not responding to a limit set by some Gatherer? <b>PS:</b> Interesting about the second OOME. I cannot test at the moment. Does the result have 10 random int values or not? I think using <code>ints()</code> was supposed to be a shortcut for 10 ints via <code>Stream.generate(() -&gt; rng.nextInt(10))</code>?",
    "score" : 0,
    "owner" : {
      "account_id" : 2348025,
      "reputation" : 16157,
      "user_id" : 2057709,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/0R41X.png?s=256",
      "display_name" : "VC.One",
      "link" : "https://stackoverflow.com/users/2057709/vc-one"
    },
    "creation_date" : 1748371567,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140463620,
    "post_id" : 79622707,
    "body" : "They aren&#39;t passing an infinite stream to <code>generate()</code> - they are using <code>ints()</code> <i>instead of</i>  <code>Stream.generate</code>. The OOME is specifically because of their limit gatherer not short-circuiting which you can easily see by adding another <code>limit()</code> and observing that the OOME is no longer thrown.",
    "score" : 1,
    "owner" : {
      "account_id" : 15064163,
      "reputation" : 17100,
      "user_id" : 10871900,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/720202b6e19abc330dcd92e6a1254562?s=256&d=identicon&r=PG",
      "display_name" : "dan1st",
      "link" : "https://stackoverflow.com/users/10871900/dan1st"
    },
    "creation_date" : 1748369822,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140463570,
    "post_id" : 79622707,
    "body" : "@dan1st <i>&quot;Is supposed to work regardless of the size of the source&quot;</i> I hear you and that&#39;s why people think it&#39;s a bug, right? I am countering with common sense and throwing in another logic that says: <code>ints()</code> returns an <code>IntStream</code> which is an infinite Stream. Using this &quot;infinite&quot; result itself as input to <code>Stream.generate</code> (which also gives a new infinite Stream as own result ) is going to create a memory problem. The <b>Gatherer</b> doesn&#39;t even matter at this point, you&#39;re in a feedback loop of &quot;infinite trying to contain infinite&quot;...",
    "score" : 0,
    "owner" : {
      "account_id" : 2348025,
      "reputation" : 16157,
      "user_id" : 2057709,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/0R41X.png?s=256",
      "display_name" : "VC.One",
      "link" : "https://stackoverflow.com/users/2057709/vc-one"
    },
    "creation_date" : 1748368903,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140463536,
    "post_id" : 79622707,
    "body" : "@davidalayachew PS: Also notice that <code>nextInt</code> returns <code>int</code> data type but then <code>ints()</code> returns <code>IntStream</code> data type? It makes sense to me why a Stream of <code>int</code> works with a <code>limit</code> but an unlimited Stream of <code>IntStream</code> creates an issue. It&#39;s like one is putting &quot;infinite inside infinite&quot; and that is why it causes an <b>Out Of Memory</b> exception. There is no bug, just don&#39;t put an <code>IntStream</code> (naturally infinite) where actually finite <code>int</code> is the expected input.",
    "score" : 0,
    "owner" : {
      "account_id" : 2348025,
      "reputation" : 16157,
      "user_id" : 2057709,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/0R41X.png?s=256",
      "display_name" : "VC.One",
      "link" : "https://stackoverflow.com/users/2057709/vc-one"
    },
    "creation_date" : 1748368232,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140463520,
    "post_id" : 79622707,
    "body" : "@VC.One This isn&#39;t really what the question is about. It&#39;s that implementing a short-circuiting limit with gatherers is supposed to work regardless of the size of the source and what the sink does. And it is a bug as you can see in the JBS issue and the now integrated PR.",
    "score" : 2,
    "owner" : {
      "account_id" : 15064163,
      "reputation" : 17100,
      "user_id" : 10871900,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/720202b6e19abc330dcd92e6a1254562?s=256&d=identicon&r=PG",
      "display_name" : "dan1st",
      "link" : "https://stackoverflow.com/users/10871900/dan1st"
    },
    "creation_date" : 1748367839,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140463508,
    "post_id" : 79622707,
    "body" : "@davidalayachew I tried to point out in my somehow hidden Answer that this is not a bug but a mis-understanding of the difference in data types. Using <code>nextInt()</code> gives <code>int</code> primitives into your infinite Stream. This former will respond to a limit. However, using <code>ints()</code> gives instead an <b>unlimited stream</b> of <code>int</code> primitives into your infinite Stream. This latter will cause an Out of Memory exception since is worst data type. To me it seems natural putting infinite length <code>ints()</code> inside infinite container <code>Stream.generate() </code>would cause some memory/storage issues as a real world result.",
    "score" : 0,
    "owner" : {
      "account_id" : 2348025,
      "reputation" : 16157,
      "user_id" : 2057709,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/0R41X.png?s=256",
      "display_name" : "VC.One",
      "link" : "https://stackoverflow.com/users/2057709/vc-one"
    },
    "creation_date" : 1748367543,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140457044,
    "post_id" : 79622707,
    "body" : "@ozkanpakdil I guess we&#39;d need Viktor Klang to write an answer once <a href=\"https://github.com/openjdk/jdk/pull/25418\" rel=\"nofollow noreferrer\">the PR</a> is integrated \uD83D\uDE02 - that aside, I think finding issues people face with Open Source tools and IDEs on Stack Overflow (and similar sites) and implementing solutions (or fixing corresponding bugs) and writing an answer explaining where the issue comes from, how and when/where it was fixed is a legitimate way to farm reputation on Stack Overflow and similar sites (though probably not that efficient in most cases when there&#39;s no bounty).",
    "score" : 2,
    "owner" : {
      "account_id" : 15064163,
      "reputation" : 17100,
      "user_id" : 10871900,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/720202b6e19abc330dcd92e6a1254562?s=256&d=identicon&r=PG",
      "display_name" : "dan1st",
      "link" : "https://stackoverflow.com/users/10871900/dan1st"
    },
    "creation_date" : 1748175783,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140456993,
    "post_id" : 79622707,
    "body" : "a missed bounty :) but turned to be a good bug report, I like SO \uD83E\uDD13",
    "score" : 0,
    "owner" : {
      "account_id" : 58650,
      "reputation" : 4945,
      "user_id" : 175554,
      "user_type" : "registered",
      "accept_rate" : 40,
      "profile_image" : "https://i.sstatic.net/KmFczdGy.jpg?s=256",
      "display_name" : "ozkanpakdil",
      "link" : "https://stackoverflow.com/users/175554/ozkanpakdil"
    },
    "creation_date" : 1748173251,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140453231,
    "post_id" : 79622707,
    "body" : "The bug that Viktor Klang created based on this: <a href=\"https://bugs.openjdk.org/browse/JDK-8357647\" rel=\"nofollow noreferrer\">bugs.openjdk.org/browse/JDK-8357647</a>",
    "score" : 5,
    "owner" : {
      "account_id" : 1211967,
      "reputation" : 9964,
      "user_id" : 1180351,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
      "display_name" : "Rob Spoor",
      "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
    },
    "creation_date" : 1748014321,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140452343,
    "post_id" : 79622707,
    "body" : "I have added this question to the Core Libs Dev Mailing List -- <a href=\"https://mail.openjdk.org/pipermail/core-libs-dev/2025-May/146592.html\" rel=\"nofollow noreferrer\">mail.openjdk.org/pipermail/core-libs-dev/2025-May/146592.htm&zwnj;&#8203;l</a>",
    "score" : 3,
    "owner" : {
      "account_id" : 14010051,
      "reputation" : 250,
      "user_id" : 10118965,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/61afd55894624ae8f6e4189b68db1f30?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "davidalayachew",
      "link" : "https://stackoverflow.com/users/10118965/davidalayachew"
    },
    "creation_date" : 1747997192,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140427549,
    "post_id" : 79622707,
    "body" : "most probably a bug - second snippet is using a <code>RandomIntsSpliterator</code> which is <code>SplitIterator.SIZED</code> and returns an etimated size of <code>Long.MAX_VALUE</code> - <code>toList()</code>/<code>toArray()</code> uses this size to create the list",
    "score" : 5,
    "owner" : {
      "account_id" : 31180,
      "reputation" : 29752,
      "user_id" : 85421,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/kKvXH.gif?s=256",
      "display_name" : "user85421",
      "link" : "https://stackoverflow.com/users/85421/user85421"
    },
    "creation_date" : 1747291236,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79643092" : [ {
      "comment_id" : 140472494,
      "post_id" : 79643092,
      "body" : "If Viktor gives an answer, I can always change acceptance, but for now I&#39;ll accept yours. Thank you very much for your clear answer!",
      "score" : 2,
      "owner" : {
        "account_id" : 5174533,
        "reputation" : 13154,
        "user_id" : 4142130,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/164f6e8d8691de95326965a42bfe8fab?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Hoopje",
        "link" : "https://stackoverflow.com/users/4142130/hoopje"
      },
      "creation_date" : 1748609456,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140468782,
      "post_id" : 79643092,
      "body" : "I agree you should wait for Viktor. They would deserve the bounty and answer acceptance. I mostly just wanted to show, with an example, how the <code>SIZED</code> characteristic interacted with the gatherer bug, as that helps explain the differences in behavior the OP found. (sorry for reposted comment; felt there was some poor wording in previous one).",
      "score" : 1,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49884,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1748509852,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140467785,
      "post_id" : 79643092,
      "body" : "Also, excellent example with the <code>Stream::generate</code> and the custom <code>Spliterator</code>. Those are the very classes used to create Streams internally, so thisbis very useful to see how the guts ebb and flow to creating the bug in question.",
      "score" : 0,
      "owner" : {
        "account_id" : 14010051,
        "reputation" : 250,
        "user_id" : 10118965,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/61afd55894624ae8f6e4189b68db1f30?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "davidalayachew",
        "link" : "https://stackoverflow.com/users/10118965/davidalayachew"
      },
      "creation_date" : 1748472656,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140467774,
      "post_id" : 79643092,
      "body" : "I&#39;m holding out fot Viktor himself to come on amd give an answer lol. But if he doesn&#39;t, I&#39;ll hand the bounty to you.",
      "score" : 2,
      "owner" : {
        "account_id" : 14010051,
        "reputation" : 250,
        "user_id" : 10118965,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/61afd55894624ae8f6e4189b68db1f30?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "davidalayachew",
        "link" : "https://stackoverflow.com/users/10118965/davidalayachew"
      },
      "creation_date" : 1748472479,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}