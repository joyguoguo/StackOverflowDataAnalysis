{
  "question" : {
    "question_id" : 79718348,
    "title" : "How to add a &quot;Class-Path&quot; entry to a Jar manifest in Gradle compatible with the configuration cache?",
    "body" : "<p>I'm using Gradle (currently V8.9) to create JAR files with a &quot;Class-Path&quot; entry in the manifest that points to all JARs on the respective project's runtimeClasspath. How to do this has been answered several times, but always years ago (e.g., <a href=\"https://stackoverflow.com/questions/22659463/add-classpath-in-manifest-using-gradle\">Add classpath in manifest using Gradle</a>). Here's the Groovy build script snippet that I used successfully for several years now (for all Java subprojects in a multi-project build):</p>\n<pre><code>    jar.doFirst {\n        manifest {\n            if (!configurations.runtimeClasspath.empty) {\n                attributes('Class-Path':configurations.runtimeClasspath*.name.join(' '))\n            }\n        }\n    }\n</code></pre>\n<p>Now, I want to enable the &quot;configuration cache&quot;. If I do so, Gradle (correctly) complains that I access a configuration during execution time: <code> Cannot reference a Gradle script object from a Groovy closure as these are not supported with the configuration cache.</code></p>\n<p>So I tried to move the Class-Path code to configuration time and looked at several examples from the Internet. One of several attempts is this:</p>\n<pre><code>    jar {\n        def classpath = configurations.runtimeClasspath.files\n        // Input declaration is needed for the proper up-to-date checks\n        inputs.files(classpath).withNormalizer(ClasspathNormalizer)\n        manifest {\n            attributes('Class-Path':classpath.collect { cp -&gt; cp.join(' ') { it.name } })\n        }\n    }\n</code></pre>\n<p>With all my attempts, there is an error because the configuration seems to become immutable too early now, so that other parts of the build script cannot add dependencies etc. One error message I got with these attempts is: <code>Cannot change attributes of configuration ':SomeProject:runtimeClasspath' after it has been locked for mutation</code> Another is: <code>Cannot change dependencies of dependency configuration ':SomeOtherProject:api' after it has been included in dependency resolution.</code></p>\n<p>This is a pretty standard use case and the configuration cache has become rather stable, recently, too. So I guess this should be possible and not too hard. <strong>So how can I add a &quot;Class-Path&quot; entry to a JAR manifest in a multi-project build based on the runtimeClasspath configuration and stay compatible with the configuration cache?</strong></p>\n",
    "tags" : [ "java", "gradle" ],
    "owner" : {
      "account_id" : 31149831,
      "reputation" : 81,
      "user_id" : 23957395,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/19bfe9d06751aeddacacadbfd7ed9468?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "T. Baum",
      "link" : "https://stackoverflow.com/users/23957395/t-baum"
    },
    "is_answered" : true,
    "view_count" : 107,
    "answer_count" : 1,
    "score" : 3,
    "last_activity_date" : 1753801195,
    "creation_date" : 1753779383,
    "link" : "https://stackoverflow.com/questions/79718348/how-to-add-a-class-path-entry-to-a-jar-manifest-in-gradle-compatible-with-the",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79718821,
    "question_id" : 79718348,
    "body" : "<p>I think I found a solution:</p>\n<pre><code>        jar {\n            def classPathProvider = configurations.runtimeClasspath\n                .incoming\n                .artifacts\n                .resolvedArtifacts\n                .map { artifacts -&gt;\n                    artifacts.collect { it.file.name }.join(' ')\n                }\n            inputs.files(configurations.runtimeClasspath)\n                  .withNormalizer(ClasspathNormalizer)\n\n            manifest {\n                attributes('Class-Path':classPathProvider)\n            }\n        }\n</code></pre>\n<p>Using the &quot;incoming&quot; field of Configuration and the respective further methods, one can get a &quot;Provider&quot; for the class path that can be lazyly evaluated.</p>\n",
    "score" : 0,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 31149831,
      "reputation" : 81,
      "user_id" : 23957395,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/19bfe9d06751aeddacacadbfd7ed9468?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "T. Baum",
      "link" : "https://stackoverflow.com/users/23957395/t-baum"
    },
    "creation_date" : 1753801195,
    "last_activity_date" : 1753801195,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}