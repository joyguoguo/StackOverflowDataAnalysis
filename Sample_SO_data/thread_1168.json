{
  "question" : {
    "question_id" : 79736241,
    "title" : "Do virtual threads cause heap allocations and GC pressure when their stack grows?",
    "body" : "<p>I'm working with Java's virtual threads and trying to fully understand their memory management implications, specifically regarding their stacks.</p>\n<p>My current understanding is that a virtual thread's stack is not a single, contiguous block of memory like a traditional platform thread's stack. Instead, it's stored as an object (or a series of objects) on the Java heap. When a virtual thread needs to run, its stack is &quot;mounted&quot; onto a carrier (platform) thread. When it blocks, it's &quot;unmounted.&quot;</p>\n<p>This leads to my core question: What happens when a virtual thread's call stack grows beyond the capacity of its current stack chunk?</p>\n<p>For example, consider a virtual thread executing a deeply recursive method or a long chain of method calls. Its stack depth will increase.</p>\n<ul>\n<li>Does the JVM handle this by allocating a new, larger stack chunk object on the heap and copying the contents of the old, smaller chunk into it?</li>\n<li>If so, does the old stack chunk become garbage?</li>\n</ul>\n<p>My concern is that in an application with a very high number of virtual threads that have fluctuating stack depths, this process of growing stacks could lead to significant heap allocation churn and put pressure on the Garbage Collector.</p>\n<p>Could this &quot;stack resizing&quot; process become a hidden source of heap allocations and GC overhead that we need to be mindful of when designing systems with virtual threads?</p>\n",
    "tags" : [ "java", "virtual-threads" ],
    "owner" : {
      "account_id" : 31951,
      "reputation" : 1948,
      "user_id" : 88105,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/fe1c8df60629cd08b4ac37f19dcb2bde?s=256&d=identicon&r=PG",
      "display_name" : "Jaromir Hamala",
      "link" : "https://stackoverflow.com/users/88105/jaromir-hamala"
    },
    "is_answered" : false,
    "view_count" : 200,
    "answer_count" : 0,
    "score" : 2,
    "last_activity_date" : 1755286312,
    "creation_date" : 1755246766,
    "link" : "https://stackoverflow.com/questions/79736241/do-virtual-threads-cause-heap-allocations-and-gc-pressure-when-their-stack-grows",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140726239,
    "post_id" : 79736241,
    "body" : "The virtual thread instance and its initial stack are already the garbage of the future, especially when following the intended pattern of having them short-lived. Plus the things, the code running in the virtual thread does. The impact of stack growing is negligible. Nobody cares about the growing array of a <code>StringBuilder</code>, for example and usually, the are more of them than virtual threads. Truly temporary objects are the garbage that is easiest to handle.",
    "score" : 2,
    "owner" : {
      "account_id" : 3211603,
      "reputation" : 300981,
      "user_id" : 2711488,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
      "display_name" : "Holger",
      "link" : "https://stackoverflow.com/users/2711488/holger"
    },
    "creation_date" : 1757494797,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140670329,
    "post_id" : 79736241,
    "body" : "The flip side is that virtual threads are <i>designed</i> for use-cases where threads are short-lived and light-weight.  (Refer to the JEP, etc,)  If you&#39;ve got threads where the stack is expected to get rather large, that&#39;s not what virtual threads were designed for.  If your threads are heavy-weight, use classical threads and either an executor service or a third-party thread pool library.",
    "score" : 3,
    "owner" : {
      "account_id" : 47283,
      "reputation" : 723428,
      "user_id" : 139985,
      "user_type" : "registered",
      "accept_rate" : 69,
      "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
      "display_name" : "Stephen C",
      "link" : "https://stackoverflow.com/users/139985/stephen-c"
    },
    "creation_date" : 1755364842,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140669169,
    "post_id" : 79736241,
    "body" : "You might enjoy the talk, <a href=\"https://youtu.be/6nRS6UiN7X0\" rel=\"nofollow noreferrer\"><i>Continuations - Under the Covers</i></a> by Ron Pressler",
    "score" : 1,
    "owner" : {
      "account_id" : 322981,
      "reputation" : 346951,
      "user_id" : 642706,
      "user_type" : "registered",
      "accept_rate" : 58,
      "profile_image" : "https://i.sstatic.net/ZWEI3.jpg?s=256",
      "display_name" : "Basil Bourque",
      "link" : "https://stackoverflow.com/users/642706/basil-bourque"
    },
    "creation_date" : 1755301115,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140668032,
    "post_id" : 79736241,
    "body" : "yes, virtual threads cause heap allocations and the same way as anything else in heap - it creates gc pressure",
    "score" : 5,
    "owner" : {
      "account_id" : 3415144,
      "reputation" : 24355,
      "user_id" : 2864275,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f1f73deb5983ac46af2a74732752292e?s=256&d=identicon&r=PG",
      "display_name" : "IÅ‚ya Bursov",
      "link" : "https://stackoverflow.com/users/2864275/i%c5%82ya-bursov"
    },
    "creation_date" : 1755261751,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}