{
  "question" : {
    "question_id" : 79644729,
    "title" : "Test with mocked service and another test with real implementation",
    "body" : "<p>TL;DR: I want to test the controller method that uses a service and the service itself that is being called, both in their respective unit test classes but can't do it since mocked bean replaces original bean.</p>\n<hr />\n<p>I have a service that I'm using in a controller.</p>\n<pre><code>public class SomeController {\n    @PostMapping(&quot;/load&quot;)\n    public ResponseEntity&lt;String&gt; someMethod(@RequestParam(&quot;val&quot;) String val) {\n        String lifeStatus = someService.serviceMethod(val);\n        return ResponseEntity.status(HttpStatus.OK).body(lifeStatus);\n    }\n}\n</code></pre>\n<p>Let's say the service is this:</p>\n<pre><code>public class SomeServiceImpl implements SomeService {\n    public String serviceMethod(String val){\n        //business logic here\n        if (resultOfSuchBusinessLogic){ \n            return &quot;Life is good&quot;;\n        }\n        return &quot;Life is not so good&quot;;\n    }\n}\n</code></pre>\n<p>Then I wanted to create a test for this controller method. So I made a test config:</p>\n<pre><code>@Configuration\n@ActiveProfiles(&quot;test&quot;) //So I can load application-test.properties\npublic class TestConfig {\n    @Autowired private SomeServiceMock someService;\n\n    @Bean\n    @Primary\n    SomeService someService() {\n        return someService;\n    }\n\n}\n</code></pre>\n<p>And a MockService:</p>\n<pre><code>public class SomeServiceMock implements SomeService {\n    public String serviceMethod(String val){\n        if (val == &quot;good&quot;){\n            return &quot;Life is good&quot;;\n        }\n        return &quot;Life is not so good&quot;;\n    }\n}\n</code></pre>\n<p>And in my test class for the controller I did this:</p>\n<pre><code>@ContextConfiguration(classes = TestConfig.class)\n@SpringBootTest\n@ActiveProfiles(&quot;test&quot;)\npublic class SomeControllerTests {\n    @Autowired private SomeController controller;\n\n    public void someTestOk()  {\n        ResponseEntity someVar = controller.someMethod(&quot;someValue&quot;);\n\n        assertFalse(someVar.getBody(), &quot;Life is good&quot;); \n    }\n}\n</code></pre>\n<p>At this point this worked and I didn't care about the inner behavior of the SomeServiceImpl class.\nBut then I did care.\nAnd I can't, for the love of me, figure it out what do I have to do so it uses the real implementation of the bean and not the mocked one. Because when I do this:</p>\n<pre><code>@SpringBootTest\n@ActiveProfiles(&quot;test&quot;)\npublic class SomeServiceTests {\n    @Autowired private SomeService someService;\n\n    public void someTestOk()  {\n        ResponseEntity someVar = someService.someMethod(&quot;someValue&quot;);\n\n        assertTrue(someVar.getBody(), &quot;Life is good&quot;); \n    }\n}\n</code></pre>\n<p>It still uses the Mocked one despite not having the ContextConfiguration. I found out that the Context is the same and when it creates a Bean then it will replace the original one.\nI tried to add the dirtycontext clean annotation but it still doesn't work. I also tried using the config class with mock:</p>\n<pre><code>@Bean\n@Primary //(with and without this)\npublic SomeService someService() {\n    return mock(SomeService.class);\n}\n\n@BeforeAll method\nwhen(someService.someMethod(anyString()).then(blah bla)\n</code></pre>\n<p>But still doesn't work. Either both use the original bean or both use the mocked. Any pointers at what I can be missing?</p>\n",
    "tags" : [ "java", "spring", "testing", "mocking" ],
    "owner" : {
      "account_id" : 15553608,
      "reputation" : 91,
      "user_id" : 11220661,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/521ab2f3f09c3f27f9286f9815862f56?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Palayn",
      "link" : "https://stackoverflow.com/users/11220661/palayn"
    },
    "is_answered" : true,
    "view_count" : 112,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1748619993,
    "creation_date" : 1748561029,
    "link" : "https://stackoverflow.com/questions/79644729/test-with-mocked-service-and-another-test-with-real-implementation",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79645703,
    "question_id" : 79644729,
    "body" : "<p>So I had two things going on here.</p>\n<p>1 ) I was understading the profiles thing wrong. @ActiveProfiles(&quot;test&quot;)  is needed so it loads the test properties. And I was using it in the same class that declared the mocked services.</p>\n<p>2 ) So I changed the @Profile to (&quot;mock&quot;) on my testconfig and added it into the tests that needed the mocked services. And also in the mocked services because it complained that there are 2 beans instead of one in the test that used the real implementation.</p>\n<pre><code>@SpringBootTest\n@ActiveProfiles(&quot;test&quot;) \npublic class SomeServiceTests {}\n\n@SpringBootTest\n@ActiveProfiles({&quot;test&quot;,&quot;mock&quot;})\npublic class SomeControllerTests {}\n\n@Configuration\n@Profile(&quot;mock&quot;)\npublic class TestConfig {\n    @Bean\n    @Primary\n    public SomeService someService(){\n        return new SomeServiceMock()\n    }\n}\n\n@Service\n@Profile(&quot;mock&quot;)\npublic class SomeServiceMock implements SomeService{}\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 15553608,
      "reputation" : 91,
      "user_id" : 11220661,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/521ab2f3f09c3f27f9286f9815862f56?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Palayn",
      "link" : "https://stackoverflow.com/users/11220661/palayn"
    },
    "creation_date" : 1748618174,
    "last_activity_date" : 1748619993,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140471033,
    "post_id" : 79644729,
    "body" : "Have you tried replacing with a SpyBean? SpyBeans allow you to call the real method versus a mocked/stubbed method. So you can flip between implementations for different tests",
    "score" : 0,
    "owner" : {
      "account_id" : 21724606,
      "reputation" : 1431,
      "user_id" : 16034206,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/MRBdT.jpg?s=256",
      "display_name" : "pebble unit",
      "link" : "https://stackoverflow.com/users/16034206/pebble-unit"
    },
    "creation_date" : 1748566276,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}