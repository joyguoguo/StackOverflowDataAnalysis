{
  "question" : {
    "question_id" : 79662446,
    "title" : "Spring Security WebSocket Authentication with JWT - STOMP Connection Fails with &quot;Failed to send message to ExecutorSubscribableChannel&quot;",
    "body" : "<p>Problem Description\nI'm implementing JWT-based authentication for WebSockets in a Spring Boot application using STOMP. HTTP requests work perfectly with JWT authentication, but WebSocket connections fail with the error:</p>\n<pre><code>STOMP Error: Failed to send message to ExecutorSubscribableChannel[clientInboundChannel]\n</code></pre>\n<p>Setup:\n-Spring Boot 3.x with Spring Security 6.x\n-JWT tokens (access + refresh) for authentication\n-CSRF disabled, stateless sessions\n-React frontend connecting via SockJS/STOMP</p>\n<p>Expected Behavior: WebSocket connection should authenticate using JWT token and allow messaging.</p>\n<p>Actual Behavior: WebSocket handshake succeeds, but STOMP CONNECT frame is rejected.</p>\n<p>Current Configuration\nSecurityConfig.java (HTTP Security):</p>\n<pre><code>    @Bean\npublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n    return http\n        .cors(Customizer.withDefaults())\n        .csrf(AbstractHttpConfigurer::disable)\n        .authorizeHttpRequests(request -&gt; request\n            .requestMatchers(&quot;/auth/**&quot;).permitAll()\n            .requestMatchers(&quot;/ws/**&quot;).authenticated() // This might be the issue?\n            .anyRequest().authenticated()\n        )\n        .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n        .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class)\n        .build();\n}\n</code></pre>\n<p>WebSocketSecurityConfig.java:</p>\n<pre><code>    @Configuration\n@EnableWebSocketSecurity\npublic class WebSocketSecurityConfig {\n    @Bean\n    public AuthorizationManager&lt;Message&lt;?&gt;&gt; messageAuthorizationManager() {\n        return MessageMatcherDelegatingAuthorizationManager.builder()\n            .nullDestMatcher().permitAll() // Allow CONNECT frames\n            .simpDestMatchers(&quot;/app/**&quot;).authenticated()\n            .simpSubscribeDestMatchers(&quot;/topic/**&quot;, &quot;/user/**&quot;).authenticated()\n            .anyMessage().denyAll()\n            .build();\n    }\n}\n</code></pre>\n<p>WebSocketConfig.java (Basic - no interceptors):</p>\n<pre><code>@Configuration\n@EnableWebSocketMessageBroker\npublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer {\n    @Override\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\n        registry.addEndpoint(&quot;/ws&quot;)\n                .setAllowedOrigins(&quot;http://localhost:5173&quot;)\n                .withSockJS();\n    }\n    \n    @Override\n    public void configureMessageBroker(MessageBrokerRegistry registry) {\n        registry.enableSimpleBroker(&quot;/topic&quot;, &quot;/user&quot;);\n        registry.setApplicationDestinationPrefixes(&quot;/app&quot;);\n    }\n    //tried with interceptor too\n    //    @Override\n//    public void configureClientInboundChannel(ChannelRegistration registration) {\n//        // Create authorization interceptor with event publisher\n//        AuthorizationChannelInterceptor auths = new AuthorizationChannelInterceptor(messageAuthorizationManager);\n//        SpringAuthorizationEventPublisher publisher = new SpringAuthorizationEventPublisher(applicationContext);\n//        auths.setAuthorizationEventPublisher(publisher);\n//\n//        registration.interceptors(\n//                new SecurityContextChannelInterceptor(), // Transfers auth context for WebSocket messages\n//                auths // Handles WebSocket message authorization\n//        );\n//    }\n\n}\n</code></pre>\n<p>JWTFilter.java (Handles both HTTP and WebSocket tokens):</p>\n<pre><code>@Override\nprotected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n        throws ServletException, IOException {\n    \n    String authHeader = request.getHeader(&quot;Authorization&quot;);\n    String token = null;\n    \n    if (authHeader != null &amp;&amp; authHeader.startsWith(&quot;Bearer &quot;)) {\n        token = authHeader.substring(7);\n    }\n    // For WebSocket connections, check query parameter\n    if (token == null &amp;&amp; request.getRequestURI().startsWith(&quot;/ws&quot;) &amp;&amp; request.getParameter(&quot;access_token&quot;) != null) {\n        token = request.getParameter(&quot;access_token&quot;);\n    }\n    \n    if (token != null) {\n        // JWT validation logic - this works for HTTP requests\n        String username = jwtService.extractUserName(token);\n        if (username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null) {\n            UserDetails userDetails = userDetailsService.loadUserByUsername(username);\n            if (jwtService.validateToken(token, userDetails)) {\n                UsernamePasswordAuthenticationToken authToken = \n                    new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());\n                SecurityContextHolder.getContext().setAuthentication(authToken);\n            }\n        }\n    }\n    \n    filterChain.doFilter(request, response);\n}\n</code></pre>\n<p>AppUserDetails.java:</p>\n<pre><code>@Override\npublic Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {\n    return Collections.emptyList(); // Could this be causing issues?\n}\n\n@Override\npublic String getUsername() {\n    return user.getUserName(); // Returns email\n}\n</code></pre>\n<p>Frontend Connection</p>\n<pre><code>const headers = { 'Authorization': `Bearer ${accessToken}` };\nstompClient.connect(headers, onConnected, onError);\n</code></pre>\n<p>Server Logs</p>\n<pre><code>✅ JWT authentication successful for user: priya@gmail.com (HTTP handshake)\n❌ STOMP Error: Failed to send message to ExecutorSubscribableChannel[clientInboundChannel]\n</code></pre>\n<p>What I've Tried</p>\n<ol>\n<li><p>Changed SecurityConfig to permit /ws/info/**, /ws/*/websocket etc.</p>\n</li>\n<li><p>Modified WebSocketSecurityConfig to .permitAll() for CONNECT frames</p>\n</li>\n<li><p>Verified JWT token extraction - works correctly for both HTTP and WebSocket requests</p>\n</li>\n</ol>\n<p>Questions</p>\n<ol>\n<li><p>Do I need specific interceptors in WebSocketConfig to transfer authentication context from HTTP handshake to STOMP messages?</p>\n</li>\n<li><p>Should AppUserDetails.getAuthorities() return empty list or does Spring Security require at least one authority for WebSocket authentication?</p>\n</li>\n<li><p>Is blocking /ws/** in SecurityConfig preventing proper WebSocket authentication flow?</p>\n</li>\n<li><p>How to properly separate HTTP and WebSocket authentication without interceptors interfering with HTTP logout functionality?</p>\n</li>\n</ol>\n",
    "tags" : [ "java", "spring", "spring-boot", "websocket", "jwt" ],
    "owner" : {
      "account_id" : 23542681,
      "reputation" : 31,
      "user_id" : 17586630,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/e1603e301479790f4d64e9b4a012517a?s=256&d=identicon&r=PG",
      "display_name" : "Ankit Arsh",
      "link" : "https://stackoverflow.com/users/17586630/ankit-arsh"
    },
    "is_answered" : true,
    "view_count" : 351,
    "answer_count" : 1,
    "score" : 1,
    "last_activity_date" : 1749710198,
    "creation_date" : 1749664629,
    "link" : "https://stackoverflow.com/questions/79662446/spring-security-websocket-authentication-with-jwt-stomp-connection-fails-with",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79663032,
    "question_id" : 79662446,
    "body" : "<p>After extensive debugging, I found the root cause: Spring Security's WebSocket support assumes session-based authentication, but JWT is stateless. The authenticated user from your HTTP handshake doesn't automatically transfer to STOMP message processing.</p>\n<p>Working Solution</p>\n<p>1. Allow WebSocket endpoints in SecurityConfig:</p>\n<pre><code>@Bean\npublic SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n    return http\n        .authorizeHttpRequests(request -&gt; request\n            .requestMatchers(&quot;/auth/**&quot;).permitAll()\n            .requestMatchers(&quot;/ws/**&quot;).permitAll() // ← Allow WebSocket handshake\n            .anyRequest().authenticated()\n        )\n        // ... rest of config\n}\n</code></pre>\n<p>2. Custom WebSocket JWT Interceptor:</p>\n<pre><code>@Component\npublic class WebSocketAuthChannelInterceptor implements ChannelInterceptor {\n    \n    private final WebSocketAuthenticatorService authService;\n    \n    @Override\n    public Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) {\n        StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);\n        \n        if (accessor != null &amp;&amp; StompCommand.CONNECT == accessor.getCommand()) {\n            String authHeader = accessor.getFirstNativeHeader(&quot;Authorization&quot;);\n            \n            if (authHeader != null &amp;&amp; authHeader.startsWith(&quot;Bearer &quot;)) {\n                String jwt = authHeader.substring(7);\n                try {\n                    UsernamePasswordAuthenticationToken user = authService.getAuthenticatedOrFail(jwt);\n                    accessor.setUser(user);\n                } catch (AuthenticationException e) {\n                    return null; // Reject connection\n                }\n            } else {\n                return null; // No auth header\n            }\n        }\n        return message;\n    }\n}\n</code></pre>\n<p>3. Authentication Service:</p>\n<pre><code>@Service\npublic class WebSocketAuthenticatorService {\n    \n    public UsernamePasswordAuthenticationToken getAuthenticatedOrFail(String jwt) {\n        String email = jwtService.extractUserName(jwt);\n        UserDetails userDetails = userDetailsService.loadUserByUsername(email);\n        \n        if (jwtService.validateToken(jwt, userDetails)) {\n            return new UsernamePasswordAuthenticationToken(\n                userDetails, null, \n                Collections.singleton(new SimpleGrantedAuthority(&quot;ROLE_USER&quot;))\n            );\n        }\n        throw new AuthenticationCredentialsNotFoundException(&quot;Invalid token&quot;);\n    }\n}\n</code></pre>\n<p>4. Register Interceptor:</p>\n<pre><code>@Override\npublic void configureClientInboundChannel(ChannelRegistration registration) {\n    registration.interceptors(webSocketAuthChannelInterceptor);\n}\n</code></pre>\n<p>Key Points</p>\n<ul>\n<li><p>No <code>@EnableWebSocketSecurity</code> - bypassed entirely</p>\n</li>\n<li><p>JWT validation happens directly in STOMP CONNECT frames</p>\n</li>\n<li><p>Clean separation - authentication service handles token logic</p>\n</li>\n<li><p>Frontend unchanged - still sends <code>Authorization: Bearer &lt;token&gt;</code></p>\n</li>\n</ul>\n<p>This approach gives complete control over WebSocket authentication without fighting Spring Security's session assumptions.</p>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 23542681,
      "reputation" : 31,
      "user_id" : 17586630,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/e1603e301479790f4d64e9b4a012517a?s=256&d=identicon&r=PG",
      "display_name" : "Ankit Arsh",
      "link" : "https://stackoverflow.com/users/17586630/ankit-arsh"
    },
    "creation_date" : 1749710198,
    "last_activity_date" : 1749710198,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}