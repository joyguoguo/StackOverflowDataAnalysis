{
  "question" : {
    "question_id" : 79805691,
    "title" : "Why does the Java collator for the Hungarian locale mix E and &#201;?",
    "body" : "<p>I want to order a huge list of countries, and I have noticed that, for example, E and É are treated as equals. But in the Hungarian grammar, E comes before É, so a rule should be added, 'E &lt; É'.</p>\n<p>Example code:</p>\n<pre><code>List&lt;String&gt; countries = List.of(&quot;Észak-korea&quot;, &quot;Észtország&quot;, &quot;Eritrea&quot;, &quot;Etiópia&quot;, &quot;El Salvador&quot;);\nLocale locale = Locale.of(&quot;hu&quot;, &quot;HU&quot;);\nCollator collator = Collator.getInstance(locale);\nList&lt;String&gt; orderedCountries = countries.stream().sorted(collator).toList();\nSystem.out.println(orderedCountries);\n</code></pre>\n<p>The result is this:</p>\n<pre class=\"lang-none prettyprint-override\"><code>[El Salvador, Eritrea, Észak-korea, Észtország, Etiópia]\n</code></pre>\n<p>The expected result:</p>\n<pre class=\"lang-none prettyprint-override\"><code>[El Salvador, Eritrea, Etiópia, Észak-korea, Észtország]\n</code></pre>\n<p>Setting collator strength changes nothing. The rule set clearly misses the order of the accentuated letters, compared to their simple letter counterparts. Like A &lt; Á, I &lt; I, E &lt; É, etc.</p>\n<p>I use <a href=\"https://en.wikipedia.org/wiki/OpenJDK\" rel=\"nofollow noreferrer\">OpenJDK</a> 21 (21.0.2).</p>\n<p>Why is there a rule set for Hungarian language that fails to follow the rules of the Hungarian language? I don't want to create own rules to implement the functionality that should be there already. Maybe there is a good answer to that. Or is there a different method to achieve the expected result with the default Java libraries?</p>\n<p>Edit: <strong>Seems like I was wrong, and I don't know my own language. Thanks for the replies. The vowels are counted as equals as their accented counterparts when you put words in order. So E = É.</strong></p>\n",
    "tags" : [ "java", "locale", "collation", "rules", "java-21" ],
    "owner" : {
      "account_id" : 14809911,
      "reputation" : 385,
      "user_id" : 10695889,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/0f14e9a454440321fe7a426538e05f8a?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "B.G.",
      "link" : "https://stackoverflow.com/users/10695889/b-g"
    },
    "is_answered" : true,
    "view_count" : 574,
    "answer_count" : 2,
    "score" : 8,
    "last_activity_date" : 1762222482,
    "creation_date" : 1761908456,
    "link" : "https://stackoverflow.com/questions/79805691/why-does-the-java-collator-for-the-hungarian-locale-mix-e-and-%c3%89",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79806170,
    "question_id" : 79805691,
    "body" : "<h3>Regarding your specific question:</h3>\n<blockquote>\n<p><em>Why is there a rule set for Hungarian language that fails to follow the rules of the Hungarian language?</em></p>\n</blockquote>\n<p>You would almost certainly have to ask the language experts who contributed these specific collation rules to the <a href=\"https://cldr.unicode.org/\" rel=\"nofollow noreferrer\">Unicode CLDR project</a>, if you want a definitive answer.</p>\n<p>Having said that, you can see that the CLDR itself <a href=\"https://cldr.unicode.org/index/cldr-spec/collation-guidelines#pitfalls\" rel=\"nofollow noreferrer\">alludes to this</a>:</p>\n<blockquote>\n<p><em>There are a number of pitfalls with collation, so be careful. In some cases, such as Hungarian or Japanese, the rules can be fairly complicated (of course, reflecting that the sorting sequence for those languages is complicated).</em></p>\n</blockquote>\n<p>There is also a discussion (from almost 20 years ago) when the MySQL team was trying to <a href=\"https://mysql.general.narkive.com/8e2PKzex/hungarian-collation\" rel=\"nofollow noreferrer\">define Hungarian collation rules</a> - outside the scope of this Java question, but still interesting. I won't try to capture the full thread here, but it includes the following snippets:</p>\n<blockquote>\n<p>&quot;<em>Most people agree that this is the Hungarian alphabet: a á b c cs d dz dzs e é f g gy h i í j k l ly m n ny o ó ö ő p q r s sz t ty u ú ü ű v w x y z zs</em>&quot;</p>\n</blockquote>\n<blockquote>\n<p>Some people also say there's a secondary sort\nrule for these short/long vowel pairs:\na á, e é, i í, o ó, ö ő, u ú, ü ű\nFor these pairs, long = short usually, but long &gt; short\nif all else is equal.</p>\n</blockquote>\n<blockquote>\n<p>An alternative collation sometimes used (in libraries, and some dictionaries\nand lexica) is according to the basic latin [sic] alphabet, whit the accented\nletters having the same value as the not accented. Or anything in between.\nE.g., honoring the digraphs and the trigraph, but leaving the accents out of\nthe business.</p>\n</blockquote>\n<p>So, &quot;leaving the accents out of the business&quot; seems to have been acceptable in some cases.</p>\n<p>The thread goes on to discuss various other complexities. Worth a read.</p>\n<p>If you feel strongly enough you could <a href=\"https://cldr.unicode.org/requesting_changes\" rel=\"nofollow noreferrer\">ask the CLDR team</a> for more info about the history of this topic.</p>\n<p>There are already some tickets about Hungarian collation such as <a href=\"https://unicode-org.atlassian.net/browse/ICU-2692\" rel=\"nofollow noreferrer\">collation rules for hu (Hungarian)</a>. This one was marked &quot;won't fix&quot;.</p>\n<hr />\n<h3>I just want my expected sort order to work - what can I do?</h3>\n<p>You said in the question:</p>\n<blockquote>\n<p><em>I don't want to create own rules to implement the functionality that should be there already.</em></p>\n</blockquote>\n<p>If you are using a version of Java prior to JDK 23, you can choose different locale providers via <a href=\"https://www.oracle.com/java/technologies/javase/jdk11-suported-locales.html\" rel=\"nofollow noreferrer\"><code>java.locale.providers</code></a>:</p>\n<ul>\n<li>&quot;CLDR&quot; - what we have been discussing (and the only provider supported in JDK 23 and later).</li>\n<li>&quot;COMPAT&quot; for compatibility with Java's older built-in rules. Not recommended for modern applications.</li>\n<li>&quot;SPI&quot; - basically your own custom provider (or someone else's).</li>\n<li>&quot;HOST&quot; - whatever formatting rules your operating system may provide.</li>\n</ul>\n<p>None of the older (non-CLDR) options should be used - and I expect they would not help you, anyway.</p>\n<p>There is no way (as far as I can see) to get your results <em>without</em> a custom solution.</p>\n<p>I have looked at other answers provided <a href=\"https://stackoverflow.com/a/79805702/12567365\">here</a> and <a href=\"https://stackoverflow.com/a/79805719/12567365\">here</a>. In both cases, neither approach worked for me. I tested several variants on these approaches - none of them sorted your data the way you want to sort it. Those answers may be of more help, if they can be clarified by their authors.</p>\n<hr />\n<h3>For completeness, a custom approach (even if you don't want to use it, someone else might)</h3>\n<p>I appreciate that you want to provide the least surprising sort order for consumers of your data.</p>\n<p>Here is one way you can do that in Java - but <strong>with a very large caveat that I am not any kind of expert in Hungarian. I do not know the language at all</strong>.</p>\n<p>You can use a custom <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/text/RuleBasedCollator.html\" rel=\"nofollow noreferrer\">RuleBasedCollator</a> to do that.</p>\n<p>Here is a first (somewhat naive) implementation:</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.text.ParseException;\nimport java.text.RuleBasedCollator;\nimport java.util.List;\n\n...\n\nString myRules = &quot;&quot;&quot;\n     &lt; a, A &lt; á, Á &lt; b, B &lt; c, C &lt; cs, CS, Cs &lt; d, D &lt;\n     dz, DZ, Dz &lt; dzs, DZS, Dzs &lt;\n     e, E &lt; é, É &lt; f, F &lt; g, G &lt; gy, GY, Gy &lt; h, H &lt;\n     i, I &lt; í, Í &lt; j, J &lt; k, K &lt; l, L &lt; ly, LY, Ly &lt;\n     m, M &lt; n, N &lt; ny, NY, Ny &lt; o, O &lt; ó, Ó &lt; ö, Ö &lt; ő, Ő &lt; p, P &lt;\n     q, Q &lt; r, R &lt; s, S &lt; sz, SZ, Sz &lt; t, T &lt; ty, TY, Ty &lt;\n     u, U &lt; ú, Ú &lt; ü, Ü &lt; ű, Ű &lt; v, V &lt; w, W &lt; x, X &lt;\n     y, Y &lt; z, Z &lt; zs, ZS, Zs\n    &quot;&quot;&quot;;\nRuleBasedCollator myCollator = new RuleBasedCollator(myRules);\n\nList&lt;String&gt; countries = List.of(&quot;Észak-korea&quot;, &quot;Észtország&quot;, &quot;Eritrea&quot;,\n        &quot;Etiópia&quot;, &quot;El Salvador&quot;);\nList&lt;String&gt; expectedResults = List.of(&quot;El Salvador&quot;, &quot;Eritrea&quot;, &quot;Etiópia&quot;,\n        &quot;Észak-korea&quot;, &quot;Észtország&quot;);\nList&lt;String&gt; orderedCountries = countries.stream().sorted(myCollator).toList();\n\nSystem.out.println(expectedResults);\nSystem.out.println(orderedCountries);\n</code></pre>\n<p>This outputs expected and actual results:</p>\n<pre class=\"lang-none prettyprint-override\"><code>[El Salvador, Eritrea, Etiópia, Észak-korea, Észtország]\n[El Salvador, Eritrea, Etiópia, Észak-korea, Észtország]\n</code></pre>\n<p>It uses rules such as <code>e, E &lt; é, É</code> to ensure accented letters are sorted after their unaccented counterparts.</p>\n<p>Note that I do not use a Hungarian locale anywhere in the above code.</p>\n<hr />\n<p>This could be enhanced in a couple of ways (and maybe more):</p>\n<p>(a) If you explicitly use a Hungarian locale, Java uses the following collation rules (as extracted from the CLDR rules):</p>\n<p><a href=\"https://github.com/openjdk/jdk/blob/d91fb17a80f6a577fdc77843df358c77d701f221/src/jdk.localedata/share/classes/sun/text/resources/ext/CollationData_hu.java\" rel=\"nofollow noreferrer\">CollationData_hu.java</a>:</p>\n<pre class=\"lang-java prettyprint-override\"><code>{ &quot;Rule&quot;,\n    /* for hu, default sorting except for the following: */\n    /* add cs &quot;ligature&quot; between c and d. */\n    /* add d&lt;stroke&gt; between d and e. */\n    /* add gy &quot;ligature&quot; between g and h. */\n    /* add ly &quot;ligature&quot; between l and l&lt;stroke&gt;. */\n    /* add l&lt;stroke&gt; between l and m. */\n    /* add sz &quot;ligature&quot; between s and t. */\n    /* add zs &quot;ligature&quot; between z and z&lt;abovedot&gt; */\n    /* add z&lt;abovedot&gt; after z.       */\n    &quot;&amp; C &lt; cs , cS , Cs , CS &quot; // cs ligatures\n    + &quot;&amp; D &lt; \\u0111, \\u0110 &quot;    // tal : african [sic] d &lt; d-stroke\n    + &quot;&amp; G &lt; gy, Gy, gY, GY &quot;    // gy ligatures\n    + &quot;&amp; L &lt; ly, Ly, lY, LY &quot;    // l &lt; ly\n    + &quot;&amp; O &lt; o\\u0308 , O\\u0308 &quot; // O &lt; o-umlaut\n    + &quot;&lt; o\\u030b , O\\u030b &quot;     // o-double-accute\n    + &quot;&amp; S &lt; sz , sZ , Sz , SZ &quot; // s &lt; sz ligature\n    + &quot;&amp; U &lt; u\\u0308 , U\\u0308 &quot; // u &lt; u-umlaut\n    + &quot;&lt; u\\u030b , U\\u030b &quot;     // u-double-accute\n    + &quot;&amp; Z &lt; zs , zS , Zs , ZS &quot; // stop-stroke &lt; zs ligature\n}\n</code></pre>\n<p>As noted already in some comments, they do not handle accented characters in the way you expect/need.  You could enhance your custom rules by adding these extra ones to your custom collator.</p>\n<hr />\n<p>Also (b): These Hungarian-specific rules are appended to a much larger set of default rules in <a href=\"https://github.com/openjdk/jdk/blob/d91fb17a80f6a577fdc77843df358c77d701f221/src/java.base/share/classes/sun/util/locale/provider/CollationRules.java\" rel=\"nofollow noreferrer\">CollationRules.java</a>.</p>\n<p>This is a very long list.</p>\n<p>You can't (shouldn't!) access this class directly - it's in a <code>sun.util</code> package. You could take a copy of the rules, and append your custom rules, for completeness. These rules may, of course, change in the future (but they appear to be quite stable, these days).</p>\n<hr />\n<p>Just to repeat my earlier warning: I am not a Hungarian language expert. I would only want to use this type of custom approach in a very specific circumstance - so maybe <em>only</em> for your country name sort, and nowhere else. You may be able to improve upon my approach.</p>\n<p>Or you may find a better way.</p>\n",
    "score" : 7,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 12743722,
      "reputation" : 22621,
      "user_id" : 12567365,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/zNR3x.png?s=256",
      "display_name" : "andrewJames",
      "link" : "https://stackoverflow.com/users/12567365/andrewjames"
    },
    "creation_date" : 1761940615,
    "last_activity_date" : 1762119099,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79805719,
    "question_id" : 79805691,
    "body" : "<p>Java isn’t missing any grammar rules. The Hungarian collation in OpenJDK follows the Unicode/CLDR standard, where accented letters (like É) are treated as secondary forms of their base letter (E). Because of this, the traditional Hungarian dictionary order (A &lt; Á &lt; B &lt; C &lt; Cs … E &lt; É) is not applied by default.</p>\n<p>No built-in Java Collator implements the full Hungarian dictionary alphabet.</p>\n<p>If you need the real Hungarian dictionary order, you must use a tailored collation. For example, with <a href=\"https://unicode-org.github.io/icu/userguide/icu4j/\" rel=\"nofollow noreferrer\"><em>ICU4J</em></a>:</p>\n<p><code>Collator coll = Collator.getInstance(new ULocale(&quot;hu@collation=dictionary&quot;));</code></p>\n<p>This collator follows the correct Hungarian dictionary rules, including treating E and É as separate letters.</p>\n",
    "score" : 6,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 44318283,
      "reputation" : 132,
      "user_id" : 31691216,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/331d80b7ddd44ea266a2a0876e0b0074?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Siripireddy Giri",
      "link" : "https://stackoverflow.com/users/31691216/siripireddy-giri"
    },
    "creation_date" : 1761909582,
    "last_activity_date" : 1762222482,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140829159,
    "post_id" : 79805691,
    "body" : "See also <a href=\"https://stackoverflow.com/q/65832378/5133585\">stackoverflow.com/q/65832378/5133585</a>",
    "score" : 0,
    "owner" : {
      "account_id" : 6651855,
      "reputation" : 292025,
      "user_id" : 5133585,
      "user_type" : "registered",
      "accept_rate" : 96,
      "profile_image" : "https://i.sstatic.net/dfqcw.png?s=256",
      "display_name" : "Sweeper",
      "link" : "https://stackoverflow.com/users/5133585/sweeper"
    },
    "creation_date" : 1761912512,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140829149,
    "post_id" : 79805691,
    "body" : "<a href=\"https://github.com/unicode-org/cldr/blob/main/common/collation/hu.xml\" rel=\"nofollow noreferrer\">Here</a> is the CLDR entry for Hungarian collation. It does not contain the rule &quot;E &lt; &#201;&quot;. That&#39;s why.",
    "score" : 3,
    "owner" : {
      "account_id" : 6651855,
      "reputation" : 292025,
      "user_id" : 5133585,
      "user_type" : "registered",
      "accept_rate" : 96,
      "profile_image" : "https://i.sstatic.net/dfqcw.png?s=256",
      "display_name" : "Sweeper",
      "link" : "https://stackoverflow.com/users/5133585/sweeper"
    },
    "creation_date" : 1761912448,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140829121,
    "post_id" : 79805691,
    "body" : "The concept here is called &quot;collation order&quot;.  Knowing the right term can help you find information. Collation order is a characteristic of locale / localization (and not a matter of grammar). Knowing the right classification can also help you find information.",
    "score" : 3,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1761911588,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79805719" : [ {
      "comment_id" : 140830947,
      "post_id" : 79805719,
      "body" : "As noted by @MatthieuM. there are examples in the CLDR of languages having multiple collations, such as Spanish. Another one: the <a href=\"https://github.com/unicode-org/cldr/blob/main/common/collation/de.xml\" rel=\"nofollow noreferrer\">German data</a>, which has multiple sets of collation rules.",
      "score" : 2,
      "owner" : {
        "account_id" : 12743722,
        "reputation" : 22621,
        "user_id" : 12567365,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/zNR3x.png?s=256",
        "display_name" : "andrewJames",
        "link" : "https://stackoverflow.com/users/12567365/andrewjames"
      },
      "creation_date" : 1762007490,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140830939,
      "post_id" : 79805719,
      "body" : "Have you run this code? What output does it produce using the data in the question? There is no such thing as <code>collation=dictionary</code> for locale <code>hu</code> in the CLDR (as used by ICU4J). There is only <code>collation=standard</code>. See the <a href=\"https://github.com/unicode-org/cldr/blob/main/common/collation/hu.xml\" rel=\"nofollow noreferrer\">hu.xml</a> file: it only contains <code>&lt;collation type=&quot;standard&quot; &gt;</code> (and a proposed draft - also <code>standard</code>).",
      "score" : 1,
      "owner" : {
        "account_id" : 12743722,
        "reputation" : 22621,
        "user_id" : 12567365,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/zNR3x.png?s=256",
        "display_name" : "andrewJames",
        "link" : "https://stackoverflow.com/users/12567365/andrewjames"
      },
      "creation_date" : 1762007207,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140830830,
      "post_id" : 79805719,
      "body" : "I would like to note that having <i>multiple</i> collation orders depending on the <i>usecase</i> is not unusual. For example, if I remember correctly, Spanish uses a different collation order between phone books (yeah, disappearing as they are) and dictionaries, with regard to whether LL is treated as its own letter, or as just two Ls.",
      "score" : 1,
      "owner" : {
        "account_id" : 49441,
        "reputation" : 303291,
        "user_id" : 147192,
        "user_type" : "registered",
        "accept_rate" : 80,
        "profile_image" : "https://i.sstatic.net/E78Vj.png?s=256",
        "display_name" : "Matthieu M.",
        "link" : "https://stackoverflow.com/users/147192/matthieu-m"
      },
      "creation_date" : 1762002539,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}