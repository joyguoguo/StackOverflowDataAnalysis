{
  "question" : {
    "question_id" : 79792327,
    "title" : "How can I store Huffman-encoded bits into a truly compressed binary file in Java?",
    "body" : "<p>I'm building a Huffman compressor in Java.<br />\nI already have: The original text, the Huffman code table (<code>Map&lt;Character, String&gt;</code>), and the order of character appearance.</p>\n<p>My current goal is to write the compressed result into a <code>.bin</code> file.<br />\nHowever, the output file is <strong>larger than the original text</strong>, because each <code>'0'</code> or <code>'1'</code> bit is being stored as a full byte instead of being packed into real bits.</p>\n<p>Here’s my current implementation:</p>\n<pre><code>private static byte[] convertBitsToBytes(String bits) {\n        int len = bits.length();\n        int numBytes = (int) Math.ceil(len / 8.0);\n        byte[] bytes = new byte[numBytes];\n\n        for (int i = 0; i &lt; len; i++) {\n            if (bits.charAt(i) == '1') {\n                bytes[i / 8] |= (byte) (1 &lt;&lt; (7 - (i % 8)));\n            }\n        }\n        return bytes;\n    }\n\n    public static void saveBinaryFile(File file, String originalText, Map&lt;Character, String&gt; huffmanTable) {\n        try (FileOutputStream fos = new FileOutputStream(file)) {\n            for (char c : originalText.toCharArray()) {\n                String huffmanCode = huffmanTable.get(c);\n                if (huffmanCode != null) {\n                    fos.write((byte) c);\n\n                    byte[] compressedBytes = convertBitsToBytes(huffmanCode);\n                    fos.write(compressedBytes);\n                }\n            }\n            System.out.println(&quot;Binary file saved successfully.&quot;);\n        } catch (IOException ex) {\n            System.out.println(&quot;Error saving binary file: &quot; + ex.getMessage());\n        }\n    }\n</code></pre>\n<p>I tried writing both the character and its Huffman binary string directly into the binary file.<br />\nEach bit (<code>'0'</code> or <code>'1'</code>) was written as a full byte, using <code>DataOutputStream.writeByte()</code>.</p>\n<p>I expected the resulting <code>.bin</code> file to contain the original character followed by its compressed bit sequence — and overall to <strong>weigh less than the original text file</strong> from which the data was taken.</p>\n<p>However, the file ended up <strong>larger than the text file</strong>, because each <code>'0'</code> and <code>'1'</code> is still stored as one byte instead of real bits.<br />\nI’m trying to find a way to make it truly compressed by packing the bits efficiently. Result should be &quot;h111e10l10l10o0&quot; in the binary file imaging I had those binary codes.</p>\n",
    "tags" : [ "java", "binary", "compression", "bit-manipulation", "huffman-code" ],
    "owner" : {
      "account_id" : 30719361,
      "reputation" : 19,
      "user_id" : 23554990,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/ACg8ocKXKr2nps9xK3X_X0e1L48V01soX3vTIS4yL-ngcxbjgA=k-s256",
      "display_name" : "Eslyn19",
      "link" : "https://stackoverflow.com/users/23554990/eslyn19"
    },
    "is_answered" : true,
    "view_count" : 138,
    "answer_count" : 2,
    "score" : 0,
    "last_activity_date" : 1760669877,
    "creation_date" : 1760628592,
    "link" : "https://stackoverflow.com/questions/79792327/how-can-i-store-huffman-encoded-bits-into-a-truly-compressed-binary-file-in-java",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79792695,
    "question_id" : 79792327,
    "body" : "<p>Something like:</p>\n<pre class=\"lang-java prettyprint-override\"><code>    int bin = 0;\n    int n = 0;\n    for (int i = 0; i &lt; len; i++) {\n        bin = (bin &lt;&lt; 1) | (bits.charAt(i) &amp; 1);\n        n++;\n        if (n == 8) {\n            // write the byte bin to the output\n            n = 0;\n            bin = 0;\n        }\n    }\n    if (n != 0) {\n        bin &lt;&lt;= 8 - n;\n        // write the byte bin to the output\n    }   \n</code></pre>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1136690,
      "reputation" : 115267,
      "user_id" : 1180620,
      "user_type" : "registered",
      "accept_rate" : 83,
      "profile_image" : "https://i.sstatic.net/FXaAg.jpg?s=256",
      "display_name" : "Mark Adler",
      "link" : "https://stackoverflow.com/users/1180620/mark-adler"
    },
    "creation_date" : 1760669877,
    "last_activity_date" : 1760669877,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79792594,
    "question_id" : 79792327,
    "body" : "<p>Calling <code>convertBitsToBytes</code> on each symbol individually means that the codes for adjacent symbols can never combine to properly fill the bytes. Most bytes will be partially &quot;unused&quot; (all 8 bits have to exist of course, but some of them wouldn't be meaningful), and at least one byte is used per symbol, which rules out compression if the symbols were originally single-byte letters themselves. Also, a normal Huffman decoder would not be able to decompress that data, since it has unexpected &quot;gaps&quot; that normally don't exist.</p>\n<p>You could first append all codes into a long string, and apply <code>convertBitsToBytes</code> to that. Then adjacent codes can combine. This is not a great solution, just a simple trick to get you going, perhaps sufficient for a school exercise, I don't consider it a serious implementation technique since it relies on building a string in memory that's 8x the size of the compressed file. It's fundamentally inefficient.</p>\n<p>The &quot;proper&quot; (IMO) solution is to buffer up bits in an integer (<code>int</code> or <code>long</code>) and write out groups of 8 as bytes when you have them (you can save up multiple bytes if you want, but be careful to keep the buffer empty enough that you can append your largest symbol to it), so every byte is fully used (except usually the last byte, containing the bits left in the buffer in the end). That way adjacent codes still combine, but without building up a potentially large string. By the way it's a bit simpler and more efficient to do this if codes are represented as pairs of integers, one integer to hold the bit pattern of the code and another integer to hold the length of the code (this limits the maximum length of a code, but that's not a serious problem and in fact there is often an even lower length limit imposed in order to simplify table-driven Huffman decoding).</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 267086,
      "reputation" : 65818,
      "user_id" : 555045,
      "user_type" : "registered",
      "accept_rate" : 100,
      "profile_image" : "https://www.gravatar.com/avatar/182d0ce855c8324a596648c04643e8f9?s=256&d=identicon&r=PG",
      "display_name" : "user555045",
      "link" : "https://stackoverflow.com/users/555045/user555045"
    },
    "creation_date" : 1760651425,
    "last_activity_date" : 1760651425,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140800174,
    "post_id" : 79792327,
    "body" : "Hi, from what I understand now , convertBitsToBytes works for char instead for a string, so bits.length is always 1.  The reason is that you read the file and from the file you&#39;ve received only a one char.",
    "score" : 0,
    "owner" : {
      "account_id" : 21740819,
      "reputation" : 1,
      "user_id" : 16048216,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/ec4febff83dbf34081aeff89165683d9?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Meir Ka",
      "link" : "https://stackoverflow.com/users/16048216/meir-ka"
    },
    "creation_date" : 1760632854,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140800066,
    "post_id" : 79792327,
    "body" : "You have code commented <code>Not use yet</code>; why haven&#39;t you tried writing to your output file from what it returns?",
    "score" : 1,
    "owner" : {
      "account_id" : 682692,
      "reputation" : 50046,
      "user_id" : 535275,
      "user_type" : "registered",
      "accept_rate" : 91,
      "profile_image" : "https://i.sstatic.net/Ft2Mw.jpg?s=256",
      "display_name" : "Scott Hunter",
      "link" : "https://stackoverflow.com/users/535275/scott-hunter"
    },
    "creation_date" : 1760628857,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}