{
  "question" : {
    "question_id" : 79662544,
    "title" : "Efficient way to reconstruct minimal number sequence matching a digit subsequence",
    "body" : "<p>I got this task:</p>\n<p>The builders at a tech company are fixing a computer. This computer stores a special number made by a secret game using two small numbers, firstStep and secondStep. But uh-oh! Some digits (numbers) of the big number got lost!</p>\n<p>They still have part of the number called puzzleNumber. It’s like a puzzle — some of the numbers are there, but others are missing. The task is to figure out what the full number might have been before some digits were lost.</p>\n<p>Here’s how the game works:</p>\n<p>Start with a score of 0.</p>\n<p>You can add firstStep or secondStep to the score as many times as you want.</p>\n<p>Each time you add, write down only the last digit of the score (that’s called the unit digit, like the 3 in 123).</p>\n<p>Keep writing down these digits to make a big number.</p>\n<p>Now imagine you did this and got a number, but someone erased some of the digits. What you see now is puzzleNumber.</p>\n<p>Now the Task is:\nFind the smallest possible full number that could have made puzzleNumber by just erasing some digits from it.</p>\n<p>If it’s not possible to do that with any number from the game, return &quot;-1&quot;.</p>\n<p><strong>Example:</strong></p>\n<pre><code>puzzleNumber = &quot;27&quot;\nfirstStep = 2\nsecondStep = 3\n\nLet's play the game:\n\nStart at 0.\n\nAdd 2 → score = 2 → last digit = 2 → full = &quot;2&quot;\n\nAdd 2 → score = 4 → last digit = 4 → full = &quot;24&quot;\n\nAdd 3 → score = 7 → last digit = 7 → full = &quot;247&quot;\n\nNow look! If you remove the 4 from &quot;247&quot;, you get &quot;27&quot; — the same as puzzleNumber!\nThere could be other numbers too, like &quot;257&quot;, but we want the smallest one.\nSo the answer is: &quot;247&quot;\n</code></pre>\n<p><strong>constrains:</strong></p>\n<pre><code>2 &lt;= |puzzleNumber| &lt;= 2*10^5\n1 &lt;= firstStep, secondStep &lt;= 9\n</code></pre>\n<p>This is an interview question in hackerrank, and I have come up with below code but it passed 7 test cases out of 15 , one test case failed saying wrong output and remaining failed with time out errors. All the failed test cases are hidden so I don't have details of them.</p>\n<pre><code>import java.util.*;\n\npublic class Main {\n    public static String solve(String puzzleNumber, int firstStep, int secondStep) {\n        Queue&lt;State&gt; queue = new LinkedList&lt;&gt;();\n        Set&lt;String&gt; seen = new HashSet&lt;&gt;();\n\n        queue.offer(new State(0, &quot;&quot;, 0)); // cur, sequence, matchedIndex\n\n        while (!queue.isEmpty()) {\n            State curr = queue.poll();\n\n            if (curr.matched == puzzleNumber.length()) {\n                return curr.sequence;\n            }\n\n            String key = (curr.cur % 10) + &quot;:&quot; + curr.matched;\n            if (seen.contains(key)) continue;\n            seen.add(key);\n\n            // Try adding firstStep\n            int nextX = curr.cur + firstStep;\n            int digitX = nextX % 10;\n            int matchedX = curr.matched;\n            if (matchedX &lt; puzzleNumber.length() &amp;&amp; puzzleNumber.charAt(matchedX) == (char)(digitX + '0')) {\n                matchedX++;\n            }\n            queue.offer(new State(nextX, curr.sequence + digitX, matchedX));\n\n            // Try adding secondStep\n            if (firstStep != secondStep) { // prevent duplicate branches\n                int nextY = curr.cur + secondStep;\n                int digitY = nextY % 10;\n                int matchedY = curr.matched;\n                if (matchedY &lt; puzzleNumber.length() &amp;&amp; puzzleNumber.charAt(matchedY) == (char)(digitY + '0')) {\n                    matchedY++;\n                }\n                queue.offer(new State(nextY, curr.sequence + digitY, matchedY));\n            }\n        }\n\n        return &quot;-1&quot;;\n    }\n\n    static class State {\n        int cur;\n        String sequence;\n        int matched;\n\n        State(int cur, String sequence, int matched) {\n            this.cur = cur;\n            this.sequence = sequence;\n            this.matched = matched;\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(solve(&quot;27&quot;, 2, 3)); // Expected output: &quot;247&quot;\n        System.out.println(solve(&quot;324&quot;, 2, 3)); // Expected: 36924\n        System.out.println(solve(&quot;521&quot;, 5, 5)); // Expected: -1    \n    }\n}\n</code></pre>\n<p>What is the correct way to solve this problem in less time complexity?</p>\n",
    "tags" : [ "java", "algorithm" ],
    "owner" : {
      "account_id" : 31187804,
      "reputation" : 794,
      "user_id" : 23993901,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/7417aaad0c8ece3fac44f06d05a8ba8b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "CodeCrusader",
      "link" : "https://stackoverflow.com/users/23993901/codecrusader"
    },
    "is_answered" : true,
    "view_count" : 420,
    "answer_count" : 2,
    "score" : 7,
    "last_activity_date" : 1750027731,
    "creation_date" : 1749669773,
    "link" : "https://stackoverflow.com/questions/79662544/efficient-way-to-reconstruct-minimal-number-sequence-matching-a-digit-subsequenc",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79665332,
    "question_id" : 79662544,
    "body" : "<h3>Solvability</h3>\n<p>The check whether it is possible to do is pretty easy depending on step sizes:</p>\n<ul>\n<li>both 5: can only create 0 or 5</li>\n<li>both steps are even: only even digits can be created</li>\n<li>otherwise: all digits can be created</li>\n</ul>\n<p>So if you encounter one of the restrictions you can first check whether it is possible or not before you proceed. The mathematical reason why otherwise all digits can be created is because the gcd of 10 and the 2 step sizes is always 1, except for the combinations mentioned above: gcd(10, 5, 5) = 5 and gcd(10, even, even) = 2. The gcd tells us which digits we can create: all those where digit % gcd = 0.</p>\n<h3>Step Size Equality</h3>\n<p>If both steps are the same we can generate the solution in a straight forward way because there is always only one possibility how the next digit can be reached. The solution size is at most 10 times the input size (if all input digits are 0 and both steps are the same and 1, 3, 7 or 9). This makes 2 million and should be easily doable (use StringBuilder and not string concatenation).</p>\n<h3>Different Step Sizes</h3>\n<p>If the step sizes are different it is more complicated, but the solution size is at most 5 times the input size. The difficulty is to know when to add which digit. For this you can create a 10 x 10 array with the dimensions being current digit and difference and the stored value is the step size to take (everything is mod 10).\nThe current digit matters, e.g. steps = 2 and 3, diff = 5, if the current digit is 7, then you want to make step 3 first, otherwise step 2. You can create this array like so:</p>\n<ol>\n<li><p>Initializing everything to 0.</p>\n</li>\n<li><p>For each current digit set all those values where the difference is one of the step sizes (to the step size).</p>\n</li>\n<li><p>Go through the array (if both step sizes are even skip odd current number and differences) and if you encounter a 0 you check with both step sizes whether you can reach a populated value from that position.</p>\n<ol>\n<li>if not then remember that you had to skip a 0 value</li>\n<li>if only one was populated, use that step size</li>\n<li>if both were populated use the one leading to the lower current digit</li>\n</ol>\n</li>\n<li><p>Repeat 3. until you didn't have to skip a 0 value in 3.1. (at most 5 times). Important to note is that you have to make all the calculations in 3. based on the previous state to ensure not using values that were just populated in the current run of 3. For this it is probably the easiest to create a deep copy of the array at the start of 3. and then check against that clone.</p>\n</li>\n</ol>\n<p>Now you can also create the output for two different step sizes in a straightforward way by looking up next step size in the precalculated array.</p>\n<h3>Implementation</h3>\n<p>Here is an implementation. It uses a <strong>slightly different lookup format</strong>: current digit, next puzzle number digit and the value is the best next reachable digit (to get to the puzzle number digit). This is because it <strong>makes it easier to generate the solution</strong> (no more calculation like modulo needed, only a simple lookup), but otherwise the logic is the same as above.</p>\n<pre class=\"lang-java prettyprint-override\"><code>public static String solve(String puzzleNumber, int firstStep, int secondStep) {\n    int inc = 1; // increment\n    if (firstStep == 5 &amp;&amp; secondStep == 5) {\n        for (int i = 0; i &lt; puzzleNumber.length(); i++)\n            if ((puzzleNumber.charAt(i) - '0') % 5 != 0)\n                return &quot;-1&quot;;\n    } else if (firstStep % 2 == 0 &amp;&amp; secondStep % 2 == 0) {\n        for (int i = 0; i &lt; puzzleNumber.length(); i++)\n            if ((puzzleNumber.charAt(i) - '0') % 2 != 0)\n                return &quot;-1&quot;;\n        inc = 2;\n    }\n    StringBuilder sb = new StringBuilder();\n    if (firstStep == secondStep) {\n        for (int i = 0, d = 0; i &lt; puzzleNumber.length(); i++)\n            do {\n                d = (d + firstStep) % 10;\n                sb.append(d);\n            } while (d != puzzleNumber.charAt(i) - '0');\n    } else {\n        int[][] lookup = new int[10][10];\n        for (int i = 0; i &lt; 10; i += inc)\n            for (int j = 0; j &lt; 10; j += inc)\n                lookup[i][j] = 10;\n        for (int i = 0; i &lt; 10; i += inc) {\n            lookup[i][(i + firstStep) % 10] = (i + firstStep) % 10;\n            lookup[i][(i + secondStep) % 10] = (i + secondStep) % 10;\n        }\n        boolean skipped = true;\n        while (skipped) {\n            skipped = false;\n            int[][] backup = new int[10][];\n            for (int i = 0; i &lt; 10; i += inc)\n                backup[i] = lookup[i].clone();\n            for (int cur = 0; cur &lt; 10; cur += inc)\n                for (int next = 0; next &lt; 10; next += inc)\n                    if (backup[cur][next] == 10) {\n                        int cur1 = (cur + firstStep) % 10;\n                        int cur2 = (cur + secondStep) % 10;\n                        if (backup[cur1][next] + backup[cur2][next] == 20)\n                            skipped = true;\n                        else if (backup[cur2][next] == 10)\n                            lookup[cur][next] = cur1;\n                        else if (backup[cur1][next] == 10)\n                            lookup[cur][next] = cur2;\n                        else\n                            lookup[cur][next] = Math.min(cur1, cur2);\n                    }\n        }\n        for (int i = 0, d = 0; i &lt; puzzleNumber.length(); i++)\n            do {\n                d = lookup[d][puzzleNumber.charAt(i) - '0'];\n                sb.append(d);\n            } while (d != puzzleNumber.charAt(i) - '0');\n    }\n    return sb.toString();\n}\n</code></pre>\n<p>Time complexity O(n) and additional space is O(1). You can't get better than that complexity-wise. I might not be a &quot;reputable source&quot;, but I know hackerrank very well and I'm pretty sure this will pass all the tests easily.</p>\n",
    "score" : 16,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 6136413,
      "reputation" : 9587,
      "user_id" : 4785110,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/71b70abe72497023835a6dd8961b7c89?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "maraca",
      "link" : "https://stackoverflow.com/users/4785110/maraca"
    },
    "creation_date" : 1749845241,
    "last_activity_date" : 1750027731,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79662648,
    "question_id" : 79662544,
    "body" : "<p>You seem to be doing a breadth-first search.</p>\n<p>To make it faster at finding the correct answer, you can</p>\n<ul>\n<li>explore the same states in less time, by optimizing your code</li>\n<li>make your search smarter, exploring less states to find the answer</li>\n</ul>\n<p>Avoiding string manipulation (use <code>byte[]</code>, if you can safely find a maximal length?) and generally making states simpler would help to explore faster. Also, you could use a queue built on a circular vector instead of a linked list (avoids many allocations).</p>\n<p>To search smarter, you would need to find some additional structure in the problem. Since you only retain <code>score % 10</code> at each step, you can build a look-up table with the shortest sequence of [step1,step2] to reach each digit given the last score digit. That should be much faster than blind depth-first search: once you have built this table, you can advance directly to your goal. For the initial example, with step1=2 and step2=3, the table would look like:</p>\n<pre><code>delta  optimal sequence\n    0 = 2+2+3+3\n    1 = 2+3+3+3\n    2 = 2\n    3 = 3\n    4 = 2+2\n    5 = 2+3\n    6 = 3+3\n    7 = 2+2+3\n    8 = 2+3+3\n    9 = 3+3+3\n</code></pre>\n<p>so, to get to &quot;27&quot; using this table</p>\n<pre><code>(current=0, goal=2, delta=2) =&gt; choose 2 =&gt; score%10 = 2, output &quot;2&quot;\n(current=2, goal=7, delta=5) =&gt; choose 2, then 3 =&gt; score%10 = 7, output &quot;247&quot;\n</code></pre>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 8546,
      "reputation" : 18030,
      "user_id" : 15472,
      "user_type" : "registered",
      "accept_rate" : 87,
      "profile_image" : "https://www.gravatar.com/avatar/9b4128da626e5b0049cd4fb88033e3b3?s=256&d=identicon&r=PG",
      "display_name" : "tucuxi",
      "link" : "https://stackoverflow.com/users/15472/tucuxi"
    },
    "creation_date" : 1749674876,
    "last_activity_date" : 1749674876,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140515962,
    "post_id" : 79662544,
    "body" : "@KellyBundy  I thought I remembered his answer there before the bounty was put up.  It&#39;s why I didn&#39;t answer this one -- there was already a good answer.",
    "score" : 0,
    "owner" : {
      "account_id" : 7178634,
      "reputation" : 60910,
      "user_id" : 5483526,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/780a651189f64a2cbf4b7f62cf852005?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Matt Timmermans",
      "link" : "https://stackoverflow.com/users/5483526/matt-timmermans"
    },
    "creation_date" : 1750045040,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140515507,
    "post_id" : 79662544,
    "body" : "@MattTimmermans But how do you know that maraca would&#39;ve answered without the bounty?",
    "score" : 0,
    "owner" : {
      "account_id" : 17476274,
      "reputation" : 27969,
      "user_id" : 12671057,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/90d2e6942c69df199a95d06e0c8e9a10?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Kelly Bundy",
      "link" : "https://stackoverflow.com/users/12671057/kelly-bundy"
    },
    "creation_date" : 1750017312,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140515325,
    "post_id" : 79662544,
    "body" : "didn&#39;t really need to add a bounty.  @maraca&#39;s answer is good.",
    "score" : 0,
    "owner" : {
      "account_id" : 7178634,
      "reputation" : 60910,
      "user_id" : 5483526,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/780a651189f64a2cbf4b7f62cf852005?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Matt Timmermans",
      "link" : "https://stackoverflow.com/users/5483526/matt-timmermans"
    },
    "creation_date" : 1750010849,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140508633,
    "post_id" : 79662544,
    "body" : "@OldDogProgrammer, some test cases failed with wrong output so not my post is not eligible for code review site",
    "score" : 3,
    "owner" : {
      "account_id" : 31187804,
      "reputation" : 794,
      "user_id" : 23993901,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/7417aaad0c8ece3fac44f06d05a8ba8b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "CodeCrusader",
      "link" : "https://stackoverflow.com/users/23993901/codecrusader"
    },
    "creation_date" : 1749733132,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140506719,
    "post_id" : 79662544,
    "body" : "@ElliottFrisch, when i ried <code>Queue&lt;State&gt; queue = new PriorityQueue&lt;&gt;((a,b) -&gt; a.sequence.compareTo(b.sequence));</code> the output are not matching, for example the correct answer is 247 but im getting 24680357 for 1st test case in my main method.",
    "score" : 0,
    "owner" : {
      "account_id" : 31187804,
      "reputation" : 794,
      "user_id" : 23993901,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/7417aaad0c8ece3fac44f06d05a8ba8b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "CodeCrusader",
      "link" : "https://stackoverflow.com/users/23993901/codecrusader"
    },
    "creation_date" : 1749671215,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140506682,
    "post_id" : 79662544,
    "body" : "Try changing <code>Queue&lt;State&gt; queue = new LinkedList&lt;&gt;();</code> to <code>Queue&lt;State&gt; queue = new PriorityQueue&lt;&gt;();</code>",
    "score" : 0,
    "owner" : {
      "account_id" : 3557625,
      "reputation" : 201916,
      "user_id" : 2970947,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/HLTev.png?s=256",
      "display_name" : "Elliott Frisch",
      "link" : "https://stackoverflow.com/users/2970947/elliott-frisch"
    },
    "creation_date" : 1749670174,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79665332" : [ {
      "comment_id" : 140515674,
      "post_id" : 79665332,
      "body" : "@KellyBundy I viewed the StringBuilder as the result, you could return it instead of a string. Otherwise all algorithms generating a string of size O(n) in O(n) steps need O(n) space because Strings are immutable in Java. Whether you create it from char array, concatenation or with a StringBuilder.",
      "score" : 0,
      "owner" : {
        "account_id" : 6136413,
        "reputation" : 9587,
        "user_id" : 4785110,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/71b70abe72497023835a6dd8961b7c89?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "maraca",
        "link" : "https://stackoverflow.com/users/4785110/maraca"
      },
      "creation_date" : 1750025142,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140515528,
      "post_id" : 79665332,
      "body" : "How is it &quot;additional space is O(1)&quot;? I get why the return value isn&#39;t &quot;additional space&quot;, but what about the StringBuilder?",
      "score" : 0,
      "owner" : {
        "account_id" : 17476274,
        "reputation" : 27969,
        "user_id" : 12671057,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/90d2e6942c69df199a95d06e0c8e9a10?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Kelly Bundy",
        "link" : "https://stackoverflow.com/users/12671057/kelly-bundy"
      },
      "creation_date" : 1750018079,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}