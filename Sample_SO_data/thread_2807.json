{
  "question" : {
    "question_id" : 79594185,
    "title" : "Why does ScheduledExecutorService stop after first execution in Java?",
    "body" : "<p>I am working on a Java project and using a ScheduledExecutorService to run a task at a fixed interval.\nHowever, I noticed that the task only runs once and then stops, even though I am using scheduleAtFixedRate.</p>\n<p>Here is the code:</p>\n<pre><code>import java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class SchedulerTest {\npublic static void main(String[] args) {\n    ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n    \n    scheduler.scheduleAtFixedRate(() -&gt; {\n        System.out.println(&quot;Running task at: &quot; + System.currentTimeMillis());\n        if (true) { \n            throw new RuntimeException(&quot;Exception during task execution&quot;);\n        }\n    }, 0, 5, TimeUnit.SECONDS);\n}\n</code></pre>\n<p>I expected the task to continue running and print a message every 5 seconds, even if an exception occurs during execution.</p>\n<p>I tried the following:</p>\n<ul>\n<li>Replacing scheduleAtFixedRate with scheduleWithFixedDelay.</li>\n<li>Removing the RuntimeException and noticed that the task keeps running normally.</li>\n<li>Searching online, but most discussions focus on scheduling delays, not on tasks stopping after an exception.</li>\n</ul>\n",
    "tags" : [ "java", "concurrency", "scheduledexecutorservice" ],
    "owner" : {
      "account_id" : 41618822,
      "reputation" : 21,
      "user_id" : 30374414,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/MVMzhZpB.jpg?s=256",
      "display_name" : "Hanan",
      "link" : "https://stackoverflow.com/users/30374414/hanan"
    },
    "is_answered" : true,
    "view_count" : 139,
    "answer_count" : 3,
    "score" : 2,
    "last_activity_date" : 1745748090,
    "creation_date" : 1745687026,
    "link" : "https://stackoverflow.com/questions/79594185/why-does-scheduledexecutorservice-stop-after-first-execution-in-java",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79594191,
    "question_id" : 79594185,
    "body" : "<p>The documentation for <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/ScheduledExecutorService.html#scheduleAtFixedRate(java.lang.Runnable,long,long,java.util.concurrent.TimeUnit)\" rel=\"noreferrer\">scheduleAtFixedRate</a> is quite clear:</p>\n<blockquote>\n<p>The sequence of task executions continues indefinitely until one of the following exceptional completions occur:</p>\n<p>An execution of the task throws an exception. In this case calling get on the returned future will throw ExecutionException, holding the exception as its cause.</p>\n</blockquote>\n<p>Thus task is not run after the exception. The returned value from the call will give a future which you can use to retrieve the status, after exception <code>future.isDone()</code> will be true and <code>future.get()</code> would return the exception.</p>\n<pre><code>var future = scheduler.scheduleAtFixedRate(() -&gt; {\n    System.out.println(&quot;Running task at: &quot; + System.currentTimeMillis());\n    if (true) { \n        throw new RuntimeException(&quot;Exception during task execution&quot;);\n    }\n}, 0, 5, TimeUnit.SECONDS);\n</code></pre>\n",
    "score" : 5,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 5998820,
      "reputation" : 16283,
      "user_id" : 4712734,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f6e922a2cb7e2da59286f27b162aaca5?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "DuncG",
      "link" : "https://stackoverflow.com/users/4712734/duncg"
    },
    "creation_date" : 1745687507,
    "last_activity_date" : 1745688049,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79594206,
    "question_id" : 79594185,
    "body" : "<p>In ScheduledExecutorService, if a task throws an exception and itâ€™s not caught inside the task, the scheduler cancels it automatically.</p>\n<p>In my code, the RuntimeException caused the task to stop after the first run.</p>\n<p>To fix it, I should catch exceptions inside the task using a try-catch block, so that the scheduler can continue running the task even if an error happens</p>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 41589017,
      "reputation" : 41,
      "user_id" : 30360329,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/9089d438b69458cfb588f49cb2bde55b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Raneem Alharbi",
      "link" : "https://stackoverflow.com/users/30360329/raneem-alharbi"
    },
    "creation_date" : 1745688047,
    "last_activity_date" : 1745688047,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79594208,
    "question_id" : 79594185,
    "body" : "<p>The fact that you throw an error ends the scheduled task, as DuncG already stated. Nevertheless, your program would also quit after scheduling the task, as ScheduledExecutorService operates asynchronously. So removing the</p>\n<pre><code>throw new RuntimeException(&quot;Exception during task execution&quot;);\n</code></pre>\n<p>part, would result in same observation. You need to keep you app running to also keep the asynchronous SchedulerService running. Consider using <a href=\"https://github.com/awaitility/awaitility\" rel=\"nofollow noreferrer\">Awaitility </a> to do so:</p>\n<pre><code>public static void main(String[] args) {\n    try (ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1)) {\n      final ScheduledFuture&lt;?&gt; scheduledFuture = scheduler.scheduleAtFixedRate(() -&gt; {\n        System.out.println(&quot;Running task at: &quot; + System.currentTimeMillis());\n      }, 0, 5, TimeUnit.SECONDS);\n      Awaitility.await().until(scheduledFuture::isDone);\n    }\n}\n</code></pre>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 11555562,
      "reputation" : 569,
      "user_id" : 8466853,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/cd7f72b426ce3c46739900b8ba014e26?s=256&d=identicon&r=PG",
      "display_name" : "Arno",
      "link" : "https://stackoverflow.com/users/8466853/arno"
    },
    "creation_date" : 1745688102,
    "last_activity_date" : 1745748090,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140372520,
    "post_id" : 79594185,
    "body" : "This has been covered multiple times, so search to learn more. Upshot: Feature not a bug. Trap for most or all exceptions, and possibly errors, if you want to avoid halting of your repeating task.",
    "score" : 1,
    "owner" : {
      "account_id" : 322981,
      "reputation" : 346951,
      "user_id" : 642706,
      "user_type" : "registered",
      "accept_rate" : 58,
      "profile_image" : "https://i.sstatic.net/ZWEI3.jpg?s=256",
      "display_name" : "Basil Bourque",
      "link" : "https://stackoverflow.com/users/642706/basil-bourque"
    },
    "creation_date" : 1745698444,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79594208" : [ {
      "comment_id" : 140372717,
      "post_id" : 79594208,
      "body" : "<code>Executors::newScheduledThreadPool(int)</code> creates a pool that uses <i>non-daemon</i> threads. They&#39;ll keep the JVM alive even after the main thread exits. But you&#39;re right this is something to keep in mind.",
      "score" : 1,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49884,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1745708145,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}