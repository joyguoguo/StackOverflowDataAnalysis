{
  "question" : {
    "question_id" : 79583872,
    "title" : "Remove substring from string that consists of same words but different separators between them",
    "body" : "<p>In my Java program I have the two strings x and y.</p>\n<p>String y is a substring of x. It contains the same words in the same order as x, but the words are separated in different ways.</p>\n<p>String x contains &quot; &quot; and &quot;\\n&quot; as separators.\nString y contains &quot; &quot; and &quot;\\r\\n&quot; as separators.</p>\n<p>Note that y contains separators at places where x does not contain separators.</p>\n<p>For example:</p>\n<pre><code>String x = &quot;Hello, \\nI am a cool \\nstring and that \\nis nice.&quot;\nString y = &quot;Hello, \\r\\nI am a \\r\\ncool \\r\\n \\r\\nstring&quot;\n</code></pre>\n<p>I want to remove the substring y from the string x, while x needs to keep every &quot;\\n&quot;.\nSo for the example my final string should be:</p>\n<pre><code>String final = &quot; and that \\nis nice.&quot;\n</code></pre>\n<p>Extra info: This problem occurs in my JavaFX application. The user can enter a text which should be printed in a PDF file (string x in the example above). The text is too long for one field in the PDF. That's why I need to scan the text of the field (string y), remove it from the user-input-string (string x), and add the shortened string (string final) to the next field in the PDF. String y contains more separators than x because the text is wrapped in the PDF field, which creates extra line breaks.\nSee this post for more information: <a href=\"https://stackoverflow.com/questions/79581684/how-to-retrieve-only-the-visible-inside-of-border-text-of-pdfield\">How to retrieve only the visible (inside of border) text of PDField?</a></p>\n",
    "tags" : [ "java", "string", "substring" ],
    "owner" : {
      "account_id" : 29060554,
      "reputation" : 19,
      "user_id" : 22261336,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/c47937c02449181b5b6eb9b5c8ecafa5?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "felixschoene",
      "link" : "https://stackoverflow.com/users/22261336/felixschoene"
    },
    "is_answered" : true,
    "view_count" : 169,
    "answer_count" : 3,
    "score" : -2,
    "last_activity_date" : 1745252503,
    "creation_date" : 1745194092,
    "link" : "https://stackoverflow.com/questions/79583872/remove-substring-from-string-that-consists-of-same-words-but-different-separator",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79584242,
    "question_id" : 79583872,
    "body" : "<p>Here's a really stupid idea: convert your pattern (string y) to a regular expression and match it against your input (string x). In the regex, you would collapse all repeated space and CRLF sequences into a subpattern that matches at least one space or line feed.</p>\n<pre><code>final String x = &quot;Hello, \\nI am a cool \\nstring and that \\nis nice.&quot;;\nfinal String y = &quot;Hello, \\r\\nI am a \\r\\ncool \\r\\n \\r\\nstring&quot;;\n\nfinal String pattern = y.replaceAll(&quot;( |\\r\\n)+&quot;, &quot;[ \\\\\\\\n]+&quot;);\nfinal String result = x.replaceAll(pattern, &quot;&quot;);\n</code></pre>\n<p>Result = <code>&quot; and that \\nis nice.&quot;</code></p>\n<p>Note that this means that any other regular expression meta characters in your search string will also have an effect. You might want to escape the search string first (<code>Pattern#escape</code>), then transform it into a valid regular expression.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 39208,
      "reputation" : 269387,
      "user_id" : 112968,
      "user_type" : "registered",
      "accept_rate" : 68,
      "profile_image" : "https://i.sstatic.net/zHTaT.png?s=256",
      "display_name" : "knittl",
      "link" : "https://stackoverflow.com/users/112968/knittl"
    },
    "creation_date" : 1745222677,
    "last_activity_date" : 1745229951,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79584936,
    "question_id" : 79583872,
    "body" : "<p>One way to do it would be to match regions of strings while ignoring and skipping over the characters you don't consider to be significant for matching:</p>\n<pre><code>/**\n * Determines if the code point can be skipped.\n * i.e. is it in the string and a space, carriage return or newline?\n */\nboolean isSkippable(String s, int index) {\n    if (index &lt; 0 || index &gt;= s.length()) return false;\n    int cp = s.codePointAt(index);\n    return cp == ' ' || cp == '\\r' || cp == '\\n';\n}\n\n/**\n * Finds the end of the matching region starting at the offset,\n * skipping ignorable whitespace, or returns -1 if no match.\n */\nint matchAtIgnoreSpace(String haystack, String needle, int offset) {\n    int needex = 0;\n    // skip over any skippable whitespace\n    while (isSkippable(needle, needex)) needex = needle.offsetByCodePoints(needex, 1);\n    while (isSkippable(haystack, offset)) offset = haystack.offsetByCodePoints(offset, 1);\n    while (needex &lt; needle.length() &amp;&amp; offset &lt; haystack.length()) {\n        if (haystack.codePointAt(offset) != needle.codePointAt(needex)) {\n            return -1;  // the characters don't match\n        } else {\n            // they matched; advance by one\n            needex = needle.offsetByCodePoints(needex, 1);\n            offset = haystack.offsetByCodePoints(offset, 1);\n        }\n        while (isSkippable(needle, needex)) needex = needle.offsetByCodePoints(needex, 1);\n        // if we just matched the last character, we're done\n        if (needex == needle.length()) return offset;\n        while (isSkippable(haystack, offset)) offset = haystack.offsetByCodePoints(offset, 1);\n    }\n    return offset;\n}\n\n/**\n * Removes the needle from the haystack if it matches at any offset,\n * ignoring skippable whitespace. Only removes the first match, if any.\n * Returns the original haystack string if there is no match.\n */\nString removeIgnoreSpace(String haystack, String needle) {\n    for (int i = 0; i &lt; haystack.length(); i++) {\n        int end = matchAtIgnoreSpace(haystack, needle, i);\n        if (end != -1) {\n            String result = haystack.substring(0, i) + haystack.substring(end + 1);\n            return result;\n        }\n    }\n    return haystack;\n}\n</code></pre>\n<p>If you call it with your <code>x</code> and <code>y</code> strings, it returns `&quot; and that \\nis nice&quot; as expected. If the match is not at the beginning then</p>\n<pre><code>removeIgnoreSpace(&quot;beginning &quot; + x, y)\n</code></pre>\n<p>would return <code>&quot;beginning and that \\nis nice&quot;</code>, removing only the region that matched.</p>\n<p>(Note: the conditional return commented with &quot;if we just matched the last character, we're done&quot; is intended to keep from advancing the offset into the haystack when the entire needle has been matched; otherwise, we would consume the space and only return &quot;and that \\nis nice&quot; without the leading space.)</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 318670,
      "reputation" : 16467,
      "user_id" : 636009,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/IIQJV.jpg?s=256",
      "display_name" : "David Conrad",
      "link" : "https://stackoverflow.com/users/636009/david-conrad"
    },
    "creation_date" : 1745252061,
    "last_activity_date" : 1745252503,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79584443,
    "question_id" : 79583872,
    "body" : "<p>try this one.</p>\n<pre><code>public class Main {\n    public static void main(String[] args) {\n        String x = &quot;Hello, \\nI am a cool \\nstring and that \\nis nice.&quot;;\n        String y = &quot;Hello, \\r\\nI am a \\r\\ncool \\r\\n \\r\\nstring&quot;;\n\n        String xNormalized = x.replace(&quot;\\n&quot;, &quot; &quot;).replaceAll(&quot;\\\\s+&quot;, &quot; &quot;).trim();\n        String yNormalized = y.replace(&quot;\\r\\n&quot;, &quot; &quot;).replaceAll(&quot;\\\\s+&quot;, &quot; &quot;).trim();\n\n        // find where yNormalized starts in xNormalized\n        int matchIndex = xNormalized.indexOf(yNormalized);\n        if (matchIndex == -1) {\n            System.out.println(&quot;Y is not a normalized substring of X.&quot;);\n            return;\n        }\n\n        //remove from original x the words that match yNormalized (but preserve newlines)\n        String[] yWords = yNormalized.split(&quot; &quot;);\n        int wordIndex = 0;\n\n        StringBuilder result = new StringBuilder();\n        StringBuilder currentWord = new StringBuilder();\n        boolean inMatchingPart = false;\n\n        for (int i = 0; i &lt; x.length(); i++) {\n            char ch = x.charAt(i);\n\n            if (ch == '\\n') {\n               \n                result.append('\\n');\n                continue;\n            }\n\n            if (Character.isWhitespace(ch)) {\n                if (currentWord.length() &gt; 0) {\n                    String word = currentWord.toString();\n\n                    if (wordIndex &lt; yWords.length &amp;&amp; word.equals(yWords[wordIndex])) {\n                        \n                        wordIndex++;\n                    } else {\n                       \n                        result.append(word);\n                    }\n                    currentWord.setLength(0);\n                }\n               \n                if (wordIndex &gt;= yWords.length) {\n                    result.append(ch);\n                }\n            } else {\n                currentWord.append(ch);\n            }\n        }\n\n       \n        if (currentWord.length() &gt; 0) {\n            String word = currentWord.toString();\n            if (wordIndex &lt; yWords.length &amp;&amp; word.equals(yWords[wordIndex])) {\n                \n            } else {\n                result.append(word);\n            }\n        }\n\n        System.out.println(&quot;Final Output:\\n&quot; + result.toString());\n    }\n}\n</code></pre>\n",
    "score" : -1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 29151515,
      "reputation" : 166,
      "user_id" : 22332267,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/AAcHTteMmC3TlDsNht62CPTM2CLujCwbZb-hUNbmiCJHIbLb=k-s256",
      "display_name" : "Lojini",
      "link" : "https://stackoverflow.com/users/22332267/lojini"
    },
    "creation_date" : 1745232074,
    "last_activity_date" : 1745232074,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140354826,
    "post_id" : 79583872,
    "body" : "One problem is, if you skip as many spaces, carriage returns, and newlines to match only the other characters, you&#39;ll skip the space and just get &quot;and that \\nis nice&quot; without the leading space. Do you have to retain that leading space? (Also, nit: <code>final</code> is not allowed as a Java identifier.)",
    "score" : 0,
    "owner" : {
      "account_id" : 318670,
      "reputation" : 16467,
      "user_id" : 636009,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/IIQJV.jpg?s=256",
      "display_name" : "David Conrad",
      "link" : "https://stackoverflow.com/users/636009/david-conrad"
    },
    "creation_date" : 1745248957,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140354766,
    "post_id" : 79583872,
    "body" : "Instead of trying to convert the strings as in some answers, you could write a matching function that skips the spaces and line separators. Does the string to be removed always occur at the beginning of the other string, or can it appear anywhere?",
    "score" : 0,
    "owner" : {
      "account_id" : 318670,
      "reputation" : 16467,
      "user_id" : 636009,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/IIQJV.jpg?s=256",
      "display_name" : "David Conrad",
      "link" : "https://stackoverflow.com/users/636009/david-conrad"
    },
    "creation_date" : 1745247389,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140354062,
    "post_id" : 79583872,
    "body" : "You said that your string <code>x</code> must keep all the <code>\\n</code> linebreaks. Why are the <code>\\n</code> sequences between <code>Hello, \\nI</code> and <code>cool \\nstring</code> removed in your final <code>x</code> string?",
    "score" : 1,
    "owner" : {
      "account_id" : 108033,
      "reputation" : 20099,
      "user_id" : 286934,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f16a184d26b72795ff243464d715cffe?s=256&d=identicon&r=PG",
      "display_name" : "Progman",
      "link" : "https://stackoverflow.com/users/286934/progman"
    },
    "creation_date" : 1745231417,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140353763,
    "post_id" : 79583872,
    "body" : "Are line breaks always following a space like in your example? Note that string x has <code>a cool \\nstring</code> but y has <code>a \\r\\ncool \\r\\n \\r\\nstring</code> (two spaces between cool and string). How do you want to match <code>replace me</code> and <code>replace     me</code> or <code>rep lace m e</code>?",
    "score" : 0,
    "owner" : {
      "account_id" : 39208,
      "reputation" : 269387,
      "user_id" : 112968,
      "user_type" : "registered",
      "accept_rate" : 68,
      "profile_image" : "https://i.sstatic.net/zHTaT.png?s=256",
      "display_name" : "knittl",
      "link" : "https://stackoverflow.com/users/112968/knittl"
    },
    "creation_date" : 1745221730,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79584443" : [ {
      "comment_id" : 140354832,
      "post_id" : 79584443,
      "body" : "Using <code>&quot;\\\\s+&quot;</code> will also treat tabs and other whitespace characters as special.",
      "score" : 0,
      "owner" : {
        "account_id" : 318670,
        "reputation" : 16467,
        "user_id" : 636009,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/IIQJV.jpg?s=256",
        "display_name" : "David Conrad",
        "link" : "https://stackoverflow.com/users/636009/david-conrad"
      },
      "creation_date" : 1745249055,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}