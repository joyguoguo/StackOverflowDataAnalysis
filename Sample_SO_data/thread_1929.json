{
  "question" : {
    "question_id" : 79663059,
    "title" : "Cybersource microform upgrade from V0.4 to V2 -Validation of the Context key with the public key is getting failed",
    "body" : "<p><a href=\"https://i.sstatic.net/JpxWEOT2.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/JpxWEOT2.png\" alt=\"enter image description here\" /></a></p>\n<p>Here is the class that am using ,based on the flow that I have ,the validation always fails and return false in the line boolean isValid = signature.verify(signatureBytes);\nLOG.info(&quot;Signature valid? {}&quot;, isValid);\ncan i plase request you to validate and advie what is it that am doing wrong and i am trying to use only java libraries for validations or conversions.\nAm not sure if am using right libs / code to vlaidate the token.</p>\n<pre><code>package com.wwg.integrations.validator;\nimport de.hybris.platform.servicelayer.config.ConfigurationService;\nimport org.apache.http.conn.ssl.SSLConnectionSocketFactory;\nimport org.apache.http.impl.client.HttpClients;\nimport org.json.JSONObject;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.http.client.HttpComponentsClientHttpRequestFactory;\nimport org.springframework.web.client.RestTemplate;\nimport java.nio.charset.StandardCharsets;\nimport javax.net.ssl.SSLContext;\nimport java.math.BigInteger;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.security.KeyFactory;\nimport java.security.KeyManagementException;\nimport java.security.KeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.security.cert.X509Certificate;\nimport java.security.spec.RSAPublicKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.Arrays;\nimport java.util.Base64;\n\npublic class CaptureContextTokenValidator {\n    private static final Logger LOG = LoggerFactory.getLogger(WWGCaptureContextTokenValidator.class);\n    public static final String CYBERSOURCE_PUBLIC_KEY_URL = &quot;cybersource.public.key.url&quot;;\n    private ConfigurationService configurationService;\n\n    public boolean validateCaptureContextToken(String captureContextToken) {\n        if (captureContextToken == null || captureContextToken.isEmpty()) {\n            LOG.error(&quot;Capture context token is null or empty&quot;);\n            return false;\n        }\n        String kidId = extractKidFromJWTToken(captureContextToken);\n        JSONObject jwkJson = fetchRSAKeyUsingKidId(kidId);\n        try {\n            PublicKey publicKey = extractPublicKeyFromJWK(jwkJson);\n            LOG.info(&quot;Public Key: &quot; + publicKey);\n            return validateCaptureContextWithPublicKey(captureContextToken, publicKey);\n        } catch (Exception e) {\n            throw new RuntimeException(&quot;Error during validation&quot;, e);\n        }\n    }\n\n    private JSONObject fetchRSAKeyUsingKidId(String kidId) {\n        RestTemplate restTemplate = getRestTemplate();\n        final String publicKeyURL = getConfigurationService().getConfiguration().getString(CYBERSOURCE_PUBLIC_KEY_URL) + kidId;\n        LOG.info(&quot;Fetching public key using : &quot; + publicKeyURL);\n\n        try {\n            URI uri = new URI(publicKeyURL);\n            HttpEntity&lt;String&gt; requestEntity = new HttpEntity&lt;&gt;(null, null);\n            ResponseEntity&lt;String&gt; result = restTemplate.exchange(uri, HttpMethod.GET, requestEntity, String.class);\n            String jsonResponse = result.getBody();\n            LOG.info(&quot;Response from public key fetch: &quot; + jsonResponse);\n            return new JSONObject(jsonResponse);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(&quot;Invalid URI&quot;, e);\n        } catch (Exception e) {\n            throw new RuntimeException(&quot;Error parsing JSON response&quot;, e);\n        }\n    }\n\n    private RestTemplate getRestTemplate() {\n        try {\n            SSLContext sslContext = org.apache.http.ssl.SSLContexts.custom()\n                    .loadTrustMaterial(null, (X509Certificate[] chain, String authType) -&gt; true)\n                    .build();\n            HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();\n            requestFactory.setHttpClient(HttpClients.custom().setSSLSocketFactory(new SSLConnectionSocketFactory(sslContext)).build());\n            return new RestTemplate(requestFactory);\n        } catch (NoSuchAlgorithmException | KeyManagementException | KeyStoreException e) {\n            throw new RuntimeException(&quot;Error creating RestTemplate&quot;, e);\n        }\n    }\n\n    public PublicKey extractPublicKeyFromJWK(JSONObject jwk) throws Exception {\n        // Extract the modulus and exponent\n        String n = jwk.getString(&quot;n&quot;);\n        String e = jwk.getString(&quot;e&quot;);\n\n        // Add padding to make Base64 decoding safe\n        n = addBase64Padding(n);\n        e = addBase64Padding(e);\n\n        // Decode using URL-safe decoder\n        byte[] modulusBytes = Base64.getUrlDecoder().decode(n);\n        byte[] exponentBytes = Base64.getUrlDecoder().decode(e);\n\n        // Convert to BigInteger\n        BigInteger modulus = new BigInteger(1, modulusBytes);\n        BigInteger exponent = new BigInteger(1, exponentBytes);\n\n        // Create the public key spec\n        RSAPublicKeySpec spec = new RSAPublicKeySpec(modulus, exponent);\n        KeyFactory factory = KeyFactory.getInstance(&quot;RSA&quot;);\n\n        return factory.generatePublic(spec);\n    }\n\n    private String addBase64Padding(String base64) {\n        int paddingLength = (4 - base64.length() % 4) % 4;\n        return base64 + &quot;=&quot;.repeat(paddingLength);\n    }\n\n    private boolean validateCaptureContextWithPublicKey(String captureContextToken, PublicKey publicKey) {\n        try {\n            // Split the JWT token into parts\n            String[] parts = captureContextToken.split(&quot;\\\\.&quot;);\n            if (parts.length != 3) {\n                LOG.error(&quot;Invalid JWT token format: {}&quot;, captureContextToken);\n                return false;\n            }\n\n            // Construct header and payload\n            String headerAndPayload = parts[0] + &quot;.&quot; + parts[1];\n            byte[] signatureBytes = Base64.getUrlDecoder().decode(parts[2]);\n\n            // Initialize the Signature instance\n            Signature signature = Signature.getInstance(&quot;SHA256withRSA&quot;);\n            signature.initVerify(publicKey);\n\n            // Update the Signature instance with header and payload\n            signature.update(headerAndPayload.getBytes(StandardCharsets.US_ASCII));\n\n            // Verify the signature\n            boolean isValid = signature.verify(signatureBytes);\n            LOG.info(&quot;Signature valid? {}&quot;, isValid);\n            return isValid;\n        } catch (Exception e) {\n            LOG.error(&quot;Error validating JWT signature&quot;, e);\n            return false;\n        }\n    }\n\n\n    private String extractKidFromJWTToken(String jwt) {\n        try {\n            String[] parts = jwt.split(&quot;\\\\.&quot;);\n            if (parts.length &lt; 2) {\n                throw new IllegalArgumentException(&quot;Invalid JWT token format&quot;);\n            }\n            String bodyData = new String(Base64.getUrlDecoder().decode(parts[1]));\n            JSONObject jsonObject = new JSONObject(bodyData);\n            return     jsonObject\n                    .getJSONObject(&quot;flx&quot;)\n                    .getJSONObject(&quot;jwk&quot;)\n                    .optString(&quot;kid&quot;);\n        } catch (Exception e) {\n            throw new RuntimeException(&quot;Failed to extract kid from JWT token&quot;, e);\n        }\n    }\n\n    public ConfigurationService getConfigurationService() {\n        return configurationService;\n    }\n    public void setConfigurationService(ConfigurationService configurationService) {\n        this.configurationService = configurationService;\n    }\n\n}\n</code></pre>\n",
    "tags" : [ "java", "encryption", "rsa", "cybersource" ],
    "owner" : {
      "account_id" : 2517144,
      "reputation" : 381,
      "user_id" : 2188318,
      "user_type" : "registered",
      "accept_rate" : 59,
      "profile_image" : "https://i.sstatic.net/naNI5.jpg?s=256",
      "display_name" : "Karthik",
      "link" : "https://stackoverflow.com/users/2188318/karthik"
    },
    "is_answered" : false,
    "view_count" : 93,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1749711737,
    "creation_date" : 1749711737,
    "link" : "https://stackoverflow.com/questions/79663059/cybersource-microform-upgrade-from-v0-4-to-v2-validation-of-the-context-key-wit",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ ],
  "answer_comments" : { }
}