{
  "question" : {
    "question_id" : 79767460,
    "title" : "Java Beans are not being created when not referenced by others directly in Weld",
    "body" : "<p>I have 2 providers which contains details about themselves and they are updating a ProviderDetails class which contains details of all the providers</p>\n<pre class=\"lang-java prettyprint-override\"><code>class ProviderA{ \n    @Inject \n    AllProviderDetails allProviderDetails;\n\n    @postConstruct\n    void init(){\n    allProviderDetails.update(something);\n    }\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>class ProviderB{ \n    @Inject \n    AllProviderDetails allProviderDetails;\n    \n    @postConstruct\n    void init(){\n    allProviderDetails.update(something);\n    }\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>@Singleton \nclass AllProviderDetails { \n    public void getDetails(){\n    return something; \n    }\n\n    public void update(){\n    update details\n    }\n}\n</code></pre>\n<p>The application injects just the AllProviderDetails which should contain details of all the providers</p>\n<pre><code>class Main{ \n@Inject AllProviderDetails;\n}\n</code></pre>\n<p>The problem is that PostContruct methods are not being called on ProviderA and ProviderB by Weld(meaning the beans are not being created) and the application doesn't have have details of any providers.</p>\n<p>Shouldn't the ProviderA and ProviderB be created and managed by Weld. Is there any annotation which forces them to be created even if they have no references? On Injecting the ProviderA and ProviderB in the application elsewhere the beans are being created(cause I am assuming they have a refernce now).</p>\n<p>Also on checking the behaviour with Spring, it automatically creates Beans if they have @Component annotations, is there something similar in Weld to do the same.</p>\n<p>Weld version 3.1.9</p>\n",
    "tags" : [ "java", "cdi", "jboss-weld" ],
    "owner" : {
      "account_id" : 43974873,
      "reputation" : 13,
      "user_id" : 31510988,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/3e178263f4a657b8eabdc3f5b6242646?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Bharath-07",
      "link" : "https://stackoverflow.com/users/31510988/bharath-07"
    },
    "is_answered" : true,
    "view_count" : 55,
    "answer_count" : 1,
    "score" : 1,
    "last_activity_date" : 1758183738,
    "creation_date" : 1758119673,
    "link" : "https://stackoverflow.com/questions/79767460/java-beans-are-not-being-created-when-not-referenced-by-others-directly-in-weld",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79768160,
    "question_id" : 79767460,
    "body" : "<p>Even though the CDI specification doesn't state it, Weld (and all other impls I saw so far) is lazy in its bean creation and will only create the bean when it is first used.</p>\n<p>There is a way to eager init bean that I will explain in a bit and there is likely going to be an even simpler one in newer version as it is being <a href=\"https://github.com/jakartaee/cdi/issues/835\" rel=\"nofollow noreferrer\">discussed on a spec level</a> at the moment.</p>\n<p>However, first you also need to understand bean scopes/contexts - your <code>ProviderA</code> and <code>ProviderB</code> have no <a href=\"https://jakarta.ee/specifications/cdi/3.0/jakarta-cdi-spec-3.0#bean_defining_annotations\" rel=\"nofollow noreferrer\">bean defining annotation</a>. If you are using bean <a href=\"https://jakarta.ee/specifications/cdi/3.0/jakarta-cdi-spec-3.0#bean_archive\" rel=\"nofollow noreferrer\">discovery mode</a> <code>all</code>, they will still be picked up as beans and given a <code>@Dependent</code> scope. If you use <code>annotated</code>, they will not be identified as beans at all. It is recommended to always use some bean defining annotation. Note that CDI 4.0 changed the default mode to <code>annotated</code>.</p>\n<p>This is important because <code>@Dependent</code> beans in combination with eager init don't really make sense because <a href=\"https://jakarta.ee/specifications/cdi/3.0/jakarta-cdi-spec-3.0#dependent_context\" rel=\"nofollow noreferrer\">such beans</a>:</p>\n<ul>\n<li>Have their lifecycle bound to a bean they are injected into</li>\n<li>Injected instances are never shared between injection points. Each injection point for a dependent bean gets a new instance.</li>\n</ul>\n<p>If you want your providers to exist for the lifetime of application, you can go either with <code>@ApplicationScoped</code> or <code>@Singleton</code> (not the EJB singleton, use the one from <code>jakarta.inject</code> package).</p>\n<p>Now finally onto eager init - you can add the following observer into a bean you want to eager init. Note that you should do this for app scoped or singleton beans most of the time:</p>\n<pre class=\"lang-java prettyprint-override\"><code>    public void eagerInit(@Observes @Initialized(ApplicationScoped.class) Object obj){\n        // no code needed\n    }\n</code></pre>\n",
    "score" : 2,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 6963528,
      "reputation" : 7041,
      "user_id" : 5342297,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/ec65b3838b1d1ea981cdb5be0a7a4a57?s=256&d=identicon&r=PG",
      "display_name" : "Siliarus",
      "link" : "https://stackoverflow.com/users/5342297/siliarus"
    },
    "creation_date" : 1758183738,
    "last_activity_date" : 1758183738,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}