{
  "question" : {
    "question_id" : 79712823,
    "title" : "Question regarding Euler phi coprime algorithm",
    "body" : "<p>Below is my implementation of <a href=\"https://en.wikipedia.org/wiki/Euler%27s_totient_function\" rel=\"nofollow noreferrer\">Euler's totient function</a>.</p>\n<pre><code>int n = 36; // any random no\nint result = n;\nfor (int i = 2; i * i &lt;= n; i++) {\n    if (n % i == 0) {\n        while (n % i == 0) {\n            n /= i;\n        }\n        result -= result / i;\n    }\n }\nif (n &gt; 1) {\n    result -= result / n;\n}\n</code></pre>\n<p>Why do we use <code>i*i</code> in the <code>for</code> loop?\nIs using only <code>i&lt;=n</code> not the correct approach?</p>\n",
    "tags" : [ "java", "prime-factoring" ],
    "owner" : {
      "account_id" : 23047570,
      "reputation" : 17,
      "user_id" : 17164921,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a-/AOh14GjsyBhGR_xTN7GKhojoRGDtZBflh4ccvjtA8P0=k-s256",
      "display_name" : "Tanishq Vernela",
      "link" : "https://stackoverflow.com/users/17164921/tanishq-vernela"
    },
    "is_answered" : true,
    "view_count" : 167,
    "closed_date" : 1753492114,
    "answer_count" : 2,
    "score" : -4,
    "last_activity_date" : 1753499218,
    "creation_date" : 1753334403,
    "link" : "https://stackoverflow.com/questions/79712823/question-regarding-euler-phi-coprime-algorithm",
    "closed_reason" : "Needs details or clarity"
  },
  "answers" : [ {
    "answer_id" : 79713357,
    "question_id" : 79712823,
    "body" : "<p>It's simple mathematics.  Suppose <code>n</code> has a factor <code>a</code> that's larger than <code>√n</code>, then it must also have a factor <code>n/a</code> that must be smaller than <code>√n</code>.</p>\n<p>Thus, if there are no factors smaller than <code>√n</code>, then there can be no factors larger than that (i.e. <code>n</code> must be prime), and so we can finish the iteration at that point to save time and energy.</p>\n<hr />\n<p>As an aside, <code>i &lt;= n</code> would be wrong, as we do not consider <code>n</code> to be a factor of itself.  We would write <code>i &lt; n</code> if we wanted to execute the pointless part of the loop.</p>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 6229027,
      "reputation" : 32424,
      "user_id" : 4850040,
      "user_type" : "registered",
      "accept_rate" : 62,
      "profile_image" : "https://i.sstatic.net/acYd0.png?s=256",
      "display_name" : "Toby Speight",
      "link" : "https://stackoverflow.com/users/4850040/toby-speight"
    },
    "creation_date" : 1753360284,
    "last_activity_date" : 1753360284,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79714965,
    "question_id" : 79712823,
    "body" : "<p>Let's look at your algorithm in detail. Its task is to find the Euler number, which is equal to the number of natural numbers less than or equal to <code>n</code> and mutually prime with it. For example, for the number 36, there are 12 such numbers: 1, 5, 7, 11, 13, 17, 19, 23, 25, 29, 31, 35. At each iteration, this algorithm removes numbers from the range [1, <code>n</code>] that do not satisfy the condition. The number 36 is divisible by 2, so all numbers divisible by 2 are removed in code:</p>\n<pre class=\"lang-java prettyprint-override\"><code>        result -= result / i;\n</code></pre>\n<p>Next, the number 36 is divided into multipliers 2x2x9 in code:</p>\n<pre class=\"lang-java prettyprint-override\"><code>        while (n % i == 0) {\n            n /= i;\n        }\n</code></pre>\n<p>The number 9 is divisible by 3, so all numbers that are multiples of 3 are removed, except for those that are multiples of 2. Etc. There is no point in continuing the loop when <code>i &gt; √n</code>, since all the numbers will already be exhausted.</p>\n<pre class=\"lang-none prettyprint-override\"><code>// 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 (              result = 36)\n// 1 - 3 - 5 - 7 - 9 -- 11 -- 13 -- 15 -- 17 -- 19 -- 21 -- 23 -- 25 -- 27 -- 29 -- 31 -- 33 -- 35 -- (result -= 18, result = 18)\n// 1 - - - 5 - 7 - - -- 11 -- 13 -- -- -- 17 -- 19 -- -- -- 23 -- 25 -- -- -- 29 -- 31 -- -- -- 35 -- (result -=  6, result = 12)\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 29816933,
      "reputation" : 2059,
      "user_id" : 22851022,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/JfMqJ6p2.png?s=256",
      "display_name" : "Konstantin Makarov",
      "link" : "https://stackoverflow.com/users/22851022/konstantin-makarov"
    },
    "creation_date" : 1753457559,
    "last_activity_date" : 1753499218,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140614980,
    "post_id" : 79712823,
    "body" : "Alongside @user85421 &#39;s input (notably that <code>n&#47;x</code> and <code>x</code> are factors of <code>n</code>, assuming <code>n&#47;x</code> is an integer), note that if you&#39;re searching for two numbers s.t. <code>A * B = C</code>, that if you start with the &quot;two ends&quot; of your range (e.g. C=100, B=100, A=1) and move A and B towards each other, they would become equivalent once <code>A=B=sqrt(C)</code>, anything further would just be checking <code>B * A = C</code>, the same problem. So it&#39;s really <code>i &lt; sqrt(n)</code>, with the noted optimizations about saving a sqrt for a cheaper multiplication.",
    "score" : 1,
    "owner" : {
      "account_id" : 1992310,
      "reputation" : 11519,
      "user_id" : 1786065,
      "user_type" : "registered",
      "accept_rate" : 91,
      "profile_image" : "https://i.sstatic.net/udTpS.png?s=256",
      "display_name" : "Rogue",
      "link" : "https://stackoverflow.com/users/1786065/rogue"
    },
    "creation_date" : 1753360443,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140614195,
    "post_id" : 79712823,
    "body" : "( btw I do not know that function, using knowledge from finding prime number algorithms )",
    "score" : 0,
    "owner" : {
      "account_id" : 31180,
      "reputation" : 29752,
      "user_id" : 85421,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/kKvXH.gif?s=256",
      "display_name" : "user85421",
      "link" : "https://stackoverflow.com/users/85421/user85421"
    },
    "creation_date" : 1753343815,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140614174,
    "post_id" : 79712823,
    "body" : "<code>i &lt;= n</code> would probably work, but <code>i*i &lt;=n</code> (that is <code>i &lt;= sqrt(n)</code>) is an (old) optimization: 1) <code>i*i</code> can be faster than <code>sqrt()</code>; 2) not using divisors <code>&gt; sqrt(n)</code> since these are already *considered*&#185; by the smaller ones (if <code>x</code> is a divisor of <code>n</code>, then is <code>n&#47;x</code> is also a divisor [e.g. <code>20&#47;4</code> is <code>5</code>, so <code>5</code> is also a divisor of <code>n</code>] ) || <b>&#185;</b> the reason of the last <code>if</code>",
    "score" : 3,
    "owner" : {
      "account_id" : 31180,
      "reputation" : 29752,
      "user_id" : 85421,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/kKvXH.gif?s=256",
      "display_name" : "user85421",
      "link" : "https://stackoverflow.com/users/85421/user85421"
    },
    "creation_date" : 1753343086,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}