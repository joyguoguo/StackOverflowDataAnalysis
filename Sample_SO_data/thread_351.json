{
  "question" : {
    "question_id" : 79814977,
    "title" : "AWS API Gateway HTTP API v2 removes padding (`=`) from query parameters when calling Lambda (Java Spring Boot)",
    "body" : "<p>I’m using AWS API Gateway HTTP API v2 with a Lambda function running a Java Spring Boot application<br />\nThe integration type is Lambda proxy integration with <code>payloadFormatVersion: 2.0</code>.</p>\n<p>Everything works fine, except that <strong>query parameters get modified</strong> by API Gateway before reaching my Spring Boot app.</p>\n<h3><strong>The problem</strong></h3>\n<p>When I call this endpoint:</p>\n<pre><code>GET https://api.example.com/welcome?param1=aGVsbG8gbXkgbmFtZSBpcyBqb2huCg==\n</code></pre>\n<h3><strong>What I see in logs</strong></h3>\n<pre><code>DEBUG --- Securing GET /welcome?param1=aGVsbG8gbXkgbmFtZSBpcyBqb2huCg==\nDEBUG --- GET &quot;/welcome?param1=aGVsbG8gbXkgbmFtZSBpcyBqb2huCg==&quot;\nINFO  --- preHandle: method=GET, uri=/welcome, parameters=[param1=aGVsbG8gbXkgbmFtZSBpcyBqb2huCg]\n</code></pre>\n<p>As you can see, the request <strong>arrives with the correct value (<code>==</code> present)</strong>,<br />\nbut by the time Spring handles it, the padding is <strong>missing</strong>.</p>\n<hr />\n<h3><strong>What I tried</strong></h3>\n<p>To work around this issue, I added a filter that attempts to automatically <strong>restore the missing Base64 padding</strong> when needed:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Component\n@Order(HIGHEST_PRECEDENCE)\npublic class Base64PaddingFixFilter extends OncePerRequestFilter {\n\n  @Override\n  protected void doFilterInternal(\n      HttpServletRequest request,\n      HttpServletResponse response,\n      FilterChain filterChain)\n      throws ServletException, IOException {\n\n    var originalParams = request.getParameterMap();\n\n    var fixedParams = originalParams.entrySet().stream()\n        .collect(Collectors.toMap(\n            Map.Entry::getKey,\n            e -&gt; Arrays.stream(e.getValue())\n                       .map(Base64PaddingFixFilter::padBase64IfNeeded)\n                       .toArray(String[]::new)));\n\n    var hasModifiedParams = !fixedParams.equals(originalParams);\n\n    if (hasModifiedParams) {\n      var wrapped = new FixedParamsRequestWrapper(request, fixedParams);\n      filterChain.doFilter(wrapped, response);\n    } else {\n      filterChain.doFilter(request, response);\n    }\n  }\n\n  private static String padBase64IfNeeded(String s) {\n    if (s == null) return null;\n    var len = s.length();\n    if (len == 0) return s;\n\n    var base64UrlPattern = &quot;^[A-Za-z0-9_\\\\-]+=*$&quot;;\n    if (!s.matches(base64UrlPattern)) return s;\n\n    var mod = len % 4;\n    if (mod == 0) return s;\n    var pad = 4 - mod;\n    return s + &quot;=&quot;.repeat(pad);\n  }\n\n  private static class FixedParamsRequestWrapper extends HttpServletRequestWrapper {\n    private final Map&lt;String, String[]&gt; fixedParams;\n\n    public FixedParamsRequestWrapper(HttpServletRequest request, Map&lt;String, String[]&gt; fixedParams) {\n      super(request);\n      this.fixedParams = fixedParams;\n    }\n\n    @Override public String getParameter(String name) {\n      var values = fixedParams.get(name);\n      return (values != null &amp;&amp; values.length &gt; 0) ? values[0] : null;\n    }\n\n    @Override public Map&lt;String, String[]&gt; getParameterMap() { return fixedParams; }\n    @Override public String[] getParameterValues(String name) { return fixedParams.get(name); }\n  }\n}\n</code></pre>\n<p>This works for Base64 parameters — it detects and restores missing <code>=</code> characters.</p>\n<hr />\n<h3><strong>The problem with this workaround</strong></h3>\n<p>If a <strong>query parameter is <em>not</em></strong> Base64, but happens to match the Base64 pattern (<code>[A-Za-z0-9_-]+=*</code>),<br />\nthe filter <strong>incorrectly adds padding</strong> to it, treating it as a “corrupted” Base64 value.</p>\n<p>Example:</p>\n<pre><code>GET /welcome?param1=abc\n</code></pre>\n<p>becomes:</p>\n<pre><code>param1=abc=\n</code></pre>\n<p>which is obviously not correct.</p>\n<p>So this approach is unreliable unless all query parameters are guaranteed to be Base64-encoded.</p>\n<hr />\n<h3><strong>Questions</strong></h3>\n<ol>\n<li><p>Why does <strong>API Gateway HTTP API v2</strong> remove or alter the padding (<code>=</code>) in query parameters before invoking the Lambda?</p>\n</li>\n<li><p>Is there a way to configure API Gateway to <strong>preserve query parameters exactly as sent</strong> (no decoding/re-encoding)?</p>\n</li>\n<li><p>Is there a more reliable workaround than inspecting and re-padding parameters manually ?</p>\n</li>\n</ol>\n",
    "tags" : [ "java", "spring-boot", "aws-lambda", "urlencode", "aws-api-gateway-v2" ],
    "owner" : {
      "account_id" : 44057493,
      "reputation" : 11,
      "user_id" : 31554368,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/906dcd8d65f0db97423ee72a76f40aaa?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "nekatte",
      "link" : "https://stackoverflow.com/users/31554368/nekatte"
    },
    "is_answered" : false,
    "view_count" : 64,
    "answer_count" : 0,
    "score" : -1,
    "last_activity_date" : 1762714566,
    "creation_date" : 1762714566,
    "link" : "https://stackoverflow.com/questions/79814977/aws-api-gateway-http-api-v2-removes-padding-from-query-parameters-when-cal",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140849908,
    "post_id" : 79814977,
    "body" : "I’m running into this issue with my OAuth provider, which redirects back to my app with the state parameter as a Base64 value that isn’t URL-encoded (e.g., <code>aGVsbG8gbXkgbmFtZSBpcyBqb2huCg==</code>).  Because of that, AWS API Gateway can cut off or change the query parameters, so by the time they reach my Spring Boot backend, the state doesn’t match anymore and the OAuth2 flow breaks.  One idea I have is to grab the raw request before it gets parsed and manually re-encode the state and other values, but I’m not sure if that’s even possible.",
    "score" : 0,
    "owner" : {
      "account_id" : 44057493,
      "reputation" : 11,
      "user_id" : 31554368,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/906dcd8d65f0db97423ee72a76f40aaa?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "nekatte",
      "link" : "https://stackoverflow.com/users/31554368/nekatte"
    },
    "creation_date" : 1762934602,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140845916,
    "post_id" : 79814977,
    "body" : "What is calling your API?  You are using values that mean something in a URL and have not properly encoded the values.  It should look something more like:  <code>https:&#47;&#47;api.example.com&#47;welcome?param1=aGVsbG8gbXkgbmFtZSBpc&zwnj;&#8203;yBqb2huCg%3D%3D</code>",
    "score" : 2,
    "owner" : {
      "account_id" : 3509196,
      "reputation" : 17640,
      "user_id" : 2933977,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/25308d33862d9b72e0b93160b1fd778c?s=256&d=identicon&r=PG",
      "display_name" : "stdunbar",
      "link" : "https://stackoverflow.com/users/2933977/stdunbar"
    },
    "creation_date" : 1762729703,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}