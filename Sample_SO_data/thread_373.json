{
  "question" : {
    "question_id" : 79811246,
    "title" : "Hibernate 6 unidirectional many to one relationship and database cascading deletes",
    "body" : "<p>I have an extensive JPA model which exclusively uses unidirectional @ManyToOne relationships from child to parent, for example like this.</p>\n<pre><code>public class Child {\n  @ManyToOne(optional = false)\n  @JoinColumn(name = &quot;parent&quot;)\n  private Parent parent\n}\n</code></pre>\n<p>There are zillions of relations like this in a rather convoluted hierarchy leading to a root-most entity.  We've set up database cascading deletes, so it is only necessary to delete the root-most entity when we want to delete things.  This was considerably more efficient than doing it in JPA.  This used to work fine but with Hibernate 6 we're encountering a problem.</p>\n<p>If I've loaded an <code>Child</code> entity at some point in a test, say, then try to delete a <code>Parent</code> entity I get an exception like this</p>\n<pre><code>org.hibernate.TransientObjectException: persistent instance references an unsaved transient instance of 'Parent'\n</code></pre>\n<p>I can see from the stack that this exception is being raised via <code>CascadingAction.CHECK_ON_FLUSH</code>.  From debug I can also see that the relation triggering this is from child to parent.  This is perhaps not unreasonably checking that the loaded entities don't have any dangling references.  They obviously will, however, because we're not deleting things using JPA, it is done via data base cascading deletes.</p>\n<p>I really don't want to have to replicate the DB cascading deletes in JPA and as mention it is considerably slower than data base cascading deletes.</p>\n<p>Is there a way to disable this check, or to instead flag these relationships as data-base cascading deletes so Hibernate knows it can just remove the entities safely?</p>\n<p>NB I'm using Spring Boot.</p>\n",
    "tags" : [ "java", "spring", "hibernate", "jpa" ],
    "owner" : {
      "account_id" : 1488686,
      "reputation" : 422,
      "user_id" : 1396337,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/6107b09afa6e90ec7a981625129a3b98?s=256&d=identicon&r=PG",
      "display_name" : "Mumrah",
      "link" : "https://stackoverflow.com/users/1396337/mumrah"
    },
    "is_answered" : true,
    "view_count" : 123,
    "answer_count" : 2,
    "score" : 1,
    "last_activity_date" : 1762513289,
    "creation_date" : 1762431029,
    "link" : "https://stackoverflow.com/questions/79811246/hibernate-6-unidirectional-many-to-one-relationship-and-database-cascading-delet",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79811809,
    "question_id" : 79811246,
    "body" : "<blockquote>\n<p>We've set up database cascading deletes [...]. This was considerably more efficient than doing it in JPA.</p>\n</blockquote>\n<p>I can believe that it provided faster deletion behavior, but it was never a good idea.  JPA and other ORM systems are designed and built for <em>state management</em>, not merely query building.  Undercutting their ability to track the state they are entrusted with managing cannot reasonably be expected to end well.</p>\n<blockquote>\n<p>This used to work fine but with Hibernate 6 we're encountering a problem.</p>\n</blockquote>\n<p>I am prepared to believe that you did not recognize any problems with the database-level cascading deletes in conjunction with older versions of Hibernate.  It might even have been that there genuinely weren't any.  Nevertheless, see &quot;cannot reasonably be expected to end well&quot;, above.  Even if hadn't before, that misfortunate ending has arrived now.</p>\n<blockquote>\n<p>If I've loaded an <code>Child</code> entity at some point in a test, say, then try to delete a <code>Parent</code> entity I get an exception</p>\n</blockquote>\n<p>I presume you mean that you delete the particular <code>Parent</code> with which the <code>Child</code> in question is associated. The resulting DB-level cascading deletes then yank the persistent representation of the <code>Child</code> out from underneath the persistence unit.  The persistence unit is thereby made inconsistent: the state of the <code>Child</code> as judged by the database is deleted / transient, but it is still persistent / managed as far as the entity manager is concerned.  The best you can hope for is that the EM doesn't notice and / or doesn't care, but there is not, in general, any basis for assuming that that's what you will actually observe.</p>\n<blockquote>\n<p>I really don't want to have to replicate the DB cascading deletes in JPA and as mention it is considerably slower than data base cascading deletes.</p>\n</blockquote>\n<p>If Hibernate is to maintain synchronicity with the DB then there is more work to do than just removing rows from the DB.  Yes, that will be more costly than allowing Hibernate to lose sync, but losing sync was never a very good option.  However, you might get some relief by adding a (Hibernate-specific) <a href=\"https://docs.hibernate.org/orm/6.6/javadocs/org/hibernate/annotations/OnDelete.html\" rel=\"nofollow noreferrer\"><code>@OnDelete</code></a> annotation:</p>\n<pre><code>public class Child {\n  @ManyToOne(optional = false)\n  @JoinColumn(name = &quot;parent&quot;)\n  @OnDelete(action = CASCADE)\n  private Parent parent\n}\n</code></pre>\n<p>This tells Hibernate that there should be an <code>on delete cascade</code> clause on the foreign key constraint supporting the relationship. As I understand the docs, however, you would still need to use that together with JPA-level cascading removes in order for it to be effective in preventing the persistence context from losing synchronization with the DB. And I think that means you'll need to make the relationship bidirectional, though one or both ends can be lazy-loaded.  Hibernate will fetch the relationship if necessary so that it knows what entities need to be evicted from its cache, but with <code>@OnDelete</code>, is should not execute <code>delete</code> statements on the database for those.</p>\n<blockquote>\n<p>Is there a way to disable this check,</p>\n</blockquote>\n<p>Not as far as I can tell.</p>\n<blockquote>\n<p>or to instead flag these relationships as data-base cascading deletes</p>\n</blockquote>\n<p>See above, but, as already described, this ...</p>\n<blockquote>\n<p>so Hibernate knows it can just remove the entities safely?</p>\n</blockquote>\n<p>... does not follow.  Hibernate needs to know what child (and grandchild, <em>etc</em>) entities are deleted in order to manage its cache appropriately.  That will have a cost, both in code to map the other side of the relationship and in DB operations performed, but it should be at least a bit cheaper than without the <code>@OnDelete</code>.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1762466540,
    "last_activity_date" : 1762466540,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79812262,
    "question_id" : 79811246,
    "body" : "<p>As per the comments the problem is that if the database cascades the deletes then the persistence context is left in an inconsistent state.  This used to be ignored but now Hibernate detects the inconsistency and raises an error.</p>\n<p>It is therefore necessary to either replicate all the cascading deletes in JPA (which is not DRY so I'm not doing that) or clear the persistence context.  Clearing the persistence context on delete can be achieved like this.</p>\n<pre><code>@NoRepositoryBean\npublic interface CascadingDeleteRepository&lt;TEntity, TId&gt; extends CrudRepository&lt;TEntity, TId&gt; {\n\n  @Override\n  default void delete(TEntity entity) {\n    cascadingDelete(entity);\n  }\n\n  @Query(&quot;DELETE FROM #{#entityName} e WHERE e = :entity&quot;)\n  @Modifying(clearAutomatically = true)\n  void cascadingDelete(@Param(&quot;entity&quot;) TEntity entity);\n}\n</code></pre>\n<p>In an ideal world, perhaps, there would be a way to tell JPA that an association is cascaded on delete by the DB, and then the persistence context could automatically clean up transitive references to the deleted entity.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1488686,
      "reputation" : 422,
      "user_id" : 1396337,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/6107b09afa6e90ec7a981625129a3b98?s=256&d=identicon&r=PG",
      "display_name" : "Mumrah",
      "link" : "https://stackoverflow.com/users/1396337/mumrah"
    },
    "creation_date" : 1762513289,
    "last_activity_date" : 1762513289,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140848225,
    "post_id" : 79811246,
    "body" : "The test was typically deleting the root-most entity during tear down, so the entity manager would have been left in an invalid state, yes; but we&#39;d shortly throw it away anyway.  Similarly if a user was deleting something via the api the entity manager would be junked at the end of the api call.  So whilst the entity manager was left in a bad state, it isn&#39;t particularly problematic as we&#39;d have no expectation of using the entity manager afterwards.",
    "score" : 0,
    "owner" : {
      "account_id" : 1488686,
      "reputation" : 422,
      "user_id" : 1396337,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/6107b09afa6e90ec7a981625129a3b98?s=256&d=identicon&r=PG",
      "display_name" : "Mumrah",
      "link" : "https://stackoverflow.com/users/1396337/mumrah"
    },
    "creation_date" : 1762853327,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140841903,
    "post_id" : 79811246,
    "body" : "With your test - what used to happen exactly? JPA required that providers throw an error if an entity is left referencing an unmanaged instance like you describe - so the behavior change was fixing a spec violation. The spec mandated throwing an exception as it isn&#39;t clear what that fk value should be, and if it should insert/merge the &#39;parent&#39; reference to make things work.",
    "score" : 0,
    "owner" : {
      "account_id" : 231721,
      "reputation" : 21335,
      "user_id" : 496099,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/efa7510cf47d7bd79e80486246e7e39e?s=256&d=identicon&r=PG",
      "display_name" : "Chris",
      "link" : "https://stackoverflow.com/users/496099/chris"
    },
    "creation_date" : 1762522817,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140840655,
    "post_id" : 79811246,
    "body" : "&quot;<i>is there any tractable way to do that?</i>&quot; is the wrong question.  Yes you can do that, either by using the appropriate <code>EntityManager</code> to <code>detach()</code> individual entities or by <code>clear()</code>ing the whole context, thereby detaching <i>all</i> of its persistent entities.  But you&#39;re talking about having to consistently do that throughout the application and its tests, and dealing with all the fallout it produces.  What a nasty, brittle mess that would be.  The right question is &quot;how can avoid needing to do that?&quot;, and @Gimby has already explained that.",
    "score" : 0,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1762456889,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140840249,
    "post_id" : 79811246,
    "body" : "Hibernate 6 has seen many breaking changes ever since hibernate-entitymanager was replaced with built-in JPA support that is far more compliant to the JPA spec. This may have been a situation of &quot;it should have always been broken, you were lucky until now&quot;.  Data disappearing outside of the view of HIbernate is pretty much automated chaos. That is the thing with Hibernate/JPA... if you want to use it, use it. Don&#39;t half-use it and then go do low level SQL anyway. Use JPA cascades, not DDL cascades. If you want to use DDL cascades, you should look into using something like JOOQ instead.",
    "score" : 2,
    "owner" : {
      "account_id" : 187094,
      "reputation" : 5301,
      "user_id" : 424903,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/8oHZF.png?s=256",
      "display_name" : "Gimby",
      "link" : "https://stackoverflow.com/users/424903/gimby"
    },
    "creation_date" : 1762443615,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140840242,
    "post_id" : 79811246,
    "body" : "@talex you may be correct, is there any tractable way to do that?  I&#39;d have to chase all the transitive dependencies which sounds like a nightmare.  Maybe I should just use jdbc :(",
    "score" : 0,
    "owner" : {
      "account_id" : 1488686,
      "reputation" : 422,
      "user_id" : 1396337,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/6107b09afa6e90ec7a981625129a3b98?s=256&d=identicon&r=PG",
      "display_name" : "Mumrah",
      "link" : "https://stackoverflow.com/users/1396337/mumrah"
    },
    "creation_date" : 1762443341,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140840234,
    "post_id" : 79811246,
    "body" : "You have to evict all loaded children manually. Otherwise even if you suppress the error Hibernate may try to save them.",
    "score" : 1,
    "owner" : {
      "account_id" : 4497436,
      "reputation" : 20786,
      "user_id" : 3656904,
      "user_type" : "registered",
      "accept_rate" : 67,
      "profile_image" : "https://www.gravatar.com/avatar/8bdbd1f89f8907e8e8b15ab88c084c65?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "talex",
      "link" : "https://stackoverflow.com/users/3656904/talex"
    },
    "creation_date" : 1762443080,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140840206,
    "post_id" : 79811246,
    "body" : "Sorry it was Hibernate 6.  The JPA relationship isn&#39;t bidirectional.",
    "score" : 0,
    "owner" : {
      "account_id" : 1488686,
      "reputation" : 422,
      "user_id" : 1396337,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/6107b09afa6e90ec7a981625129a3b98?s=256&d=identicon&r=PG",
      "display_name" : "Mumrah",
      "link" : "https://stackoverflow.com/users/1396337/mumrah"
    },
    "creation_date" : 1762442392,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140840131,
    "post_id" : 79811246,
    "body" : "The title says the issue involves Hibernate 7, but the text says Hibernate 6.  Which is it?",
    "score" : 0,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1762440801,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140840124,
    "post_id" : 79811246,
    "body" : "Is the JPA-level relationship bidirectional?  If so then please present the <code>Parent</code> side of the relationship, too.",
    "score" : 0,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1762440620,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140840083,
    "post_id" : 79811246,
    "body" : "Be a man, switch to JDBC.",
    "score" : 1,
    "owner" : {
      "account_id" : 4688171,
      "reputation" : 11611,
      "user_id" : 3795036,
      "user_type" : "registered",
      "accept_rate" : 88,
      "profile_image" : "https://i.sstatic.net/eM2E2.png?s=256",
      "display_name" : "K.Nicholas",
      "link" : "https://stackoverflow.com/users/3795036/k-nicholas"
    },
    "creation_date" : 1762439530,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140839958,
    "post_id" : 79811246,
    "body" : "Yeah the cascades are all defined in the database schema.",
    "score" : 0,
    "owner" : {
      "account_id" : 1488686,
      "reputation" : 422,
      "user_id" : 1396337,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/6107b09afa6e90ec7a981625129a3b98?s=256&d=identicon&r=PG",
      "display_name" : "Mumrah",
      "link" : "https://stackoverflow.com/users/1396337/mumrah"
    },
    "creation_date" : 1762435583,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140839905,
    "post_id" : 79811246,
    "body" : "&quot;We&#39;ve set up database cascading deletes&quot; - as in, directly in the database DDL and no Hibernate/JPA cascaded deletes?",
    "score" : 0,
    "owner" : {
      "account_id" : 187094,
      "reputation" : 5301,
      "user_id" : 424903,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/8oHZF.png?s=256",
      "display_name" : "Gimby",
      "link" : "https://stackoverflow.com/users/424903/gimby"
    },
    "creation_date" : 1762433514,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79811809" : [ {
      "comment_id" : 140841874,
      "post_id" : 79811809,
      "body" : "@Mumrah Yes, the <code>cascade</code> attribute of a relationship annotation controls which operations cascade from the entity on which the annotation appears to the one on the other side of the relationship. I did say &quot; I think that means you&#39;ll need to make the relationship bidirectional&quot;.",
      "score" : 0,
      "owner" : {
        "account_id" : 2792262,
        "reputation" : 190832,
        "user_id" : 2402272,
        "user_type" : "registered",
        "accept_rate" : 85,
        "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
        "display_name" : "John Bollinger",
        "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
      },
      "creation_date" : 1762521363,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140841644,
      "post_id" : 79811809,
      "body" : "I tried various annotations on the @ManyToOne end but they all seem to control propagation from Child to Parent whereas the problem I&#39;m having is the propagation from Parent to Child and as mentioned these associations are all unidirectional right now.",
      "score" : 0,
      "owner" : {
        "account_id" : 1488686,
        "reputation" : 422,
        "user_id" : 1396337,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/6107b09afa6e90ec7a981625129a3b98?s=256&d=identicon&r=PG",
        "display_name" : "Mumrah",
        "link" : "https://stackoverflow.com/users/1396337/mumrah"
      },
      "creation_date" : 1762513377,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}