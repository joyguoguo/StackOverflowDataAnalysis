{
  "question" : {
    "question_id" : 79651869,
    "title" : "How to design a Java project to enable dynamic class loading based on the api version",
    "body" : "<p>I am currently trying to create a custom java api project which I can use in my other project. The project will try to call api endpoints to a server. This server has different api version support. The caller from the main project can have a server of any version (Will be limited to a range of version we support). How can I create a java project which like dynamically loads the necessary class and calls the necessary api endpoints. The endpoints for each version should be fairly similar in the functionalities available. Dont think it will change much based on the version but maybe the request parameter and their structure might change. But I dont expect the functionality itself missing between versions.\nMy intially thoughts are something like this</p>\n<pre><code>multiversion-sdk/\n├── build.gradle\n├── settings.gradle\n├── README.md\n├── sdk-common/\n│   ├── build.gradle\n│   └── src/main/java/com/emc/server/\n│       ├── ServerClient.java\n│       ├── ApiProvider.java &lt;-- Use this in my mainproject to somehow get the classes from the generated folder.\n│       └── ServerVersion.java\n├── server-sdk-v9_2_1/ &lt;--- This project is auto generated using openapi-generator based on list of endpoints from yaml/json file\n│   ├── build.gradle\n│   └── src/main/java/org/openapitools/client/v921/\n│       ├── api/\n│       └── model/\n└── server-sdk-v9_9_0/\n    ├── build.gradle\n    └── src/main/java/org/openapitools/client/v990/\n        ├── api/\n        └── model/\n\n</code></pre>\n<p>Any ideas or references I can use to achieve this?</p>\n<p>I have tried passing in the version from the main project from that resolving the actual path of the class based on the version but it seems clutered and doesnt seem production ready. I want both the underlying contructor and methods.</p>\n<p>The current implementaion I am using is something like this</p>\n<pre><code>public class IsilonClient {\n    private final ApiProvider apiProvider;\n    private final IsilonVersion version;\n\n    public IsilonClient(String basePath, String username, String password, String requestedVersion) {\n// Version comparison and mapping logic\n// if the supported version is not found will resolve it with something previous version       \nthis.version = IsilonVersion.findClosestMatch(requestedVersion);\n        this.apiProvider = new ApiProvider(basePath, username, password, version);\n    }\n\n    public &lt;T&gt; T api(Class&lt;T&gt; apiClass) {\n        return apiProvider.getApi(apiClass);\n    }\n}\n\n</code></pre>\n<p>Api Provider Implementation</p>\n<pre><code>public class ApiProvider {\n\n    private final Map&lt;Class&lt;?&gt;, Object&gt; apiCache = new ConcurrentHashMap&lt;&gt;();\n    private final ApiClient apiClient;\n    private final IsilonVersion version;\n\n    public ApiProvider(String basePath, String username, String password, IsilonVersion version) {\n        this.version = version;\n        this.apiClient = this.createApiClient(basePath, username, password);\n    }\n\n    public &lt;T&gt; T getApi(Class&lt;T&gt; apiInterface) {\n        return (T) this.apiCache.computeIfAbsent(apiInterface, this::createApi);\n    }\n// Dynamically builds the fully qualified class name of the API implementation\n    private &lt;T&gt; T createApi(Class&lt;T&gt; apiInterface) {\n        try {\n            String versionString = &quot;v&quot; + this.version.getVersion().replace(&quot;.&quot;, &quot;&quot;);\n            String implementationClassName = apiInterface.getName().replace(\n                &quot;com.emc.isilon.api&quot;,\n                &quot;org.openapitools.client.&quot; + versionString + &quot;.api&quot;\n            );\n            Class&lt;?&gt; implementationClass = Class.forName(implementationClassName);\n            Constructor&lt;?&gt; constructor = implementationClass.getConstructor(ApiClient.class);\n            return (T) constructor.newInstance(this.apiClient);\n        } catch (Exception exception) {\n            throw new RuntimeException(&quot;Failed to create API implementation&quot;, exception);\n        }\n    }\n}\n\n</code></pre>\n<p>Main project usage</p>\n<pre><code>// Create client in the Hyperion project.\n// we can either pass the version directly or just pass the credentials and let the lib do a common api call to get the version first and then build the Apiclient accordingly\nIsilonClient client = new IsilonClient(\n    &quot;https://isilon:8080&quot;,\n    &quot;admin&quot;,\n    &quot;password&quot;,\n    &quot;9.3.0&quot;  // Will use 9.2.1\n);\n// Use APIs\nSnapshotApi snapshotApi = client.api(SnapshotApi.class);\nsnapshotApi.createSnapshot(params);\n\n</code></pre>\n<p>In my case if a server doesnt has a version which we dont support we will roll back and use the last latest version we currently support</p>\n",
    "tags" : [ "java", "gradle", "openapi-generator" ],
    "owner" : {
      "account_id" : 26040008,
      "reputation" : 1,
      "user_id" : 19744963,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/AItbvmnCTmvMMJlLiIOQdaqGjaVd5eAtuJxwMoJiDmhk=k-s256",
      "display_name" : "Neel Patel",
      "link" : "https://stackoverflow.com/users/19744963/neel-patel"
    },
    "is_answered" : false,
    "view_count" : 82,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1749053645,
    "creation_date" : 1748983199,
    "link" : "https://stackoverflow.com/questions/79651869/how-to-design-a-java-project-to-enable-dynamic-class-loading-based-on-the-api-ve",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140491044,
    "post_id" : 79651869,
    "body" : "It is unclear that what do you want to achieve and why are you using this approach. Using reflections is kind of over-engineering if you just want to route your requests according to API version.  Just create another class for api/v2 and use annotations @RestController @RequestMapping(&quot;/api/v2/customers&quot;)  Request will automatically be routed to this controller.",
    "score" : 1,
    "owner" : {
      "account_id" : 16860149,
      "reputation" : 181,
      "user_id" : 12191150,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/fec9a6154254eb5fd901f4a0045c0b1f?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Yasin Ahmed",
      "link" : "https://stackoverflow.com/users/12191150/yasin-ahmed"
    },
    "creation_date" : 1749142945,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140487612,
    "post_id" : 79651869,
    "body" : "@StephenC The decision doesn&#39;t need to be taken right away. When the user adds this server I get the version and create the client based on the version store it in a hashmap for future api call usage.",
    "score" : 0,
    "owner" : {
      "account_id" : 26040008,
      "reputation" : 1,
      "user_id" : 19744963,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/AItbvmnCTmvMMJlLiIOQdaqGjaVd5eAtuJxwMoJiDmhk=k-s256",
      "display_name" : "Neel Patel",
      "link" : "https://stackoverflow.com/users/19744963/neel-patel"
    },
    "creation_date" : 1749056484,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140487430,
    "post_id" : 79651869,
    "body" : "I have edited my question with some code samples of how I am using it",
    "score" : 0,
    "owner" : {
      "account_id" : 26040008,
      "reputation" : 1,
      "user_id" : 19744963,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/AItbvmnCTmvMMJlLiIOQdaqGjaVd5eAtuJxwMoJiDmhk=k-s256",
      "display_name" : "Neel Patel",
      "link" : "https://stackoverflow.com/users/19744963/neel-patel"
    },
    "creation_date" : 1749053673,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140486276,
    "post_id" : 79651869,
    "body" : "Please provide enough code so others can better understand or reproduce the problem.",
    "score" : 0,
    "owner" : {
      "account_id" : -1,
      "reputation" : 1,
      "user_id" : -1,
      "user_type" : "moderator",
      "profile_image" : "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=256&d=identicon&r=PG",
      "display_name" : "Community",
      "link" : "https://stackoverflow.com/users/-1/community"
    },
    "creation_date" : 1749034106,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140485326,
    "post_id" : 79651869,
    "body" : "Not sure what you mean by <i>API version</i>, but higher Java versions can run code compiled with lower Java version, e.g. JDK 24 should be able to run code compiled with JDK 21, so why not just compile the &quot;dynamic&quot; part with the highest Java version? Or have I completely misunderstood your question?",
    "score" : 0,
    "owner" : {
      "account_id" : 2485939,
      "reputation" : 20969,
      "user_id" : 2164365,
      "user_type" : "registered",
      "accept_rate" : 40,
      "profile_image" : "https://i.sstatic.net/RKSgV.png?s=256",
      "display_name" : "Abra",
      "link" : "https://stackoverflow.com/users/2164365/abra"
    },
    "creation_date" : 1749008887,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140485290,
    "post_id" : 79651869,
    "body" : "You also need to clarify how dynamic this is.  Does the decision of what API version to make available happen when the webapp is starting?  Or do you make it later; e.g. in response to API version numbers encoded in the request URIs?",
    "score" : 1,
    "owner" : {
      "account_id" : 47283,
      "reputation" : 723428,
      "user_id" : 139985,
      "user_type" : "registered",
      "accept_rate" : 69,
      "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
      "display_name" : "Stephen C",
      "link" : "https://stackoverflow.com/users/139985/stephen-c"
    },
    "creation_date" : 1749007116,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140485283,
    "post_id" : 79651869,
    "body" : "You need to clarify what you have tried, and (ideally) show us the relevant code.  And explain clearly what is wrong with it.  (&quot;cluttered&quot; is subjective, and &quot;not production ready&quot; could mean anything.)",
    "score" : 1,
    "owner" : {
      "account_id" : 47283,
      "reputation" : 723428,
      "user_id" : 139985,
      "user_type" : "registered",
      "accept_rate" : 69,
      "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
      "display_name" : "Stephen C",
      "link" : "https://stackoverflow.com/users/139985/stephen-c"
    },
    "creation_date" : 1749006752,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140484895,
    "post_id" : 79651869,
    "body" : "@Robert There are probably 50 or so endpoints with different functionality given by the server. The idea is to support different version of the server based on the customer need. The main project allows the customer to add the server. This server can be of any version (but we can give them the list of the supported version we have). They can also add multiple servers with different version so we need to do the operations based on whatever that server is running on. So a serverA of version v1 will fire a api like /platform/v1/getfiles , serverB running on version v2 use /platform/v2/getfiles",
    "score" : 0,
    "owner" : {
      "account_id" : 26040008,
      "reputation" : 1,
      "user_id" : 19744963,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/AItbvmnCTmvMMJlLiIOQdaqGjaVd5eAtuJxwMoJiDmhk=k-s256",
      "display_name" : "Neel Patel",
      "link" : "https://stackoverflow.com/users/19744963/neel-patel"
    },
    "creation_date" : 1748985820,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140484867,
    "post_id" : 79651869,
    "body" : "Why do you want to do this? Sounds a bit like premature optimization to me, or an <a href=\"https://xyproblem.info/\" rel=\"nofollow noreferrer\">xy problem</a>. Is it even worth the effort? How many endpoints and classes and versions do you have? What is their percentage of the whole code base? What do you expect to gain from the extra effort of building your own class loader? Why not have all supported versions in the jar? Or do you want a server per client or per version? How do your endpoints handle versioning currently? Can you split on a load balancer and send some callers to different servers?",
    "score" : 1,
    "owner" : {
      "account_id" : 1535561,
      "reputation" : 9056,
      "user_id" : 1431720,
      "user_type" : "registered",
      "accept_rate" : 89,
      "profile_image" : "https://www.gravatar.com/avatar/f5a1388d4d3b2bf03b11bb5658c68c29?s=256&d=identicon&r=PG",
      "display_name" : "Robert",
      "link" : "https://stackoverflow.com/users/1431720/robert"
    },
    "creation_date" : 1748984946,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}