{
  "question" : {
    "question_id" : 79636988,
    "title" : "Referencing parameter attributes in JPQL",
    "body" : "<p>I get a nice DTO in my controller.</p>\n<pre class=\"lang-java prettyprint-override\"><code>// UserController\n    @GetMapping\n    public ResponseEntity&lt;List&lt;UserResponseDto&gt;&gt; findUsers(@ParameterObject FindUserRequestDto userRequestDto,\n                                                           @ParameterObject Pageable pageable) {\n        List&lt;UserResponseDto&gt; userResponseDtos = userService.find(userRequestDto, pageable);\n        return ResponseEntity.ok(userResponseDtos);\n    }\n</code></pre>\n<p>But then I <em>have to</em> flatten it to use in my repository method. Or do I?</p>\n<pre class=\"lang-java prettyprint-override\"><code>// UserService implementation\n    @Override\n    public List&lt;UserResponseDto&gt; find(FindUserRequestDto userRequestDto, Pageable pageable) {\n        // flattening\n        List&lt;User&gt; users = repository.find(\n                userRequestDto.getDateOfBirth(),\n                userRequestDto.getPhone(),\n                userRequestDto.getName(),\n                userRequestDto.getEmail(),\n                pageable);\n        List&lt;UserResponseDto&gt; userDtos = users.stream()\n                .map(userMapper::toResponseDto)\n                .toList();\n        return userDtos;\n    }\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>    @Query(&quot;&quot;&quot;\n            SELECT u\n            FROM User u\n            WHERE (CAST(:dateOfBirth AS DATE) IS NULL OR u.dateOfBirth &gt; CAST(:dateOfBirth AS DATE))\n            AND (:name IS NULL OR u.name LIKE CONCAT(:name, '%'))\n            AND (:email IS NULL OR EXISTS (\n                SELECT 1 FROM EmailData ed WHERE ed.user = u AND ed.email = :email\n            ))\n            AND (:phone IS NULL OR EXISTS (\n                SELECT 1 FROM PhoneData pd WHERE pd.user = u AND pd.phone = :phone\n            ))\n            &quot;&quot;&quot;)\n    List&lt;User&gt; find(@Param(&quot;dateOfBirth&quot;) LocalDate dateOfBirth,\n                    @Param(&quot;phone&quot;) String phone,\n                    @Param(&quot;name&quot;) String name,\n                    @Param(&quot;email&quot;) String email,\n                    Pageable pageable);\n</code></pre>\n<p>Is there a way to somehow reference parameter attributes inside a JPQL query? Or otherwise avoid listing all DTO attributes in the parameter list (making it long)?</p>\n",
    "tags" : [ "java", "spring-data" ],
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2681,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "is_answered" : true,
    "view_count" : 101,
    "answer_count" : 1,
    "score" : -4,
    "last_activity_date" : 1748185089,
    "creation_date" : 1748105380,
    "link" : "https://stackoverflow.com/questions/79636988/referencing-parameter-attributes-in-jpql",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79637786,
    "question_id" : 79636988,
    "body" : "<p>You can use this syntax</p>\n<pre><code>@Query(&quot;&quot;&quot;\n            SELECT u\n            FROM User u\n            WHERE (CAST(:#{#dto.getDateOfBirth()} AS DATE) IS NULL OR u.dateOfBirth &gt; CAST(:#{#dto.getDateOfBirth()} AS DATE))\n            AND (:#{#dto.getName()} IS NULL OR u.name LIKE CONCAT(:#{dto.getName()}, '%'))\n            AND (:#{#dto.getEmail()} IS NULL OR EXISTS (\n                SELECT 1 FROM EmailData ed WHERE ed.user = u AND ed.email = :#{#dto.getEmail()}\n            ))\n            AND (:#{#dto.getPhone()} IS NULL OR EXISTS (\n                SELECT 1 FROM PhoneData pd WHERE pd.user = u AND pd.phone = :#{#dto.getPhone()}\n            ))\n            &quot;&quot;&quot;)\n    List&lt;User&gt; find(UserRequestDTO dto,\n                    Pageable pageable);\n</code></pre>\n",
    "score" : 1,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 3375477,
      "reputation" : 726,
      "user_id" : 2833679,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/OA9i8K18.jpg?s=256",
      "display_name" : "Alex",
      "link" : "https://stackoverflow.com/users/2833679/alex"
    },
    "creation_date" : 1748185089,
    "last_activity_date" : 1748185089,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140457595,
    "post_id" : 79636988,
    "body" : "@AndreyB.Panfilov it&#39;s a good suggestion, thank you",
    "score" : 0,
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2681,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "creation_date" : 1748196855,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140455737,
    "post_id" : 79636988,
    "body" : "if my memory serves me right smth. like <code>:#{#request.dateOfBirth}</code> should work (<a href=\"https://spring.io/blog/2014/07/15/spel-support-in-spring-data-jpa-query-definitions\" rel=\"nofollow noreferrer\">spring.io/blog/2014/07/15/&hellip;</a>), however I would stay clear of such ideas, use  jpa specifications instead: <a href=\"https://stackoverflow.com/a/75572804/3426309\">stackoverflow.com/a/75572804/3426309</a>",
    "score" : 3,
    "owner" : {
      "account_id" : 4181375,
      "reputation" : 6263,
      "user_id" : 3426309,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/v58O6.jpg?s=256",
      "display_name" : "Andrey B. Panfilov",
      "link" : "https://stackoverflow.com/users/3426309/andrey-b-panfilov"
    },
    "creation_date" : 1748106536,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}