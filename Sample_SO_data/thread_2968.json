{
  "question" : {
    "question_id" : 79581673,
    "title" : "Implementing Breadth First Search from CLRS",
    "body" : "<p>At my wits end here. I'm following this psuedocode from CLRS and I don't know why my final for loop doesn't keep going to give me the distance from the given source node to all other vertices. I'm so lost that I don't know which part of this I'm messing up.\nThe way our assignment is, we get skeleton code that differs slightly and we have to find a way to augment our code to make it work.\nI think I've done so mostly but I think I'm using the wrong variables in the wrong places.\nSorry that I'm not explaining it better but again, I don't know what part here is messing up.</p>\n<pre><code>package graph;\n\nimport ds.Queue;\nimport java.util.*;\n\npublic class Graph {\n    public int n;   //number of vertice\n    public int[][] A;   //the adjacency matrix\n    private final int WHITE = 2;\n    private final int GRAY = 3;\n    private final int BLACK = 4;\n    \n    public Graph () {\n        n = 0;\n        A = null;\n    }\n    \n    public Graph (int _n, int[][] _A) {\n        this.n = _n;\n        this.A = _A;\n    }\n    \n    /*\n     * Input: s denotes the index of the source node\n     * Output: the array dist, where dist[i] is the distance between the i-th node to s\n     */\n    public int[] bfs (int s) \n    {\n        int [] dist = new int[n];\n        int [] col = new int[n];\n        for (int i = 0; i &lt; n; i++)\n        {\n            col[i] = WHITE;\n            dist[i] = Integer.MAX_VALUE;\n        }\n        col[s] = GRAY;\n        dist[s] = 0;\n\n        Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();\n        q.add(s);\n\n        while (!q.isEmpty())\n        {\n            int u = q.poll();\n\n            for (int i : A[u])\n            {\n                if(col[i] == WHITE)\n                {\n                    col[i] = GRAY;\n                    dist[i] = dist[u] + 1;\n                    q.add(i);\n                }\n            }\n            col[u] = BLACK;\n        }\n        return dist;\n\n\n\n    }\n    \n    public void print_array (int[] array) {\n        for (int i = 0; i &lt; array.length; i++)\n            System.out.println(i + &quot;: &quot; + array[i]);\n    }\n    \n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        int n = 8;\n        int[][] A = \n            {{0, 1, 0, 0, 1, 0, 0, 0},\n            {1, 0, 0, 0, 0, 1, 0, 0},\n            {0, 0, 0, 1, 0, 1, 1, 0},\n            {0, 0, 1, 0, 0, 0, 1, 1},\n            {1, 0, 0, 0, 0, 0, 0, 0},\n            {0, 1, 1, 0, 0, 0, 1, 0},\n            {0, 0, 1, 1, 0, 1, 0, 1},\n            {0, 0, 0, 1, 0, 0, 1, 0}};\n        Graph g = new Graph(n, A);\n        g.print_array(g.bfs(1));\n    }\n\n}\n</code></pre>\n<p><a href=\"https://i.sstatic.net/Ooj0ec18.png\" rel=\"nofollow noreferrer\">pseudo code</a></p>\n",
    "tags" : [ "java", "algorithm", "breadth-first-search", "clrs" ],
    "owner" : {
      "account_id" : 38416144,
      "reputation" : 23,
      "user_id" : 28763006,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/2fc15b1f891fce92a0b4aa6b202fb3d7?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Jide Fadairo",
      "link" : "https://stackoverflow.com/users/28763006/jide-fadairo"
    },
    "is_answered" : true,
    "view_count" : 86,
    "answer_count" : 1,
    "score" : 1,
    "last_activity_date" : 1746273929,
    "creation_date" : 1745007759,
    "link" : "https://stackoverflow.com/questions/79581673/implementing-breadth-first-search-from-clrs",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79581898,
    "question_id" : 79581673,
    "body" : "<p>You are given a graph represented as an adjacency matrix, not an adjacency list, so to find the neighbors of a node <code>i</code>, iterate over all other nodes <code>j</code> and check if <code>A[i][j]</code> is <code>1</code>.</p>\n<pre class=\"lang-java prettyprint-override\"><code>for (int v = 0; v &lt; n; v++)\n    if (A[u][v] == 1 &amp;&amp; col[v] == WHITE) {\n        col[v] = GRAY;\n        dist[v] = dist[u] + 1;\n        q.add(v);\n    }\n</code></pre>\n",
    "score" : 6,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 13170666,
      "reputation" : 91467,
      "user_id" : 9513184,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/176386ce0b94057e55352484e69707f9?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Unmitigated",
      "link" : "https://stackoverflow.com/users/9513184/unmitigated"
    },
    "creation_date" : 1745021157,
    "last_activity_date" : 1745021157,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}