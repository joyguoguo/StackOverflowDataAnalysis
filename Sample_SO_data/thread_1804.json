{
  "question" : {
    "question_id" : 79673215,
    "title" : "Should JUnit tests crash instead of failing?",
    "body" : "<p>I'm writing a small app and have encountered the following issue:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Test\npublic void givenSkiExists_whenAddingNewSki_thenThrowEntityAlreadyPresentException () {\n   skiManager.addEntity(new Ski(new SkiType(&quot;name1&quot;, &quot;description1&quot;), &quot;brand1&quot;, &quot;model1&quot;, &quot;bond1&quot;, 1f));\n\n   assertThrows(EntityAlreadyPresentException.class, () -&gt; skiManager.addEntity(new Ski(new SkiType(&quot;name1&quot;, &quot;description1&quot;), &quot;brand1&quot;, &quot;model1&quot;, &quot;bond1&quot;, 1f)));\n}\n</code></pre>\n<p>the first skiManager.addEntity can throw multiple custom errors, but this test is not designed to check that, it assumes the first addEntity will work correctly, but I still need to handle the unhandled exceptions, and my question is:</p>\n<p>Do I let it crash by just adding <code>throws Exception</code> to the unit test declaration or should I wrap it with <code>try {...} catch (Exception e) {fail(e.message);}</code>? is there any advantage to the second approach?</p>\n",
    "tags" : [ "java", "unit-testing", "junit" ],
    "owner" : {
      "account_id" : 21384180,
      "reputation" : 3137,
      "user_id" : 15749574,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/oJBEm.jpg?s=256",
      "display_name" : "JustSightseeing",
      "link" : "https://stackoverflow.com/users/15749574/justsightseeing"
    },
    "is_answered" : true,
    "view_count" : 102,
    "closed_date" : 1750424513,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1750497016,
    "creation_date" : 1750414610,
    "link" : "https://stackoverflow.com/questions/79673215/should-junit-tests-crash-instead-of-failing",
    "closed_reason" : "Duplicate"
  },
  "answers" : [ {
    "answer_id" : 79673273,
    "question_id" : 79673215,
    "body" : "<p>A test suite passes when all the tests in it pass or are skipped. If any test fails or errors out, the test suite does not pass.</p>\n<p>With that in mind, there are very few practical differences between failing a test and allowing it to error out. Unless your <code>catch</code> block adds some useful behavior/info, I'd just let the test error out, and not bother with the boilerplate of catching all those exceptions in every test just to fail it.</p>\n<p>For example:</p>\n<pre class=\"lang-java prettyprint-override\"><code>catch (MyConfigException e) {\n   fail(&quot;Got a MyConfigException. &quot; + \n        &quot;This probably means you forgot to set teh SOME_CONFIG env vairable&quot;, \n        e);\n}\n</code></pre>\n<p>If multiple tests rely on the same set up logic, it might be a good idea to move it to some setup method, so if it errors out you get a clear indication where the problem was instead of having multiple tests failing for the same underlying reason.</p>\n<p>For example:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class SkiTests\n\nprivate SkiManager skiManager;\n\n@Before\npublic void setUp() {\n    // Set up the SkiManager...\n\n    // Set up the first entity\n   skiManager.addEntity(new Ski(new SkiType(&quot;name1&quot;, &quot;description1&quot;), &quot;brand1&quot;, &quot;model1&quot;, &quot;bond1&quot;, 1f));\n}\n\n@Test\npublic void givenSkiExists_whenAddingNewSki_thenThrowEntityAlreadyPresentException () {\n    assertThrows(EntityAlreadyPresentException.class, () -&gt; skiManager.addEntity(new Ski(new SkiType(&quot;name1&quot;, &quot;description1&quot;), &quot;brand1&quot;, &quot;model1&quot;, &quot;bond1&quot;, 1f)));\n}\n\n@Test\npublic void testSomethingElseWithTheSameEntity() {\n   //...\n}\n</code></pre>\n",
    "score" : 2,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 2818342,
      "reputation" : 315967,
      "user_id" : 2422776,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/2353050223ebecb113741c29458de4b2?s=256&d=identicon&r=PG",
      "display_name" : "Mureinik",
      "link" : "https://stackoverflow.com/users/2422776/mureinik"
    },
    "creation_date" : 1750417239,
    "last_activity_date" : 1750497016,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140529362,
    "post_id" : 79673215,
    "body" : "What do you mean by “crash” here? A tear that fails it’s preconditions should fail, an exception outside of code under test will fail, tests aren’t actual code.",
    "score" : 1,
    "owner" : {
      "account_id" : 195854,
      "reputation" : 160525,
      "user_id" : 438992,
      "user_type" : "registered",
      "accept_rate" : 90,
      "profile_image" : "https://i.sstatic.net/QouOz.jpg?s=256",
      "display_name" : "Dave Newton",
      "link" : "https://stackoverflow.com/users/438992/dave-newton"
    },
    "creation_date" : 1750419973,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140529182,
    "post_id" : 79673215,
    "body" : "Definitely opinion-based. For my part I tend to be lazy and just let unexpected exceptions fall out of the test method. Often it gives simpler test code, which is an advantage. JUnit includes <code>assertDoesNotThrow()</code>. It seems to be included to take your situation into account.",
    "score" : 1,
    "owner" : {
      "account_id" : 7612423,
      "reputation" : 87400,
      "user_id" : 5772882,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/8283c64511fa80afed5259d10850168f?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Anonymous",
      "link" : "https://stackoverflow.com/users/5772882/anonymous"
    },
    "creation_date" : 1750415227,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}