{
  "question" : {
    "question_id" : 79824377,
    "title" : "Why does the shuffle-found trigger order for a TimSort comparator contract violation *not* reliably reproduce the error when manually tested?",
    "body" : "<p><strong>Background:</strong></p>\n<p>I'm debugging a Java sorting setup where I found a faulty Comparator already (violates the contract).\nMy goal is to implement a test case which provokes the well-known</p>\n<pre><code>java.lang.IllegalArgumentException: Comparison method violates its general contract!\n</code></pre>\n<p>thrown by TimSort for such Comparators.</p>\n<p><strong>How do I provoke the error?</strong><br />\nI repeatedly shuffle and sort a list with many &quot;problematic&quot; values (e.g., many elements with the same field value). This is very reliable an reproducable, after a couple runs the expected error is thrown.</p>\n<pre class=\"lang-java prettyprint-override\"><code>for (int i = 0; i &lt; 10_000; i++) {\n    List&lt;Pojo&gt; shuffled = new ArrayList&lt;&gt;(input);\n    Collections.shuffle(shuffled);\n    try {\n        List&lt;Pojo&gt; sorted = new ArrayList&lt;&gt;(shuffled);\n        Collections.sort(sorted, faultyComparator);\n    } catch (Exception e) {\n        // Store the list that triggered the exception!\n        triggerOrder = new ArrayList&lt;&gt;(shuffled);\n        break;\n    }\n}\n</code></pre>\n<p><strong>My confusion:</strong></p>\n<p>After successfully capturing a list (<code>triggerOrder</code>) that caused the contract violation error, I expect <em>replaying</em> the sort <strong>with exactly this same order</strong> and comparator to yield the same error every time.</p>\n<p>But when I switch the input to a found triggerOrder for the next execution the sort runs fine! Even further shuffling of <code>triggerOrder</code> respectively <code>input</code> never provokes the error again.</p>\n<p>The input generator:</p>\n<pre class=\"lang-java prettyprint-override\"><code>List&lt;Pojo&gt; input = IntStream\n// starting order to find a trigger order\n        .of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40)\n// a found trigger order\n//        .of(10, 7, 27, 24, 33, 13, 23, 19, 37, 25, 22, 31, 1, 35, 18, 28, 29, 3, 9, 8, 15, 39, 14, 10, 10, 34, 17, 26, 2, 12, 4, 32, 5, 11, 16, 36, 38, 21, 10, 6)\n        .mapToObj(i -&gt; new Pojo(null, i % 10 == 0 ? 10 : i, i + &quot;.pdf&quot;))\n        .collect(Collectors.toCollection(ArrayList::new));\n\nclass Pojo {\n    private String name;\n    private Integer date;\n    private String file;\n\n    public Pojo(String name, int date, String file) {\n        this.name = name;\n        this.date = date;\n        this.file = file;\n    }\n\n    // Getter\n}\n</code></pre>\n<p>Just if you're curios, the faulty comparator (I know it's rubbish ;)):</p>\n<pre class=\"lang-java prettyprint-override\"><code>Comparator&lt;Pojo&gt; faultyComparator = (b1, b2) -&gt; {\n    if (b1 == null &amp;&amp; b2 == null) return 0;\n    if (b1 == null) return -1;\n    if (b2 == null) return 1;\n    final int result = compareToNullSave(b1.getName(), (b2.getName()));\n    if (result != 0) return result;\n    final int dateResult = b1.getDate().compareTo(b2.getDate());\n    if (dateResult != 0) return result; // this should be &quot;return dateResult;&quot;\n    return compareToNullSave(b1.getFile(), b2.getFile());\n}\n\npublic static int compareToNullSave(String s1, String s2) {\n    if (s1 == null) return s2 == null ? 0 : -1;\n    if (s2 == null) return 1;\n    return s1.compareTo(s2);\n}\n</code></pre>\n<hr />\n<h2>My question:</h2>\n<p><strong>Why does a shuffle-found trigger order, which <em>reliably</em> causes a TimSort comparator contract violation in one run, fail to reproduce the exception in another run?</strong></p>\n<ul>\n<li>The comparator is still broken in the same way.</li>\n<li>The error is provoked in a shuffle-for loop easily.</li>\n<li>Re-playing with the exact list order (that triggered the error) in a new run does <em>not</em> throw. Whereas the trigger order in the <em>same</em> run reliable reproduces the error.</li>\n<li>Even further shuffling doesn't seem to help after that.</li>\n</ul>\n<p>Is TimSort doing some kind of internal magic with runs, memory layout or merging that's dependent on more than just the input order?<br />\nIs there any way to reliably construct an input order that <em>always</em> triggers the exception?</p>\n<p><strong>Explanations/Efficiency:</strong></p>\n<ul>\n<li>Why does the sort outcome seem non-deterministic w.r.t. the input order?</li>\n<li>What should I know about TimSortâ€™s inner mechanics that makes the error appear and disappear like this?</li>\n</ul>\n<p>Thanks in advance for any insights!</p>\n",
    "tags" : [ "java", "comparator", "timsort" ],
    "owner" : {
      "account_id" : 13087697,
      "reputation" : 57,
      "user_id" : 9456200,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/LtEjd.jpg?s=256",
      "display_name" : "polo",
      "link" : "https://stackoverflow.com/users/9456200/polo"
    },
    "is_answered" : false,
    "view_count" : 157,
    "answer_count" : 0,
    "score" : 5,
    "last_activity_date" : 1763551069,
    "creation_date" : 1763551069,
    "link" : "https://stackoverflow.com/questions/79824377/why-does-the-shuffle-found-trigger-order-for-a-timsort-comparator-contract-viola",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140875404,
    "post_id" : 79824377,
    "body" : "Hmm. I still can&#39;t seem to reproduce the problem with Java 25. I modified <code>Pojo</code> to implement <code>Serializable</code>. I kept <code>Pojo</code> a record for simplicity. In one JVM instance I would find 500 unique trigger orders and serialize them to a file. Then in another JVM instance I would load those 500 trigger orders and attempt to sort all of them again. They always threw the expected exception indicating a bad comparator.",
    "score" : 0,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49884,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1764213992,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140871746,
    "post_id" : 79824377,
    "body" : "@siggemannen, many thanks for the minimal example.",
    "score" : 0,
    "owner" : {
      "account_id" : 13087697,
      "reputation" : 57,
      "user_id" : 9456200,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/LtEjd.jpg?s=256",
      "display_name" : "polo",
      "link" : "https://stackoverflow.com/users/9456200/polo"
    },
    "creation_date" : 1764061363,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140871743,
    "post_id" : 79824377,
    "body" : "You&#39;re both absolutely right @Slaw and siggemannen. A found trigger order will trigger again in the same run, but if you note the trigger order and start a new execution with that order the error wont occur.  Slaw, the commented out order once triggered the error but won&#39;t trigger it anymore. You can reproduce this strange behavior with siggemannens example by adding a propper to string method an copying a found trigger order for the next run.",
    "score" : 1,
    "owner" : {
      "account_id" : 13087697,
      "reputation" : 57,
      "user_id" : 9456200,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/LtEjd.jpg?s=256",
      "display_name" : "polo",
      "link" : "https://stackoverflow.com/users/9456200/polo"
    },
    "creation_date" : 1764061341,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140866215,
    "post_id" : 79824377,
    "body" : "I can reproduce the crash as well, see: <a href=\"https://onecompiler.com/java/445b3vfqx\" rel=\"nofollow noreferrer\">onecompiler.com/java/445b3vfqx</a> perhaps you messed up the right variable to sort?",
    "score" : 0,
    "owner" : {
      "account_id" : 17972905,
      "reputation" : 10131,
      "user_id" : 13061224,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/GyOMS.jpg?s=256",
      "display_name" : "siggemannen",
      "link" : "https://stackoverflow.com/users/13061224/siggemannen"
    },
    "creation_date" : 1763729352,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140863209,
    "post_id" : 79824377,
    "body" : "Actually, your commented-out &quot;found trigger order&quot; doesn&#39;t throw an exception for me in the first place. A proper <a href=\"https://stackoverflow.com/help/minimal-reproducible-example\">minimal reproducible example</a> would at least let me know if I&#39;m doing something wrong on my end.",
    "score" : 0,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49884,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1763586883,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140863188,
    "post_id" : 79824377,
    "body" : "Perhaps I&#39;m misunderstanding the problem, but I can&#39;t reproduce the problem on Java 25 after making your code snippets runnable (though I made <code>Pojo</code> a record). I even ran your code in an infinite loop. Calling <code>Collections.sort(triggerOrder, faultyComparator)</code> after finding a trigger order always threw an exception. Can you provide a proper <a href=\"https://stackoverflow.com/help/minimal-reproducible-example\">minimal reproducible example</a>?",
    "score" : 0,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49884,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1763586295,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140862944,
    "post_id" : 79824377,
    "body" : "Even if I override the hashCode method with a consistent implementation, the mysterious behavior remains. The IntStream is only used to construct the List; I don&#39;t think the list retains any information about stream flags.",
    "score" : 2,
    "owner" : {
      "account_id" : 13087697,
      "reputation" : 57,
      "user_id" : 9456200,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/LtEjd.jpg?s=256",
      "display_name" : "polo",
      "link" : "https://stackoverflow.com/users/9456200/polo"
    },
    "creation_date" : 1763575854,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140862686,
    "post_id" : 79824377,
    "body" : "the hashes of <code>int</code> / <code>Integer</code> values are just.. that int, i.e. they are consistent and immutable. But the hashcode of Pojo instances is consistent for a single JVM run but will change if you start the same java invokation a second time. So that <i>might</i> be it.",
    "score" : 0,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107136,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1763569375,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140862676,
    "post_id" : 79824377,
    "body" : "IntStreams have all the stream flags that allow parallel processing. An obvious kneejerk answer to the question &#39;why does my VM act differently on different runs&#39; should be &quot;It&#39;s either a race condition or due to system identity hashcodes&quot;.",
    "score" : 0,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107136,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1763569176,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140862555,
    "post_id" : 79824377,
    "body" : "I don&#39;t know the answer, but you should unit test your comparators for adherence to the contract stated in the Comparator javadoc. You might find something like <a href=\"https://tomregan.github.io/comparatorverifier/\" rel=\"nofollow noreferrer\">tomregan.github.io/comparatorverifier</a> useful.",
    "score" : 0,
    "owner" : {
      "account_id" : 19118721,
      "reputation" : 12449,
      "user_id" : 13963086,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/9df2c3c4c87d8050b8fd6a59c88c7133?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "k314159",
      "link" : "https://stackoverflow.com/users/13963086/k314159"
    },
    "creation_date" : 1763565380,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}