{
  "question" : {
    "question_id" : 79817835,
    "title" : "Returning memory from glibc malloc non-main arenas to the operating system",
    "body" : "<p>I simulated a scenario in Java that leads to severe glibc memory fragmentation.</p>\n<ul>\n<li>Step one: simulate a multithreaded environment with 600 threads.</li>\n<li>Step two: every second, start two new threads that read a large file via <code>java.nio.channels.FileChannel</code>.</li>\n<li>Step three: after 10 seconds, terminate automatically and let GC perform the cleanup.</li>\n</ul>\n<p>This program will keep using memory from the non-main arena regions until the maximum number of arenas is reached, at which point memory usage stabilizes. If you then stop all threads and leave only the main thread sleeping, you’ll find that the process’s RSS metric does not decrease and remains high.</p>\n<ul>\n<li>According to the NMT report, you’ll find that the JVM’s accounting does not show using that much memory.</li>\n<li>From the Linux pmap and smaps information, you’ll see that each 64 MB block in the non-main arena regions has about 8 MB touched in physical memory. If you try to read the binary data from memory, you’ll find that all of it is content from your file.</li>\n</ul>\n<p>The most fascinating part is glibc’s parameter behavior. When I try using the <code>MALLOC_TRIM_THRESHOLD_</code> environment variable, regardless of the value I set, RSS reclamation begins to occur. Since the <code>DirectBuffer</code> used to read the file is 8 MB, I tried 52,428,800 (50 MB) and 8,388,608 (8 MB). Each time, the process’s RSS would reclaim around 16 MB. I once used gdb to inspect the process’s ptmalloc2 allocator trim_threshold parameter, the default value exists and is around 48 MB. After configuring the <code>MALLOC_TRIM_THRESHOLD_</code> variable, the reclamation behavior changes completely, especially for memory in the non-main arena regions.</p>\n<p>By the way, the JDK version I used is 21-openjdk, and the glibc version is 2.39.</p>\n<p>On each file read, the process calls <code>malloc</code> to request off-heap memory, and after the thread dies, the GC thread initiates the free operation. Therefore, in the JVM dump you can observe that all objects, including off-heap <code>DirectBuffer</code>s, are being destroyed in order.</p>\n<p>My main questions are twofold: <strong>why does this parameter affect the drop in memory usage?</strong> In addition, when it is set to 50 MB, even before theoretically reaching the 50 MB reclaimable threshold, glibc also returns memory from the non-main arena to the OS. <strong>It seems that after this parameter is set, glibc’s free behavior has changed?</strong></p>\n<p>To add: this is a JVM runtime parameter, and it’s simple.</p>\n<p><em><em>-Xms6g -Xmx6g -XX:MaxDirectMemorySize=5g -XX:+AlwaysPreTouch -XX:+UseG1GC -Xlog:gc</em>:file=gc.log:time,uptime,level,tags:filecount=5,filesize=100M</em>*</p>\n<pre><code>import java.io.RandomAccessFile;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FileRead1 {\n\n    private static volatile boolean stop = false;\n\n    public static void main(String[] args) throws InterruptedException {\n\n        liveThreadLoopWithoutMemory();\n        \n\n        int count = 0;\n        while (true) {\n            if (count &gt; (Integer.MAX_VALUE -1) ) {\n                break;\n            }\n            count++;\n            try {\n                for (int i = 0; i &lt; 2; i++) {\n                    newThread();\n                }\n\n                for (int i = 0; i &lt; 5; i++) {\n                    Thread.sleep(1000L);\n                }\n            } catch (InterruptedException e) {\n            }\n        }\n\n        stop = true;\n\n        while (true) {\n            for (int i = 0; i &lt; 5; i++) {\n                Thread.sleep(1000L);\n            }\n        }\n    }\n\n    private static void liveThreadLoopWithoutMemory() {\n        for (int i = 0; i &lt; 600; i++) {\n            new Thread(() -&gt; {\n                while (true) {\n                    try {\n                        Thread.sleep(100L);\n                    } catch (InterruptedException e) {\n                        throw new RuntimeException(e);\n                    }\n                    if (stop) {\n                        break;\n                    }\n                }\n            }).start();\n        }\n    }\n\n    private static void newThread() {\n        Thread thread = new Thread(new Runnable() {\n\n            private final List&lt;String&gt; strings = new ArrayList&lt;&gt;();\n\n            @Override\n            public void run() {\n\n                test(strings, &quot;test.txt&quot;, &quot;UTF-8&quot;, false);\n\n                strings.clear();\n            }\n        });\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    private static void test(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test1(strings, src, encoding, hasTitle);\n    }\n\n    private static void test1(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test2(strings, src, encoding, hasTitle);\n\n    }\n\n    private static void test2(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test3(strings, src, encoding, hasTitle);\n    }\n\n    private static void test3(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test4(strings, src, encoding, hasTitle);\n\n    }\n\n    private static void test4(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test5(strings, src, encoding, hasTitle);\n    }\n\n    private static void test5(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test6(strings, src, encoding, hasTitle);\n\n    }\n\n\n    private static void test6(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test7(strings, src, encoding, hasTitle);\n    }\n\n    private static void test7(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test8(strings, src, encoding, hasTitle);\n    }\n\n    private static void test8(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test9(strings, src, encoding, hasTitle);\n    }\n\n    private static void test9(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        test10(strings, src, encoding, hasTitle);\n    }\n\n    private static void test10(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n        new TaskReadFile() {\n            @Override\n            public void process(String str) {\n                super.process(str + &quot;swk&quot;);\n            }\n        }.readFile(strings, src, encoding, hasTitle);\n    }\n\n\n    static class TaskReadFile implements ReadFileInterface {\n\n\n        private final List&lt;String&gt; stringList = new ArrayList&lt;&gt;();\n\n        @Override\n        public void process(String str) {\n            stringList.add(str + &quot;123&quot;);\n        }\n\n        @Override\n        public void clear() {\n            stringList.clear();\n        }\n    }\n\n    interface ReadFileInterface {\n\n        void process(String str);\n\n        void clear();\n\n        default void readFile(List&lt;String&gt; strings, String src, String encoding, boolean hasTitle) {\n            int readLimit = 8 * 1024 * 1024;\n            int startIndex = 0;\n\n            try (RandomAccessFile raf = new RandomAccessFile(src, &quot;r&quot;);) {\n                FileChannel channel = raf.getChannel();\n                ByteBuffer rbuf = ByteBuffer.allocate(readLimit);\n\n                synchronized (rbuf) {\n                    channel.position(startIndex);\n                    \n                    byte[] temp = new byte[0];\n                    int LF = 10;\n                    long lineCount = 0;\n\n                    while (channel.read(rbuf) != -1) {\n                        int position = rbuf.position();\n                        byte[] rbyte = new byte[position];\n                        rbuf.flip();\n                        rbuf.get(rbyte);\n                        int startnum = 0;\n\n                        for (int i = 0; i &lt; rbyte.length; i++) {\n                            if (rbyte[i] == LF) {\n                                if (channel.position() == startIndex) {\n                                    startnum = i + 1;\n                                } else {\n                                    if (hasTitle &amp;&amp; 0 == lineCount) {\n                                        startnum = i + 1;\n                                        lineCount++;\n                                        continue;\n                                    }\n                                    int lineLen = i - startnum + 1;\n                                    byte[] line = new byte[temp.length + lineLen];\n                                    System.arraycopy(temp, 0, line, 0, temp.length);\n                                    System.arraycopy(rbyte, startnum, line, temp.length, lineLen);\n                                    startnum = i + 1;\n                                    temp = new byte[0];\n                                    String str = trimEndingCRLF(line, encoding);\n                                    strings.add(str);\n                                    process(str);\n                                }\n                            }\n                        }\n\n\n                        if (startnum &lt; rbyte.length) {\n                            byte[] temp2 = new byte[temp.length + rbyte.length - startnum];\n                            System.arraycopy(temp, 0, temp2, 0, temp.length);\n                            System.arraycopy(rbyte, startnum, temp2, temp.length, rbyte.length - startnum);\n                            temp = temp2;\n                        }\n                        rbuf.clear();\n                    }\n                }\n\n                rbuf.clear();\n\n                try {\n                    Thread.sleep(10000L);\n                } catch (InterruptedException e) {\n                    throw new RuntimeException(e);\n                }\n\n                clear();\n\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n\n        default String trimEndingCRLF(byte[] line, String encoding) throws UnsupportedEncodingException {\n            if (line.length != 0 &amp;&amp; line[0] != 10) {\n                int lastIdx = line.length - 1;\n                if (line[lastIdx] != 10) {\n                    ++lastIdx;\n                } else if (line[lastIdx - 1] == 13) {\n                    --lastIdx;\n                }\n\n                return new String(line, 0, lastIdx, encoding);\n            } else {\n                return &quot;&quot;;\n            }\n        }\n    }\n}\n\n```java\n</code></pre>\n",
    "tags" : [ "java", "jvm", "malloc", "glibc" ],
    "owner" : {
      "account_id" : 18013206,
      "reputation" : 41,
      "user_id" : 13092300,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a-/AOh14Giu1KJ_vCxpaOfrJC1r0V8N10S6191xRiOB_6P2pg=k-s256",
      "display_name" : "Forever",
      "link" : "https://stackoverflow.com/users/13092300/forever"
    },
    "is_answered" : true,
    "view_count" : 78,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1762994649,
    "creation_date" : 1762957258,
    "link" : "https://stackoverflow.com/questions/79817835/returning-memory-from-glibc-malloc-non-main-arenas-to-the-operating-system",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79818048,
    "question_id" : 79817835,
    "body" : "<blockquote>\n<p>When I try using the <code>MALLOC_TRIM_THRESHOLD_</code> environment variable, regardless of the value I set, RSS reclamation begins to occur.</p>\n<p>[...]</p>\n<p>My main questions are twofold: <strong>why does this parameter affect the drop in memory usage?</strong></p>\n</blockquote>\n<p>Because that's its purpose?</p>\n<blockquote>\n<p>In addition, when it is set to 50 MB, even before theoretically reaching the 50 MB reclaimable threshold, glibc also returns memory from the non-main arena to the OS. <strong>It seems that after this parameter is set, glibc’s free behavior has changed?</strong></p>\n</blockquote>\n<p>I can't speak to the details of how specific values of this parameter affect whether or when the Glibc allocator releases memory to the system, but yes, there is a qualitative difference between specifying any value for <code>MALLOC_TRIM_THRESHOLD_</code> and not specifying it at all.  Glibc now documents these by way of its <a href=\"https://www.gnu.org/software/libc/manual/html_node/Tunables.html\" rel=\"nofollow noreferrer\">&quot;tunables&quot;</a> feature that is meant to consolidate libray tuning into one place.  The corresponding tunable in this case is <code>glibc.malloc.trim_threshold</code>, and this is <a href=\"https://www.gnu.org/software/libc/manual/html_node/Memory-Allocation-Tunables.html#index-glibc_002emalloc_002etrim_005fthreshold\" rel=\"nofollow noreferrer\">its documentation</a>:</p>\n<blockquote>\n<p>This tunable supersedes the <code>MALLOC_TRIM_THRESHOLD_</code> environment variable and is identical in features.</p>\n<p>The value of this tunable is the minimum size (in bytes) of the top-most, releasable chunk in an arena that will trigger a system call in order to return memory to the system from that arena.</p>\n<p>If this tunable is not set, the default value is set as 128 KB and the threshold is adjusted dynamically to suit the allocation patterns of the program. If the tunable is set, the dynamic adjustment is disabled and the value is set as static.</p>\n</blockquote>\n<p>Pay special attention to the last paragraph.  If any value for this parameter is set then it defines a fixed threshold, but if none is set at all then Glibc performs some kind of dynamic adaptation, which is not explained in detail.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190712,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1762967921,
    "last_activity_date" : 1762967921,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140855227,
    "post_id" : 79817835,
    "body" : "Yes, this is just a demo example, not an actual production requirement.",
    "score" : 0,
    "owner" : {
      "account_id" : 18013206,
      "reputation" : 41,
      "user_id" : 13092300,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a-/AOh14Giu1KJ_vCxpaOfrJC1r0V8N10S6191xRiOB_6P2pg=k-s256",
      "display_name" : "Forever",
      "link" : "https://stackoverflow.com/users/13092300/forever"
    },
    "creation_date" : 1763181120,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140854731,
    "post_id" : 79817835,
    "body" : "There is no need for going the <code>RandomAccessFile</code> detour when creating a <code>FileChannel</code> for far more than a decade now. Further, all those array allocations and copy operations are unnecessary and distracting from the purpose of the code, read into a <code>ByteBuffer</code>, identify the boundaries within that buffer, create the string from the buffer. Or just use the built-in methods for reading lines from a channel (Assuming you need the channel for demonstration purposes, as otherwise, <code>Files.readAllLines(Path.get(src))</code> will do the entire job for you).",
    "score" : 1,
    "owner" : {
      "account_id" : 3211603,
      "reputation" : 300941,
      "user_id" : 2711488,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
      "display_name" : "Holger",
      "link" : "https://stackoverflow.com/users/2711488/holger"
    },
    "creation_date" : 1763142037,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140850827,
    "post_id" : 79817835,
    "body" : "There is a pretty detailed description of Glibc&#39;s allocator here: <a href=\"https://sourceware.org/glibc/wiki/MallocInternals\" rel=\"nofollow noreferrer\">sourceware.org/glibc/wiki/MallocInternals</a>, and a higher-level summary <a href=\"https://www.gnu.org/software/libc/manual/html_node/The-GNU-Allocator.html\" rel=\"nofollow noreferrer\">in the Glibc manual</a>.",
    "score" : 0,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190712,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1762965309,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140850586,
    "post_id" : 79817835,
    "body" : "Please don&#39;t add comments to clarify; <a href=\"https://stackoverflow.com/posts/79817835/edit\">edit</a> your question instead, so that all information is in the question.",
    "score" : 5,
    "owner" : {
      "account_id" : 1535561,
      "reputation" : 9056,
      "user_id" : 1431720,
      "user_type" : "registered",
      "accept_rate" : 89,
      "profile_image" : "https://www.gravatar.com/avatar/f5a1388d4d3b2bf03b11bb5658c68c29?s=256&d=identicon&r=PG",
      "display_name" : "Robert",
      "link" : "https://stackoverflow.com/users/1431720/robert"
    },
    "creation_date" : 1762957506,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79818048" : [ {
      "comment_id" : 140855226,
      "post_id" : 79818048,
      "body" : "@Forever When I use the MALLOC_TRIM_THRESHOLD_ parameter, dynamic adjustment will be disabled.In the code, since the allocation size exceeds the M_MMAP_THRESHOLD limit, memory will be allocated via mmap as an independent region.When freeing, it is recognized as an independent region and thus is directly released via munmap, without adhering to the MALLOC_TRIM_THRESHOLD_ limit.",
      "score" : 0,
      "owner" : {
        "account_id" : 18013206,
        "reputation" : 41,
        "user_id" : 13092300,
        "user_type" : "registered",
        "profile_image" : "https://lh3.googleusercontent.com/a-/AOh14Giu1KJ_vCxpaOfrJC1r0V8N10S6191xRiOB_6P2pg=k-s256",
        "display_name" : "Forever",
        "link" : "https://stackoverflow.com/users/13092300/forever"
      },
      "creation_date" : 1763180990,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140855224,
      "post_id" : 79818048,
      "body" : "Thanks for the final note about “some kind of dynamic adaptation.” Using the parameter descriptions in this article, I found some changes related to dynamic adjustment, and it seems I’ve found the cause. <a href=\"https://www.openeuler.org/en/blog/wangshuo/Glibc%20Malloc%20Principle/Glibc_Malloc_Principle?ref=deep-kondah.com\" rel=\"nofollow noreferrer\">openeuler.org/en/blog/wangshuo/Glibc%20Malloc%20Principle/&hellip;</a>",
      "score" : 0,
      "owner" : {
        "account_id" : 18013206,
        "reputation" : 41,
        "user_id" : 13092300,
        "user_type" : "registered",
        "profile_image" : "https://lh3.googleusercontent.com/a-/AOh14Giu1KJ_vCxpaOfrJC1r0V8N10S6191xRiOB_6P2pg=k-s256",
        "display_name" : "Forever",
        "link" : "https://stackoverflow.com/users/13092300/forever"
      },
      "creation_date" : 1763180894,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140851492,
      "post_id" : 79818048,
      "body" : "Thank you for your reply. Yes, if we go by “that” statement, this parameter does indeed affect the overall non-main area and even glibc’s memory reclamation mechanism. At present, it seems that reclamation is triggered in the non-main arena even before reaching 50 MB, which appears inconsistent with the intended purpose of this parameter.",
      "score" : 0,
      "owner" : {
        "account_id" : 18013206,
        "reputation" : 41,
        "user_id" : 13092300,
        "user_type" : "registered",
        "profile_image" : "https://lh3.googleusercontent.com/a-/AOh14Giu1KJ_vCxpaOfrJC1r0V8N10S6191xRiOB_6P2pg=k-s256",
        "display_name" : "Forever",
        "link" : "https://stackoverflow.com/users/13092300/forever"
      },
      "creation_date" : 1762995334,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}