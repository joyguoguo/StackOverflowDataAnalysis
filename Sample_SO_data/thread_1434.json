{
  "question" : {
    "question_id" : 79706196,
    "title" : "How can I optimize the time complexity of my brute-force solution for finding all unique triplets with sum zero?",
    "body" : "<p>I'm solving the &quot;3Sum&quot; problem where I need to find all unique triplets in an array that sum to zero.</p>\n<p>Here’s my brute-force Java code:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {\n    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n    for(int i = 0; i &lt; nums.length - 2; i++) {\n        for(int j = i + 1; j &lt; nums.length - 1; j++) {\n            for(int k = j + 1; k &lt; nums.length; k++) {\n                if(nums[i] + nums[j] + nums[k] == 0) {\n                    List&lt;Integer&gt; triplet = Arrays.asList(nums[i], nums[j], nums[k]);\n                    Collections.sort(triplet);\n                    if(!result.contains(triplet)) {\n                        result.add(triplet);\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}\n</code></pre>\n<p>It works correctly and returns the right triplets, but it is very slow for large arrays (like size &gt; 1000). I want to optimize this solution to make it faster.</p>\n<p>I’ve read that sorting or using a <code>HashSet</code> might help, but I’m not sure how to implement that in an efficient way.</p>\n<p>Can someone explain how I can improve the time complexity of this solution, and what changes I should make to my code to implement a better approach?</p>\n",
    "tags" : [ "java", "arrays", "algorithm", "time-complexity" ],
    "owner" : {
      "account_id" : 43102739,
      "reputation" : 27,
      "user_id" : 31079177,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/71d512985b81b3c89e379f3a46386a9e?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Ghanshyam dubey",
      "link" : "https://stackoverflow.com/users/31079177/ghanshyam-dubey"
    },
    "is_answered" : true,
    "view_count" : 162,
    "answer_count" : 4,
    "score" : -1,
    "last_activity_date" : 1752923916,
    "creation_date" : 1752843070,
    "link" : "https://stackoverflow.com/questions/79706196/how-can-i-optimize-the-time-complexity-of-my-brute-force-solution-for-finding-al",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79706227,
    "question_id" : 79706196,
    "body" : "<p>Sure. If you <a href=\"https://www.baeldung.com/java-quicksort\" rel=\"nofollow noreferrer\">sort</a> your array, then you will know about any index that you could use <a href=\"https://www.baeldung.com/java-binary-search\" rel=\"nofollow noreferrer\">binary search</a> by searching for pairs. Therefore your algorithm would be as follows:</p>\n<ul>\n<li>on the first level you have a left index and a right index</li>\n<li>left is initialized with 0 and right is initialized by length - 1</li>\n<li>while left &lt;= right do\n<ul>\n<li>apply binary search between left and right until you either find a match or you used up your logN steps</li>\n<li>if there was a match, store it as a triplet</li>\n<li>probe with incremented left, but unchanged right as well as decremented right and unchanged left in a similar manner (using binary search) to find further triplet if they fulfill the condition</li>\n<li>after the probing is finished, increment left and decrement right until you get past of any duplicates</li>\n</ul>\n</li>\n</ul>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 194308,
      "reputation" : 80465,
      "user_id" : 436560,
      "user_type" : "registered",
      "accept_rate" : 87,
      "profile_image" : "https://i.sstatic.net/2GESV.jpg?s=256",
      "display_name" : "Lajos Arpad",
      "link" : "https://stackoverflow.com/users/436560/lajos-arpad"
    },
    "creation_date" : 1752844440,
    "last_activity_date" : 1752923916,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79706380,
    "question_id" : 79706196,
    "body" : "<ol>\n<li><p><strong>First, sort the array.</strong></p>\n</li>\n<li><p><strong>Fix the first number</strong>, then use <strong>two pointers</strong> (<code>left</code> and <code>right</code>) to search for the other two numbers in the remaining part of the array, so that the sum of the three numbers is zero.</p>\n</li>\n<li><p><strong>Skip duplicate elements</strong> to avoid duplicate solutions.</p>\n</li>\n</ol>\n<ul>\n<li><p>The time complexity is $O(n^2)$, which is much faster than three nested loops.</p>\n</li>\n<li><p>By using sorting and the two-pointer approach, duplicates are handled naturally, so there’s no need to use <code>contains</code> to check for duplicates (which would be $O(n)$ and slower).</p>\n</li>\n</ul>\n<pre><code>public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {\n    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n    Arrays.sort(nums); // Sort the array to use two pointers efficiently\n    for (int i = 0; i &lt; nums.length - 2; i++) {\n        // Skip duplicate values for the first element\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;\n        int left = i + 1;\n        int right = nums.length - 1;\n        while (left &lt; right) {\n            int sum = nums[i] + nums[left] + nums[right];\n            if (sum == 0) {\n                // Found a triplet that sums to zero\n                result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n                // Skip duplicate values for the second element\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                // Skip duplicate values for the third element\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n                left++;\n                right--;\n            } else if (sum &lt; 0) {\n                // If the sum is less than zero, move the left pointer to increase the sum\n                left++;\n            } else {\n                // If the sum is greater than zero, move the right pointer to decrease the sum\n                right--;\n            }\n        }\n    }\n    return result;\n}\n</code></pre>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 43105510,
      "reputation" : 11,
      "user_id" : 31080827,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/v8AwUVEo.gif?s=256",
      "display_name" : "SHUOQING HUANG",
      "link" : "https://stackoverflow.com/users/31080827/shuoqing-huang"
    },
    "creation_date" : 1752850629,
    "last_activity_date" : 1752850629,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79706594,
    "question_id" : 79706196,
    "body" : "<p>What the brute force solution is doing is going through every possible triplet (say, <code>a</code>, <code>b</code>, and <code>c</code>) and then checking if their sum is 0.<br />\nThat makes the time complexity: <strong>O(n³)</strong>.</p>\n<p>Instead of fixing all three and then checking them, we can:</p>\n<ul>\n<li><p>Fix two numbers (say <code>a</code> and <code>b</code>).</p>\n</li>\n<li><p>Compute the required third number as <code>0 - (a + b)</code>.</p>\n</li>\n<li><p>Check if that third number exists in the list.</p>\n</li>\n</ul>\n<p>This changes the complexity to:<br />\n<code>O(n² × time_complexity_of_checking_third_number)</code></p>\n<p>The <strong>key observation</strong> is that we do not need to go through all numbers the third time, because we would know the third number already (since we have the sum of all three, and two numbers).</p>\n<p>Now, how can we check if the third number exists (and how many times it appears)?</p>\n<ul>\n<li>Option 1: We can use Linear Search and go through each element. (Brute force method)</li>\n<li>Option 2: We can sort the array first and use Binary Search to find the third element's existence (and count) in O(log n) time. This makes the total complexity = O(n² log n).</li>\n<li>Option 3: We can put all elements in a HashSet beforehand. Using hashing techniques gives us the power of searching elements (or checking if certain elements exist) in constant time O(1). Since we might need the count of the third element, we can use a HashMap instead. This approach brings the time complexity down to O(n²) if we ignore collisions.</li>\n<li>Option 4 (Best): Sort and use Two-Pointer technique.\nTotal = O(n²) without extra space (except for the result).</li>\n</ul>\n<p>Implementation:</p>\n<pre class=\"lang-java prettyprint-override\"><code>// implementation of two pointer approach: \n public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n        Arrays.sort(nums); // Sort the array\n        int n = nums.length;\n\n        for (int i = 0; i &lt; n - 2; i++) {\n            // Skip duplicates for the first element\n            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;\n\n            int left = i + 1;\n            int right = n - 1;\n\n            while (left &lt; right) {\n                int sum = nums[i] + nums[left] + nums[right];\n\n                if (sum == 0) {\n                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n\n                    // Skip duplicates for left and right\n                    while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) left++;\n                    while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) right--;\n\n                    left++;\n                    right--;\n                } else if (sum &lt; 0) {\n                    left++; // Need bigger sum\n                } else {\n                    right--; // Need smaller sum\n                }\n            }\n        }\n\n        return result;\n\n\n// implementation of hash map solution: \npublic static List&lt;List&lt;Integer&gt;&gt; threeSumHashMap(int[] nums) {\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n        int n = nums.length;\n\n        // Frequency map\n        Map&lt;Integer, Integer&gt; freq = new HashMap&lt;&gt;();\n        for (int num : nums) {\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\n        }\n\n        Set&lt;String&gt; seen = new HashSet&lt;&gt;(); // To avoid duplicates\n\n        for (int i = 0; i &lt; n; i++) {\n            for (int j = i + 1; j &lt; n; j++) {\n                int a = nums[i], b = nums[j];\n                int needed = -(a + b);\n\n                // Temporarily reduce counts of current two numbers\n                freq.put(a, freq.get(a) - 1);\n                freq.put(b, freq.get(b) - 1);\n\n                if (freq.containsKey(needed) &amp;&amp; freq.get(needed) &gt; 0) {\n                    int[] triplet = {a, b, needed};\n                    Arrays.sort(triplet); // Sort to ensure uniqueness\n                    String key = Arrays.toString(triplet);\n                    if (!seen.contains(key)) {\n                        seen.add(key);\n                        result.add(Arrays.asList(triplet[0], triplet[1], triplet[2]));\n                    }\n                }\n\n                // Restore counts\n                freq.put(a, freq.get(a) + 1);\n                freq.put(b, freq.get(b) + 1);\n            }\n        }\n\n        return result;\n    }\n</code></pre>\n<p>Feel free to ask if you have any doubts!</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 38327136,
      "reputation" : 53,
      "user_id" : 28716518,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/YjFTXoqx.jpg?s=256",
      "display_name" : "Parth Agarwal",
      "link" : "https://stackoverflow.com/users/28716518/parth-agarwal"
    },
    "creation_date" : 1752863409,
    "last_activity_date" : 1752863409,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79706368,
    "question_id" : 79706196,
    "body" : "<p>you can use two pointer approach by sorting an array here is the example code :</p>\n<pre><code>vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n    vector&lt;vector&lt;int&gt;&gt; result;\n    int n = nums.size();\n\n    sort(nums.begin(), nums.end());\n\n    for (int i = 0; i &lt; n - 2; ++i) {\n        // Skip duplicate elements for the first element\n        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue;\n\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left &lt; right) {\n            int sum = nums[i] + nums[left] + nums[right];\n\n            if (sum == 0) {\n                result.push_back({nums[i], nums[left], nums[right]});\n\n                // Skip duplicates for left and right\n                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) ++left;\n                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) --right;\n\n                ++left;\n                --right;\n            } else if (sum &lt; 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n\n    return result;\n}\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 43103291,
      "reputation" : 1,
      "user_id" : 31079515,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/e0caf92e9bf38d8fc5b9004d38472727?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Panyam Karthikeya",
      "link" : "https://stackoverflow.com/users/31079515/panyam-karthikeya"
    },
    "creation_date" : 1752850282,
    "last_activity_date" : 1752850282,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79706594" : [ {
      "comment_id" : 140650364,
      "post_id" : 79706594,
      "body" : "There may be an even faster algorithm with FFT if the integer range is limited. <a href=\"https://stackoverflow.com/questions/6701733/asymptotically-optimal-way-to-find-the-sum-of-three-elements-of-an-array-closest\" title=\"asymptotically optimal way to find the sum of three elements of an array closest\">stackoverflow.com/questions/6701733/&hellip;</a>",
      "score" : 0,
      "owner" : {
        "account_id" : 3813614,
        "reputation" : 11574,
        "user_id" : 3163618,
        "user_type" : "registered",
        "accept_rate" : 82,
        "profile_image" : "https://www.gravatar.com/avatar/7baa9537384cb1b60aab8e624d2fde2b?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "qwr",
        "link" : "https://stackoverflow.com/users/3163618/qwr"
      },
      "creation_date" : 1754601552,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79706227" : [ {
      "comment_id" : 140602077,
      "post_id" : 79706227,
      "body" : "@KellyBundy indeed, thanks for pointing that out. Adjusted my answer to cope with this by adding a further step to &quot;probe&quot; with incremented left and unchanged right as well as decremented right and unchanged left with binary search for the middle member before we do the increment to find further triplets.",
      "score" : 0,
      "owner" : {
        "account_id" : 194308,
        "reputation" : 80465,
        "user_id" : 436560,
        "user_type" : "registered",
        "accept_rate" : 87,
        "profile_image" : "https://i.sstatic.net/2GESV.jpg?s=256",
        "display_name" : "Lajos Arpad",
        "link" : "https://stackoverflow.com/users/436560/lajos-arpad"
      },
      "creation_date" : 1752923982,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140600850,
      "post_id" : 79706227,
      "body" : "For input <code>{-3, -2, -1, 0, 1, 2, 3}</code>, how would this find the triple <code>{-3, 1, 2}</code>? Doesn&#39;t it find the triple <code>{-3, 0, 3}</code> and then throw away the <code>-3</code>?",
      "score" : 1,
      "owner" : {
        "account_id" : 17476274,
        "reputation" : 27969,
        "user_id" : 12671057,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/90d2e6942c69df199a95d06e0c8e9a10?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Kelly Bundy",
        "link" : "https://stackoverflow.com/users/12671057/kelly-bundy"
      },
      "creation_date" : 1752862902,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}