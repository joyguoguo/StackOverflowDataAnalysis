{
  "question" : {
    "question_id" : 79822646,
    "title" : "Should a permutation in an ObservableList generate added and removed changes in JavaFX?",
    "body" : "<p>I thought that during a permutation in an <code>ObservableList</code>, added and removed changes should not be generated. However, calling <code>FXCollections.reverse()</code> showed that this is not the case. This is my code:</p>\n<pre><code>public class Permutation {\n\n    public static void main(String[] args) {\n        test(&quot;FXCollections.reverse()&quot;, FXCollections::reverse);\n        test(&quot;sort(reverseOrder())&quot;, list -&gt; list.sort(Comparator.reverseOrder()));\n    }\n\n    private static void test(String name, Consumer&lt;ObservableList&lt;Integer&gt;&gt; op) {\n        ObservableList&lt;Integer&gt; list = FXCollections.observableArrayList(1, 2, 3);\n        list.addListener((ListChangeListener&lt;Integer&gt;) change -&gt; {\n            while (change.next())\n                System.out.printf(&quot;%s - Added: %s, Removed: %s, Permutated: %s%n&quot;,\n                    name, change.wasAdded(), change.wasRemoved(), change.wasPermutated());\n        });\n        op.accept(list);\n    }\n}\n</code></pre>\n<p>And this is the output:</p>\n<pre><code>FXCollections.reverse() - Added: true, Removed: true, Permutated: false\nsort(reverseOrder()) - Added: false, Removed: false, Permutated: true\n</code></pre>\n<p>Could you please tell me if this is a bug or expected behavior?</p>\n",
    "tags" : [ "java", "javafx" ],
    "owner" : {
      "account_id" : 34599290,
      "reputation" : 1188,
      "user_id" : 26656564,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/882f996623517814360ba4bb403102e7?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "SilverCube",
      "link" : "https://stackoverflow.com/users/26656564/silvercube"
    },
    "is_answered" : true,
    "view_count" : 205,
    "answer_count" : 2,
    "score" : 7,
    "last_activity_date" : 1763453264,
    "creation_date" : 1763403773,
    "link" : "https://stackoverflow.com/questions/79822646/should-a-permutation-in-an-observablelist-generate-added-and-removed-changes-in",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79822948,
    "question_id" : 79822646,
    "body" : "<h1>Change Types</h1>\n<p>Note that when a <a href=\"https://openjfx.io/javadoc/25/javafx.base/javafx/collections/ListChangeListener.Change.html\" rel=\"nofollow noreferrer\"><code>ListChangeListener.Change</code></a> reports elements were both added <em>and</em> removed, then that change is a &quot;replacement&quot; change. At least some elements that were removed were replaced by a new element (even if that new element was previously at a different position in the same list).</p>\n<p>A replacement change can be handled specially by checking if <a href=\"https://openjfx.io/javadoc/25/javafx.base/javafx/collections/ListChangeListener.Change.html#wasReplaced()\" rel=\"nofollow noreferrer\"><code>Change::wasReplaced()</code></a> returns true.</p>\n<hr />\n<h1>Expected Change Type</h1>\n<p>The documentation of <a href=\"https://openjfx.io/javadoc/25/javafx.base/javafx/collections/FXCollections.html#reverse(javafx.collections.ObservableList)\" rel=\"nofollow noreferrer\"><code>FXCollections::reverse(ObservableList)</code></a> says:</p>\n<blockquote>\n<p>Reverses the order in the list. Fires only <strong>one</strong> change notification on the list.</p>\n</blockquote>\n<p>The only stipulation is that <em>one</em> change event will be fired. It doesn't say what kind of change event will be fired. Though given the API of <a href=\"https://openjfx.io/javadoc/25/javafx.base/javafx/collections/ListChangeListener.Change.html\" rel=\"nofollow noreferrer\"><code>ListChangeListener.Change</code></a> there's really only two options. The event will either be a replacement change or a permutation change. Either change type would be a valid implementation, and <code>reverse</code> happens to be implemented in such a way that you get a replacement change.</p>\n<h2>Why not a Permutation Change?</h2>\n<p>The implementation of <code>reverse</code> is arguably the consequence of making it a static method of <code>FXCollections</code> instead of an instance method of <code>ObservableList</code>.</p>\n<p>The only way <code>reverse</code> has to interact with the <code>ObservableList</code> is via the API of <code>ObservableList</code>. Combine that with <code>reverse</code> guaranteeing only one change event will be fired plus <code>ObservableList</code> not providing a way to fire events from the &quot;outside&quot;, and the choice of implementation becomes rather limited. You can't call methods of <code>ObservableList</code> that might unduly fire change events and you have no way to explicitly fire a permutation change event. In fact, you really only have one choice that behaves the same regardless of implementation, and that's how the method is <a href=\"https://github.com/openjdk/jfx/blob/master/modules/javafx.base/src/main/java/javafx/collections/FXCollections.java#L586\" rel=\"nofollow noreferrer\">currently implemented</a>:</p>\n<blockquote>\n<pre class=\"lang-java prettyprint-override\"><code>@SuppressWarnings(&quot;unchecked&quot;)\npublic static void reverse(ObservableList list) {\n    Object[] newContent = list.toArray();\n    for (int i = 0; i &lt; newContent.length / 2; ++i) {\n        Object tmp = newContent[i];\n        newContent[i] = newContent[newContent.length - i - 1];\n        newContent[newContent.length -i - 1] = tmp;\n    }\n    list.setAll(newContent);\n}\n</code></pre>\n</blockquote>\n<p>The method extracts the elements into an array, reverses the array, then sets the list's elements to the array via <code>setAll</code>. That final step is where the replacement change comes from. Though note that seems to be relying on implementation details of <a href=\"https://openjfx.io/javadoc/25/javafx.base/javafx/collections/ObservableList.html#setAll(E...)\" rel=\"nofollow noreferrer\"><code>ObservableList::setAll(Object...)</code></a>, whose documentation says:</p>\n<blockquote>\n<p>Clears the ObservableList and adds all the elements passed as var-args.</p>\n</blockquote>\n<p>There's no guarantee that <code>setAll</code> will only fire one change event. The standard implementations<sup><strong>1</strong></sup> fire a single replacement change, but I believe it would be legal for an implementation to fire a separate &quot;remove&quot; and &quot;add&quot; change (clear the list, fire remove change, add the elements, fire add change)<sup><strong>3</strong></sup>. Maybe I'm wrong here.</p>\n<h2>Then Why Sorting Gives a Permutation Change?</h2>\n<p>The <code>List::sort(Comparator)</code> method is an instance method inherited by <code>ObservableList</code>. This means the implementation has more control over what kind of change event it fires. It also means the implementation has direct access to the underlying data structure, giving it more freedom to do things which won't cause undue change events to be fired.</p>\n<p>That said, the standard implementations of <code>ObservableList</code><sup><strong>1</strong></sup> are simple wrappers around a <code>List</code>. So currently they still end up extracting the elements into an array. The array is sorted (via a merge sort) while keeping track of the index changes. Then the backing <code>List</code> has its elements set from the sorted array (setting the elements doesn't go through the <code>ObservableList</code> so no change events are fired). Finally, a permutation change is fired with the appropriate <code>int[]</code>.</p>\n<p><strong>However</strong>, be aware that the <code>ObservableList</code> interface does <em>not</em> guarantee that calling the instance <code>sort</code> method will result in a permutation change event being fired, let alone that only one change event will be fired<sup><strong>4</strong></sup>. If you want to guarantee a single change event then use one of the two <code>FXCollections::sort</code> static methods. But there's no way to <em>guarantee</em> the change event will be a permutation change. Currently, for standard implementations of <code>ObservableList</code>, you'll get a permutation change event whether you sort via <code>List::sort</code> or via <code>FXCollections::sort</code>. For non-standard implementations you'll get a <em>replacement</em> change for the latter method<sup><strong>2</strong></sup>; it depends on the implementation for the former method.</p>\n<hr />\n<p><sup><strong>1.</strong> The instances returned by the <code>FXCollections::observable[Array]List</code> static factory methods are the &quot;standard implementations&quot; of <code>ObservableList</code>.</sup></p>\n<p><sup><strong>2.</strong> For <code>FXCollections::sort</code>, the difference is whether or not the <code>ObservableList</code> is also an instance of the internal <a href=\"https://github.com/openjdk/jfx/blob/master/modules/javafx.base/src/main/java/com/sun/javafx/collections/SortableList.java\" rel=\"nofollow noreferrer\"><code>SortableList</code></a> interface. Technically, a non-standard implementation could implement that interface. Though again, that doesn't guarantee anything about the <em>type</em> of change event fired. Additionally, if the list is not a <code>SortableList</code> then the implementation copies the list, sorts the copy, then sets the elements of the original list via <code>setAll</code>, similar to <code>reverse</code>. Thus, the &quot;single replacement change&quot; again seems dependent on implementation details of <code>setAll</code>.</sup></p>\n<p><sup><strong>3.</strong> I would find it very odd if an implementation fired more than one event from <code>setAll</code>, at least when the number of &quot;added&quot; elements equals the number of &quot;removed&quot; elements.</sup></p>\n<p><sup><strong>4.</strong> I struggle to imagine a legitimate scenario where <code>sort</code> would fire more than one event.</sup></p>\n",
    "score" : 6,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49884,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1763433453,
    "last_activity_date" : 1763453264,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79822685,
    "question_id" : 79822646,
    "body" : "<p><a href=\"https://hg.openjdk.org/openjfx/8/master/rt/log?rev=FXCollection\" rel=\"noreferrer\">According to the source code,</a> it looks like the FXCollections.reverse() method actually takes items from the source array and inserts them into a new array:</p>\n<pre><code>    public static void reverse(ObservableList list) {\n        Object[] newContent = list.toArray();\n        for (int i = 0; i &lt; newContent.length / 2; ++i) {\n            Object tmp = newContent[i];\n            newContent[i] = newContent[newContent.length - i - 1];\n            newContent[newContent.length -i - 1] = tmp;\n        }\n        list.setAll(newContent);\n    }\n</code></pre>\n<p><a href=\"https://docs.oracle.com/javase/8/javafx/api/javafx/collections/ObservableList.html#setAll-java.util.Collection-\" rel=\"noreferrer\">The setAll() method</a> is clearing the list and readding elements, so I think the behavior you are experiencing is the intended design.</p>\n<p>The method is distinct from <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#reverseOrder--\" rel=\"noreferrer\">the reverseOrder() comparator,</a> which doesn't seem to actually add/remove items.</p>\n",
    "score" : 5,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 20683840,
      "reputation" : 301,
      "user_id" : 15186748,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/62226406d7bbded226606ef7798f6523?s=256&d=identicon&r=PG",
      "display_name" : "mole1000",
      "link" : "https://stackoverflow.com/users/15186748/mole1000"
    },
    "creation_date" : 1763406827,
    "last_activity_date" : 1763406827,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140860753,
    "post_id" : 79822646,
    "body" : "I&#39;m sure you are aware of this, but it may be worth pointing out explicitly that the functionality of these two method calls is not the same in general. (One orders the elements in the reverse of the <i>current</i> order, the other orders elements in the reverse of the <i>natural</i> order.)",
    "score" : 2,
    "owner" : {
      "account_id" : 2518243,
      "reputation" : 210906,
      "user_id" : 2189127,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
      "display_name" : "James_D",
      "link" : "https://stackoverflow.com/users/2189127/james-d"
    },
    "creation_date" : 1763485139,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140858987,
    "post_id" : 79822646,
    "body" : "The API spec doesn&#39;t state conditions under which a permutation change must be fired, so it&#39;s not technically a bug. I agree that I would intuitively expect this to fire a permutation change, not a &quot;replaced&quot; (added+removed) change. To be robust, you should test for both (handling the &quot;permutated&quot; case is probably the more efficient path).",
    "score" : 5,
    "owner" : {
      "account_id" : 2518243,
      "reputation" : 210906,
      "user_id" : 2189127,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
      "display_name" : "James_D",
      "link" : "https://stackoverflow.com/users/2189127/james-d"
    },
    "creation_date" : 1763407118,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}