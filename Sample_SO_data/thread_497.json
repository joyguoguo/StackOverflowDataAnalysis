{
  "question" : {
    "question_id" : 79799286,
    "title" : "How does Spring JPA “instantiate” the interfaces that extends repositories?",
    "body" : "<p>I'm delving into Java concepts such as dynamic proxies, reflection, etc. That's why I'm trying to implement some Spring features. Anyway...</p>\n<p>I created the dynamic proxy:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Override\npublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n    if (method.isAnnotationPresent(Query.class)) {\n        System.out.println(&quot;It's a query!&quot;);\n    } else {\n        System.out.println(&quot;Not a query!&quot;);\n    }\n\n    Object result = method.invoke(repository, args);\n    System.out.println(&quot;After &quot; + method.getName() + &quot; is called&quot;);\n    return result;\n}\n</code></pre>\n<p>And extended my ApplicationContext:</p>\n<pre class=\"lang-java prettyprint-override\"><code>if (CrudRepository.class.isAssignableFrom(node.type)) {\n    Class&lt;?&gt;[] interfaces = node.type.getInterfaces().length &gt; 0\n            ? node.type.getInterfaces()\n            : new Class&lt;?&gt;[]{ node.type };\n\n    InvocationHandler handler = new CrudInvocationHandler((CrudRepository&lt;?, ?&gt;) bean);\n    bean = Proxy.newProxyInstance(\n            node.type.getClassLoader(),\n            interfaces,\n            handler\n    );\n}\n</code></pre>\n<p>Then I realized that in my configuration class, I need to return an existing class:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Bean\npublic UserRepository userRepository() {\n    return new UserRepository();\n}\n</code></pre>\n<p>So, at this point, I'm stuck. How does Spring JPA handle these things?</p>\n<p>How is it able to return a proxy instance for a repository interface (like UserRepository) even though there’s no actual implementation class?</p>\n",
    "tags" : [ "java", "spring", "spring-data-jpa", "spring-data" ],
    "owner" : {
      "account_id" : 26568716,
      "reputation" : 11,
      "user_id" : 20195288,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/a2d1340c37fed2593656142d552d5798?s=256&d=identicon&r=PG",
      "display_name" : "kitt51",
      "link" : "https://stackoverflow.com/users/20195288/kitt51"
    },
    "is_answered" : true,
    "view_count" : 166,
    "answer_count" : 1,
    "score" : 2,
    "last_activity_date" : 1761402374,
    "creation_date" : 1761358204,
    "link" : "https://stackoverflow.com/questions/79799286/how-does-spring-jpa-instantiate-the-interfaces-that-extends-repositories",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79799522,
    "question_id" : 79799286,
    "body" : "<blockquote>\n<p>How is it able to return a proxy instance for a repository interface (like UserRepository) even though there’s no actual implementation class?</p>\n</blockquote>\n<p>Your statement &quot;even there's no actual implementation&quot; is only partly true regarding JPA, but more to this below.</p>\n<p>In general, given, that your example <code>UserRepository</code> would be an interface and not a class, you can provide a proxy without having a concrete class implementing that interface. Something like would be valid:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Bean\npublic UserRepository userRepository() {\n    return (UserRepository) Proxy.newProxyInstance(...);\n}\n</code></pre>\n<blockquote>\n<p>How does Spring JPA handle these things?</p>\n</blockquote>\n<p>Spring (Data) JPA uses Spring AOP to achieve this.</p>\n<p>It provides an implementation of <code>JpaRepository</code> and wraps it with a proxy using Spring AOP to add the remaining functionality from your repository interface (it could theoretically also use the Java proxy or Cglib for this). How the remaining methods in the interface look like, what they should provide, it gathers through reflection.</p>\n<p>In detail:</p>\n<p>On application start up it scans the class path for repositories and registers a bean factory for each repository bean name. The bean factory then creates an instance of <code>org.springframework.data.jpa.repository.support.SimpleJpaRepository</code> (in most cases) and wraps it with <code>org.springframework.aop.framework.ProxyFactory</code> to add additional functionality.</p>\n<p>You find the corresponding source in <code>org.springframework.data.repository.core.support.RepositoryFactorySupport.getRepository(...)</code>, which essentially contains:</p>\n<pre class=\"lang-java prettyprint-override\"><code>// &quot;target&quot; here is an instance of JpaRepositoryImplementation\n//     for example SimpleJpaRepository\n// &quot;repositoryInterface&quot; is the class of your repository interface\n\nProxyFactory result = new ProxyFactory();\nresult.setTarget(target);\nresult.setInterfaces(repositoryInterface, Repository.class, TransactionalProxy.class);\n\n// configure the proxy with result.addAdvice(...) and result.addAdvisor(...)\n// for example to handle &quot;default&quot; methods of your interface:\nresult.addAdvice(new DefaultMethodInvokingMethodInterceptor());\n\nreturn repository;\n</code></pre>\n<p>And in case you wonder how the bean factories are registered: It is achieved by an implementation of <code>org.springframework.context.annotation.ImportBeanDefinitionRegistrar</code>, which is basically wired up with <code>@EnableJpaRepositories</code> as well as with the <code>org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration</code> through   <code>JpaRepositoriesImportSelector</code> :</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Import(JpaRepositoriesRegistrar.class)\npublic @interface EnableJpaRepositories {\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>@Import(JpaRepositoriesImportSelector.class)\npublic class JpaRepositoriesAutoConfiguration {\n</code></pre>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 21851467,
      "reputation" : 974,
      "user_id" : 16143492,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/PMrGU.png?s=256",
      "display_name" : "nineninesevenfour",
      "link" : "https://stackoverflow.com/users/16143492/nineninesevenfour"
    },
    "creation_date" : 1761398519,
    "last_activity_date" : 1761402294,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140816791,
    "post_id" : 79799286,
    "body" : "I&#39;m not sure it&#39;s how Spring does it, but <i>you</i> can use <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/reflect/Proxy.html\" rel=\"nofollow noreferrer\"><code>java.lang.reflect.Proxy</code></a> to do it.",
    "score" : 0,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1761399984,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79799522" : [ {
      "comment_id" : 140816833,
      "post_id" : 79799522,
      "body" : "@JohnBollinger updated the answer, please review again. Thx!",
      "score" : 0,
      "owner" : {
        "account_id" : 21851467,
        "reputation" : 974,
        "user_id" : 16143492,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/PMrGU.png?s=256",
        "display_name" : "nineninesevenfour",
        "link" : "https://stackoverflow.com/users/16143492/nineninesevenfour"
      },
      "creation_date" : 1761402019,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140816811,
      "post_id" : 79799522,
      "body" : "@JohnBollinger Actually there are multiple question, I answered to &quot;How does Spring JPA handle these things?&quot;, but there was a second question &quot;How is it able to return a proxy instance for a repository interface ... even though there’s no actual implementation class?&quot;, which I left unanswered, I agree.",
      "score" : 0,
      "owner" : {
        "account_id" : 21851467,
        "reputation" : 974,
        "user_id" : 16143492,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/PMrGU.png?s=256",
        "display_name" : "nineninesevenfour",
        "link" : "https://stackoverflow.com/users/16143492/nineninesevenfour"
      },
      "creation_date" : 1761400944,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140816790,
      "post_id" : 79799522,
      "body" : "I think the question is how Spring produces an instance of a class implementing interface <code>MyRepository</code> without having one specified to it or built in.  That it it uses AoP goes a little way in that direction, but this answer seems largely to be saying just &quot;Spring has a class for that&quot;.",
      "score" : 0,
      "owner" : {
        "account_id" : 2792262,
        "reputation" : 190832,
        "user_id" : 2402272,
        "user_type" : "registered",
        "accept_rate" : 85,
        "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
        "display_name" : "John Bollinger",
        "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
      },
      "creation_date" : 1761399878,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}