{
  "question" : {
    "question_id" : 79567260,
    "title" : "docker-java exec PTY stream terminates immediately (IOException: Connection aborted / Pipe has been terminated) on Windows + WSL 2",
    "body" : "<p>I'm encountering a persistent issue using docker-java on Windows 11 with Docker Desktop (WSL 2 backend) where interactive PTY streams created via execStartCmd terminate almost immediately after starting.</p>\n<p>Environment:</p>\n<p>OS: Windows 11 Home 24H2\nDocker: Docker Desktop 4.40.0 using WSL 2 backend (Ubuntu 2)\nJava: JDK 17.0.11\ndocker-java Version: Tested with 3.3.6, 3.4.0, 3.5.0\nTransport: docker-java-transport-httpclient5 (Issue persists across tested docker-java versions with this transport. Netty transport failed to resolve via Maven).\nDocker Host URI (Detected by docker-java): npipe:////./pipe/dockerDesktopLinuxEngine\nProblem Description:</p>\n<p>When attempting to create an interactive terminal session using dockerClient.execCreateCmd(...).withTty(true).withAttachStdin(true)... followed by dockerClient.execStartCmd(...).exec(callback), the following happens:</p>\n<p>The initial connection to the Docker daemon works (e.g., pingCmd succeeds).\nThe exec instance is created successfully.\nThe ResultCallback.Adapter receives the onStart event.\nThe callback typically receives one or two onNext events containing the initial shell prompt data (e.g., #).\nImmediately after receiving these first few bytes, the connection is abruptly terminated. The onError callback is invoked with either:\njava.io.IOException: An established connection was aborted by the software in your host computer (when running within my main Spring Boot application using WebSockets to forward the stream)\njava.io.IOException: java.io.IOException: Denna pipe har avslutats (This pipe has been terminated) (when running the minimal reproducible example below).\nThis happens consistently across the tested docker-java versions when using the httpclient5 transport. Manual docker exec -it  sh commands from the host terminal work perfectly fine.</p>\n<p>Minimal Reproducible Example (DockerTest.java):</p>\n<pre><code>package com.example.test;\n\nimport com.github.dockerjava.api.DockerClient;\nimport com.github.dockerjava.api.async.ResultCallback;\nimport com.github.dockerjava.api.command.CreateContainerResponse;\nimport com.github.dockerjava.api.command.ExecCreateCmdResponse;\nimport com.github.dockerjava.api.model.Frame;\nimport com.github.dockerjava.api.model.HostConfig;\nimport com.github.dockerjava.core.DefaultDockerClientConfig;\nimport com.github.dockerjava.core.DockerClientConfig;\nimport com.github.dockerjava.core.DockerClientImpl;\nimport com.github.dockerjava.httpclient5.ApacheDockerHttpClient;\nimport com.github.dockerjava.transport.DockerHttpClient;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.PipedInputStream;\nimport java.io.PipedOutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\n\npublic class DockerTest {\n\n    private static final Logger logger = LoggerFactory.getLogger(DockerTest.class);\n\n    public static void main(String[] args) {\n        DockerClient dockerClient = null;\n        String containerId = null;\n        PipedOutputStream ptyStdin = null; // For potential input later\n        PipedInputStream ptyStdinPipe = null; // For potential input later\n\n        try {\n            // --- 1. Initialize Docker Client ---\n            logger.info(&quot;Attempting to initialize Docker client using default host detection...&quot;);\n            DockerClientConfig config = DefaultDockerClientConfig.createDefaultConfigBuilder().build();\n            logger.info(&quot;DockerClientConfig resolved DOCKER_HOST to: {}&quot;, config.getDockerHost());\n\n            DockerHttpClient httpClient = new ApacheDockerHttpClient.Builder()\n                    .dockerHost(config.getDockerHost())\n                    .sslConfig(config.getSSLConfig())\n                    .connectionTimeout(Duration.ofSeconds(30))\n                    .responseTimeout(Duration.ofSeconds(45))\n                    .build();\n\n            dockerClient = DockerClientImpl.getInstance(config, httpClient);\n            logger.info(&quot;Pinging Docker daemon...&quot;);\n            dockerClient.pingCmd().exec();\n            logger.info(&quot;Docker Ping Successful!&quot;);\n\n            // --- 2. Create and Start a Simple Container ---\n            String imageName = &quot;ubuntu:latest&quot;; // Use a simple image\n             logger.info(&quot;Pulling image {} if not present...&quot;, imageName);\n             try {\n                 dockerClient.inspectImageCmd(imageName).exec();\n                 logger.info(&quot;Image {} already present.&quot;, imageName);\n             } catch (Exception e) { // Catch generic Exception as NotFoundException might not be the only cause\n                 logger.info(&quot;Image {} not found or error inspecting, pulling...&quot;, imageName);\n                 dockerClient.pullImageCmd(imageName).start().awaitCompletion();\n                 logger.info(&quot;Image {} pulled.&quot;, imageName);\n             }\n\n\n            logger.info(&quot;Creating container from image {}...&quot;, imageName);\n            HostConfig hostConfig = HostConfig.newHostConfig().withNetworkMode(&quot;none&quot;); // No network needed\n            CreateContainerResponse container = dockerClient.createContainerCmd(imageName)\n                    .withHostConfig(hostConfig)\n                    .withCmd(&quot;sleep&quot;, &quot;infinity&quot;) // Keep container running\n                    .withTty(true) // Keep TTY for potential exec later\n                    .withAttachStdin(false) // Stdin attached later via exec\n                    .withAttachStdout(true)\n                    .withAttachStderr(true)\n                    .exec();\n            containerId = container.getId();\n            logger.info(&quot;Created container: {}&quot;, containerId);\n\n            dockerClient.startContainerCmd(containerId).exec();\n            logger.info(&quot;Started container: {}&quot;, containerId);\n\n            // --- 3. Create Exec Instance (Shell) ---\n            logger.info(&quot;Creating exec instance in container {}...&quot;, containerId);\n            ExecCreateCmdResponse execCreateResponse = dockerClient.execCreateCmd(containerId)\n                    .withAttachStdout(true)\n                    .withAttachStderr(true)\n                    .withAttachStdin(true) // Attach stdin\n                    .withTty(true) // Allocate TTY\n                    .withCmd(&quot;sh&quot;, &quot;-i&quot;) // Interactive shell\n                    .exec();\n            String execId = execCreateResponse.getId();\n            logger.info(&quot;Created exec instance: {}&quot;, execId);\n\n            // --- 4. Start Exec and Attach Streams ---\n            // Setup pipes for stdin\n            ptyStdin = new PipedOutputStream();\n            ptyStdinPipe = new PipedInputStream(ptyStdin);\n\n            logger.info(&quot;Starting exec instance {} and attaching streams...&quot;, execId);\n\n            // Create final references for use in the inner class\n            final PipedInputStream finalPtyStdinPipe = ptyStdinPipe;\n            final PipedOutputStream finalPtyStdin = ptyStdin;\n\n            ResultCallback.Adapter&lt;Frame&gt; callback = new ResultCallback.Adapter&lt;Frame&gt;() {\n                @Override\n                public void onStart(Closeable closeable) {\n                    logger.info(&quot;[EXEC CALLBACK] onStart&quot;);\n                }\n\n                @Override\n                public void onNext(Frame frame) {\n                    logger.info(&quot;[EXEC CALLBACK] onNext: Type={}, Payload={}&quot;,\n                            frame.getStreamType(),\n                            new String(frame.getPayload(), StandardCharsets.UTF_8).trim());\n                    // Simulate the point where the original error occurred\n                    // If the connection aborts shortly after this log, it matches the pattern\n                }\n\n                @Override\n                public void onError(Throwable throwable) {\n                    logger.error(&quot;[EXEC CALLBACK] onError:&quot;, throwable);\n                }\n\n                @Override\n                public void onComplete() {\n                    logger.info(&quot;[EXEC CALLBACK] onComplete&quot;);\n                }\n\n                @Override\n                public void close() throws IOException {\n                     logger.info(&quot;[EXEC CALLBACK] close&quot;);\n                     if (finalPtyStdinPipe != null) finalPtyStdinPipe.close(); // Use final reference\n                     if (finalPtyStdin != null) finalPtyStdin.close(); // Use final reference\n                }\n            };\n\n            // Start the exec command\n            dockerClient.execStartCmd(execId)\n                    .withDetach(false)\n                    .withTty(true)\n                    .withStdIn(ptyStdinPipe) // Attach the input stream\n                    .exec(callback);\n\n            logger.info(&quot;Exec instance started. Waiting for callback events...&quot;);\n\n            // Keep the main thread alive briefly to see callbacks\n            Thread.sleep(15000); // Wait 15 seconds\n\n            logger.info(&quot;Minimal test finished waiting.&quot;);\n\n\n        } catch (Exception e) {\n            logger.error(&quot;An error occurred during the test:&quot;, e);\n        } finally {\n            // --- 5. Cleanup ---\n            logger.info(&quot;Starting cleanup...&quot;);\n            // Close streams using original variables (which might be null if setup failed)\n            if (ptyStdin != null) try { ptyStdin.close(); } catch (IOException e) { /* ignore */ }\n            if (ptyStdinPipe != null) try { ptyStdinPipe.close(); } catch (IOException e) { /* ignore */ }\n\n            if (dockerClient != null) {\n                if (containerId != null) {\n                    try {\n                        logger.info(&quot;Stopping container {}...&quot;, containerId);\n                        dockerClient.stopContainerCmd(containerId).withTimeout(5).exec();\n                    } catch (Exception e) {\n                        logger.warn(&quot;Error stopping container {}: {}&quot;, containerId, e.getMessage());\n                    }\n                    try {\n                        logger.info(&quot;Removing container {}...&quot;, containerId);\n                        dockerClient.removeContainerCmd(containerId).withForce(true).exec();\n                    } catch (Exception e) {\n                        logger.warn(&quot;Error removing container {}: {}&quot;, containerId, e.getMessage());\n                    }\n                }\n                try {\n                    logger.info(&quot;Closing Docker client...&quot;);\n                    dockerClient.close();\n                } catch (IOException e) {\n                    logger.error(&quot;Error closing Docker client:&quot;, e);\n                }\n            }\n            logger.info(&quot;Cleanup finished.&quot;);\n        }\n    }\n\n}\n</code></pre>\n<p>Relevant Logs from Minimal Test:</p>\n<blockquote>\n<p>[docker-java-stream-...] INFO com.example.test.DockerTest - [EXEC\nCALLBACK] onStart [docker-java-stream-...] INFO\ncom.example.test.DockerTest - [EXEC CALLBACK] onNext: Type=RAW,\nPayload=# [docker-java-stream-...] INFO com.example.test.DockerTest -\n[EXEC CALLBACK] onNext: Type=RAW, Payload= [docker-java-stream-...]\nERROR com.example.test.DockerTest - [EXEC CALLBACK] onError:\njava.io.IOException: java.io.IOException: Denna pipe har avslutats\nat java.base/java.nio.channels.Channels$2.read(Channels.java:240)\nat org.apache.hc.core5.http.impl.io.SessionInputBufferImpl.read(SessionInputBufferImpl.java:195)\n... (stack trace continues) ... Caused by: java.io.IOException: Denna pipe har avslutats\nat java.base/sun.nio.ch.Iocp.translateErrorToIOException(Iocp.java:299)\n... (stack trace continues) ... [docker-java-stream-...] INFO com.example.test.DockerTest - [EXEC CALLBACK] onComplete</p>\n</blockquote>\n<p>Troubleshooting Steps Taken:</p>\n<p>Created the minimal reproducible example above.\nTested docker-java versions 3.3.6, 3.4.0, and 3.5.0 with the httpclient5 transport â€“ the PTY stream error persists.\nAttempted to use the netty transport, but encountered Maven dependency resolution issues preventing its download.\nReinstalled Docker Desktop.\nEnsured WSL 2 integration is enabled for the default distro (Ubuntu).\nDisabled Windows Defender Firewall and all third-party antivirus software.\nTried connecting via the default named pipe (npipe:////./pipe/dockerDesktopLinuxEngine) and explicitly via tcp://localhost:2375 (after enabling insecure TCP exposure in Docker Desktop). While TCP allowed the initial pingCmd to succeed when the named pipe failed, the subsequent PTY stream still failed with the &quot;Connection aborted&quot; error. TCP exposure has since been disabled.</p>\n<p>Expected Behavior:</p>\n<p>The execStartCmd callback should remain active, receiving further output from the container's shell. It should only call onComplete or close when the shell process inside the container exits or the Closeable from onStart is closed.</p>\n<p>Actual Behavior:</p>\n<p>The connection underlying the PTY stream is terminated by the host system almost immediately after the stream starts, triggering onError.</p>\n<p>Question:</p>\n<p>Has anyone encountered similar PTY stream termination issues with docker-java (specifically the httpclient5 transport) on Windows with WSL 2? Is this a known incompatibility, or are there other potential environmental factors or configurations I should investigate?</p>\n",
    "tags" : [ "java", "docker", "docker-exec" ],
    "owner" : {
      "account_id" : 28269319,
      "reputation" : 1,
      "user_id" : 21612770,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d3334df2207eea7d5944c5fe592f0872?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "ha33an",
      "link" : "https://stackoverflow.com/users/21612770/ha33an"
    },
    "is_answered" : false,
    "view_count" : 54,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1744306983,
    "creation_date" : 1744306394,
    "link" : "https://stackoverflow.com/questions/79567260/docker-java-exec-pty-stream-terminates-immediately-ioexception-connection-abor",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ ],
  "answer_comments" : { }
}