{
  "question" : {
    "question_id" : 79754611,
    "title" : "Spring Boot own token authenticator not working",
    "body" : "<p>I have a Spring Boot application in which a want to use a token (stored in a database table) for authentication. I added an own filter and authentication provider but the provider isn't used. Why is this the case?</p>\n<p>My code:</p>\n<p>SecurityConfig.java</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n  private final TokenAuthenticationProvider tokenAuthenticationProvider;\n\n  public SecurityConfig(\n    TokenAuthenticationProvider tokenAuthenticationProvider\n  ) {\n    this.tokenAuthenticationProvider = tokenAuthenticationProvider;\n  }\n\n  @Bean\n  public SecurityFilterChain filterChain(HttpSecurity security) throws Exception {\n\n    security\n      .csrf(AbstractHttpConfigurer::disable)\n      .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n      .authorizeHttpRequests(authorize -&gt; authorize.anyRequest().authenticated())\n      .addFilterAfter(new TokenAuthFilter(), LogoutFilter.class)\n      .authenticationProvider(tokenAuthenticationProvider);\n\n    return security.build();\n  }\n\n}\n</code></pre>\n<p>TokenAuthenticationProvider.java</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Component\npublic class TokenAuthenticationProvider implements AuthenticationProvider {\n\n  private final TokenRepository tokenRepository;\n\n  public TokenAuthenticationProvider(TokenRepository tokenRepository) {\n    this.tokenRepository = tokenRepository;\n  }\n\n  @Override\n  public Authentication authenticate(Authentication authentication) throws \n    // TODO\n  }\n\n  @Override\n  public boolean supports(Class&lt;?&gt; authentication) {\n    return authentication.equals(TokenAuthenticationToken.class);\n  }\n\n\n}\n\n</code></pre>\n<p>TokenAuthenticationToken.java</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class TokenAuthenticationToken extends AbstractAuthenticationToken {\n  \n  private final String token;\n  private final Long namespace;\n\n  private TokenAuthenticationToken(String token, Long namespace, Boolean authenticated) {\n    super(Collections.emptyList());\n    this.token = token;\n    this.namespace = namespace;\n  }\n\n  public static TokenAuthenticationToken unauthenticated(String token) {\n    return new TokenAuthenticationToken(token, null, false);\n  }\n\n  public static TokenAuthenticationToken authenticated(String token, Long namespace) {\n    return new TokenAuthenticationToken(token, namespace, true);\n  }\n\n  @Override\n  public Object getCredentials() {\n    return this.token;\n  }\n\n  @Override\n  public Object getPrincipal() {\n    return this.namespace;\n  }\n\n}\n</code></pre>\n<p>TokenAuthFilter.java</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class TokenAuthFilter extends OncePerRequestFilter {\n\n  private final static String AUTH_HEADER_METHOD = &quot;APIToken&quot;;\n  private final static String AUTH_HEADER_PARAM = &quot;Token&quot;;\n\n  @Override\n  protected void doFilterInternal(\n    @NonNull HttpServletRequest request, \n    @NonNull HttpServletResponse response, \n    @NonNull FilterChain filterChain\n  ) throws ServletException, IOException {\n\n    String authHeader = request.getHeader(&quot;Authorization&quot;);\n    if (authHeader != null) {\n      String[] headerParts = authHeader.split(&quot;=&quot;);\n      if (headerParts.length != 2 || !headerParts[0].equals(AUTH_HEADER_METHOD+&quot; &quot;+AUTH_HEADER_PARAM)) {\n        response.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n        return;\n      }\n      Authentication auth = TokenAuthenticationToken.unauthenticated(headerParts[1]);\n      SecurityContextHolder.getContext().setAuthentication(auth);\n    }\n\n    filterChain.doFilter(request, response);\n  }\n\n}\n</code></pre>\n<p>Is this even the best way to implement this? I also tried to use a UsernamePasswordAuthenticationToken in my filter for the DaoAuthenticationProvider to handle it and load the token via a user details service, but this wasn't working too.</p>\n",
    "tags" : [ "java", "spring", "spring-boot", "spring-security" ],
    "owner" : {
      "account_id" : 481264,
      "reputation" : 2980,
      "user_id" : 894982,
      "user_type" : "registered",
      "accept_rate" : 79,
      "profile_image" : "https://www.gravatar.com/avatar/2c032f96340ca6a29958a6f0525454e7?s=256&d=identicon&r=PG",
      "display_name" : "Johni",
      "link" : "https://stackoverflow.com/users/894982/johni"
    },
    "is_answered" : false,
    "view_count" : 59,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1756903694,
    "creation_date" : 1756903694,
    "link" : "https://stackoverflow.com/questions/79754611/spring-boot-own-token-authenticator-not-working",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140712027,
    "post_id" : 79754611,
    "body" : "I think I will try to use the <code>AbstractAuthenticationProcessingFilter</code>.",
    "score" : 0,
    "owner" : {
      "account_id" : 481264,
      "reputation" : 2980,
      "user_id" : 894982,
      "user_type" : "registered",
      "accept_rate" : 79,
      "profile_image" : "https://www.gravatar.com/avatar/2c032f96340ca6a29958a6f0525454e7?s=256&d=identicon&r=PG",
      "display_name" : "Johni",
      "link" : "https://stackoverflow.com/users/894982/johni"
    },
    "creation_date" : 1756907921,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140712007,
    "post_id" : 79754611,
    "body" : "Another option could be to extend the <code>AbstractPreAuthenticationProcessingFilter</code> and implement an <code>AuthenticationUserDetailsService</code> which handles the <code>PreAuthenticationToken</code> which will then load the necessary information to construct an fully authenticated user.",
    "score" : 0,
    "owner" : {
      "account_id" : 3192259,
      "reputation" : 126777,
      "user_id" : 2696260,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/qHEzx.png?s=256",
      "display_name" : "M. Deinum",
      "link" : "https://stackoverflow.com/users/2696260/m-deinum"
    },
    "creation_date" : 1756907537,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140711992,
    "post_id" : 79754611,
    "body" : "You could but that wouldn&#39;t really be as how Spring Security is supposed to work. I would suggest to let your filter extend the <code>AbstractAuthenticationProcessingFilter</code> and implement the <code>attemptAuthentication</code> method (see the <code>UsernamePasswordAuthenticationFilter</code> for an example). This will integrate nicely with Sprng Security (through events etc.) and you can still have your dedicated <code>AuthenticationProvider</code>. Separating separate roles nicely.",
    "score" : 0,
    "owner" : {
      "account_id" : 3192259,
      "reputation" : 126777,
      "user_id" : 2696260,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/qHEzx.png?s=256",
      "display_name" : "M. Deinum",
      "link" : "https://stackoverflow.com/users/2696260/m-deinum"
    },
    "creation_date" : 1756907269,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140711957,
    "post_id" : 79754611,
    "body" : "Ok, I see. I thought the AuthenticationManager will be called by spring boot automatically.  So I have to use the AuthenticationManagerResolver to get an instance of the AuthenticationManager and pass it my AbstractAuthenticationToken in which case I think it would be better to ditch the Provider and do all the authentication in the filter, since I only have REST endpoints. Is this assumtion right?",
    "score" : 0,
    "owner" : {
      "account_id" : 481264,
      "reputation" : 2980,
      "user_id" : 894982,
      "user_type" : "registered",
      "accept_rate" : 79,
      "profile_image" : "https://www.gravatar.com/avatar/2c032f96340ca6a29958a6f0525454e7?s=256&d=identicon&r=PG",
      "display_name" : "Johni",
      "link" : "https://stackoverflow.com/users/894982/johni"
    },
    "creation_date" : 1756906599,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140711876,
    "post_id" : 79754611,
    "body" : "Why should it work? Your authentication provider doesn&#39;t do anything, your filter only produces an unauthenticated token en passes is to the security context holder. Your <code>TokenAuthFilter</code> should call the <code>AuthenticationManager</code> which will lookup your <code>AuthenticationProvider</code> which should handle the authentication. The result of the authentication should be stored.",
    "score" : 0,
    "owner" : {
      "account_id" : 3192259,
      "reputation" : 126777,
      "user_id" : 2696260,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/qHEzx.png?s=256",
      "display_name" : "M. Deinum",
      "link" : "https://stackoverflow.com/users/2696260/m-deinum"
    },
    "creation_date" : 1756904714,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}