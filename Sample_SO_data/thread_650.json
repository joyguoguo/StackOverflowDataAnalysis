{
  "question" : {
    "question_id" : 79786299,
    "title" : "jOOQ removes SQL inside ignore comments during execution",
    "body" : "<p>I'm using jOOQ with PostgreSQL and want to execute a query with an EXPLAIN (ANALYZE, FORMAT JSON) prefix.</p>\n<p>I set the parser settings to ignore comments:</p>\n<pre><code>Settings settings = new Settings()\n                .withParseDialect(SQLDialect.ORACLE)\n                .withParseUnknownFunctions(ParseUnknownFunctions.IGNORE)\n                .withTransformTableListsToAnsiJoin(true)\n                .withTransformUnneededArithmeticExpressions(TransformUnneededArithmeticExpressions.ALWAYS)\n                .withTransformRownum(Transformation.ALWAYS)\n                .withParamCastMode(ParamCastMode.DEFAULT)\n                .withRenderOptionalAsKeywordForFieldAliases(RenderOptionalKeyword.ON)\n                .withRenderOptionalAsKeywordForTableAliases(RenderOptionalKeyword.ON)\n                .withRenderQuotedNames(RenderQuotedNames.EXPLICIT_DEFAULT_UNQUOTED)\n                .withRenderNameCase(RenderNameCase.UPPER)\n                .withRenderCoalesceToEmptyStringInConcat(true)\n                .withBatchSize(DbConnectionHelper.MAX_BATCH_SIZE)\n                .withParseIgnoreComments(true)\n                ;\n        return settings;\n</code></pre>\n<p>Then I delimit the EXPLAIN clause like this:</p>\n<pre><code>String explainSql = &quot;&quot;&quot;\n    /* [jooq ignore start] */\n    EXPLAIN (ANALYZE, FORMAT JSON)\n    /* [jooq ignore stop] */\n&quot;&quot;&quot; + sql;\n\ntry (Statement stmt = conn.createStatement();\n     ResultSet rs = stmt.executeQuery(explainSql)) {\n    // process result\n}\n</code></pre>\n<p><strong>Issue:</strong></p>\n<p>jOOQ now ignores the EXPLAIN clause during parsing as expected, but it also removes it from the executed SQL.\nSo, the executed query no longer contains EXPLAIN (ANALYZE, FORMAT JSON) and fails to produce the plan.</p>\n<p><strong>I'm using:</strong></p>\n<ul>\n<li>jOOQ version: 3.19.6</li>\n<li>PostgreSQL 14</li>\n<li>JDBC (not via DSL fetch)</li>\n<li>Java 11</li>\n<li>Database source dialect: Oracle</li>\n<li>Destination dialect: PostgreSQL</li>\n</ul>\n<p><strong>Question:</strong></p>\n<p>Is there a way to make jOOQ <strong>ignore a part of SQL during parsing</strong> but <strong>keep it in the actual execution</strong>?</p>\n",
    "tags" : [ "java", "sql", "jooq", "sql-parser" ],
    "owner" : {
      "account_id" : 25917081,
      "reputation" : 59,
      "user_id" : 19640317,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/MOEOkdpB.jpg?s=256",
      "display_name" : "Raoua KHATERCHI",
      "link" : "https://stackoverflow.com/users/19640317/raoua-khaterchi"
    },
    "is_answered" : true,
    "view_count" : 104,
    "answer_count" : 1,
    "score" : 2,
    "last_activity_date" : 1760007116,
    "creation_date" : 1760006054,
    "link" : "https://stackoverflow.com/questions/79786299/jooq-removes-sql-inside-ignore-comments-during-execution",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79786310,
    "question_id" : 79786299,
    "body" : "<p>The <code>Settings.parseIgnoreComments</code> feature's purpose is for the jOOQ parser to skip sections of input SQL <em>entirely</em>, without keeping them around. The main reason why it was introduced is to be able to parse and interpret vendor specific DDL, e.g. when generating code only from DDL files using the <a href=\"https://www.jooq.org/doc/latest/manual/code-generation/codegen-meta-sources/codegen-ddl/\" rel=\"nofollow noreferrer\"><code>DDLDatabase</code></a>. In that case, maintaining these vendor-specific clauses is unnecessary for jOOQ, as jOOQ doesn't need them, and the DDL isn't being executed by jOOQ, normally.</p>\n<p>jOOQ doesn't have any model for maintaining input comment or whitespace as that would be very complicated to get right. For example, how would you represent a comment like this in jOOQ?</p>\n<pre class=\"lang-sql prettyprint-override\"><code>LEFT /* comment here */ JOIN\n</code></pre>\n<p>The amount of meta data that we'd have to keep around would be substantial. So far, this wasn't really useful in ordinary jOOQ contexts, as 99% of jOOQ users wouldn't need this feature set.</p>\n<p>There are feature requests that go into such a direction, including:</p>\n<ul>\n<li><a href=\"https://github.com/jOOQ/jOOQ/issues/8722\" rel=\"nofollow noreferrer\">#8722</a>: Maintaining whitespace, comments, and other non-essential meta data with parser output</li>\n<li><a href=\"https://github.com/jOOQ/jOOQ/issues/9260\" rel=\"nofollow noreferrer\">#9260</a>: Support plain SQL templates in the parser (though, these would be limited to well-known locations, e.g. everywhere a <code>Field</code> is reasonably expected. This wouldn't allow for arbitrary syntax to be maintained)</li>\n</ul>\n<p>Even if jOOQ would ever go into a direction where these very specialised, and rather rare parsing use-cases would be covered, I still think it wouldn't be the best approach to add simple <code>EXPLAIN</code> clauses to your output SQL, which can be done via one of jOOQ's many SPIs, for example:</p>\n<ul>\n<li><a href=\"https://www.jooq.org/doc/latest/manual/sql-building/dsl-context/custom-execute-listeners/\" rel=\"nofollow noreferrer\"><code>ExecuteListener</code></a>, if you're executing a jOOQ query via jOOQ API</li>\n<li><a href=\"https://www.jooq.org/doc/latest/manual/sql-building/queryparts/custom-sql-transformation/\" rel=\"nofollow noreferrer\"><code>VisitListener</code></a>, if you're using the <a href=\"https://www.jooq.org/doc/latest/manual/sql-execution/parsing-connection/\" rel=\"nofollow noreferrer\"><code>ParsingConnection</code></a> as it seems from your example</li>\n<li><a href=\"https://www.jooq.org/doc/latest/manual/sql-building/sql-parser/sql-parser-listener/\" rel=\"nofollow noreferrer\"><code>ParseListener</code></a> could intercept certain parse calls and handle this case for you. For example, you could remove the <code>EXPLAIN</code> syntax from the parse SQL string (but remember it in the <code>ParseContext</code>), parse the SQL, and re-add the SQL string in the rendered output in some way.</li>\n</ul>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 247217,
      "reputation" : 223532,
      "user_id" : 521799,
      "user_type" : "registered",
      "accept_rate" : 89,
      "profile_image" : "https://www.gravatar.com/avatar/eb96efa7a5664ba1c4ebf586abd4121f?s=256&d=identicon&r=PG",
      "display_name" : "Lukas Eder",
      "link" : "https://stackoverflow.com/users/521799/lukas-eder"
    },
    "creation_date" : 1760007116,
    "last_activity_date" : 1760007116,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79786310" : [ {
      "comment_id" : 140787948,
      "post_id" : 79786310,
      "body" : "@Raoua Thanks for your feedback. I just realised that the <code>ParseListener::parseEnd</code> event has no way to update the resulting parsed object. I assumed that this was the case, but you can only patch the input source string (<code>ParseContext::characters</code>), not the output object. Patching the input source obviously isn&#39;t useful here. I&#39;ve created a feature request for this: <a href=\"https://github.com/jOOQ/jOOQ/issues/19191\" rel=\"nofollow noreferrer\">github.com/jOOQ/jOOQ/issues/19191</a>. As a workaround, your <code>ParseListener</code> could still communicate with a <code>VisitListener</code> (e.g. via <code>ThreadLocal</code> or similar) in order to be able to re-render the desired clauses.",
      "score" : 0,
      "owner" : {
        "account_id" : 247217,
        "reputation" : 223532,
        "user_id" : 521799,
        "user_type" : "registered",
        "accept_rate" : 89,
        "profile_image" : "https://www.gravatar.com/avatar/eb96efa7a5664ba1c4ebf586abd4121f?s=256&d=identicon&r=PG",
        "display_name" : "Lukas Eder",
        "link" : "https://stackoverflow.com/users/521799/lukas-eder"
      },
      "creation_date" : 1760086101,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140786671,
      "post_id" : 79786310,
      "body" : "Lukas, just to illustrate my implementation. I tried both a ParseListener and an ExecuteListener to handle EXPLAIN (ANALYZE, FORMAT JSON). The parser skips the EXPLAIN as expected, but at execution time jOOQ only executes the inner SQL without the EXPLAIN, so I donâ€™t get the plan. ParseListener:<code>public void parseStart(ParseContext ctx) throws ParserException { if (ctx.parseKeywordIf(&quot;EXPLAIN&quot;)) {ctx.data(&quot;explain_detected&quot;, true);if (ctx.parseIf(&#39;(&#39;){ctx.parseKeywordIf(&quot;ANALYZE&quot;);ctx.parseIf(&zwnj;&#8203;&#39;,&#39;);ctx.parseKeywor&zwnj;&#8203;dIf(&quot;FORMAT&quot;);ctx.pa&zwnj;&#8203;rseKeywordIf(&quot;JSON&quot;)&zwnj;&#8203;;ctx.parseIf(&#39;)&#39;); }}</code>",
      "score" : 1,
      "owner" : {
        "account_id" : 25917081,
        "reputation" : 59,
        "user_id" : 19640317,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/MOEOkdpB.jpg?s=256",
        "display_name" : "Raoua KHATERCHI",
        "link" : "https://stackoverflow.com/users/19640317/raoua-khaterchi"
      },
      "creation_date" : 1760023929,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}