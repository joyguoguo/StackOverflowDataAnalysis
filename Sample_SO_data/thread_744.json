{
  "question" : {
    "question_id" : 79776934,
    "title" : "Fatal error and unusual result when converting OpenCV Mat into a JavaFX image",
    "body" : "<p>This is a follow-up question to two previous posts on the most efficient way to convert an OpenCV <a href=\"https://docs.opencv.org/3.4/d3/d63/classcv_1_1Mat.html\" rel=\"nofollow noreferrer\">Mat</a> object into a JavaFX <a href=\"https://openjfx.io/javadoc/25/javafx.graphics/javafx/scene/image/Image.html\" rel=\"nofollow noreferrer\">Image</a> (<a href=\"https://stackoverflow.com/questions/79771565/bufferedimage-vs-matofbyte-for-converting-an-opencv-matrix-to-a-javafx-image\">post 1</a>, <a href=\"https://stackoverflow.com/questions/79774713/converting-an-opencv-mat-to-a-javafx-image-not-working-when-using-bytebuffer-and\">post 2</a>).</p>\n<p>@James_D, @Slaw, pointed to two possible approaches, in which @Slaw elaborated in his <a href=\"https://stackoverflow.com/questions/79774713/converting-an-opencv-mat-to-a-javafx-image-not-working-when-using-bytebuffer-and#answer-79775390\">answer</a>:</p>\n<blockquote>\n<p>MemorySegment(of the Mat) -&gt; ByteBuffer -&gt; PixelBuffer -&gt; return the\nimage using WritableImage</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p>Byte [] -&gt; ByteBuffer -&gt; read the buffer using WritableImage and\nreturn the image</p>\n</blockquote>\n<p>For the first one, I am getting a fatal error. Meanwhile, with the second approach, I am getting an unusual result where the image becomes repetitive on the X-axis, displaying horizontal stripes.</p>\n<h2>About the app</h2>\n<p>This part of the application is responsible for maintaining only a specific color, based on the user's input of the maximum and minimum HSV values.</p>\n<p>For this purpose, the class FilterByHSV has the <code>filterImage(int minHue, int maxHue, int minSaturation, int maxSaturation, int minValue, int maxValue)</code> method that returns a matrix, where all pixels within the specified <a href=\"https://en.wikipedia.org/wiki/HSL_and_HSV\" rel=\"nofollow noreferrer\">HSV</a> range, using sliders, are shown in color, and the rest are in gray.</p>\n<p>Whenever the user changes one of the <code>slider</code> , <code>filterImage</code> is invoked, and the resulting Mat object is then converted into an Image that will be displayed in the application.</p>\n<p>For converting the mat into an image, the class <code>MatToFXImage extends Task&lt;Image&gt;</code> implements the necessary logic in the <code>call</code> method.</p>\n<h2>The code</h2>\n<ol>\n<li><code>ProcessImage</code> is to create the UI and its elements.</li>\n</ol>\n<pre><code>import javafx.application.Application;\nimport javafx.geometry.Insets;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Label;\nimport javafx.scene.control.Slider;\nimport javafx.scene.image.Image;\nimport javafx.scene.image.ImageView;\nimport javafx.scene.layout.ColumnConstraints;\nimport javafx.scene.layout.GridPane;\nimport javafx.scene.layout.HBox;\nimport javafx.scene.layout.RowConstraints;\nimport javafx.scene.text.Font;\nimport javafx.stage.Stage;\n\nimport java.util.Objects;\n\npublic class ProcessImage extends Application {\n\n    private GridPane createFilterWindow() {\n        // Create main GridPane\n        GridPane mainGridPane = new GridPane();\n        mainGridPane.setPrefHeight(600.0);\n        mainGridPane.setPrefWidth(800.0);\n        mainGridPane.setStyle(&quot;-fx-background-color: #5b5b5b&quot;);\n    \n        // Create column constraints\n        ColumnConstraints mainColumn = new ColumnConstraints();\n        mainColumn.setHgrow(javafx.scene.layout.Priority.ALWAYS);\n        mainGridPane.getColumnConstraints().add(mainColumn);\n    \n        // Create row constraints\n        RowConstraints row1 = new RowConstraints();\n        row1.setVgrow(javafx.scene.layout.Priority.NEVER);\n        RowConstraints row2 = new RowConstraints();\n        row2.setVgrow(javafx.scene.layout.Priority.ALWAYS);\n        mainGridPane.getRowConstraints().addAll(row1, row2);\n    \n        // Create first HBox (controls section)\n        HBox controlsHBox = new HBox();\n        controlsHBox.setAlignment(javafx.geometry.Pos.CENTER);\n    \n        // Create inner GridPane for controls\n        GridPane controlsGridPane = new GridPane();\n        controlsGridPane.setAlignment(javafx.geometry.Pos.CENTER);\n        controlsGridPane.setVgap(20);\n        controlsGridPane.setStyle(&quot;-fx-background-color: #00ff93&quot;);\n        HBox.setHgrow(controlsGridPane, javafx.scene.layout.Priority.ALWAYS);\n    \n        // Create column constraint for inner GridPane\n        ColumnConstraints innerColumn = new ColumnConstraints();\n        innerColumn.setHgrow(javafx.scene.layout.Priority.ALWAYS);\n        controlsGridPane.getColumnConstraints().add(innerColumn);\n    \n        // Create slider controls\n        createSliderControl(controlsGridPane, 0, &quot;Min H&quot;, &quot;minHueSlider&quot;, &quot;minHueLabel&quot;);\n        createSliderControl(controlsGridPane, 1, &quot;Max H&quot;, &quot;maxHueSlider&quot;, &quot;maxHueLabel&quot;);\n        createSliderControl(controlsGridPane, 2, &quot;Min S&quot;, &quot;minSaturationSlider&quot;, &quot;minSaturationLabel&quot;);\n        createSliderControl(controlsGridPane, 3, &quot;Max S&quot;, &quot;maxSaturationSlider&quot;, &quot;maxSaturationLabel&quot;);\n        createSliderControl(controlsGridPane, 4, &quot;Min V&quot;, &quot;minValueSlider&quot;, &quot;minValueLabel&quot;);\n        createSliderControl(controlsGridPane, 5, &quot;Max V&quot;, &quot;maxValueSlider&quot;, &quot;maxValueLabel&quot;);\n    \n        controlsHBox.getChildren().add(controlsGridPane);\n        mainGridPane.add(controlsHBox, 0, 0);\n    \n        // Create second HBox (image section)\n        HBox imageHBox = new HBox();\n        imageHBox.setAlignment(javafx.geometry.Pos.CENTER);\n    \n        // Create ImageView\n        ImageView inputImage = new ImageView();\n        inputImage.setId(&quot;inputImage&quot;);\n        inputImage.setPickOnBounds(true);\n        inputImage.setPreserveRatio(true);\n        inputImage.setFitHeight(500);\n        inputImage.setFitWidth(500);\n    \n        // Load image\n        try {\n            Image image = new Image(getClass().getResource(&quot;path_to_your_image&quot;).toString(), true);\n            inputImage.setImage(image);\n        } catch (Exception e) {\n            System.err.println(&quot;Could not load image: &quot; + e.getMessage());\n        }\n    \n        imageHBox.getChildren().add(inputImage);\n        mainGridPane.add(imageHBox, 0, 1);\n    \n        return mainGridPane;\n    }\n    \n    private void createSliderControl(GridPane gridPane, int rowIndex, String labelText, String sliderId, String labelId) {\n        HBox hbox = new HBox();\n        hbox.setAlignment(javafx.geometry.Pos.CENTER);\n        hbox.setPrefHeight(60);\n    \n        // Create label\n        Label nameLabel = new Label(labelText);\n        nameLabel.setTextFill(javafx.scene.paint.Color.BLACK);\n        nameLabel.setFont(Font.font(&quot;Times New Roman Bold&quot;, 15.0));\n        HBox.setMargin(nameLabel, new Insets(0, 20, 0, 20));\n    \n        // Create slider\n        Slider slider = new Slider();\n        slider.setId(sliderId);\n        slider.setBlockIncrement(0.1);\n        slider.setMajorTickUnit(0.5);\n        slider.setMax(255.0);\n        slider.getStyleClass().add(&quot;slider&quot;);\n        HBox.setHgrow(slider, javafx.scene.layout.Priority.ALWAYS);\n    \n        // Create value label\n        Label valueLabel = new Label(&quot;0&quot;);\n        valueLabel.setId(labelId);\n        valueLabel.setTextFill(javafx.scene.paint.Color.BLACK);\n        valueLabel.setFont(Font.font(&quot;Times New Roman Bold&quot;, 15.0));\n        HBox.setMargin(valueLabel, new Insets(0, 20, 0, 20));\n    \n        hbox.getChildren().addAll(nameLabel, slider, valueLabel);\n        gridPane.add(hbox, 0, rowIndex);\n    }\n    \n    @Override\n    public void start(Stage stage) throws Exception {\n        GridPane parentNode = createFilterWindow();\n        Scene scene = new Scene(parentNode, 900, 700);\n        stage.setTitle(&quot;Test window&quot;);\n    \n        ProcessImageController controller = new ProcessImageController();\n        controller.mainGridPane = parentNode;\n        controller.inputImage = (ImageView) parentNode.lookup(&quot;#inputImage&quot;);\n        controller.setInputImagePath(&quot;C:\\\\Users\\\\PC\\\\Desktop\\\\bird-9445431.jpg&quot;);\n        controller.minHueLabel = (Label) parentNode.lookup(&quot;#minHueLabel&quot;);\n        controller.maxHueLabel = (Label) scene.lookup(&quot;#maxHueLabel&quot;);\n        controller.minSaturationLabel = (Label) parentNode.lookup(&quot;#minSaturationLabel&quot;);\n        controller.maxSaturationLabel = (Label) parentNode.lookup(&quot;#maxSaturationLabel&quot;);\n        controller.minValueLabel = (Label) parentNode.lookup(&quot;#minValueLabel&quot;);\n        controller.maxValueLabel = (Label) parentNode.lookup(&quot;#maxValueLabel&quot;);\n        controller.minHueSlider = (Slider) scene.lookup(&quot;#minHueSlider&quot;);\n        controller.maxHueSlider = (Slider) scene.lookup(&quot;#maxHueSlider&quot;);\n        controller.minSaturationSlider = (Slider) parentNode.lookup(&quot;#minSaturationSlider&quot;);\n        controller.maxSaturationSlider = (Slider) parentNode.lookup(&quot;#maxSaturationSlider&quot;);\n        controller.minValueSlider = (Slider) parentNode.lookup(&quot;#minValueSlider&quot;);\n        controller.maxValueSlider = (Slider) parentNode.lookup(&quot;#maxValueSlider&quot;);\n        controller.initialize();\n    \n        try {\n            stage.getIcons().add(new Image(Objects.requireNonNull(getClass().getResourceAsStream(&quot;resources/window-icon.png&quot;))));\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    \n        stage.setScene(scene);\n        stage.show();\n    \n        stage.show();\n    }\n</code></pre>\n<ol start=\"2\">\n<li><code>ProcessImageController</code> Is the controller of the view and its controls.</li>\n</ol>\n<pre><code>import javafx.application.Platform;\nimport javafx.fxml.FXML;\nimport javafx.scene.control.Label;\nimport javafx.scene.control.Slider;\nimport javafx.scene.image.Image;\nimport javafx.scene.image.ImageView;\nimport javafx.scene.layout.GridPane;\nimport org.opencv.core.Mat;\nimport tasks.MatToFXImage;\nimport utils.FilterByHSV;\nimport utils.HSVAdaptor;\n\nimport java.util.Objects;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class ProcessImageController {\n    // UI Components\n    @FXML\n    public GridPane mainGridPane;\n    @FXML\n    public ImageView inputImage;\n\n    // Labels\n    @FXML\n    public Label minHueLabel;\n    @FXML\n    public Label maxHueLabel;\n    @FXML\n    public Label minSaturationLabel;\n    @FXML\n    public Label maxSaturationLabel;\n    @FXML\n    public Label minValueLabel;\n    @FXML\n    public Label maxValueLabel;\n\n    // Sliders\n    @FXML\n    public Slider minHueSlider;\n    @FXML\n    public Slider maxHueSlider;\n    @FXML\n    public Slider minSaturationSlider;\n    @FXML\n    public Slider maxSaturationSlider;\n    @FXML\n    public Slider minValueSlider;\n    @FXML\n    public Slider maxValueSlider;\n\n    private FilterByHSV filterByHSV;\n\n    // Single-thread executor ensures processing tasks don't overlap and preserves order.\n    private final ExecutorService imageProcessingExecutor = Executors.newSingleThreadExecutor(r -&gt; {\n        Thread t = new Thread(r, &quot;image-processing&quot;);\n        t.setDaemon(true);\n        return t;\n    });\n\n    // Scheduled executor used only for debounce timing.\n    private final ScheduledExecutorService debounceExecutor = Executors.newSingleThreadScheduledExecutor(r -&gt; {\n        Thread t = new Thread(r, &quot;debounce-timer&quot;);\n        t.setDaemon(true);\n        return t;\n    });\n\n    // Holds the currently scheduled debounce task so it can be cancelled/rescheduled.\n    private final AtomicReference&lt;ScheduledFuture&lt;?&gt;&gt; pendingDebounce = new AtomicReference&lt;&gt;();\n\n    // Debounce interval in milliseconds.\n    private static final long DEBOUNCE_MS = 150L;\n\n    @FXML\n    public void initialize() {\n        setupSliderListeners();\n    }\n\n    private void setupSliderListeners() {\n        addSliderPair(minHueSlider, minHueLabel, maxHueSlider, maxHueLabel);\n        addSliderPair(minSaturationSlider, minSaturationLabel, maxSaturationSlider, maxSaturationLabel);\n        addSliderPair(minValueSlider, minValueLabel, maxValueSlider, maxValueLabel);\n    }\n\n    private void addSliderPair(Slider minSlider, Label minLabel, Slider maxSlider, Label maxLabel) {\n        // Min slider\n        minSlider.valueProperty().addListener((_, _, newV) -&gt; {\n            double minVal = newV.doubleValue();\n            // Clamp to maintain the gap\n            double maxAllowed = maxSlider.getValue() - 10.0;\n            if (minVal &gt; maxAllowed) {\n                minVal = maxAllowed;\n                minSlider.setValue(minVal);\n            }\n            minLabel.setText(String.format(&quot;%.02f&quot;, minVal));\n            scheduleDebouncedUpdate();\n        });\n\n        // Max slider\n        maxSlider.valueProperty().addListener((_, _, newV) -&gt; {\n            double maxVal = newV.doubleValue();\n            // Clamp to maintain the gap\n            double minAllowed = minSlider.getValue() + 10.0;\n            if (maxVal &lt; minAllowed) {\n                maxVal = minAllowed;\n                maxSlider.setValue(maxVal);\n            }\n            maxLabel.setText(String.format(&quot;%.02f&quot;, maxVal));\n            scheduleDebouncedUpdate();\n        });\n    }\n\n    private void scheduleDebouncedUpdate() {\n        ScheduledFuture&lt;?&gt; prev = pendingDebounce.getAndSet(debounceExecutor.schedule(() -&gt;\n                Platform.runLater(this::updateImageFilter), DEBOUNCE_MS, TimeUnit.MILLISECONDS));\n        if (prev != null)\n            prev.cancel(false);\n    }\n\n    private Image matToImage(Mat mat) {\n        try {\n            MatToFXImage task = new MatToFXImage(mat);\n//            task.exceptionProperty().subscribe(Throwable::printStackTrace);\n            new Thread(task).start();\n            return task.get();\n        } catch (InterruptedException | ExecutionException e) {\n            throw new RuntimeException(&quot;Failed to convert Mat to Image&quot;, e);\n        }\n    }\n\n    private static String stripFilePrefix(String filePath) {\n        if (filePath != null &amp;&amp; filePath.startsWith(&quot;file:&quot;)) {\n            return filePath.substring(&quot;file:&quot;.length());\n        }\n        return filePath;\n    }\n\n    private void updateImageFilter() {\n        if (filterByHSV == null) return;\n\n        // Read current slider values once\n        int minHue = (int) HSVAdaptor.adaptHue(minHueSlider.getValue(), 255, 179);\n        int maxHue = (int) HSVAdaptor.adaptHue(maxHueSlider.getValue(), 255, 179);\n\n        int minSaturation = (int) minSaturationSlider.getValue();\n        int maxSaturation = (int) maxSaturationSlider.getValue();\n\n        int minValue = (int) minValueSlider.getValue();\n        int maxValue = (int) maxValueSlider.getValue();\n\n        imageProcessingExecutor.submit(() -&gt; {\n            try {\n                Mat outputMat = filterByHSV.filterImage(minHue, maxHue, minSaturation, maxSaturation, minValue, maxValue);\n                Image outputImage = matToImage(outputMat);\n                Platform.runLater(() -&gt; inputImage.setImage(outputImage));\n            } catch (Exception e) {\n                // Consider logging to a logger instead of throwing if UI stability is preferred\n                throw new RuntimeException(&quot;Image processing failed&quot;, e);\n            }\n        });\n    }\n\n    @FXML\n    public void setInputImagePath(String path) {\n        Objects.requireNonNull(path, &quot;path&quot;);\n        Image image = new Image(&quot;file:&quot; + path);\n        inputImage.setImage(image);\n        String filePath = stripFilePrefix(image.getUrl());\n        filterByHSV = new FilterByHSV(filePath);\n    }\n\n    @FXML\n    public void setSlidersValues(double minHue, double maxHue, double minSaturation, double maxSaturation, double minValue, double maxValue) {\n        minHueSlider.setValue(minHue);\n        maxHueSlider.setValue(maxHue);\n        minSaturationSlider.setValue(minSaturation);\n        maxSaturationSlider.setValue(maxSaturation);\n        minValueSlider.setValue(minValue);\n        maxValueSlider.setValue(maxValue);\n        scheduleDebouncedUpdate();\n    }\n\n    public void dispose() {\n        ScheduledFuture&lt;?&gt; pending = pendingDebounce.getAndSet(null);\n        if (pending != null) pending.cancel(false);\n\n        debounceExecutor.shutdown();\n        imageProcessingExecutor.shutdown();\n\n        try {\n            if (!debounceExecutor.awaitTermination(500, TimeUnit.MILLISECONDS)) {\n                debounceExecutor.shutdownNow();\n            }\n            if (!imageProcessingExecutor.awaitTermination(1, TimeUnit.SECONDS)) {\n                imageProcessingExecutor.shutdownNow();\n            }\n        } catch (InterruptedException e) {\n            debounceExecutor.shutdownNow();\n            imageProcessingExecutor.shutdownNow();\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n</code></pre>\n<ol start=\"3\">\n<li><p><code>MatToFXImage</code> It is a Task where the mat will be converted into a JavaFX image.</p>\n<pre><code>import java.awt.image.BufferedImage;\nimport java.awt.image.DataBufferByte;\nimport java.awt.image.WritableRaster;\nimport java.io.ByteArrayInputStream;\nimport java.lang.foreign.Arena;\nimport java.lang.foreign.MemorySegment;\nimport java.nio.Buffer;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\n\nimport javafx.concurrent.Task;\nimport javafx.embed.swing.SwingFXUtils;\nimport javafx.scene.image.Image;\nimport javafx.scene.image.PixelBuffer;\nimport javafx.scene.image.PixelFormat;\nimport javafx.scene.image.WritableImage;\nimport org.opencv.core.CvType;\nimport org.opencv.core.Mat;\nimport org.opencv.core.MatOfByte;\nimport org.opencv.imgcodecs.Imgcodecs;\n\npublic class MatToFXImage extends Task&lt;Image&gt; {\n    private final Mat mat;\n\n    public MatToFXImage(Mat mat) {\n        if (mat == null)\n            throw new IllegalArgumentException(&quot;Mat object can't be null&quot;);\n\n        this.mat = mat;\n    }\n\n    private int determineImageType(int matType) {\n        if (matType == CvType.CV_8UC1)\n            return BufferedImage.TYPE_BYTE_GRAY;\n        else if (matType == CvType.CV_8UC3)\n            return BufferedImage.TYPE_3BYTE_BGR;\n        else\n            throw new IllegalArgumentException(&quot;Unsupported Mat type: &quot; + matType);\n    }\n\n    public Image fromAddress(long address, int width, int height) {\n        try {\n            int length = width * height * 6; // may want to guard against overflow\n            var segment = MemorySegment.ofAddress(address).reinterpret(length);\n\n            var buffer = segment.asByteBuffer();\n            var format = PixelFormat.getByteBgraPreInstance();\n            var pixels = new PixelBuffer&lt;&gt;(width, height, buffer, format);\n\n            return new WritableImage(pixels);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    public &lt;T extends Buffer&gt; Image fromBuffer(T buffer, int width, int height, PixelFormat&lt;T&gt; format) {\n        var image = new WritableImage(width, height);\n        var writer = image.getPixelWriter();\n        writer.setPixels(0, 0, width, height, format, buffer, width);\n\n        return image;\n    }\n\n    @Override\n    protected Image call() {\n// Works fine\n        MatOfByte byteMat = new MatOfByte();\n        Imgcodecs.imencode(&quot;.bmp&quot;, mat, byteMat);\n        return new Image(new ByteArrayInputStream(byteMat.toArray()));\n\n// Fatal Error\n        // try {\n        //     System.out.println(mat.dataAddr());\n        //     return fromAddress(mat.dataAddr(), mat.width(), mat.height());\n        // }catch (Exception e) {\n        //         e.printStackTrace();\n        //         return null;\n        // }\n\n// Strange result 1\n        // try {\n        //     int size = (int) (mat.total() * mat.channels());\n        //     byte[] byteArray = new byte[size * 5];\n        //     mat.get(0, 0, byteArray);\n\n        //     ByteBuffer buffer = ByteBuffer.wrap(byteArray);\n        //     PixelFormat&lt;ByteBuffer&gt; pixelFormat = PixelFormat.getByteBgraPreInstance();\n\n        //     return fromBuffer(buffer, mat.width(), mat.height(), pixelFormat);\n        // } catch (Exception e) {\n        //     e.printStackTrace();\n        //     return null;\n        // }\n\n\n// Strange result 2\n        // try {\n        //     int size = (int) (mat.total() * mat.channels());\n        //     System.out.println(mat.channels());\n        //     byte[] byteArray = new byte[size * 5];\n\n        //     mat.get(0, 0, byteArray);\n\n        //     ByteBuffer buffer = ByteBuffer.wrap(byteArray);\n        //     PixelFormat&lt;ByteBuffer&gt; pixelFormat = PixelFormat.getByteBgraPreInstance();\n        //     PixelBuffer&lt;ByteBuffer&gt; pixelBuffer = new PixelBuffer&lt;&gt;(mat.width(), mat.height(), buffer, pixelFormat);\n\n        //     return new WritableImage(pixelBuffer);\n        // } catch (Exception e) {\n        //     e.printStackTrace();\n        //     return null;\n        // }\n\n\n// Works fine\n        // int type;\n        // type = determineImageType(mat.type());\n\n        // BufferedImage image = new BufferedImage(mat.width(), mat.height(), type);\n        // WritableRaster raster = image.getRaster();\n        // DataBufferByte dataBuffer = (DataBufferByte) raster.getDataBuffer();\n\n        // // byte[] data = dataBuffer.getData();\n\n        // mat.get(0, 0, dataBuffer.getData());\n        // return SwingFXUtils.toFXImage(image, null);\n    }\n}\n\n\n</code></pre>\n</li>\n<li><p><code>FilterByHSV</code> keeps only the pixels within the specified range and turns the rest into grey.</p>\n<pre><code>package utils;\n\nimport org.opencv.core.Core;\nimport org.opencv.core.Mat;\nimport org.opencv.core.Scalar;\nimport org.opencv.imgcodecs.Imgcodecs;\nimport org.opencv.imgproc.Imgproc;\n\npublic class FilterByHSV {\n    private static final int COLOR_CONVERSION_BGR_TO_HSV = Imgproc.COLOR_BGR2HSV;\n    private static final int COLOR_CONVERSION_BGR_TO_GRAY = Imgproc.COLOR_BGR2GRAY;\n    private static final int COLOR_CONVERSION_GRAY_TO_BGR = Imgproc.COLOR_GRAY2BGR;\n\n    static {\n        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n    }\n\n    Mat image;\n    Mat imageInHSV;\n    Mat grey;\n    Mat mask;\n    Mat result;\n\n    public FilterByHSV(String imageToFilterPath) {\n        imageInHSV = new Mat();\n        grey = new Mat();\n        mask = new Mat();\n        result = new Mat();\n\n        image = Imgcodecs.imread(imageToFilterPath);\n        Imgproc.cvtColor(image, imageInHSV, COLOR_CONVERSION_BGR_TO_HSV);\n        Imgproc.cvtColor(image, grey, COLOR_CONVERSION_BGR_TO_GRAY);\n    }\n\n    public Mat filterImage(int minHue, int maxHue, int minSaturation, int maxSaturation, int minValue, int maxValue) {\n        Core.inRange(imageInHSV, new Scalar(minHue, minSaturation, minValue), new Scalar(maxHue, maxSaturation, maxValue), mask);\n        Imgproc.cvtColor(grey, result, COLOR_CONVERSION_GRAY_TO_BGR);\n        image.copyTo(result, mask);\n\n        return result;\n    }\n}\n\n\n</code></pre>\n</li>\n<li><p><code>HSVAdaptor</code> convert the HSV values into their real values.</p>\n<pre><code>public class HSVAdaptor {\n    public static double adaptHue(double hueValue, double from, double to) {\n        return (hueValue / from) * to;\n    }\n\n    public static double adaptSaturation(double saturation) {\n        return saturation * 255;\n    }\n\n    public static double adaptValue(double value) {\n        return value * 255;\n    }\n}\n</code></pre>\n</li>\n</ol>\n<p>Now this is what the result should look like (the working parts are commented as <code>// work fine</code>)</p>\n<p><img src=\"https://i.sstatic.net/HlGviDgO.png\" alt=\"enter image description here\" /></p>\n<p>For the <code>// fatal error</code> par this the error code I get:</p>\n<pre><code># A fatal error has been detected by the Java Runtime Environment:\n#\n#  EXCEPTION_ACCESS_VIOLATION (0xc0000005) at pc=0x00007ffa1a92059b, pid=49852, tid=13600\n#\n# JRE version: Java(TM) SE Runtime Environment (25.0+37) (build 25+37-LTS-3491)\n# Java VM: Java HotSpot(TM) 64-Bit Server VM (25+37-LTS-3491, mixed mode, sharing, tiered, compressed oops, compressed class ptrs, g1 gc, windows-amd64)\n# Problematic frame:\n# C  [VCRUNTIME140.dll+0x1059b]\n#\n# No core dump will be written. Minidumps are not enabled by default on client versions of Windows\n#\n# An error report file with more information is saved as:\n# C:\\Users\\PC\\IdeaProjects\\Color Isolator 2\\hs_err_pid49852.log\n[17.144s][warning][os] Loading hsdis library failed\n#\n# If you would like to submit a bug report, please visit:\n#   https://bugreport.java.com/bugreport/crash.jsp\n# The crash happened outside the Java Virtual Machine in native code.\n# See problematic frame for where to report the bug.\n</code></pre>\n<p>For <code>// strange result 1</code> this is what i get</p>\n<p><img src=\"https://i.sstatic.net/HDkbufOy.png\" alt=\"enter image description here\" /></p>\n<p>For <code>// strange result 2</code> this is what i get</p>\n<p><img src=\"https://i.sstatic.net/f530Aia6.png\" alt=\"enter image description here\" /></p>\n<p>In order to use <a href=\"https://download.java.net/java/early_access/valhalla/docs/api/java.base/java/lang/foreign/MemorySegment.html\" rel=\"nofollow noreferrer\"><code>MemorySegment</code></a> I added the following configiration, so native code can be run</p>\n<pre><code>--enable-native-access=javafx.graphics\n--enable-native-access=ALL-UNNAMED\n</code></pre>\n<p>I would like to know why both approaches are not working, and what is causing the fatal error and the unusual results when using the byte buffer</p>\n",
    "tags" : [ "java", "image", "opencv", "javafx", "mat" ],
    "owner" : {
      "account_id" : 12506291,
      "reputation" : 811,
      "user_id" : 9103039,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
      "display_name" : "Starnec",
      "link" : "https://stackoverflow.com/users/9103039/starnec"
    },
    "is_answered" : true,
    "view_count" : 244,
    "answer_count" : 1,
    "score" : 4,
    "last_activity_date" : 1759435563,
    "creation_date" : 1758997343,
    "link" : "https://stackoverflow.com/questions/79776934/fatal-error-and-unusual-result-when-converting-opencv-mat-into-a-javafx-image",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79777047,
    "question_id" : 79776934,
    "body" : "<h2>Fatal Error</h2>\n<p>The access violation means the process tried to access memory that doesn't belong to the process. On most modern operating systems that will cause the process to crash. The cause of the violation in this case is making the length of the <code>MemorySegment</code> too large via the <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/foreign/MemorySegment.html#reinterpret(long)\" rel=\"nofollow noreferrer\"><code>reinterpret</code></a> call (hence the method being <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/doc-files/RestrictedMethods.html\" rel=\"nofollow noreferrer\">restricted</a>). Which is ultimately a number-of-channels issue. Your code currently assumes there are 6 channels, where it should be at most 4. But you mention even assuming 4 channels leads to the error, which suggests your <code>Mat</code> only has 3 channels. You need to make sure it has 4 channels (BGRA) to work with JavaFX's <code>PixelBuffer</code>.</p>\n<p>See the <em>proof-of-concept</em> below for an example.</p>\n<h2>Strange Results</h2>\n<p>As for your strange results, I believe there are two issues (which may be compounding in one of the approaches).</p>\n<ol>\n<li><p>You have a number-of-channels issue again. In both cases you're still trying to use a pixel format of BGRA, a format with 4 channels. Which means the length of the <code>byte[]</code> should be:</p>\n<pre><code>int length = imageWidth * imageHeight * 4;\n</code></pre>\n<p>Your current approach is making the <code>byte[]</code> too large.</p>\n</li>\n<li><p>A mistake I made in my <a href=\"https://stackoverflow.com/a/79775390/6395627\">previous answer</a> (since fixed). I said the &quot;scanline stride&quot; was the image's width, but that value is relative to the buffer not the number of pixels. The actual value is typically the image's width <em>multiplied by</em> the number of channels when using a <code>byte[]</code> or <code>ByteBuffer</code>, and typically remains the image's width when using an <code>int[]</code> or <code>IntBuffer</code>.</p>\n</li>\n</ol>\n<p>Getting the pixel data out of the <code>Mat</code> into a <code>byte[]</code> should look like:</p>\n<pre class=\"lang-java prettyprint-override\"><code>int size = Math.toIntExact(mat.total() * mat.channels());\nbyte[] data = new byte[size];\nmat.get(0, 0, data);\n</code></pre>\n<p>Then you can create a JavaFX image one of the following ways:</p>\n<pre class=\"lang-java prettyprint-override\"><code>// (1) Using PixelBuffer. Requires 4 channels (BGRA).\nByteBuffer buffer = ByteBuffer.wrap(data);\nPixelFormat&lt;ByteBuffer&gt; format = PixelFormat.getByteBgraPreInstance();\nPixelBuffer&lt;ByteBuffer&gt; pixels = new PixelBuffer&lt;&gt;(mat.width(), mat.height(), buffer, format);\nImage image = new WritableImage(pixels);\n\n// (2) Using PixelWriter (assuming BGRA)\nWritableImage image = new WritableImage(mat.width(), mat.height());\nPixelWriter writer = image.getPixelWriter();\nPixelFormat&lt;ByteBuffer&gt; format = PixelFormat.getByteBgraInstance();\nint scanlineStride = Math.toIntExact(mat.width() * mat.channels());\nwriter.setPixels(0, 0, mat.width(), mat.height(), format, data, 0, scanlineStride);\n</code></pre>\n<p>For the second approach, use an appropriate 3-channel pixel format when your data only has 3 channels (e.g., BGR).</p>\n<hr />\n<h1>Proof of Concept</h1>\n<p>Here's an <em>proof-of-concept</em> using the <code>MemorySegment</code> approach that seems to do what you want. I can't guarantee the color isolation implementation is fully correct or most efficient. But the example does use the <code>MemorySegment</code> approach for displaying images contained in a <code>Mat</code>.</p>\n<p>Note you may need to keep a reference to the <code>Mat</code> being displayed for as long as it's being displayed. I don't know if OpenCV's Java bindings release the native memory when the Java object is garbage collected. Nor do I know what will happen on the JavaFX side after the underlying data is released after it's been displayed.</p>\n<h2>Versions</h2>\n<ul>\n<li>Java 25.0.0 (minimum 22 to use <code>MemorySegment</code>; minimum 23 to use JavaFX 25)</li>\n<li>JavaFX 25.0.0</li>\n<li>OpenCV 4.12.0</li>\n</ul>\n<h2>Configuration</h2>\n<ul>\n<li><p>Pass <code>--allow-native-access=ALL-UNNAMED,javafx.graphics</code> when running code.</p>\n</li>\n<li><p>OpenCV native library needs to be locatable by <code>System::loadLibrary</code>. One approach is to put the native library on the <code>java.library.path</code> system property.</p>\n</li>\n</ul>\n<h2>Test Image</h2>\n<p>I got the test image from <a href=\"https://wildkratts.fandom.com/wiki/Blue-and-yellow_Macaw?file=Blue-and-yellow+Macaw+RL.PNG\" rel=\"nofollow noreferrer\">here</a>. I saved it in a local file named <code>bird.png</code> located in the working directory.</p>\n<p><a href=\"https://i.sstatic.net/M6bInqyp.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/M6bInqypt.png\" alt=\"PNG of test image of bird.\" /></a></p>\n<h2>Source Code</h2>\n<p><strong>Main.java</strong></p>\n<p>Requires the test image to be in a file named <code>bird.png</code> in the working directory.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package com.example;\n\nimport java.lang.foreign.MemorySegment;\nimport java.nio.ByteBuffer;\nimport javafx.application.Application;\nimport javafx.geometry.Insets;\nimport javafx.geometry.Pos;\nimport javafx.scene.Scene;\nimport javafx.scene.image.Image;\nimport javafx.scene.image.ImageView;\nimport javafx.scene.image.PixelBuffer;\nimport javafx.scene.image.PixelFormat;\nimport javafx.scene.image.WritableImage;\nimport javafx.scene.layout.HBox;\nimport javafx.stage.Stage;\nimport org.opencv.core.Core;\nimport org.opencv.core.Mat;\nimport org.opencv.core.Scalar;\nimport org.opencv.imgcodecs.Imgcodecs;\nimport org.opencv.imgproc.Imgproc;\n\npublic class Main extends Application {\n\n  private static final String IMAGE_PATH = &quot;bird.png&quot;;\n\n  private static final double MIN_H = 10.0;\n  private static final double MAX_H = 35.0;\n  private static final double MIN_S = 50.0;\n  private static final double MAX_S = 255.0;\n  private static final double MIN_V = 50.0;\n  private static final double MAX_V = 255.0;\n\n  private Mat original;\n  private Mat filtered;\n\n  @Override\n  public void init() {\n    System.loadLibrary(Core.NATIVE_LIBRARY_NAME);\n  }\n\n  @Override\n  public void start(Stage primaryStage) {\n    original = readImageIntoMat();\n    filtered = isolateColorRange(original);\n\n    ImageView originalView = new ImageView(matToImage(original));\n    ImageView filteredView = new ImageView(matToImage(filtered));\n\n    HBox root = new HBox(originalView, filteredView);\n    root.setAlignment(Pos.CENTER);\n    root.setSpacing(10);\n    root.setPadding(new Insets(10));\n\n    primaryStage.setScene(new Scene(root));\n    primaryStage.show();\n  }\n\n  private Mat readImageIntoMat() {\n    Mat img = Imgcodecs.imread(IMAGE_PATH, Imgcodecs.IMREAD_UNCHANGED);\n    if (img.empty()) throw new IllegalStateException(&quot;could not load image&quot;);\n\n    if (img.channels() != 4) {\n      Imgproc.cvtColor(img, img, Imgproc.COLOR_BGR2BGRA);\n    }\n    return img;\n  }\n\n  private Image matToImage(Mat mat) {\n    if (mat.empty()) throw new IllegalArgumentException(&quot;empty&quot;);\n    if (mat.channels() != 4) throw new IllegalArgumentException(&quot;channels != 4&quot;);\n    if (!mat.isContinuous()) throw new IllegalArgumentException(&quot;not continuous&quot;);\n\n    long dataAddress = mat.dataAddr();\n    long dataLength = mat.total() * mat.channels();\n    MemorySegment data = MemorySegment.ofAddress(dataAddress).reinterpret(dataLength);\n\n    ByteBuffer buffer = data.asByteBuffer();\n    PixelFormat&lt;ByteBuffer&gt; format = PixelFormat.getByteBgraPreInstance();\n    PixelBuffer&lt;ByteBuffer&gt; pixels = new PixelBuffer&lt;&gt;(mat.width(), mat.height(), buffer, format);\n\n    return new WritableImage(pixels);\n  }\n\n  private Mat isolateColorRange(Mat src) {\n    if (src.empty()) throw new IllegalArgumentException(&quot;empty&quot;);\n    if (src.channels() != 4) throw new IllegalArgumentException(&quot;channels != 4&quot;);\n\n    Scalar min = new Scalar(MIN_H, MIN_S, MIN_V);\n    Scalar max = new Scalar(MAX_H, MAX_S, MAX_V);\n\n    Mat hsv = new Mat();\n    Imgproc.cvtColor(src, hsv, Imgproc.COLOR_BGR2HSV);\n\n    Mat mask = new Mat();\n    Core.inRange(hsv, min, max, mask);\n    hsv.release();\n\n    Mat dst = new Mat();\n    Imgproc.cvtColor(src, dst, Imgproc.COLOR_BGR2GRAY);\n    Imgproc.cvtColor(dst, dst, Imgproc.COLOR_GRAY2BGRA);\n\n    src.copyTo(dst, mask);\n    mask.release();\n\n    return dst;\n  }\n}\n</code></pre>\n<h2>Output</h2>\n<p>Here's a screenshot of the example running. The left image is the original bird image and the right image is the color-isolated image. Both images are contained in a OpenCV <code>Mat</code> and displayed using a <code>MemorySegment</code> plus <code>PixelBuffer</code>.</p>\n<p><a href=\"https://i.sstatic.net/rlzwVFkZ.jpg\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/rlzwVFkZ.jpg\" alt=\"Screenshot of example JavaFX application.\" /></a></p>\n",
    "score" : 5,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49884,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1759014993,
    "last_activity_date" : 1759435563,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140765333,
    "post_id" : 79776934,
    "body" : "I absolutely understand your point, and, of course, it doesn&#39;t make sense to start a background thread that will then be stopped by the <code>get()</code> method later. However, this code was directly copied from an old, early version of it. Now, it overrides the <code>setOnSucceeded()</code> method to display the image after the task finishes using <code>getValue()</code>. Thank you :)",
    "score" : 2,
    "owner" : {
      "account_id" : 12506291,
      "reputation" : 811,
      "user_id" : 9103039,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
      "display_name" : "Starnec",
      "link" : "https://stackoverflow.com/users/9103039/starnec"
    },
    "creation_date" : 1759087579,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140764898,
    "post_id" : 79776934,
    "body" : "Off topic, but why on earth would you go to all the trouble of creating a <code>Task</code> to convert the image, and run it in a background thread, only to block the current thread by calling <code>task.get()</code> as soon as you start the new thread. If you’re going to do that, you may as well just do the conversion in the current thread and eliminate a whole bunch of unnecessary complexity.",
    "score" : 5,
    "owner" : {
      "account_id" : 2518243,
      "reputation" : 210906,
      "user_id" : 2189127,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
      "display_name" : "James_D",
      "link" : "https://stackoverflow.com/users/2189127/james-d"
    },
    "creation_date" : 1759069141,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140764155,
    "post_id" : 79776934,
    "body" : "@Slaw, it does not matter by which number I multiply (4 will also cause the fatal error as well)",
    "score" : 0,
    "owner" : {
      "account_id" : 12506291,
      "reputation" : 811,
      "user_id" : 9103039,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
      "display_name" : "Starnec",
      "link" : "https://stackoverflow.com/users/9103039/starnec"
    },
    "creation_date" : 1759006341,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140764150,
    "post_id" : 79776934,
    "body" : "For this line: <code>int length = width * height * 6</code>. May I ask why you&#39;re multiplying by <code>6</code> here? The reason my answer to your previous question multiplied by <code>4</code> is because the pixel format being used expects 4 channels (BGRA). Your code acts as if there are 6 channels. The number of bytes is <code>imageWidth * imageHeight * numOfChannels</code>. And again, the JavaFX API being used here expects the pixel format to have 4 channels in BGRA order. Multiplying by 6 instead of 4 may mean the <code>MemorySegment</code> is too large, letting Java go out-of-bounds leading to a segmentation fault.",
    "score" : 2,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49884,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1759006153,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140764046,
    "post_id" : 79776934,
    "body" : "context: (1) <a href=\"https://stackoverflow.com/questions/79774713/converting-an-opencv-mat-to-a-javafx-image-not-working-when-using-bytebuffer-and\" title=\"converting an opencv mat to a javafx image not working when using bytebuffer and\">stackoverflow.com/questions/79774713/&hellip;</a> (2) <a href=\"https://stackoverflow.com/questions/79771565/bufferedimage-vs-matofbyte-for-converting-an-opencv-matrix-to-a-javafx-image\" title=\"bufferedimage vs matofbyte for converting an opencv matrix to a javafx image\">stackoverflow.com/questions/79771565/&hellip;</a>",
    "score" : 2,
    "owner" : {
      "account_id" : 3072614,
      "reputation" : 16436,
      "user_id" : 2602877,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/c76ea7b35660e77624550130276c61d3?s=256&d=identicon&r=PG",
      "display_name" : "Christoph Rackwitz",
      "link" : "https://stackoverflow.com/users/2602877/christoph-rackwitz"
    },
    "creation_date" : 1758999647,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79777047" : [ {
      "comment_id" : 140770814,
      "post_id" : 79777047,
      "body" : "Thank you, @Slaw. Yes I just checked the <a href=\"https://openjfx.io/javadoc/25/javafx.graphics/javafx/scene/image/PixelWriter.html#setPixels%28int,int,int,int,javafx.scene.image.PixelFormat,T,int%29\" rel=\"nofollow noreferrer\">doc</a>: <code>scanlineStride - the distance between the pixel data for the start of one row of data in the buffer to the start of the next row of data.</code> Which means we have to multiply the <code>width</code> by the <code>number of channels</code> to make a hop and start at the new offset.",
      "score" : 0,
      "owner" : {
        "account_id" : 12506291,
        "reputation" : 811,
        "user_id" : 9103039,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
        "display_name" : "Starnec",
        "link" : "https://stackoverflow.com/users/9103039/starnec"
      },
      "creation_date" : 1759316096,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140768529,
      "post_id" : 79777047,
      "body" : "@Starnec I updated my answer as I believe I narrowed down the problem in your &quot;strange results&quot; cases.",
      "score" : 2,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49884,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1759228978,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140765413,
      "post_id" : 79777047,
      "body" : "you are a lifesaver. It works now just perfectly. I will update the code later so it can follow your answer. I will also recheck if this is the reason why the strange behavior is occurring with the <code>ByteBuffer</code> approach as well. Finally, I will conduct a comprehensive comparison of all four approaches in terms of both RAM efficiency and execution speed. At first glance, it appears that using <code>MemorySegment</code> is significantly faster and more efficient, with approximately 40 MB of memory saved. Thank you for your time, really appreciate it.",
      "score" : 2,
      "owner" : {
        "account_id" : 12506291,
        "reputation" : 811,
        "user_id" : 9103039,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
        "display_name" : "Starnec",
        "link" : "https://stackoverflow.com/users/9103039/starnec"
      },
      "creation_date" : 1759092947,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140765399,
      "post_id" : 79777047,
      "body" : "See updated code (<a href=\"https://stackoverflow.com/revisions/79777047/4\">diff</a>). It should now work with 3-channel source images (e.g., JPEGs). I put that <code>Imgproc.COLOR_BGR2BGRA</code> conversion in <code>readImageIntoMat</code>.",
      "score" : 2,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49884,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1759091928,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140765382,
      "post_id" : 79777047,
      "body" : "Yes, absolutely, this is what the <a href=\"https://imgur.com/4kFUav5\" rel=\"nofollow noreferrer\">result</a> look like, and this is the <a href=\"https://imgur.com/0TfmBLq\" rel=\"nofollow noreferrer\">used</a> image. That is after adding this line <code>lineImgproc.cvtColor(mat, mat, Imgproc.COLOR_BGR2BGRA)</code>in the <code>if (mat.channels() != 4)</code>of the <code>matToImage(Mat mat)</code> method you provided.",
      "score" : 1,
      "owner" : {
        "account_id" : 12506291,
        "reputation" : 811,
        "user_id" : 9103039,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
        "display_name" : "Starnec",
        "link" : "https://stackoverflow.com/users/9103039/starnec"
      },
      "creation_date" : 1759090570,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140765371,
      "post_id" : 79777047,
      "body" : "@Starnec Yes, <code>PixelBuffer</code> requires 4 channels. If your image doesn&#39;t have 4 channels then you&#39;ll have to make it have 4 channels if you want to use <code>PixelBuffer</code>. Can you provide an image where my example results in black instead of gray?",
      "score" : 1,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49884,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1759089919,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140765337,
      "post_id" : 79777047,
      "body" : "Thank you for your answer, but the code only works with images that have 4 channels. And I see the limitation since the <code>PixelFormat</code> accepts only two 4-channel options. in the <code>if (mat.channels() != 4)</code> I added the <code>lineImgproc.cvtColor(mat, mat, Imgproc.COLOR_BGR2BGRA)</code> , it works but now the supposed-to-be-grey pixels are in black",
      "score" : 0,
      "owner" : {
        "account_id" : 12506291,
        "reputation" : 811,
        "user_id" : 9103039,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
        "display_name" : "Starnec",
        "link" : "https://stackoverflow.com/users/9103039/starnec"
      },
      "creation_date" : 1759087751,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}