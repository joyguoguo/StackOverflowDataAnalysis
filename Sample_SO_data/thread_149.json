{
  "question" : {
    "question_id" : 79831835,
    "title" : "Need help understanding why this Locksupport.park hangs indefinitely",
    "body" : "<p>I have the below code (whole code is <a href=\"https://github.com/grpc/grpc-java/blob/master/stub/src/main/java/io/grpc/stub/ClientCalls.java\" rel=\"nofollow noreferrer\">here</a>) that polls a queue for runnables and parks itself if the queue is empty.</p>\n<pre><code>public void waitAndDrain() throws InterruptedException {\n  throwIfInterrupted();\n  Runnable runnable = poll();\n  if (runnable == null) {\n    waiter = Thread.currentThread();\n    try {\n      while ((runnable = poll()) == null) {\n        LockSupport.park(this);\n        throwIfInterrupted();\n      }\n    } finally {\n      waiter = null;\n    }\n  }\n  do {\n    runQuietly(runnable);\n  } while ((runnable = poll()) != null);\n}\n</code></pre>\n<p>And the code that does unpark</p>\n<pre><code>public void execute(Runnable runnable) {\n  add(runnable);\n  Object waiter = this.waiter;\n  if (waiter != SHUTDOWN) {\n    LockSupport.unpark((Thread) waiter); // no-op if null\n  } else if (remove(runnable) &amp;&amp; rejectRunnableOnExecutor) {\n    throw new RejectedExecutionException();\n  }\n}\n</code></pre>\n<p>If unparks happen in succession, the lost permits are not a problem because the code that unparks also enqueues runnables, and the reader code only parks itself if the queue is not empty.\nBefore you point me to the &quot;else if&quot; block in the unpacking code that looks suspicious, let me point out that this is not an issue, for the &quot;waitor&quot; variable is only ever set to SHUTDOWN <a href=\"https://github.com/grpc/grpc-java/blob/02e98a806d4738a113519115d55fc242243e98d6/stub/src/main/java/io/grpc/stub/ClientCalls.java#L173C16-L173C24\" rel=\"nofollow noreferrer\">here</a> (could have been a private method, need not have been public) after the loop that polls the queue terminates, so if it set the waitor to SHUTDOWN, there is no chance of parking again.\nHowever our customer has reported that occasionally the application gets stuck with the parking thread waiting in the parked state:</p>\n<pre><code>    &quot;Test worker&quot; #1 prio=5 os_prio=0 cpu=68854.65ms elapsed=51528.48s tid=0x0000ffffb40311a0 nid=0x321d1c waiting on condition  [0x0000ffffb99fb000]\n   java.lang.Thread.State: WAITING (parking)\n    at jdk.internal.misc.Unsafe.park(java.base@17.0.15/Native Method)\n    - parking to wait for  &lt;0x00000000d69d5a18&gt; (a io.xxxx.stub.ClientCalls$ThreadlessExecutor)\n    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:211)\n    at io.xxxx.stub.ClientCalls$ThreadlessExecutor.waitAndDrain(ClientCalls.java:817)\n    at io.xxxx.stub.ClientCalls.blockingUnaryCall(ClientCalls.java:166)\n    ...\n</code></pre>\n<p>I have been splitting hairs unable to come up with a scenario that could cause this. Any idea is much appreciated.</p>\n",
    "tags" : [ "java", "concurrency", "thread-synchronization" ],
    "owner" : {
      "account_id" : 218143,
      "reputation" : 225,
      "user_id" : 474323,
      "user_type" : "registered",
      "accept_rate" : 39,
      "profile_image" : "https://www.gravatar.com/avatar/851b7fa17e397da1ccbd23071404e749?s=256&d=identicon&r=PG",
      "display_name" : "Kannan J",
      "link" : "https://stackoverflow.com/users/474323/kannan-j"
    },
    "is_answered" : false,
    "view_count" : 68,
    "answer_count" : 1,
    "score" : 1,
    "last_activity_date" : 1764676052,
    "creation_date" : 1764256793,
    "link" : "https://stackoverflow.com/questions/79831835/need-help-understanding-why-this-locksupport-park-hangs-indefinitely",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ ],
  "answer_comments" : { }
}