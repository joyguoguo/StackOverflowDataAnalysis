{
  "question" : {
    "question_id" : 79610079,
    "title" : "Common parent of DefaultMutableTreeNode collection",
    "body" : "<p>Can I find a common parent node of a collection of <code>DefualtMutableTreeNodes</code>?</p>\n<p>OOB ways to achieve that, if any, are preferred. That includes standard as well as external libraries.</p>\n<p>If it's not already available, the solution should be as readable and concise as possible (reducing the maintenance overhead). It shouldn't be too expensive too, if possible.</p>\n<p>Swing, Java 8.</p>\n<pre class=\"lang-java prettyprint-override\"><code>    @Test\n    // it should be split into at least two tests, but it'll do\n    void findCommonParent_returnsExpectedNode() {\n        /*\n        a____b\n        |____c____d\n        |____e____f\n        |    |____g____h____i\n        |         |____j\n        |____k\n         */\n        JTree tree = new JTree();\n        DefaultMutableTreeNode rootNodeA = new DefaultMutableTreeNode(&quot;a&quot;);\n        DefaultMutableTreeNode nodeB = new DefaultMutableTreeNode(&quot;b&quot;);\n        DefaultMutableTreeNode nodeC = new DefaultMutableTreeNode(&quot;c&quot;);\n        DefaultMutableTreeNode nodeD = new DefaultMutableTreeNode(&quot;d&quot;);\n        DefaultMutableTreeNode nodeE = new DefaultMutableTreeNode(&quot;e&quot;);\n        DefaultMutableTreeNode nodeF = new DefaultMutableTreeNode(&quot;f&quot;);\n        DefaultMutableTreeNode nodeG = new DefaultMutableTreeNode(&quot;g&quot;);\n        DefaultMutableTreeNode nodeH = new DefaultMutableTreeNode(&quot;h&quot;);\n        DefaultMutableTreeNode nodeI = new DefaultMutableTreeNode(&quot;i&quot;);\n        DefaultMutableTreeNode nodeJ = new DefaultMutableTreeNode(&quot;j&quot;);\n        DefaultMutableTreeNode nodeK = new DefaultMutableTreeNode(&quot;k&quot;);\n        nodeC.add(nodeD);\n        nodeE.add(nodeF);\n        nodeE.add(nodeG);\n        nodeG.add(nodeH);\n        nodeG.add(nodeJ);\n        nodeH.add(nodeI);\n        rootNodeA.add(nodeB);\n        rootNodeA.add(nodeC);\n        rootNodeA.add(nodeE);\n        rootNodeA.add(nodeK);\n        DefaultTreeModel model = new DefaultTreeModel(rootNodeA);\n        tree.setModel(model);\n\n        Optional&lt;DefaultMutableTreeNode&gt; commonParentOptional = findCommonParent(Arrays.asList(nodeF, nodeJ));\n        assertTrue(commonParentOptional.isPresent());\n        assertEquals(nodeE, commonParentOptional.get());\n\n        Optional&lt;DefaultMutableTreeNode&gt; anotherCommonParentOptional = findCommonParent(Arrays.asList(nodeF, new DefaultMutableTreeNode()));\n        assertFalse(anotherCommonParentOptional.isPresent());\n    }\n\n    Optional&lt;DefaultMutableTreeNode&gt; findCommonParent(List&lt;DefaultMutableTreeNode&gt; nodes) {\n        // your implementation goes here\n    }\n</code></pre>\n",
    "tags" : [ "java", "swing" ],
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2681,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "is_answered" : true,
    "view_count" : 132,
    "answer_count" : 3,
    "score" : 1,
    "last_activity_date" : 1747121027,
    "creation_date" : 1746605857,
    "link" : "https://stackoverflow.com/questions/79610079/common-parent-of-defaultmutabletreenode-collection",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79610341,
    "question_id" : 79610079,
    "body" : "<p>I've done this before with common sub classes of 2 classes, the trick is to check if one is the parent of another. If true then you found your match, otherwise let both sides go up one level.</p>\n<pre class=\"lang-java prettyprint-override\"><code>    Optional&lt;DefaultMutableTreeNode&gt; findCommonParent(List&lt;DefaultMutableTreeNode&gt; nodes) {\n        return nodes.stream()\n                .reduce(\n                        Optional.&lt;DefaultMutableTreeNode&gt;empty(),\n                        (optional, node) -&gt; optional.or(() -&gt; Optional.of(node)).flatMap(n -&gt; findCommonParent(n, node)),\n                        (optional1, optional2) -&gt; optional1.or(() -&gt; optional2));\n    }\n\n    private Optional&lt;DefaultMutableTreeNode&gt; findCommonParent(DefaultMutableTreeNode node1, DefaultMutableTreeNode node2) {\n        DefaultMutableTreeNode n1 = node1;\n        DefaultMutableTreeNode n2 = node2;\n        while (n1 != null &amp;&amp; n2 != null) {\n            if (n1 == n2 || n1 == n2.getParent()) {\n                return Optional.of(n1);\n            }\n            if (n2 == n1.getParent()) {\n                return Optional.of(n2);\n            }\n            n1 = (DefaultMutableTreeNode) n1.getParent();\n            n2 = (DefaultMutableTreeNode) n2.getParent();\n        }\n        return Optional.empty();\n    }\n</code></pre>\n<p>I don't really like that second argument to <code>reduce</code> though, as it will call the private <code>findCommonParent(n, n)</code> if the original <code>Optional</code> is empty. A small refactor to not use <code>reduce</code> or <code>Optional</code> for the private method:</p>\n<pre class=\"lang-java prettyprint-override\"><code>    Optional&lt;DefaultMutableTreeNode&gt; findCommonParent(List&lt;DefaultMutableTreeNode&gt; nodes) {\n        if (nodes.isEmpty()) {\n            return Optional.empty();\n        }\n        Iterator&lt;DefaultMutableTreeNode&gt; iterator = nodes.iterator();\n        DefaultMutableTreeNode common = iterator.next();\n        while (iterator.hasNext() &amp;&amp; common != null) {\n            DefaultMutableTreeNode node = iterator.next();\n            common = findCommonParent(common, node);\n        }\n        return Optional.ofNullable(common);\n    }\n\n    private DefaultMutableTreeNode findCommonParent(DefaultMutableTreeNode node1, DefaultMutableTreeNode node2) {\n        DefaultMutableTreeNode n1 = node1;\n        DefaultMutableTreeNode n2 = node2;\n        while (n1 != null &amp;&amp; n2 != null) {\n            if (n1 == n2 || n1 == n2.getParent()) {\n                return n1;\n            }\n            if (n2 == n1.getParent()) {\n                return n2;\n            }\n            n1 = (DefaultMutableTreeNode) n1.getParent();\n            n2 = (DefaultMutableTreeNode) n2.getParent();\n        }\n        return null;\n    }\n</code></pre>\n<p>Edit: a fix that also works for multiple levels. With this fix, for several nodes I correctly get the root node, and with input nodes f, i and j I correctly get node e.</p>\n<pre class=\"lang-java prettyprint-override\"><code>    private DefaultMutableTreeNode findCommonParent(DefaultMutableTreeNode node1, DefaultMutableTreeNode node2) {\n        DefaultMutableTreeNode n1 = node1;\n        DefaultMutableTreeNode n2 = node2;\n        while (n1 != null &amp;&amp; n2 != null) {\n            if (n1 == n2 || n1 == n2.getParent()) {\n                return n1;\n            }\n            if (n2 == n1.getParent()) {\n                return n2;\n            }\n            int level1 = n1.getLevel();\n            int level2 = n2.getLevel();\n            if (level1 &gt; level2) {\n                n1 = (DefaultMutableTreeNode) n1.getParent();\n            } else if (level2 &gt; level1) {\n                n2 = (DefaultMutableTreeNode) n2.getParent();\n            } else {\n                // same level\n                n1 = (DefaultMutableTreeNode) n1.getParent();\n                n2 = (DefaultMutableTreeNode) n2.getParent();\n            }\n        }\n        return null;\n    }\n</code></pre>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1211967,
      "reputation" : 9964,
      "user_id" : 1180351,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
      "display_name" : "Rob Spoor",
      "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
    },
    "creation_date" : 1746614267,
    "last_activity_date" : 1746645670,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79611085,
    "question_id" : 79610079,
    "body" : "<p>This is a simple translation of an answer for the similar question for <a href=\"https://stackoverflow.com/questions/54595752/find-the-longest-path-common-to-two-paths-in-java/70381752\">file system paths</a>.</p>\n<pre><code>static TreeNode findCommonParent(TreeNode a, TreeNode b) {\n    return parentsOf(a)\n            .filter(parentsOf(b).collect(Collectors.toSet())::contains)\n            // OR .filter(parent -&gt; parentsOf(b).anyMatch(parent::equals))                    \n            .findFirst().orElse(null);\n}\nprivate static Stream&lt;TreeNode&gt; parentsOf(TreeNode a) {\n    return Stream.iterate(a, Objects::nonNull, TreeNode::getParent);\n}\n</code></pre>\n<p>You can apply this operation to a list simply by adding a collector <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/stream/Collectors.html#reducing(java.util.function.BinaryOperator)\" rel=\"nofollow noreferrer\">reducing</a>:</p>\n<pre><code>// Assumes above method is in class Whatever\nstatic Optional&lt;TreeNode&gt; findCommonParent(List&lt;? extends TreeNode&gt; list) {\n    return list.stream()\n              .collect(Collectors.reducing(Whatever::findCommonParent));\n}\n</code></pre>\n<p>Quick tests:</p>\n<pre><code>var paths = new LinkedHashMap&lt;DefaultMutableTreeNode,DefaultMutableTreeNode&gt;();\npaths.put(rootNodeA, nodeG);\npaths.put(nodeE, nodeF);\npaths.put(nodeF, nodeG);\npaths.put(nodeI, nodeJ);\n\npaths.forEach((k, v) -&gt; {\n    System.out.println(&quot;findCommonParent(&quot;+k + &quot;,&quot; + v + &quot;) =&gt; &quot; + findCommonParent(k, v));\n});\n</code></pre>\n<p>Prints:</p>\n<pre><code>findCommonParent(a,g) =&gt; a\nfindCommonParent(e,f) =&gt; e\nfindCommonParent(f,g) =&gt; e\nfindCommonParent(i,j) =&gt; g\n</code></pre>\n<p>There will be a more efficient version with for/while loop avoiding the double use of stream, though at worst case it scans both hierarchies of a,b once.</p>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 5998820,
      "reputation" : 16283,
      "user_id" : 4712734,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f6e922a2cb7e2da59286f27b162aaca5?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "DuncG",
      "link" : "https://stackoverflow.com/users/4712734/duncg"
    },
    "creation_date" : 1746637918,
    "last_activity_date" : 1747121027,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79612858,
    "question_id" : 79610079,
    "body" : "<p>I think this is the best complete solution, based on the two previous answers:</p>\n<pre class=\"lang-java prettyprint-override\"><code>    Optional&lt;DefaultMutableTreeNode&gt; findCommonParent(List&lt;DefaultMutableTreeNode&gt; nodes) {\n        if (nodes.isEmpty()) {\n            return Optional.empty();\n        }\n        Iterator&lt;DefaultMutableTreeNode&gt; iterator = nodes.iterator();\n        DefaultMutableTreeNode common = iterator.next();\n        while (iterator.hasNext() &amp;&amp; common != null) {\n            DefaultMutableTreeNode node = iterator.next();\n            common = (DefaultMutableTreeNode) findCommonParent(common, node);\n        }\n        return Optional.ofNullable(common);\n    }\n\n    private TreeNode findCommonParent(TreeNode a, TreeNode b) {\n        return parentsOf(a)\n                .filter(parent -&gt; parentsOf(b).anyMatch(parent::equals))                    \n                .findFirst().orElse(null);\n    }\n\n    private static Stream&lt;TreeNode&gt; parentsOf(TreeNode a) {\n        return Stream.iterate(a, Objects::nonNull, TreeNode::getParent);\n    }\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 1211967,
      "reputation" : 9964,
      "user_id" : 1180351,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
      "display_name" : "Rob Spoor",
      "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
    },
    "creation_date" : 1746723735,
    "last_activity_date" : 1746723735,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140404918,
    "post_id" : 79610079,
    "body" : "There is a similar question for <a href=\"https://stackoverflow.com/questions/54595752/find-the-longest-path-common-to-two-paths-in-java/70381752\">file system paths</a>",
    "score" : 0,
    "owner" : {
      "account_id" : 5998820,
      "reputation" : 16283,
      "user_id" : 4712734,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f6e922a2cb7e2da59286f27b162aaca5?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "DuncG",
      "link" : "https://stackoverflow.com/users/4712734/duncg"
    },
    "creation_date" : 1746635127,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79611085" : [ {
      "comment_id" : 140408388,
      "post_id" : 79611085,
      "body" : "I prefer your first solution. The update always traverses the full inner tree to collect to a set, where the <code>anyMatch</code> will short-circuit as soon as a match is found. I think the complexity is the same as for my answer, which makes your answer nicer to read. Note that you still have to implement the overload that takes a <code>List&lt;DefaultMutableTreeNode&gt;</code>, so I think the final solution would be your methods for the common parent of two nodes, and my method for combining that method for all list elements.",
      "score" : 0,
      "owner" : {
        "account_id" : 1211967,
        "reputation" : 9964,
        "user_id" : 1180351,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
        "display_name" : "Rob Spoor",
        "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
      },
      "creation_date" : 1746720926,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140406823,
      "post_id" : 79611085,
      "body" : "@RobSpoor Fixed by using set in the filter, so it visits all parents of b once only plus up to all parents of a that don&#39;t match bs.",
      "score" : 0,
      "owner" : {
        "account_id" : 5998820,
        "reputation" : 16283,
        "user_id" : 4712734,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/f6e922a2cb7e2da59286f27b162aaca5?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "DuncG",
        "link" : "https://stackoverflow.com/users/4712734/duncg"
      },
      "creation_date" : 1746691818,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140405434,
      "post_id" : 79611085,
      "body" : "I like your solution, but it&#39;s indeed not efficient with the double loop. My fixed solution is probably a bit better; it still goes up all parents for the <code>getLevel()</code> call, but it doesn&#39;t go through all parents of <code>b</code> for each parent of <code>a</code>.",
      "score" : 0,
      "owner" : {
        "account_id" : 1211967,
        "reputation" : 9964,
        "user_id" : 1180351,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
        "display_name" : "Rob Spoor",
        "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
      },
      "creation_date" : 1746645886,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79610341" : [ {
      "comment_id" : 140408382,
      "post_id" : 79610341,
      "body" : "@DuncG I figured that as well. I thought it was just linear in the depth of the tree, but like your solution it&#39;s O(d) where <code>d</code> is the maximum depth.",
      "score" : 0,
      "owner" : {
        "account_id" : 1211967,
        "reputation" : 9964,
        "user_id" : 1180351,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
        "display_name" : "Rob Spoor",
        "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
      },
      "creation_date" : 1746720726,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140406825,
      "post_id" : 79610341,
      "body" : "Note that <code>getLevel</code> is a loop upwards, so this traverses hierarchy of a,b many times.",
      "score" : 0,
      "owner" : {
        "account_id" : 5998820,
        "reputation" : 16283,
        "user_id" : 4712734,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/f6e922a2cb7e2da59286f27b162aaca5?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "DuncG",
        "link" : "https://stackoverflow.com/users/4712734/duncg"
      },
      "creation_date" : 1746691897,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140405425,
      "post_id" : 79610341,
      "body" : "The code with <code>getLevel()</code> works with more inputs.",
      "score" : 0,
      "owner" : {
        "account_id" : 1211967,
        "reputation" : 9964,
        "user_id" : 1180351,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
        "display_name" : "Rob Spoor",
        "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
      },
      "creation_date" : 1746645739,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140405408,
      "post_id" : 79610341,
      "body" : "@DuncG I think you&#39;re right. My experience with classes used <code>isAssignableFrom</code>, so that works multiple levels deep. The unit tests succeeded so I thought that was that. I&#39;ll try to fix it, probably using <code>getLevel()</code>.",
      "score" : 0,
      "owner" : {
        "account_id" : 1211967,
        "reputation" : 9964,
        "user_id" : 1180351,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
        "display_name" : "Rob Spoor",
        "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
      },
      "creation_date" : 1746645388,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140404836,
      "post_id" : 79610341,
      "body" : "I&#39;ve not run it, but this does not look like it would work for when comparing 2 nodes more than one level apart? Example (a, g) =&gt; neither n1/n2 are parent of each other so n1:=a.parent/null and loop exits without finding a.",
      "score" : 0,
      "owner" : {
        "account_id" : 5998820,
        "reputation" : 16283,
        "user_id" : 4712734,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/f6e922a2cb7e2da59286f27b162aaca5?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "DuncG",
        "link" : "https://stackoverflow.com/users/4712734/duncg"
      },
      "creation_date" : 1746633454,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140404691,
      "post_id" : 79610341,
      "body" : "Sorry, I missed that. But the second option doesn&#39;t use it, and it looks cleaner as well.",
      "score" : 0,
      "owner" : {
        "account_id" : 1211967,
        "reputation" : 9964,
        "user_id" : 1180351,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
        "display_name" : "Rob Spoor",
        "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
      },
      "creation_date" : 1746631113,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140404285,
      "post_id" : 79610341,
      "body" : "There&#39;s no <code>Optional#or</code> in Java 8",
      "score" : 0,
      "owner" : {
        "account_id" : 10187542,
        "reputation" : 2681,
        "user_id" : 20692967,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
        "display_name" : "Sergey Zolotarev",
        "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
      },
      "creation_date" : 1746625106,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}