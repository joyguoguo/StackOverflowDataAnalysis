{
  "question" : {
    "question_id" : 79673261,
    "title" : "CachedBodyHttpServletRequest stopped working for multipart after springboot 3.X",
    "body" : "<p>I have created a filter to log all the api calls done to my rest endpoints and their responses:</p>\n<pre><code>@Order(value = Ordered.HIGHEST_PRECEDENCE)\n@Component\n@Slf4j\npublic class RequestResponseLoggingFilter extends OncePerRequestFilter {\n\n    @Autowired\n    RequestLoggingService loggingService;\n\n    @Autowired\n    @Qualifier(&quot;handlerExceptionResolver&quot;)\n    private HandlerExceptionResolver resolver;\n\n    @Autowired\n    private RequestMappingHandlerMapping reqMap;      \n\n    @Override\n    public void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws  IOException {\n\n        CachedBodyHttpServletRequest cachedBodyHttpServletRequest = new CachedBodyHttpServletRequest(httpServletRequest);\n        CachedBodyHttpServletResponse cachedBodyHttpServletResponse = new CachedBodyHttpServletResponse(httpServletResponse);\n        try {\n            filterChain.doFilter(cachedBodyHttpServletRequest, cachedBodyHttpServletResponse);\n        }catch (Exception ex){\n            log.error(&quot;Exception during rest call&quot;,ex);\n            resolver.resolveException(cachedBodyHttpServletRequest, cachedBodyHttpServletResponse, null, ex);\n        }\n        finally {\n            loggingService.logApiCall(cachedBodyHttpServletRequest, cachedBodyHttpServletResponse);\n            cachedBodyHttpServletResponse.copyBodyToResponse();\n        }\n   }\n\n}\n</code></pre>\n<p>As the data of the <code>HttpServletRequest InputStream</code> can only be read once, in order to be able to use the data in my endpoint resolvers <code>HandlerMethodArgumentResolver</code> I created a <code>CachedBodyHttpServletRequest</code>:</p>\n<pre><code>public class CachedBodyHttpServletRequest extends HttpServletRequestWrapper {\n\n    private byte[] cachedBody;\n\n    public CachedBodyHttpServletRequest(HttpServletRequest request) throws IOException {\n        super(request);\n        InputStream requestInputStream = request.getInputStream();\n        this.cachedBody = StreamUtils.copyToByteArray(requestInputStream);\n    }\n\n    @Override\n    public ServletInputStream getInputStream() {\n        return new CachedBodyServletInputStream(this.cachedBody);\n    }\n\n    @Override\n    public BufferedReader getReader() {\n        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(this.cachedBody);\n        return new BufferedReader(new InputStreamReader(byteArrayInputStream));\n    }\n\n}\n</code></pre>\n<p>And a <code>CachedBodyServletInputStream</code>:</p>\n<pre><code>@Slf4j\npublic class CachedBodyServletInputStream extends ServletInputStream {\n\n    private InputStream cachedBodyInputStream;\n\n    public CachedBodyServletInputStream(byte[] cachedBody) {\n        this.cachedBodyInputStream = new ByteArrayInputStream(cachedBody);\n    }\n\n    @Override\n    public boolean isFinished() {\n        try {\n            return cachedBodyInputStream.available() == 0;\n        } catch (IOException e) {\n            log.error(&quot;Error finishing InputStream &quot;,e);\n        }\n        return false;\n    }\n\n    @Override\n    public boolean isReady() {\n        return true;\n    }\n\n    @Override\n    public void setReadListener(ReadListener readListener) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public int read() throws IOException {\n        return cachedBodyInputStream.read();\n    }\n}\n</code></pre>\n<p>With this configuration done, I could define an endpoint expecting an UploadObject with a  HandlerMethodArgumentResolver defined for that object.</p>\n<pre><code>@PostMapping(path = &quot;/myEndpoint&quot;,consumes = {&quot;multipart/form-data&quot;,&quot;application/octet-stream&quot;,&quot;application/gzip&quot;,&quot;application/x-gzip&quot;}, produces = {&quot;application/json&quot;})\npublic @ResponseBody ResponseEntity&lt;?&gt; upload(@RequestParam Map&lt;String, String&gt; allRequestParams,\n                         @PathVariable Map&lt;String, String&gt; allPathVars,\n                         @RequestHeader Map&lt;String, String&gt; headers,\n                         UploadObject uploadObject) {\n\n    ...\n}\n\n@Component\npublic class UploadObjectResolver implements HandlerMethodArgumentResolver {          \n\n    public UploadObjectResolver() {\n       \n    }\n\n    @Override\n    public boolean supportsParameter(MethodParameter methodParameter) {\n        return methodParameter.getParameterType().equals(UploadObject.class);\n    }\n\n    @Override\n    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,\n            NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n\n\n        MultipartRequest multipartrequest = nativeWebRequest.getNativeRequest(MultipartRequest.class);\n        .....\n    }\n</code></pre>\n<p>This configuration, used to work fine in Springboot 2.X for Multipart requests, and the <code>MultipartRequest multipartrequest</code> could be logged in my <code>loggingService</code> and used in my Resolver. After upgrading to Springboot 3.X it seems that it can not detect my multiparts when executing:</p>\n<pre><code>@Override\npublic Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,\n        NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) throws Exception {\n\n\n    MultipartRequest multipartrequest = nativeWebRequest.getNativeRequest(MultipartRequest.class);\n    .....\n}\n</code></pre>\n<p><a href=\"https://i.sstatic.net/tI1gVJyf.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/tI1gVJyf.png\" alt=\"enter image description here\" /></a></p>\n<p>When I debug my Spring 2.X application and put a breakpoint in  <code>MultipartRequest multipartrequest = nativeWebRequest.getNativeRequest(MultipartRequest.class);</code>, the Object type has changed from DefaultMultipartHttpServletRequest to StandardMultipartHttpServletRequest in Springboot 3.X.</p>\n<p>¿Is there a way in springboot 3.X to Cache the multipart files in order to log them and to be able to use them in <code>HandlerMethodArgumentResolver</code>? ¿What has changed between both versions?</p>\n",
    "tags" : [ "java", "spring-boot" ],
    "owner" : {
      "account_id" : 9290832,
      "reputation" : 361,
      "user_id" : 6899327,
      "user_type" : "registered",
      "accept_rate" : 100,
      "profile_image" : "https://i.sstatic.net/S1xvb.jpg?s=256",
      "display_name" : "Jaime",
      "link" : "https://stackoverflow.com/users/6899327/jaime"
    },
    "is_answered" : false,
    "view_count" : 79,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1757602070,
    "creation_date" : 1750416651,
    "link" : "https://stackoverflow.com/questions/79673261/cachedbodyhttpservletrequest-stopped-working-for-multipart-after-springboot-3-x",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ ],
  "answer_comments" : { }
}