{
  "question" : {
    "question_id" : 79677995,
    "title" : "Does &quot;traversing&quot; a WeakReference require invocation of get()?",
    "body" : "<p>I'm interested in the <code>WeakReference</code> <em>specification</em>, not so much how to use it.</p>\n<p>The <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/ref/package-summary.html#reachability\" rel=\"nofollow noreferrer\">specification for the term &quot;weakly reachable&quot; says, in part</a>:</p>\n<blockquote>\n<p>An object is weakly reachable if it is neither strongly nor softly reachable but can be reached by <strong>traversing</strong> a weak reference.</p>\n</blockquote>\n<p>I am interested in what &quot;<strong>traversing</strong>&quot; means.</p>\n<p>The obvious conclusion is: to traverse a <code>WeakReference</code>, you call its <code>get()</code> method, yielding the referent. I understand that.</p>\n<p>But now suppose you subclass <code>WeakReference</code>, and (additionally) store the referent in an instance variable in the subclass:</p>\n<pre><code>public class Frob&lt;X&gt; extends WeakReference&lt;X&gt; {\n  private final X referent;\n  public Frob(X referent) {\n    super(referent);\n    this.referent = referent;\n  }\n  // ...\n}\n</code></pre>\n<p>Suppose further that at some point in the life of a program, the only remaining reference to the referent is this very instance variable (<code>this.referent</code> above).</p>\n<p>To &quot;get to&quot; this variable, you have to &quot;go through&quot; the <code>WeakReference</code> subclass (<code>Frob&lt;X&gt;</code>). Granted, this kind of navigation is not via the <code>get()</code> method. Does this nevertheless still constitute <strong>traversal</strong>?</p>\n",
    "tags" : [ "java" ],
    "owner" : {
      "account_id" : 72101,
      "reputation" : 16536,
      "user_id" : 208288,
      "user_type" : "registered",
      "accept_rate" : 67,
      "profile_image" : "https://www.gravatar.com/avatar/eac63f74d0e07c869a537771e24b0e6f?s=256&d=identicon&r=PG",
      "display_name" : "Laird Nelson",
      "link" : "https://stackoverflow.com/users/208288/laird-nelson"
    },
    "is_answered" : true,
    "view_count" : 75,
    "answer_count" : 1,
    "score" : 3,
    "last_activity_date" : 1750789887,
    "creation_date" : 1750786598,
    "link" : "https://stackoverflow.com/questions/79677995/does-traversing-a-weakreference-require-invocation-of-get",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79678054,
    "question_id" : 79677995,
    "body" : "<blockquote>\n<p>The obvious conclusion is: to traverse a <code>WeakReference</code>, you call its <code>get()</code> method, yielding the referent. I understand that.</p>\n</blockquote>\n<p>No.  This &quot;traverse&quot; is not something <em>you</em> do, or even that the VM does, per se.  It's part of an abstract description of characteristics of paths in a (notional) graph having objects as nodes and references of various kinds as directed edges. &quot;Traverse&quot; here evokes an analogy between a physical path and a &quot;path&quot; in the graph sense. We can imagine physically walking the path from one end to the other, traveling along -- &quot;traversing&quot; -- each edge in turn.  A path in a graph traverses all the edges belonging to it.  This is pretty idiomatic language for the domain.</p>\n<p>As it applies to reachability analysis,</p>\n<ul>\n<li><p>an object is strongly reachable if there is at least one path from a root to that object that consists entirely of edges representing strong references.  Or equivalently, that <em>traverses</em> only edges representing strong references.</p>\n</li>\n<li><p>an object is softly reachable if it is not strongly reachable, but there is at least one path from a root to that object that consists entirely of (traverses only) edges representing strong references or soft references.</p>\n</li>\n<li><p>an object is weakly reachable if it is not strongly or softly reachable, but there is at least one path from a root to that object that traverses only edges representing strong, soft, or weak references.</p>\n</li>\n<li><p>analogously for phantom references, except except that an object must be finalized before it becomes phantom reachable.</p>\n</li>\n</ul>\n<p>If an object is weakly reachable then invoking the <code>get()</code> method of a <code>WeakReference</code> to it gives you a <em>strong</em> reference.  That object is then strongly reachable, at least transiently, though it could become weakly reachable again later.</p>\n<blockquote>\n<p>But now suppose you subclass <code>WeakReference</code>, and (additionally) store the referent in an instance variable in the subclass</p>\n</blockquote>\n<p>Then the value stored in that instance variable, if not <code>null</code>, is a <em>strong</em> reference by definition.  That's the only kind of reference you can touch directly.  There is also a weak reference to the same object that is managed (in an unspecified manner) by the <code>Frob</code> / <code>WeakReference</code>.  The ability to manage a weak reference is a function of the implementation of <code>WeakReference</code> and of the garbage collector, not of the identity of the <code>WeakReference</code> class.</p>\n<p>Thus, if ...</p>\n<blockquote>\n<p>To &quot;get to&quot; this variable, you have to &quot;go through&quot; the <code>WeakReference</code> subclass (<code>Frob&lt;X&gt;</code>) [...]. Does this nevertheless still constitute traversal?</p>\n</blockquote>\n<p>That it is an object of a class descending from <code>WeakReference</code> that holds a <strong>strong</strong> reference to the object in question is immaterial.  It's still a strong reference that it holds.  If said reference object is itself strongly reachable, then any one of the existing paths of strong references that reaches it can be extended to a path of strong references that reaches the object in question, so that object is strongly reachable.</p>\n",
    "score" : 2,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1750789350,
    "last_activity_date" : 1750789887,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140539151,
    "post_id" : 79677995,
    "body" : "Right. I understand it is a strong reference. I wasn&#39;t clear whether <code>WeakReference</code> objects themselves, and whatever they refer to strongly, were treated specially or not. Sounds like an emphatic no.",
    "score" : 1,
    "owner" : {
      "account_id" : 72101,
      "reputation" : 16536,
      "user_id" : 208288,
      "user_type" : "registered",
      "accept_rate" : 67,
      "profile_image" : "https://www.gravatar.com/avatar/eac63f74d0e07c869a537771e24b0e6f?s=256&d=identicon&r=PG",
      "display_name" : "Laird Nelson",
      "link" : "https://stackoverflow.com/users/208288/laird-nelson"
    },
    "creation_date" : 1750789367,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140539088,
    "post_id" : 79677995,
    "body" : "To complete @S&#246;ren assertion, <code>this.referent</code> is a strong reference because it is a regular field of the Frob subclass. As far as I know, &quot;traversal&quot; in this context refers to how the GC walks the object graph via reference fields, not how the program accesses the referent (e.g., via <code>get()</code>).",
    "score" : 2,
    "owner" : {
      "account_id" : 209503,
      "reputation" : 23867,
      "user_id" : 460557,
      "user_type" : "registered",
      "accept_rate" : 100,
      "profile_image" : "https://www.gravatar.com/avatar/b4565f97815833390c9c880e9e8522e4?s=256&d=identicon&r=PG",
      "display_name" : "Jorge Campos",
      "link" : "https://stackoverflow.com/users/460557/jorge-campos"
    },
    "creation_date" : 1750787576,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140539059,
    "post_id" : 79677995,
    "body" : "That&#39;s a strong reference.",
    "score" : 4,
    "owner" : {
      "account_id" : 1888781,
      "reputation" : 2498,
      "user_id" : 1707427,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/4d1a2608ee35e2df7d2400a02e62bb20?s=256&d=identicon&r=PG",
      "display_name" : "S&#246;ren",
      "link" : "https://stackoverflow.com/users/1707427/s%c3%b6ren"
    },
    "creation_date" : 1750786957,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79678054" : [ {
      "comment_id" : 140539213,
      "post_id" : 79678054,
      "body" : "Right; so my only question was if &quot;the ability to manage a weak reference is a function of the implementation of <code>WeakReference</code> and of the garbage collector&quot;, then are strong references within instances of that class considered to be weakly reachable (how &quot;special&quot; is <code>WeakReference</code>?)? The overwhelming response here is: no.",
      "score" : 1,
      "owner" : {
        "account_id" : 72101,
        "reputation" : 16536,
        "user_id" : 208288,
        "user_type" : "registered",
        "accept_rate" : 67,
        "profile_image" : "https://www.gravatar.com/avatar/eac63f74d0e07c869a537771e24b0e6f?s=256&d=identicon&r=PG",
        "display_name" : "Laird Nelson",
        "link" : "https://stackoverflow.com/users/208288/laird-nelson"
      },
      "creation_date" : 1750791154,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}