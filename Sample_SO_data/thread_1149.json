{
  "question" : {
    "question_id" : 79738067,
    "title" : "Iterating over special semiprimes",
    "body" : "<p>For a project of mine related to prime counting, I am interested in iterating over special kind of semiprimes.</p>\n<p>For a given <code>n</code>, I want to iterate over semiprimes <code>k=pq</code> with the following properties/demands:</p>\n<ol>\n<li><code>k &lt;= n^(2/3)</code></li>\n<li><code>p,q</code> primes</li>\n<li><code>p&lt;q</code></li>\n<li><code>q &lt;= sqrt(n/p)</code></li>\n<li><code>p &lt;= cbrt(n)</code></li>\n<li>It is essential to be able to reconstruct <code>k,p,q</code> in constant time</li>\n</ol>\n<p>I want to emphasize that I am not interested in counting them, but rather to iterate over them/generate them, for some use.</p>\n<p>The best approach I could think of is a variation of the sieve of Eratosthenes. I am aiming for very large <code>n</code>, around <code>10^18</code> and possibly beyond after translating to <code>c++</code>, so it has to be a segmented sieve. It's also favorable in terms of space.</p>\n<p>With 13900k processor, the following code completes the task for <code>n=10^15</code> in 57 seconds while finding there are <code>144611615</code> such <code>k</code>:</p>\n<pre><code>import java.util.*;\n\npublic class Result {\n\n    static final int SEGMENT_SIZE = 1 &lt;&lt; 16;\n    \n    public static void main(String[] args) \n    {\n        long start = System.nanoTime();\n        \n        long n = (long) 1e15;\n        \n        System.out.println(S(n));\n        \n        long end = System.nanoTime();\n        System.out.println(&quot;Iteration complete in: &quot;+(end - start) / (1000000L) + &quot; ms&quot;);\n    }\n\n    static long S (long n)\n    {\n        long limit = n;\n        \n        long [] basePrimes = SoE((long) Math.cbrt(limit));\n        \n        long segstart = 0;\n        long seglim = (long) Math.pow(n , 2/3d);\n        \n        long [][] sieve = new long [2][SEGMENT_SIZE];\n        long count = 0;\n        \n        long low = segstart;\n        while (low &lt;= seglim)\n        {\n            long high = Math.min(low + SEGMENT_SIZE - 1, seglim);\n            long segLen = (int) (high - low + 1);\n            \n            Arrays.fill(sieve[0] , 1L);\n            Arrays.fill(sieve[1] , 0);\n            \n            long localsqrt = (long) Math.sqrt(high);\n\n            for (long p : basePrimes) \n            {\n                if (p &gt; localsqrt) break;\n\n                // mark multiples of p\n                long start = Math.max(((low + p - 1) / p) * p, p * p);\n                for (long m = start; m &lt;= high; m += p) {\n                    int idx = (int) (m - low);\n                    sieve[0][idx] *= p;\n                    sieve[1][idx] += 1;\n                }\n\n                // mark multiples of p^2 as non-squarefree\n                long p2 = p * p;\n                long start2 = ((low + p2 - 1) / p2) * p2;\n                for (long m = start2; m &lt;= high; m += p2)\n                {\n                    int idx = (int) (m - low);\n                    sieve[0][idx] = 0;\n                }\n            }\n            \n            // scan segment for semiprimes\n            for (int i = 0; i &lt; segLen ; i++) \n            {\n                long k = low + i;\n                if (sieve[1][i] != 1 || sieve[0][i] &lt;= 1) continue; // squarefree and exactly one small prime\n                long p = sieve[0][i];\n                long q = k / p;\n                if (q &gt; Math.sqrt(limit / p)) continue;\n\n                count++;\n            }\n            \n            low = high + 1;\n        }\n        \n        return count;\n    }\n    \n    \n    public static long [] SoE (long n)\n    {\n        if (n &lt; 2) return new long[0];\n\n        boolean[] isPrime = new boolean[(int)n + 1];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n\n        for (int i = 2; i * i &lt;= n; i++) {\n            if (!isPrime[i]) continue;\n            for (int j = i * i; j &lt;= n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n\n        int count = 0;\n        for (int i = 2; i &lt;= n; i++) if (isPrime[i]) count++;\n\n        long[] primes = new long[count];\n        int idx = 0;\n        for (int i = 2; i &lt;= n; i++) {\n            if (isPrime[i]) primes[idx++] = i;\n        }\n        return primes;\n    }\n    \n    \n}\n</code></pre>\n<p><strong>Explanation of the code:</strong></p>\n<ol>\n<li>For this task we're running a segmented sieve with a 2D array containing 2 rows. We initialize the first row with <code>1</code>'s and the second row with <code>0</code>s.</li>\n<li>The first row will indicate a running product of primes in the relevant integer's prime factorization</li>\n<li>The second row will be an indicator of the count of said primes in the above bullet</li>\n<li>For ever prime <code>p &lt;= cbrt(n)</code>, we start by marking multiples of all <code>p</code> that are <code>&gt;= p^2</code>, updating the above rows of the sieve.</li>\n<li>We then mark multiples of <code>p^2</code>: if an integer is a multiple of <code>p^2</code>, it will be irrelevant to us, so we mark the first row with <code>0</code>.</li>\n<li>At the end of this process, we have the following cases:</li>\n</ol>\n<ul>\n<li>If the first row is filled with <code>0</code>, this is not a suitable <code>k</code></li>\n<li>If the first row is filled with <code>1</code>, it means it's an integer whose smallest prime factor is <code>&gt; cbrt(n)</code>. This indicates it's not a valid <code>k</code> either.</li>\n<li>If the second row has a count <code>&gt; 2</code>, then it already has at least 3 prime factors, uninteresting either.</li>\n<li>What we're left with is integers with the second row <code>&lt;= 2</code>. The case of it equal to <code>0</code> is already omitted in the second case. So we're looking at the second row <code>=1 or 2</code>. If it's exactly <code>2</code>, we can check the first row to see the product of these <code>2</code> primes. If the first row is <strong>NOT</strong> equal to the current integer indicated by this column, this indicates that these <code>2</code> primes are not a complete factorization, and therefore it's not a valid <code>k</code>, because there is at least <code>1</code> more prime factor, so it's not a semiprime. If on the other hand it is equal, then we've found a valid <code>k</code>. However, with some math gymnastics it's possible to show that if it's equal to <code>2</code> at this point, this can't be a valid <code>k</code>: it must have additional factors.</li>\n<li>We're left with integers that have exactly <code>1</code> prime factor <code>p &lt;= cbrt(n)</code>, just like we wanted, because we've omitted the case of <code>0</code> and <code>&gt;= 2</code>. Note that primes have not been marked as well, because we've started marking multiples of primes <code>p</code> starting from <code>p^2</code>. This means that any prime will have its second row with <code>0</code>. And that's the last filter we needed. We now only have integers that have been marked with exactly <code>1</code> prime factor <code>p&lt;=cbrt(n)</code>, and they're not prime. Additionally, remember we're only iterating over integers <code>&lt;=n^(2/3)</code>, so they can't possibly have <code>2</code> or more prime factors <code>&gt;= cbrt(n)</code>. This means the integer we're currently on has exactly one additional prime factor <code>q</code>. So if we're iterating over such integer <code>k</code>, we can know <code>p</code> from the first row that was the running product. So we can easily deduce that <code>q = k / p</code>.</li>\n</ul>\n<p>With all this logic, we've successfully iterated over all such valid triplets of <code>k,p,q</code>. Note that we haven't checked the primality of <code>q</code>, so we've extracted it in <code>O(1)</code>.</p>\n<p><strong>What I am after:</strong></p>\n<p>I am posting this here because I am interested in suggestions about how to improve this code. Ideally, I want to perform this iteration much faster. I can parallelize it but multithreading is what I want to do last - first I want to improve the actual logic or come up with better schemes and algorithms for iteration.</p>\n<p>I have tried consulting some LLM's but they weren't even able to come up with any algorithm at all that actually copes with these demands. And really no useful insights.</p>\n<p>The end result is a highly optimized code for this iterating process, including parallelization. I am interested in any suggestions and recommendations of course. But ideally, I'd really love to see code (c++ / Java are favorable): in the end, the code I want to produce needs to run and faster than what I have. So if you suggest anything, I'd greatly appreciate if you actually checked it before recommending it, to not throw me in the wrong direction.</p>\n",
    "tags" : [ "java", "multithreading", "algorithm", "optimization" ],
    "owner" : {
      "account_id" : 15839337,
      "reputation" : 515,
      "user_id" : 11428287,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/8d555921e5e180565f61ac9a2ac7a678?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "MC From Scratch",
      "link" : "https://stackoverflow.com/users/11428287/mc-from-scratch"
    },
    "is_answered" : false,
    "view_count" : 257,
    "answer_count" : 0,
    "score" : 3,
    "last_activity_date" : 1755621325,
    "creation_date" : 1755459492,
    "link" : "https://stackoverflow.com/questions/79738067/iterating-over-special-semiprimes",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140691448,
    "post_id" : 79738067,
    "body" : "Nothing in what you&#39;ve written explains why you&#39;re sieving for <code>k</code> instead of just iterating all primes for <code>q</code> and then all primes <code>p &lt; q</code> to make <code>k=p*q</code> until they get too big.",
    "score" : 0,
    "owner" : {
      "account_id" : 7178634,
      "reputation" : 60910,
      "user_id" : 5483526,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/780a651189f64a2cbf4b7f62cf852005?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Matt Timmermans",
      "link" : "https://stackoverflow.com/users/5483526/matt-timmermans"
    },
    "creation_date" : 1756150084,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140691426,
    "post_id" : 79738067,
    "body" : "What does it mean to &quot;reconstruct k,p,q&quot;?",
    "score" : 0,
    "owner" : {
      "account_id" : 7178634,
      "reputation" : 60910,
      "user_id" : 5483526,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/780a651189f64a2cbf4b7f62cf852005?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Matt Timmermans",
      "link" : "https://stackoverflow.com/users/5483526/matt-timmermans"
    },
    "creation_date" : 1756149449,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140690816,
    "post_id" : 79738067,
    "body" : "This would be a great fit for <a href=\"https://codereview.stackexchange.com\">Code Review</a>!",
    "score" : 2,
    "owner" : {
      "account_id" : 3700957,
      "reputation" : 15676,
      "user_id" : 3080723,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/65b1ece9161b791b5a19d0582e177073?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Stef",
      "link" : "https://stackoverflow.com/users/3080723/stef"
    },
    "creation_date" : 1756132185,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140675564,
    "post_id" : 79738067,
    "body" : "I don&#39;t understqnd the closing votes. This question is about finding a faster algorithm, or a programming trick to have the current one run faster so it can scale. This is an interesting question, it&#39;s well written, and imho it&#39;s on topic to talk about algorithms. Maybe you don&#39;t find it interesting, but this is NOT a criterion to close a question.",
    "score" : 2,
    "owner" : {
      "account_id" : 10068177,
      "reputation" : 3202,
      "user_id" : 7442673,
      "user_type" : "registered",
      "accept_rate" : 100,
      "profile_image" : "https://i.sstatic.net/iTfit.jpg?s=256",
      "display_name" : "m.raynal - bye toxic community",
      "link" : "https://stackoverflow.com/users/7442673/m-raynal-bye-toxic-community"
    },
    "creation_date" : 1755589255,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140672414,
    "post_id" : 79738067,
    "body" : "You can drop the restriction for k, it follows by the ones for p and q. In other words you need to find all primes &lt;= max q and then multiply. Not much to exploit here. A fast algorithm to find primes is needed.",
    "score" : 0,
    "owner" : {
      "account_id" : 6136413,
      "reputation" : 9587,
      "user_id" : 4785110,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/71b70abe72497023835a6dd8961b7c89?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "maraca",
      "link" : "https://stackoverflow.com/users/4785110/maraca"
    },
    "creation_date" : 1755482731,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140672216,
    "post_id" : 79738067,
    "body" : "@ElliottFrisch I clearly stated that I am interested in much larger values of <code>n</code>. The result I gave is just a benchmark for comparison.",
    "score" : 2,
    "owner" : {
      "account_id" : 15839337,
      "reputation" : 515,
      "user_id" : 11428287,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/8d555921e5e180565f61ac9a2ac7a678?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "MC From Scratch",
      "link" : "https://stackoverflow.com/users/11428287/mc-from-scratch"
    },
    "creation_date" : 1755471775,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140672184,
    "post_id" : 79738067,
    "body" : "<i>how can I make this code faster</i> <b>Why</b>? You already found all <code>144611615</code> values of <code>k</code>. Why do you need to do it again?",
    "score" : 0,
    "owner" : {
      "account_id" : 3557625,
      "reputation" : 201916,
      "user_id" : 2970947,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/HLTev.png?s=256",
      "display_name" : "Elliott Frisch",
      "link" : "https://stackoverflow.com/users/2970947/elliott-frisch"
    },
    "creation_date" : 1755470019,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140672131,
    "post_id" : 79738067,
    "body" : "<i>&quot;To put simply, I ask &quot;how can I make this code faster&quot;. &quot;</i>  If your code works, and you want to improve it, you should consider moving it to <a href=\"https://codereview.stackexchange.com/tour\">Code Review</a>. Be sure to check out their requirement in deciding if the question is better there or here.",
    "score" : 6,
    "owner" : {
      "account_id" : 6606677,
      "reputation" : 1251,
      "user_id" : 5103317,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/c81d92487b054d7290b4f36562c0ee02?s=256&d=identicon&r=PG",
      "display_name" : "Old Dog Programmer",
      "link" : "https://stackoverflow.com/users/5103317/old-dog-programmer"
    },
    "creation_date" : 1755466370,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140672076,
    "post_id" : 79738067,
    "body" : "@MCFromScratch, my suggestion modifies the end result. I deleted it.",
    "score" : 1,
    "owner" : {
      "account_id" : 29816933,
      "reputation" : 2059,
      "user_id" : 22851022,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/JfMqJ6p2.png?s=256",
      "display_name" : "Konstantin Makarov",
      "link" : "https://stackoverflow.com/users/22851022/konstantin-makarov"
    },
    "creation_date" : 1755463748,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140672067,
    "post_id" : 79738067,
    "body" : "@JaMiT I don&#39;t understand your comments. To put simply, I ask &quot;how can I make this code faster&quot;. This is objectively unambiguous. People might have suggestions that either will or will not make it faster. Be it algorithmic changes or syntax edits. Maybe this can be done with fewer instructions or an entirely different algorithm that someone knows of from the literature. I don&#39;t see bad taste in it and I am not after brainstorming. Just consulting the community.",
    "score" : 1,
    "owner" : {
      "account_id" : 15839337,
      "reputation" : 515,
      "user_id" : 11428287,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/8d555921e5e180565f61ac9a2ac7a678?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "MC From Scratch",
      "link" : "https://stackoverflow.com/users/11428287/mc-from-scratch"
    },
    "creation_date" : 1755463270,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140672057,
    "post_id" : 79738067,
    "body" : "@KonstantinMakarov Thank you, I spotted it as well. But it can overflow rather quickly from either side though",
    "score" : 1,
    "owner" : {
      "account_id" : 15839337,
      "reputation" : 515,
      "user_id" : 11428287,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/8d555921e5e180565f61ac9a2ac7a678?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "MC From Scratch",
      "link" : "https://stackoverflow.com/users/11428287/mc-from-scratch"
    },
    "creation_date" : 1755462847,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140672048,
    "post_id" : 79738067,
    "body" : "<i>&quot;I&#39;d really love to see code (c++ / Java are favorable)&quot;</i> -- Please pick one language per question. Since your current code is Java, that seems like a good choice for the question.",
    "score" : 1,
    "owner" : {
      "account_id" : 13636391,
      "reputation" : 18610,
      "user_id" : 9837301,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/9414V.png?s=256",
      "display_name" : "JaMiT",
      "link" : "https://stackoverflow.com/users/9837301/jamit"
    },
    "creation_date" : 1755462354,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140672045,
    "post_id" : 79738067,
    "body" : "<i>&quot;I am interested in suggestions about how to improve this code.&quot;</i> -- Open-ended requests for suggestions are off-topic here. It seems like you are interested in a brain-storming session, which is not a good fit for a question-and-answer format.",
    "score" : 3,
    "owner" : {
      "account_id" : 13636391,
      "reputation" : 18610,
      "user_id" : 9837301,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/9414V.png?s=256",
      "display_name" : "JaMiT",
      "link" : "https://stackoverflow.com/users/9837301/jamit"
    },
    "creation_date" : 1755462270,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}