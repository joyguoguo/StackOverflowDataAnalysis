{
  "question" : {
    "question_id" : 79798851,
    "title" : "Java Thread interrupt non deterministic behaviour",
    "body" : "<p>I have this piece of code in Java and I tried it out on Java 21 (Eclipse Temurin and GraalVM)</p>\n<pre><code>public static void main(String[] args) {\n        Thread.currentThread().interrupt();\n\n        long start = System.currentTimeMillis();\n        System.out.println(&quot;started measuring ...&quot;);\n\n        int i = 0;\n\n        try (ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor()) {\n            List&lt;Future&lt;?&gt;&gt; futures = new ArrayList&lt;&gt;();\n            futures.add(executor.submit(() -&gt; &quot;api1&quot;));\n            futures.add(executor.submit(() -&gt; &quot;api2&quot;));\n            futures.add(executor.submit(() -&gt; &quot;api3&quot;));\n            for (; i &lt; futures.size(); i++) {\n                System.out.println((i + 1) + &quot; &quot; + futures.get(i).get());\n            }\n        } catch (ExecutionException e) {\n            System.out.println(&quot;error: &quot; + e.getCause());\n            throw new RuntimeException(e);\n        } catch (InterruptedException e) {\n            System.out.println(&quot;interrupted after &quot; + (System.currentTimeMillis() - start) + &quot; at &quot; + (i + 1));\n            throw new RuntimeException(e);\n        }\n    }\n</code></pre>\n<p>Sometimes the main thread does not get interrupted, sometimes it does. So the output is either:</p>\n<pre><code>started measuring ...\ninterrupted after 0 at 1\nException in thread &quot;main&quot; java.lang.RuntimeException: java.lang.InterruptedException\n        at rs.sf.App.main(App.java:70)\nCaused by: java.lang.InterruptedException\n        at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:471)\n        at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:190)\n        at rs.sf.App.main(App.java:63)\n</code></pre>\n<p>Or:</p>\n<pre><code>started measuring ...\n1 api1\n2 api2\n3 api3\n</code></pre>\n<p>I couldn't find what's the reason for this non-deterministic behavior. I thought that the first statement (the main thread setting the interrupt flag on itself) is executed before any other subsequent line of code and should therefore the execution should always result in <code>InterruptedException</code></p>\n<p>EDIT:</p>\n<p>If I write futures with a <code>Thread.sleep</code>, the behavior becomes deterministic and the <code>InterruptedException</code> is always thrown, i.e. like this:</p>\n<pre><code>futures.add(executor.submit(() -&gt; {\n        try {\n            Thread.sleep(500);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        return &quot;api1&quot;;\n    }));\n</code></pre>\n",
    "tags" : [ "java", "multithreading", "concurrency" ],
    "owner" : {
      "account_id" : 14819096,
      "reputation" : 69,
      "user_id" : 10702042,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/eb4e5cefedb48d6fa66438dea139eb78?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Sciotherium",
      "link" : "https://stackoverflow.com/users/10702042/sciotherium"
    },
    "is_answered" : true,
    "view_count" : 174,
    "answer_count" : 2,
    "score" : 2,
    "last_activity_date" : 1761492446,
    "creation_date" : 1761315668,
    "link" : "https://stackoverflow.com/questions/79798851/java-thread-interrupt-non-deterministic-behaviour",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79798888,
    "question_id" : 79798851,
    "body" : "<p>In your code, the main thread is always interrupted before calling <code>get()</code> on any of the futures. The non-deterministic output you're seeing is due to other factors.</p>\n<p>From the documentation of <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/Future.html#get()\" rel=\"nofollow noreferrer\"><code>Future::get()</code></a>:</p>\n<blockquote>\n<p>Waits <strong>if necessary</strong> <em>[emphasis added]</em> for the computation to complete, and then retrieves its result.</p>\n<h5>Returns:</h5>\n<p>the computed result</p>\n<h5>Throws:</h5>\n<p><code>CancellationException</code> - if the computation was cancelled</p>\n<p><code>ExecutionException</code> - if the computation threw an exception</p>\n<p><code>InterruptedException</code> - if the current thread was interrupted <strong>while waiting</strong> <em>[emphasis added]</em></p>\n</blockquote>\n<p>That means it's legal for <code>get()</code> to ignore the interrupt status of the calling thread if the <code>Future</code> is already done. Therefore the output of your code depends on how the threads are scheduled, which is non-deterministic. In other words, you have a race condition.</p>\n<p>Your tasks are very short. Thus, it's plausible for all of them to finish by the time the main thread calls <code>get()</code> on any of the futures. In that case you may not see an <code>InterruptedException</code>. But sometimes at least one task will <em>not</em> finish before the main thread calls <code>get()</code> on its future. And that's when you <em>will</em> see an <code>InterruptedException</code>.</p>\n<p>The fact adding a call to <code>sleep</code> in the tasks seemingly guarantees an <code>InterruptedException</code> supports this. It gives time for the main thread to call <code>get()</code> on one of the futures before they all finish. But it's still not deterministic; see <a href=\"https://stackoverflow.com/a/79798925/6395627\">John Bollinger's answer</a>.</p>\n<hr />\n<p>The <code>ExecutorService</code> returned by <code>newVirtualThreadPerTaskExecutor()</code> makes use of <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/FutureTask.html\" rel=\"nofollow noreferrer\"><code>FutureTask</code></a>. You can see <a href=\"https://github.com/openjdk/jdk/blob/cc9483b4da1a0f65f8773d0c7f35f2e6a7e1bd4f/src/java.base/share/classes/java/util/concurrent/FutureTask.java#L189\" rel=\"nofollow noreferrer\">its implementation</a> (at least in contemporary versions) doesn't check the interrupt status of the calling thread if the future is already done.</p>\n",
    "score" : 6,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49884,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1761317294,
    "last_activity_date" : 1761320590,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79798925,
    "question_id" : 79798851,
    "body" : "<blockquote>\n<p>I couldn't find what's the reason for this non-deterministic behavior.</p>\n</blockquote>\n<p>Simple: you have a race between your tasks completing and your main thread requesting their results.</p>\n<p>If a <code>Future</code>'s value is already available when the main thread requests it then it is successfully retrieved.  If not then, given that the main thread's interrupt status is set, attempting to retrieve the Future's value causes an <code>InterruptedException</code> to be thrown.</p>\n<blockquote>\n<p>I thought that the first statement (the main thread setting the interrupt flag on itself) is executed before any other subsequent line of code</p>\n</blockquote>\n<p>Yes, in that thread.</p>\n<blockquote>\n<p>and should therefore the execution should always result in InterruptedException</p>\n</blockquote>\n<p>No, <code>Future.get()</code> does not guarantee that.  <a href=\"https://stackoverflow.com/a/79798888/2402272\">Slaw's answer</a> explains this in more detail.</p>\n<blockquote>\n<p>EDIT:</p>\n<p>If I write futures with a Thread.sleep, the behavior becomes deterministic</p>\n</blockquote>\n<p><strong>No, it does not.</strong></p>\n<p>You still have exactly the same race as before, but in this case you have put your thumb on the scale to make it exceedingly unlikely (but not impossible) that the main thread loses to any of the executor threads.  That made your observations of the behavior <em>consistent</em>, but that's not the same as <em>deterministic</em>.</p>\n<p>I raise this in part because it is unfortunately common for inexperienced programmers to mistake methods for producing timing effects, such as <code>Thread.sleep()</code>, to be safe and effective for addressing synchronization problems.  They are not.</p>\n",
    "score" : 5,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1761319813,
    "last_activity_date" : 1761319813,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140815352,
    "post_id" : 79798851,
    "body" : "Hello Stefan, &quot;I thought that the first statement (the main thread setting the interrupt flag on itself) is executed before any other subsequent line of code&quot;, It seems not. Try adding after <b>Thread.currentThread().interrupt();</b> the line <b>Thread.sleep( 100 );</b>.",
    "score" : 0,
    "owner" : {
      "account_id" : 10843443,
      "reputation" : 916,
      "user_id" : 20882864,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/CCQCy.jpg?s=256",
      "display_name" : "Marce Puente",
      "link" : "https://stackoverflow.com/users/20882864/marce-puente"
    },
    "creation_date" : 1761316397,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140815340,
    "post_id" : 79798851,
    "body" : "<a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/Future.html#get()\" rel=\"nofollow noreferrer\"><code>Future::get()</code></a> says it throws an <code>InterruptedException</code> &quot;<i>if the current thread was interrupted <b>while waiting</i></b>&quot;. If all the futures are complete by the time you call <code>get</code> on any of them, then it&#39;s legal for them to return the result instead of throwing an interrupted exception.",
    "score" : 4,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49884,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1761316264,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140815333,
    "post_id" : 79798851,
    "body" : "Random guess: <code>FutureTask.get(...)</code> does not check the interrupt flag if there already is a result available (the fact of wether a result is available depends on how the JVM and OS schedules the main thread and the carrier threads, and is not guranteed to follow any rules whatsoever)",
    "score" : 0,
    "owner" : {
      "account_id" : 30223964,
      "reputation" : 252,
      "user_id" : 23162960,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/2451acfac254a6fc75757ecf89d75f9a?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Jannik S.",
      "link" : "https://stackoverflow.com/users/23162960/jannik-s"
    },
    "creation_date" : 1761316148,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79798925" : [ {
      "comment_id" : 140820493,
      "post_id" : 79798925,
      "body" : "“there is no such thing as ‘non-deterministic’ behavior” is not entirely correct. <i>John</i> is right in that in some areas, a certain language can have non-deterministic behaviors (usually associated with misuse). My statement should have been limited to this particular case, in which the first line of the method calls ** Thread.currentThread().interrupt(); ** is called, so one interprets that nothing after that call can be executed. If it does, the only possibility I see is that the “startup” of <b>interrupt()</b> comes after the calls to the other threads, and yes, I totally agree.",
      "score" : 0,
      "owner" : {
        "account_id" : 10843443,
        "reputation" : 916,
        "user_id" : 20882864,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/CCQCy.jpg?s=256",
        "display_name" : "Marce Puente",
        "link" : "https://stackoverflow.com/users/20882864/marce-puente"
      },
      "creation_date" : 1761571255,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140820163,
      "post_id" : 79798925,
      "body" : "@MarcePuente Since the outcome depends on the thread scheduling, we’d have to enumerate all possible influences on all relevant hardware configs and operating systems. This includes events like user input which may cause interrupts plus other processes/threads being rescheduled to handle the input and subtle timing issues which in turn even includes the room temperature as an influence, as most CPU can change their clock speed when they get too hot (or change it in smaller steps even before it gets too hot). Given those possible influences, I consider the term “non-deterministic“ justified.",
      "score" : 4,
      "owner" : {
        "account_id" : 3211603,
        "reputation" : 300981,
        "user_id" : 2711488,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
        "display_name" : "Holger",
        "link" : "https://stackoverflow.com/users/2711488/holger"
      },
      "creation_date" : 1761561121,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140815828,
      "post_id" : 79798925,
      "body" : "@MarcePuente The OP expresses confusion about the program is inconsistent with respect to whether an <code>InterruptedException</code> is thrown in the main thread.  Whether that&#39;s what they wanted or expected of the program is unspecified.  They attribute the inconsistency to indeterminism, which is a perfectly fine thing to do at the level of the Java language.  It cannot be determined from the Java language spec and the specifications of the various classes involved whether such an exception should be thrown.",
      "score" : 0,
      "owner" : {
        "account_id" : 2792262,
        "reputation" : 190832,
        "user_id" : 2402272,
        "user_type" : "registered",
        "accept_rate" : 85,
        "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
        "display_name" : "John Bollinger",
        "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
      },
      "creation_date" : 1761332765,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140815756,
      "post_id" : 79798925,
      "body" : "Hello Teacher, It is very likely that I have misinterpreted the question, but what I understood was that the <i>OP</i> wants an exception to be thrown (hence the call to <b>Thread.currentThread().interrupt();</b> in the first line), but since it&#39;s not immediate, sometimes the threads get executed, which is what he calls “non-deterministic behavior.” However, as we know, there&#39;s no such thing as “non-deterministic” behavior in machine hardware (except for hardware failures); every logical ‘1’ and “0” has a reason for being there.",
      "score" : 0,
      "owner" : {
        "account_id" : 10843443,
        "reputation" : 916,
        "user_id" : 20882864,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/CCQCy.jpg?s=256",
        "display_name" : "Marce Puente",
        "link" : "https://stackoverflow.com/users/20882864/marce-puente"
      },
      "creation_date" : 1761330214,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}