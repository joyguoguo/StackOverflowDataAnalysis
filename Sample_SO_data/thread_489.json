{
  "question" : {
    "question_id" : 79800214,
    "title" : "How to convert a database polling service to a Spring IntegrationFlow",
    "body" : "<p>I have a service that polls a database within a transaction, <em>always</em> removing the record and if an exception is thrown during processing <em>adds</em> a new record incrementing the 'try count' for that entry. It looks similar to this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Log4j2\n@Profile(&quot;simple&quot;)\n@EnableScheduling\n@Component\n@RequiredArgsConstructor\npublic class SimplePoller {\n    @Value(&quot;${outputDir}&quot;)\n    private final String outputDir;\n    private final NamedParameterJdbcTemplate template;\n\n    @Transactional\n    @Scheduled(fixedDelay = 1000)\n    void simplePoll() {\n        log.info(&quot;polling for file&quot;);\n        IncomingFile record = null;\n        try {\n            final List&lt;IncomingFile&gt; records = this.template.query(&quot;&quot;&quot;\n                delete from incoming_file where ir_id =\n                       (select ir_id from incoming_file\n                        where ir_try_count &lt; :tryMaxCount\n                        limit 1 for update skip locked)\n                returning ir_id, ir_path, ir_try_count\n                        &quot;&quot;&quot;,\n                Map.of(&quot;tryMaxCount&quot;, 3),\n                (rs, rowNum) -&gt; new IncomingFile(rs.getLong(&quot;ir_id&quot;), rs.getString(&quot;ir_path&quot;),rs.getInt(&quot;ir_try_count&quot;))\n            );\n            if (records.isEmpty()) {\n                return;\n            }\n            record = records.getFirst();\n            // Business logic which may throw an exception e.g. IOException\n            log.info(&quot;Finished processing {}&quot;, record.path());\n        } catch (Exception e) {\n            // Here the record is re-queued within the same transaction\n            this.template.update(&quot;&quot;&quot;\n                insert into incoming_file (ir_path, ir_try_count) values\n                (:path, :tryCount)\n                &quot;&quot;&quot;,\n                    Map.of(&quot;path&quot;, record.path(), &quot;tryCount&quot;, record.tryCount() + 1));\n        }\n\n    }\n\n    private record IncomingFile(long id, String path, int tryCount) {\n    }\n}\n</code></pre>\n<p>The key points to note are,</p>\n<ol>\n<li>Records are <em>always</em> removed from the table regardless if an exception is thrown or not.</li>\n<li>'Re-queueing' of a record occurs on the same thread and thus within the same transaction.</li>\n<li>The only time a transaction can roll back is if the process is stopped and the transaction is not successfully committed by the application.</li>\n</ol>\n<p>I'd like to model this using Spring Integration with IntegrationFlows:</p>\n<pre class=\"lang-java prettyprint-override\"><code>final JdbcPollingChannelAdapter adapter = new JdbcPollingChannelAdapter(jdbcOperationsProvider.getObject(),\n    &quot;&quot;&quot;\n    delete from incoming_file where ir_id =\n    (select ir_id from incoming_file\n    where ir_try_count &lt; :tryMaxCount\n    limit 1 for update skip locked)\n    returning ir_id, ir_path, ir_try_count\n    &quot;&quot;&quot;);\n    adapter.setSelectSqlParameterSource(new MapSqlParameterSource(&quot;tryMaxCount&quot;, this.maxTryCount));\n    adapter.setRowMapper((rs, rowNum) -&gt; new IncomingFile(\n            rs.getLong(&quot;ir_id&quot;),\n            rs.getString(&quot;ir_path&quot;),\n            rs.getInt(&quot;ir_try_count&quot;)\n     ));\n\n     final TransactionInterceptor interceptor = new TransactionInterceptorBuilder()\n         .transactionAttribute(new NoRollbackTransactionAttribute())\n         .transactionManager(transactionManager.getObject())\n         .build();\n     final StandardIntegrationFlow flow = IntegrationFlow\n         .from(adapter, c -&gt; c.poller(Pollers\n             .fixedRate(Duration.ofSeconds(2))\n             .maxMessagesPerPoll(-1)\n             .errorChannel(ERROR_CHANNEL)\n             .transactional(interceptor)\n             .taskExecutor(jdbcTaskExecutor)))\n         .transform(IncomingFile.class, incomingFile -&gt;\n              new GenericMessage&lt;&gt;(incomingFile.path(),\n                  Map.of(INCOMING_FILE_RECORD_ID, incomingFile.id(), INCOMING_FILE_RECORD_TRY_COUNT, incomingFile.tryCount())))\n         .handle(fileService)\n         .get();\n    final IntegrationFlowContext.IntegrationFlowRegistration register = flowContext.registration(flow).register();\n          this.registrationList.add(register);\n\n@Log4j2\nprivate static class NoRollbackTransactionAttribute extends DefaultTransactionAttribute {\n            @Override\n            public boolean rollbackOn(Throwable ex) {\n                final boolean isSpringException;\n                \n                if (ex instanceof MessagingExceptionWrapper mexw){\n                    isSpringException = mexw.getCause().getClass().getPackage().getName().startsWith(ORG_SPRINGFRAMEWORK);\n                    log.warn(&quot;MessagingWrapperException. {}, Exception type: {}&quot;, mexw.getCause().getMessage(), mexw.getCause().getClass());\n                    log.warn(&quot;Rollback: {}&quot;, isSpringException);\n                    return isSpringException;\n                }\n                isSpringException =  ex.getClass().getPackage().getName().startsWith(ORG_SPRINGFRAMEWORK);\n                log.warn(&quot;Exception&quot;, ex);\n                log.warn(&quot;Rollback: {}&quot;, isSpringException);\n                return isSpringException;\n            }\n\n</code></pre>\n<p>The main problem I am having is handling exceptions when they are thrown in the business logic i.e. in <code>fileService</code> and not losing 'messages' in the event of shutdown. I created the <code>NoRollbackTransactionAttribute</code> class in an attempt to determine what caused the exception. To match the non-spring-integration example, business logic exceptions should not roll back but should re-queue a message. Re-queueing would occur in the error handler. But the <code>rollbackOn()</code> method of <code>NotRollbackTransationAttribute</code> is called before the error handler making it difficult to determine the correct rollback action. Also in <code>NoRollBackTransactionAttribute</code> I've had to handle different Spring-specific exceptions which is not ideal. Overall this approach doesn't work well as I have found 'messages' can be lost during shutdown.</p>\n<p>Is there a better approach to model the original code using Spring integration?</p>\n",
    "tags" : [ "java", "spring", "spring-integration", "spring-integration-dsl" ],
    "owner" : {
      "account_id" : 322960,
      "reputation" : 7981,
      "user_id" : 642680,
      "user_type" : "registered",
      "accept_rate" : 74,
      "profile_image" : "https://i.sstatic.net/3yGtY.jpg?s=256",
      "display_name" : "D-Dᴙum",
      "link" : "https://stackoverflow.com/users/642680/d-d%e1%b4%99um"
    },
    "is_answered" : true,
    "view_count" : 149,
    "answer_count" : 1,
    "score" : 3,
    "last_activity_date" : 1762352315,
    "creation_date" : 1761500944,
    "link" : "https://stackoverflow.com/questions/79800214/how-to-convert-a-database-polling-service-to-a-spring-integrationflow",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79810190,
    "question_id" : 79800214,
    "body" : "<p>The <code>errorChannel</code> is used from the <code>ErrorHandlingTaskExecutor</code>. Which is indeed already after a transaction applied for that <code>task.run();</code> delegate internally.</p>\n<p>So, if you'd like to control the transaction outcome according to error, then you should consider to use other than <code>erorrChannel</code> mechanism. For example, catch an exception on the problematic endpoint using <code>ExpressionEvaluatingRequestHandlerAdvice</code>: <a href=\"https://docs.spring.io/spring-integration/reference/7.0/handler-advice/classes.html#expression-advice\" rel=\"nofollow noreferrer\">https://docs.spring.io/spring-integration/reference/7.0/handler-advice/classes.html#expression-advice</a>.</p>\n<p>Another way is to use a <code>gateway()</code> as a unit of work to handle a message and its error within the mentioned transaction. This way anything failing in sub-flow will be handled same <code>errorChannel</code> on the gateway.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 3273937,
      "reputation" : 122596,
      "user_id" : 2756547,
      "user_type" : "registered",
      "accept_rate" : 75,
      "profile_image" : "https://www.gravatar.com/avatar/2158ce6e7c048277890eb64458864c1c?s=256&d=identicon&r=PG",
      "display_name" : "Artem Bilan",
      "link" : "https://stackoverflow.com/users/2756547/artem-bilan"
    },
    "creation_date" : 1762352315,
    "last_activity_date" : 1762352315,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140836764,
    "post_id" : 79800214,
    "body" : "@ArtemBilan if I understand the Integrationflow correctly and the transaction boundaries, each poll and subsequent handling and error handling will occur on the same thread and this does seem to be born out through logging. The reason for the Executor is so that I can create several IntegrationFlows and register them individually, one per thread i.e. I would like several flows to operate in their own thread and transaction.",
    "score" : 0,
    "owner" : {
      "account_id" : 322960,
      "reputation" : 7981,
      "user_id" : 642680,
      "user_type" : "registered",
      "accept_rate" : 74,
      "profile_image" : "https://i.sstatic.net/3yGtY.jpg?s=256",
      "display_name" : "D-Dᴙum",
      "link" : "https://stackoverflow.com/users/642680/d-d%e1%b4%99um"
    },
    "creation_date" : 1762295380,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140834011,
    "post_id" : 79800214,
    "body" : "Try to remove <code>taskExecutor(jdbcTaskExecutor)</code> from your configuration and don&#39;t hand the message processing to different threads. This way you would maintain transaction from polling to handling.",
    "score" : 0,
    "owner" : {
      "account_id" : 3273937,
      "reputation" : 122596,
      "user_id" : 2756547,
      "user_type" : "registered",
      "accept_rate" : 75,
      "profile_image" : "https://www.gravatar.com/avatar/2158ce6e7c048277890eb64458864c1c?s=256&d=identicon&r=PG",
      "display_name" : "Artem Bilan",
      "link" : "https://stackoverflow.com/users/2756547/artem-bilan"
    },
    "creation_date" : 1762187103,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140823284,
    "post_id" : 79800214,
    "body" : "@AndreyB.Panfilov This sounds like adding in extra components and complexity. Using transactions is a simple way to ensure records/messages aren&#39;t lost in the case of exceptions or shutdowns. Transaction support is available in Spring integration so not sure why I would try to avoid using it.",
    "score" : 0,
    "owner" : {
      "account_id" : 322960,
      "reputation" : 7981,
      "user_id" : 642680,
      "user_type" : "registered",
      "accept_rate" : 74,
      "profile_image" : "https://i.sstatic.net/3yGtY.jpg?s=256",
      "display_name" : "D-Dᴙum",
      "link" : "https://stackoverflow.com/users/642680/d-d%e1%b4%99um"
    },
    "creation_date" : 1761673166,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140819594,
    "post_id" : 79800214,
    "body" : "I believe you should not flirt with tx handling at all, instead you need to start thinking in EIP terms, i.e.: you poll some records, process them, then mark some of them as processed and others as not processed (via headers, mutation or creating another records), at the final step you either delete processed records or resubmit unprocessed.",
    "score" : 1,
    "owner" : {
      "account_id" : 4181375,
      "reputation" : 6263,
      "user_id" : 3426309,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/v58O6.jpg?s=256",
      "display_name" : "Andrey B. Panfilov",
      "link" : "https://stackoverflow.com/users/3426309/andrey-b-panfilov"
    },
    "creation_date" : 1761535504,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79810190" : [ {
      "comment_id" : 140845670,
      "post_id" : 79810190,
      "body" : "thanks for the reply I will take a look into your suggestions.",
      "score" : 0,
      "owner" : {
        "account_id" : 322960,
        "reputation" : 7981,
        "user_id" : 642680,
        "user_type" : "registered",
        "accept_rate" : 74,
        "profile_image" : "https://i.sstatic.net/3yGtY.jpg?s=256",
        "display_name" : "D-Dᴙum",
        "link" : "https://stackoverflow.com/users/642680/d-d%e1%b4%99um"
      },
      "creation_date" : 1762712637,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}