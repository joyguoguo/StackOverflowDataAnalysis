{
  "question" : {
    "question_id" : 79836078,
    "title" : "java stream api: logging inside a stream",
    "body" : "<p>Disclaimer: The question below was met with quite a bit of critisicm. The only reason I did not delete this question is becasue stackoverflow doesnt let me after somebody reacted on it. Also the code has been altered so lots of the criticism doesnt apply anymore. I did trigger some discussion though. I guess that's good. Maybe this concept will result in an improved new question from me or somebody else. Here it comes:</p>\n<p>I really love the way you can program with java streams as a way to get from an input variable to a output in a series of well defined standardized steps, like map and filter. Therefore it sometimes feel like a pitty to leave this structure. Sometimes it seems easier and more readible to leave this structure, but that might be because a lack of available library functionality, best practices or my knowledge thereof.</p>\n<p>Let's look at this 'old-school' code (well it does have Optional and var so not that old-school)</p>\n<pre><code>public Optional&lt;Address&gt; getValidSupplierAddress(Contact contact) {\n    if (!contact.hadRecentProjects) {\n        log.debug(&quot;contact didn't have any recent projects&quot;);\n        return Optional.empty();\n    }\n    if (!contact.validatedByBoardOfCommerce()) {\n        log.debug(&quot;contact is not validated by board of commerce&quot;);\n        return Optional.empty();\n    }\n    var address = contact.getAddress();\n    if (address == null) {\n        log.debug(&quot;no address specified for contact&quot;);\n        return Optional.empty();\n    }\n    if (address.isPobox()) {\n        log.debug(&quot;address is not valid, no po. box allowed&quot;);\n        return Optional.empty();\n    }\n    return Optional.of(address);\n}\n</code></pre>\n<p>You could write this into something like this:</p>\n<pre><code>public Optional&lt;Address&gt; getValidSupplierAddress(Contact contact) {\n    return Optional.of(contact)\n         .filter(testOrElse(Contact::hadRecentProjects, \n                    () -&gt; log.debug(&quot;contact didn't have any recent projects&quot;)))\n         .filter(testOrElse(Contact::validatedByBoardOfCommerce, \n                    () -&gt; log.debug(&quot;contact is not validated by board of commerce&quot;)))\n         .map(supplier -&gt; Optional.of(supplier.getAddress())\n         .filter(testOrElse(Optional::isPresent, \n                    () -&gt; log.debug(&quot;no address specified for supplier&quot;)))\n         .map(Optional::get)\n         .filter(testOrElse(not(Address::isPobox), \n                    () -&gt; log.debug(&quot;address is not valid, no po. box allowed&quot;)));\n}\n\n    private &lt;X&gt; Predicate&lt;X&gt; testOrElse(Predicate&lt;X&gt; condition, Runnable executeOnFalse) {\n        return condition.or(x1 -&gt; { executeOnFalse.run(); return false; });\n    }\n\n</code></pre>\n<p>Did I make more readable code here or not? Not quite sure yet. I But I guess when there are any library functions that would support an approach similar to this, it might become (even?) more readable. Can anybody improve upon this code, preferrably using existing mainstream libraries?</p>\n",
    "tags" : [ "java", "logging", "stream" ],
    "owner" : {
      "account_id" : 2920132,
      "reputation" : 171,
      "user_id" : 5325562,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/ZffWS.jpg?s=256",
      "display_name" : "Maarten",
      "link" : "https://stackoverflow.com/users/5325562/maarten"
    },
    "is_answered" : true,
    "view_count" : 84,
    "answer_count" : 2,
    "score" : 0,
    "last_activity_date" : 1764842239,
    "creation_date" : 1764691493,
    "link" : "https://stackoverflow.com/questions/79836078/java-stream-api-logging-inside-a-stream",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79836169,
    "question_id" : 79836078,
    "body" : "<p>Your code snippets are bizarre and that makes them difficult to use as a 'prop' for this discussion.</p>\n<h2>Error - 1 - bad names</h2>\n<p>Your method is called <code>getAllSuppliers</code>, yet, its return type is clearly <code>Supplier</code>. One would expect instead either a <code>Stream&lt;Supplier&gt;</code> or <code>List&lt;Supplier&gt;</code>. <code>Supplier</code> here is an extremely badly chosen name. Because it is ambiguous, and regardless of the 2 obvious things it could mean, the choice is terrible:</p>\n<ol>\n<li><p>If you mean 'the general concept of a thing that can provide values', and thus that is referring to <code>java.util.function.Supplier</code>, then [A] don't do that (<strong>what</strong> is it supplying? Let's say it's a thing that creates awards for students, that should be <code>getStudentAwardSupplier()</code> or <code>getStudentAwards()</code>. not <code>getSupplier()</code>), and [B] you've missed the generics part of it.</p>\n</li>\n<li><p>You meant 'supplier' as in: This code models a store and 'supplier' is referring to 'a company that makes goods or sells services that we use as part of our business or sell on to our customers', i.e. the english dictionary definition of the word. In that case: While 'Supplier' isn't a bad name on its own, <em>in the context of java the ecosystem specifically</em>, don't do this. For the same reason you don't name your own types <code>String</code>. The OpenJDK project has essentially bogarted the name <code>Supplier</code>, you must not use it yourself unless you really, <em>really</em> know what you are doing.</p>\n</li>\n</ol>\n<h2>Error - 2 - conflict in names - does not compile</h2>\n<p>Your method has a param named <code>supplier</code> and then declares a local variable named <code>supplier</code>. This is not legal java code. It makes it harder to try to figure out what <code>supplier</code> is.</p>\n<h2>Nit - 3 - Slight abuse of Optional</h2>\n<p><code>Optional.of</code> is being abused here. You've taken a value that definitely cannot be <code>null</code>, and you wrap it in an <code>Optional</code> for no good reason. <code>Optional.of</code> generally either [A] has <code>return </code> immediately preceding it, or [B] is abuse, or [C] is a bug and should have been <code>Optional.ofNullable</code>.</p>\n<p><code>return</code> is indeed in front, here, but the gist of the code isn't to wrap the result in the branch of 'hey there is a result' (i.e. in contrast to another branch that has <code>return Optional.empty()</code>); it's to start off with an optional and then have a series of filter calls have the opportunity to 'unset' the value.</p>\n<p>That's.. borderline.</p>\n<p>It's not just whether your eyeballs can more easily 'glean' the general gist of what the code is attempting to do (which is helped by, but not solely defined by, how short the snippet is). It's also about the odds that the casual glance at the code is likely to lead to a misconception. If anybody reads this, they see <code>Optional</code> and are likely to jump to the conclusion that optional values are presumably involved. A logical leap, but one that is incorrect. Hence, the second snippet is somewhat worse.</p>\n<h2>Problem - 4 - Decision hiding</h2>\n<p>Your log code uses log level <code>debug</code>. In the first snippet, this is obvious. In the second snippet, it's both [A] not obvious and [B] even worse, it's not obvious that a silent choice has been made at all!</p>\n<p>Your <code>logOnFalse</code> method does not indicate <em>at all</em> that there IS a choice to be made about what level to log on, AND that the choice has been made for you: <code>debug</code>. This should at the very minimum be communicated in its javadoc, but more appropriately, in its name. <code>logOnDebugIfFalse</code>, for example. But now the name is unwieldy. Or, it shuold add a parameter of type <code>LogLevel</code>. This, again, leads to misleads when casually inspecting this code: I'm highly likely, if looking at this code quickly, to be utterly oblivious to the fact that a log level decision has to be made, and that this code made it for you, at <code>debug</code> level.</p>\n<p>There is some room for the notion that the source file is allowed to 'resist' modularised breakdown: Whilst understanding code inevitably occurs by chopping the code into pieces and understanding each piece individually (and this is <em>why</em> spaghetti code is so bad: It makes it hard to do the chopping), there's a limit to how far you can chop, and a single source file as a pretty good granularity: In other words, it's not reasonable to expect somebody to understand <code>logOnFalse</code> based on its use and name alone <strong>because</strong> <code>logOnFalse</code> is private.</p>\n<p>There's some truth to that, but it's a grey space: It's not a complete excuse either. For example, I'd make a <code>private static final LogLevel</code> field, and use that to convey that this code always uses the debug loglevel.</p>\n<h2>Problem - 5 - less flexible</h2>\n<p>Any code that is written once and is highly unlikely to ever be subject to changes ever again is.. playing the programming game on easy mode. In practice, projects are living things. Bugs are found, new feature requests are made, other parts of the codebase have internal requirements for this part, and so on.</p>\n<p>Hence, think about what kind of change(s) would be somewhat reasonable to be expected of this code and how you would go about implementing them / how well such changes 'fit' in the code you have so far.</p>\n<p>The first one wins by kilometers on that front. The obvious addition is: Additional 'if X then log Y' lines - the entire method is pretty much just those, after all.</p>\n<p>Imagine that a supplier also has a phone number, and the phone number is also required. In the first snippet, the git commit between the old and the new version would include solely 'added lines' (no deletions, no updates), and it would be:</p>\n<pre class=\"lang-java prettyprint-override\"><code>var phone = supplier.getPhoneNumber();\nif (phone == null) {\n    log.debug(&quot;no phone number specified for supplier&quot;);\n    return Optional.empty();\n}\n</code></pre>\n<p>Whereas in your second snippet it would require quite a lot of changes. That idea of using <code>map</code> to 'jump' from the supplier object to the address is a one-way street, you can't just add <code>.map(supplier -&gt; Optional.of(supplier.getPhoneNumber()))</code> anymore, because the thing you would be calling map on isn't a supplier, but an address.</p>\n<h2>Objective proof - 6 - you messed up</h2>\n<p>You wrote <code>supplier -&gt; Optional.of(supplier.getAddress())</code> but that's a bug - you meant <code>Optional.ofNullable</code>. You will not get a compiler error, but the error <code>no address specified for supplier</code> wil never occur; if that is the case, instead the <code>Optional.of(supplier.getAddress())</code> line will throw an NPE.</p>\n<p>Entirely anecdotal but that strongly suggests the second snippet is worse. It has led <em>you</em> to writing a bug. Whether you're likely to misunderstand/make mistakes in a certain style seems rather pertinent. There's some leeway here (when learning new styles, you're bound to make more mistakes, but that cannot be an argument to never change anything ever, of course), but it's not a good sign.</p>\n<h2>Mixed styles is bad - 7</h2>\n<p>Part of the second snippet is optional based, and parts aren't (such as <code>.getAddress()</code>, which seems to sometimes return <code>null</code>).</p>\n<p>If the intent is that addresses can never be null, then this code <strong>is an ugly workaround</strong> - you don't <em>want</em> invalid state to be able to exist in the first place. Whatever code makes an instance of <code>Supplier</code> should have caught this, you don't check 'after the fact'. When you do, you end up with a scenario where all code you write that interacts with Supplier needs to deal with the fact that, evidently, they can be in a nonsensical state (such as having no address).</p>\n<p>Either [A] the class models a concept where address can be missing, AND you embrace the use of Optional, in which case, <code>getAddress()</code> should be returning an <code>Optional&lt;Address&gt;</code> and not an <code>Address</code>, and <em>this</em> method is specced to only work with suppliers with a known address, so it checks this precondition, or [B] you don't use optional in which case you shouldn't be using it here either, or [C] the class models a concept where an address is inherently required, in which case the creation of an instance should be checking, not this code.</p>\n<p>Note the model v reality difference. Imagine a web form for a signup to a mail service. A 'username' is a required field, but if the interface has limited options for form validition, and you are modelling 'a form submit', well <em>a user can submit a form with no username entered</em>. Which means your class that models a form submit <em>must therefore also be able to model this</em>. Even if such a form cannot continue the process (as username is required). Hence you need to know what you're modelling. Same here. Perhaps whatever &quot;Supplier&quot; is modelling is a thing that CAN have a missing address, even if most of your code base cannot deal with such &quot;Supplier&quot; values.</p>\n<h2>Mixed styles is bad - 8</h2>\n<p>Your supplier is inconsistent in its naming. It uses beanspeccy <code>get</code> in <code>getAddress</code>, but fails to have a beanspeccy is - it should have been named <code>isValidatedByBoardOfCommerce</code>. Also, minor nit, <code>isPoBox</code> is the better name (capital B).</p>\n<h2>Bad endresult - 9</h2>\n<p>The final problem with this code is the entire principle. Java <strong>fundamentally</strong> has exceptions. It just does. If you hate them, then stop using it, that's what fundamental means. This code sticks its head in the sand: When invalid things happen, this code will [A] log a bunch of things, and then [B] just blindly continue on, oblivious to the bad state. The only handhold it provides for a caller to even know something is wrong, is that it's an optional. But in general if your javadoc is something along the lines of:</p>\n<pre><code>/// @Returns the supplier for this product, or NONE if the supplier is invalid.\n/// In the latter case, check the logs for what's wrong with it.\n</code></pre>\n<p>&quot;Check the logs&quot; is never acceptable in a spec. And it HAS to be part of the spec, because how else do you document this? &quot;This method returns an optional but don't worry about it, there's always a value unless bugs, and bugs are beyond the scope of this documentation?&quot; That's terrible docs.</p>\n<p>This code should throw something if a supplier is invalid; it should not &quot;return an optional.NONE + log a bunch of stuff&quot;.</p>\n<p>A conventional way to do this is to have a method whose name starts with <code>validate</code> which returns nothing and has no side effects <strong>unless</strong> the thing it validates isn't valid, in which case an exception results. Alternatively if the aim of the API is for a caller to simply obtain the reason for invalidity, then there's a split in the community; half feels you change nothing and trust the callers to invoke the validate method and catch the exception, and the other half feels there should be a method whose name starts with <code>check</code> which returns the problem. I don't think many feel there's room for 'if there are problems this method will log them and then give no indication to the caller about what's invalid about it'.</p>\n<p>The endresult of this style of coding (don't throw anything, log all info about what's wrong and return <code>Optional.NONE</code>) is that any code that could in theory respond appropriately to a problem cannot, because <code>Optional.NONE</code> is utterly devoid of information, and that any bugs tend to result in 'silently, nothing happens'.</p>\n<p>I get the widespread 'hate' for NullPointerException stack traces, but take a moment to think for yourself: <strong>Of course</strong> that stack trace is orders of magnitude more useful than 'huh, if I click this thing, the item is supposed to go to the shopping cart but instead silently nothing happens'.</p>\n<p>And with this style of code, that's exactly where you end up. Hence, terrible.</p>\n<p>In objective terms: Fixing 10 NPEs, if each NPE requires 30 seconds to find (stack trace tells you where, after all) and 4 minutes to fix (total time: 45 minutes), is superior to having to fix even <strong>1</strong> 'huh, nothing happens when I press this' if that takes 55 minutes to find and 4 minutes to fix (an hour).</p>\n",
    "score" : 6,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107186,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1764696154,
    "last_activity_date" : 1764696478,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79836265,
    "question_id" : 79836078,
    "body" : "<p>First of all I do appreciate your comments and lots of thoughts you are expressing I had myself at anytime as well. I changed the example already on a few points because of some of the just comments.</p>\n<p>I do really see where you are coming from. Although do not think the paradigm of exception handling and fault barriers are always what should be used in cases like these. In lots of applications there will be lots of optional/nullable objects. Using an Optional is an ideal way to implement code where you can both implement paths for the case where there is or is not a certain object present, both representing valid healthy situations within the application. Often there are so many permutations of optional/nullable objects that you can not speak of one happy flow and it would be really irritating to throw and catch exceptions' for all these cases that are really normal program situations.</p>\n<p>Debug and or trace logging could support understanding what happens in an application, even if there is not a real error or warning situation. So I still think this usage is valid, but if it all depends on readability and adoption. I'm sure if an often-used library like the Java API or commons-collections would offer some more options they might rapidly become popular.</p>\n<p>Thanks for your fierce criticism so I can improve my question :-)</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2920132,
      "reputation" : 171,
      "user_id" : 5325562,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/ZffWS.jpg?s=256",
      "display_name" : "Maarten",
      "link" : "https://stackoverflow.com/users/5325562/maarten"
    },
    "creation_date" : 1764703406,
    "last_activity_date" : 1764703406,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}