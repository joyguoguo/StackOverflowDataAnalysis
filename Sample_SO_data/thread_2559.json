{
  "question" : {
    "question_id" : 79612316,
    "title" : "How to pass values from application.properties to a java abstract class?",
    "body" : "<p>I'm new to Java class design and need help with the following:</p>\n<p>Example scenario:\nI want to pass the company name and email to the BaseEmailMessage class, and fetch these values from the application.properties file.</p>\n<p>I also have static variables SIGN_UP_URL and PASSWORD_RESET_URL in the SignUpEmail and PasswordResetEmail classes, respectively, and I need to fetch these from the same properties file.</p>\n<pre><code>abstract public class BaseEmailMessage {\n    // Need to fetch these from application properties\n    // as they are common for all email types\n    private String COMPANY_NAME;\n    private String COMPANY_EMAIL;\n    \n    // constructor, methods, getters, and setters...\n}\n\n@Component\npublic class SignUpEmail extends BaseEmailMessage {\n\n    // Need to fetch this from application properties specific to this class only\n    private static final String SIGN_UP_URL;\n}\n\n@Component\npublic class PasswordResetEmail extends BaseEmailMessage {\n\n    // Need to fetch this from application properties specific to this class only\n    private static final String PASSWORD_RESET_URL;\n}\n</code></pre>\n<p>How can I achieve this in a clean and maintainable way? Any best practices to improve the maintainability of this code?</p>\n<p>Thanks!</p>\n<p>I tried autowiring the Environment instance to the classes, but not sure should I move with that approach or not?</p>\n",
    "tags" : [ "java", "spring", "spring-boot", "class", "design-patterns" ],
    "owner" : {
      "account_id" : 41855570,
      "reputation" : 79,
      "user_id" : 30481365,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/e62c2dba90718ab69fba214cd8dc5e89?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "kdeepak",
      "link" : "https://stackoverflow.com/users/30481365/kdeepak"
    },
    "is_answered" : true,
    "view_count" : 101,
    "answer_count" : 2,
    "score" : 4,
    "last_activity_date" : 1746707413,
    "creation_date" : 1746705386,
    "link" : "https://stackoverflow.com/questions/79612316/how-to-pass-values-from-application-properties-to-a-java-abstract-class",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79612381,
    "question_id" : 79612316,
    "body" : "<p>You can use <code>@ConfigurationProperties</code> and constructor injection instead of manually fetching values from the environment. I think it is a maintainable way to achieve what you're asking.</p>\n<p>Avoid using static fields because they're not easily injected by Spring.</p>\n<h3>Define your properties clearly in <code>application.properties</code> :</h3>\n<pre><code>email.company-name=Example Company\nemail.company-email=info@example.com\nemail.signup.url=https://example.com/signup\nemail.passwordreset.url=https://example.com/reset-password\n</code></pre>\n<h3>Define a class to load common email configuration properties:</h3>\n<pre><code>@Component\n@ConfigurationProperties(prefix = &quot;email&quot;)\npublic class EmailProperties {\n    private String companyName;\n    private String companyEmail;\n    \n    private final Signup signup = new Signup();\n    private final Passwordreset passwordreset = new Passwordreset();\n    \n    // getters and setters\n    \n    public static class Signup {\n        private String url;\n        // getters and setters\n    }\n    \n    public static class Passwordreset {\n        private String url;\n        // getters and setters\n    }\n\n    // getters and setters for top-level properties\n    public String getCompanyName() { return companyName; }\n    public void setCompanyName(String companyName) { this.companyName = companyName; }\n\n    public String getCompanyEmail() { return companyEmail; }\n    public void setCompanyEmail(String companyEmail) { this.companyEmail = companyEmail; }\n\n    public Signup getSignup() { return signup; }\n    public Passwordreset getPasswordreset() { return passwordreset; }\n}\n</code></pre>\n<h3>Use constructor injection in your abstract class <code>BaseEmailMessage</code>:</h3>\n<pre><code>public abstract class BaseEmailMessage {\n    protected final String companyName;\n    protected final String companyEmail;\n\n    protected BaseEmailMessage(String companyName, String companyEmail) {\n        this.companyName = companyName;\n        this.companyEmail = companyEmail;\n    }\n\n    // methods, getters, etc.\n}\n</code></pre>\n<h3>Subclasses inject their specific URLs in constructors, along with the common properties:</h3>\n<pre><code>@Component\npublic class SignUpEmail extends BaseEmailMessage {\n    private final String signupUrl;\n\n    public SignUpEmail(EmailProperties emailProperties) {\n        super(emailProperties.getCompanyName(), emailProperties.getCompanyEmail());\n        this.signupUrl = emailProperties.getSignup().getUrl();\n    }\n\n    // methods using signupUrl\n    public String getSignupUrl() {\n        return signupUrl;\n    }\n}\n</code></pre>\n<p>I think this way is maintainable because it is <strong>clear separation, easy management and constructor injection</strong>.</p>\n",
    "score" : 4,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 41805186,
      "reputation" : 104,
      "user_id" : 30456909,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/DvzmO04E.jpg?s=256",
      "display_name" : "jialin.zhou",
      "link" : "https://stackoverflow.com/users/30456909/jialin-zhou"
    },
    "creation_date" : 1746707413,
    "last_activity_date" : 1746707413,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79612355,
    "question_id" : 79612316,
    "body" : "<p>Use @Value annotation like this:</p>\n<pre><code>@Value(&quot;${YOUR_KEY_NAME_FROM_PROPERTY_FILE}&quot;)\nprivate String PASSWORD_RESET_URL;\n</code></pre>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 24180242,
      "reputation" : 31,
      "user_id" : 18141029,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/AATXAJyce1fvr3ua4XM0-2kmOR5CDTMElyK9SjBp-F6-=k-s256",
      "display_name" : "Tania Gupta",
      "link" : "https://stackoverflow.com/users/18141029/tania-gupta"
    },
    "creation_date" : 1746706578,
    "last_activity_date" : 1746706578,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79612381" : [ {
      "comment_id" : 140409920,
      "post_id" : 79612381,
      "body" : "All 30 classes require the same config values, yes, using a shared EmailProperties bean with constructor injection is a good design. If each subclass only uses a small part of the config or if the hierarchy becomes too rigid, consider using composition instead of inheritance when flexibility is needed.",
      "score" : 1,
      "owner" : {
        "account_id" : 41805186,
        "reputation" : 104,
        "user_id" : 30456909,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/DvzmO04E.jpg?s=256",
        "display_name" : "jialin.zhou",
        "link" : "https://stackoverflow.com/users/30456909/jialin-zhou"
      },
      "creation_date" : 1746770993,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140409744,
      "post_id" : 79612381,
      "body" : "Thank you for clarifying! One more thing, is it a good design when you have 30+ classes inheriting from a single base class and you need to pass the values from the application.properties file?",
      "score" : 0,
      "owner" : {
        "account_id" : 41855570,
        "reputation" : 79,
        "user_id" : 30481365,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e62c2dba90718ab69fba214cd8dc5e89?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "kdeepak",
        "link" : "https://stackoverflow.com/users/30481365/kdeepak"
      },
      "creation_date" : 1746763819,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140407811,
      "post_id" : 79612381,
      "body" : "You can think of static nested classes and records as &quot;people who can walk by themselves&quot; and can exist independently. Non-static inner classes are &quot;children who must hold their parents&#39; hands to walk&quot;. Once there is no parent object, they cannot run at all. When Spring starts the configuration, it will not hold your hand (it will not instantiate the outer class first), so &quot;the child cries&quot; (reflection fails).",
      "score" : 0,
      "owner" : {
        "account_id" : 41805186,
        "reputation" : 104,
        "user_id" : 30456909,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/DvzmO04E.jpg?s=256",
        "display_name" : "jialin.zhou",
        "link" : "https://stackoverflow.com/users/30456909/jialin-zhou"
      },
      "creation_date" : 1746711766,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140407806,
      "post_id" : 79612381,
      "body" : "Why does Spring Boot&#39;s <code>@ConfigurationProperties</code> not allow the use of non-static inner classes? 1. When Spring creates a configuration class through reflection, it uses a no-argument constructor by default. 2. If the nested class is non-static, Java requires that it must be created through an outer class instance. 3. However, when Spring loads the configuration class, it does not create an outer class instance first. It directly tries to use new Inner() reflection to construct the nested class. 4. The result fails, an exception is thrown, or the configuration cannot be bound.",
      "score" : 0,
      "owner" : {
        "account_id" : 41805186,
        "reputation" : 104,
        "user_id" : 30456909,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/DvzmO04E.jpg?s=256",
        "display_name" : "jialin.zhou",
        "link" : "https://stackoverflow.com/users/30456909/jialin-zhou"
      },
      "creation_date" : 1746711706,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140407681,
      "post_id" : 79612381,
      "body" : "Why have you kept <code>Signup</code> &amp; <code>Passwordreset</code> static?",
      "score" : 0,
      "owner" : {
        "account_id" : 41855570,
        "reputation" : 79,
        "user_id" : 30481365,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e62c2dba90718ab69fba214cd8dc5e89?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "kdeepak",
        "link" : "https://stackoverflow.com/users/30481365/kdeepak"
      },
      "creation_date" : 1746709464,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140407626,
      "post_id" : 79612381,
      "body" : "It is a great suggestion.",
      "score" : 0,
      "owner" : {
        "account_id" : 41805186,
        "reputation" : 104,
        "user_id" : 30456909,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/DvzmO04E.jpg?s=256",
        "display_name" : "jialin.zhou",
        "link" : "https://stackoverflow.com/users/30456909/jialin-zhou"
      },
      "creation_date" : 1746708502,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140407601,
      "post_id" : 79612381,
      "body" : "Beat me too it - the only suggestion is to make <code>EmailProperties</code> a record.",
      "score" : 0,
      "owner" : {
        "account_id" : 8909811,
        "reputation" : 2861,
        "user_id" : 6650475,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/fe85994d05ad7aaaa1c47d638b37bc45?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Andrew S",
        "link" : "https://stackoverflow.com/users/6650475/andrew-s"
      },
      "creation_date" : 1746708151,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79612355" : [ {
      "comment_id" : 140408499,
      "post_id" : 79612355,
      "body" : "That requires the field to be mutable, which probably isn&#39;t desired (at least not in this case).  And it also makes unit testing harder.",
      "score" : 0,
      "owner" : {
        "account_id" : 8909811,
        "reputation" : 2861,
        "user_id" : 6650475,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/fe85994d05ad7aaaa1c47d638b37bc45?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Andrew S",
        "link" : "https://stackoverflow.com/users/6650475/andrew-s"
      },
      "creation_date" : 1746723669,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140407831,
      "post_id" : 79612355,
      "body" : "You are right. But for simple configurations field injection also works fine.",
      "score" : 0,
      "owner" : {
        "account_id" : 24180242,
        "reputation" : 31,
        "user_id" : 18141029,
        "user_type" : "registered",
        "profile_image" : "https://lh3.googleusercontent.com/a/AATXAJyce1fvr3ua4XM0-2kmOR5CDTMElyK9SjBp-F6-=k-s256",
        "display_name" : "Tania Gupta",
        "link" : "https://stackoverflow.com/users/18141029/tania-gupta"
      },
      "creation_date" : 1746712183,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140407609,
      "post_id" : 79612355,
      "body" : "Constructor injection is generally preferred over the use of field injection via @Value.",
      "score" : 0,
      "owner" : {
        "account_id" : 8909811,
        "reputation" : 2861,
        "user_id" : 6650475,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/fe85994d05ad7aaaa1c47d638b37bc45?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Andrew S",
        "link" : "https://stackoverflow.com/users/6650475/andrew-s"
      },
      "creation_date" : 1746708246,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}