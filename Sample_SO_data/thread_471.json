{
  "question" : {
    "question_id" : 79803091,
    "title" : "Azure keyvault configuration from multiple sources with Spring boot",
    "body" : "<p>I am creating POC for new component and I am using Azure keyvault.</p>\n<p>I have something like that:</p>\n<pre><code>@Getter\n@Setter\n@ConfigurationProperties(&quot;ssl&quot;)\npublic class SSLProperties {\n\n    @Value(&quot;${MySecret}&quot;)\n    private String trustStorePass;\n\n    private TrustStore trustStore;\n\n    @Data\n    public static class TrustStore {\n        private String path;\n    }\n\n}\n</code></pre>\n<p>and in my config class it is referenced like:</p>\n<pre><code>@Configuration\n@EnableConfigurationProperties({ SSLProperties.class })\npublic class MyConfigs{\n</code></pre>\n<p>When I pass as environment variables these (with correct values) everything is working as expected and the respective property is injected correctly:</p>\n<pre><code>SPRING_CLOUD_AZURE_KEYVAULT_SECRET_PROPERTY_SOURCES_0_ENDPOINT=&lt;endpoint&gt;\nSPRING_CLOUD_AZURE_KEYVAULT_SECRET_PROPERTY_SOURCES_0_PROFILE_TENANT_ID=&lt;tenant&gt;\nSPRING_CLOUD_AZURE_KEYVAULT_SECRET_PROPERTY_SOURCES_0_CREDENTIAL_CLIENT_SECRET=&lt;client_secret&gt;\nSPRING_CLOUD_AZURE_KEYVAULT_SECRET_PROPERTY_SOURCES_0_CREDENTIAL_CLIENT_ID=&lt;clientId&gt;\n</code></pre>\n<p>But when I pass these variables as environment variables:</p>\n<pre><code>SPRING_CLOUD_AZURE_KEYVAULT_SECRET_PROPERTY_SOURCES_0_PROFILE_TENANT_ID=&lt;tenant&gt;\nSPRING_CLOUD_AZURE_KEYVAULT_SECRET_PROPERTY_SOURCES_0_CREDENTIAL_CLIENT_SECRET=&lt;client_secret&gt;\nSPRING_CLOUD_AZURE_KEYVAULT_SECRET_PROPERTY_SOURCES_0_CREDENTIAL_CLIENT_ID=&lt;clientId&gt;\n</code></pre>\n<p>and endpoint is passed in the application.properties file:</p>\n<pre><code>spring.cloud.azure.keyvault.secret.property-sources[0].endpoint=&lt;my_endpoint&gt;\n</code></pre>\n<p>I get exception like this:</p>\n<pre><code>Caused by: org.springframework.util.PlaceholderResolutionException: Could not resolve placeholder 'MySecret' in value &quot;${MySecret}&quot;\n    at org.springframework.util.PlaceholderResolutionException.withValue(PlaceholderResolutionException.java:81)\n    at org.springframework.util.PlaceholderParser$ParsedValue.resolve(PlaceholderParser.java:423)\n    at org.springframework.util.PlaceholderParser.replacePlaceholders(PlaceholderParser.java:128)\n    at org.springframework.util.PropertyPlaceholderHelper.parseStringValue(PropertyPlaceholderHelper.java:118)\n    at org.springframework.util.PropertyPlaceholderHelper.replacePlaceholders(PropertyPlaceholderHelper.java:114)\n    at org.springframework.core.env.AbstractPropertyResolver.doResolvePlaceholders(AbstractPropertyResolver.java:255)\n    at org.springframework.core.env.AbstractPropertyResolver.resolveRequiredPlaceholders(AbstractPropertyResolver.java:226)\n    at org.springframework.context.support.PropertySourcesPlaceholderConfigurer.lambda$processProperties$0(PropertySourcesPlaceholderConfigurer.java:201)\n    at org.springframework.beans.factory.support.AbstractBeanFactory.resolveEmbeddedValue(AbstractBeanFactory.java:971)\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1649)\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1627)\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:785)\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:768)\n    at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:146)\n    at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:509)\n    ... 33 common frames omitted\nThe code is modified a bit as it is work related and I cannot just copy-paste it, but only names are changed\n</code></pre>\n<p>Spring boot version is 3.4.5 and I am using  com.azure.spring:spring-cloud-azure-starter-keyvault dependency.</p>\n<p>I want to do this in that way, but I cannot make it work.</p>\n<p>What is the reason for that?</p>\n",
    "tags" : [ "java", "spring-boot", "azure-keyvault" ],
    "owner" : {
      "account_id" : 4939453,
      "reputation" : 1680,
      "user_id" : 3976630,
      "user_type" : "registered",
      "accept_rate" : 54,
      "profile_image" : "https://www.gravatar.com/avatar/c3357bd702bd65d7a661dc261393287a?s=256&d=identicon&r=PG",
      "display_name" : "DPM",
      "link" : "https://stackoverflow.com/users/3976630/dpm"
    },
    "is_answered" : false,
    "view_count" : 55,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1762544888,
    "creation_date" : 1761671242,
    "link" : "https://stackoverflow.com/questions/79803091/azure-keyvault-configuration-from-multiple-sources-with-spring-boot",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79812739,
    "question_id" : 79803091,
    "body" : "<p>If I were you, I would just side-step this issue by any of the options below.</p>\n<h2>Use Managed Identity (recommended)</h2>\n<p>Using a Managed Identity has many advantages over using client secrets (for example you don't need to keep those secrets somewhere safe).</p>\n<p>You can even fake the managed identity endpoint (IMDS token endpoint) as well as the Azure Key Vault with local emulators. See an example below (or see the whole example as a <a href=\"https://github.com/nagyesta/lowkey-vault-example/tree/main/spring-cloud-azure-starter-testcontainers\" rel=\"nofollow noreferrer\">POC here</a>).</p>\n<p>Define the managed identity specific env variables to use a non-default token endpoint:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>IDENTITY_ENDPOINT=&quot;http://localhost:10544/metadata/identity/oauth2/token&quot;\nIDENTITY_HEADER=&quot;header&quot;\n</code></pre>\n<p>Start up a container that provides both the local key vault and the token endpoint using the same port with Testcontainers:</p>\n<pre class=\"lang-java prettyprint-override\"><code>lowkeyVault(DockerImageName.parse(&quot;nagyesta/lowkey-vault:5.0.0&quot;))\n    .hostTokenPort(10544)\n    //avoid SSL issues because of the self-signed cert\n    .mergeTrustStores()\n    //set the endpoint for you\n    .setPropertiesAfterStartup(springCloudAzureKeyVaultPropertySupplier()) \n    .build()\n</code></pre>\n<p>Configure the key vault specific properties as usual (and don't specify any authentication credentials because we will use the managed identity)</p>\n<pre class=\"lang-ini prettyprint-override\"><code>spring.cloud.azure.keyvault.secret.property-source-enabled=true\n</code></pre>\n<p>Make sure that 10544 is free and use it as you would in case of the real key vault.</p>\n<p><em>Pro tip</em>: you can populate the local key vault with a predefined set of values so your application has every property you need.</p>\n<h2>Use an intermediate property</h2>\n<p>The easier way is to use some more simple names for the credentials:</p>\n<pre class=\"lang-ini prettyprint-override\"><code>spring.cloud.azure.keyvault.secret.property-source-enabled=true\nspring.cloud.azure.keyvault.secret.property-sources[0].endpoint=&lt;my_endpoint&gt;\nspring.cloud.azure.keyvault.secret.property-sources[0].profile.tenant-id=${AKV_TENANT_ID}\nspring.cloud.azure.keyvault.secret.property-sources[0].credential.client-secret=${AKV_CLIENT_SECRET}\nspring.cloud.azure.keyvault.secret.property-sources[0].credential.client-id=${AKV_CLIENT_ID}\n</code></pre>\n<p>Then, defining the 3 env variables should do the trick:</p>\n<pre class=\"lang-bash prettyprint-override\"><code>AKV_TENANT_ID=&lt;tenant_id&gt;\nAKV_CLIENT_SECRET=&lt;client-secret&gt;\nAKV_CLIENT_ID=&lt;client-id&gt;\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 23058397,
      "reputation" : 429,
      "user_id" : 17174122,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/a61825ff4f37a5aa023d749dff8096ed?s=256&d=identicon&r=PG",
      "display_name" : "Esta Nagy",
      "link" : "https://stackoverflow.com/users/17174122/esta-nagy"
    },
    "creation_date" : 1762544888,
    "last_activity_date" : 1762544888,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140823735,
    "post_id" : 79803091,
    "body" : "Thanks, but how is that related to my case? I have a secret in the keyvault which is named MySecret and expect to be bind with the @Value annotation.",
    "score" : 0,
    "owner" : {
      "account_id" : 4939453,
      "reputation" : 1680,
      "user_id" : 3976630,
      "user_type" : "registered",
      "accept_rate" : 54,
      "profile_image" : "https://www.gravatar.com/avatar/c3357bd702bd65d7a661dc261393287a?s=256&d=identicon&r=PG",
      "display_name" : "DPM",
      "link" : "https://stackoverflow.com/users/3976630/dpm"
    },
    "creation_date" : 1761686732,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140823404,
    "post_id" : 79803091,
    "body" : "Possible duplicate of <a href=\"https://stackoverflow.com/questions/65719683/set-value-to-use-configurationproperties-prefix\">this</a>.",
    "score" : 0,
    "owner" : {
      "account_id" : 8909811,
      "reputation" : 2861,
      "user_id" : 6650475,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/fe85994d05ad7aaaa1c47d638b37bc45?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Andrew S",
      "link" : "https://stackoverflow.com/users/6650475/andrew-s"
    },
    "creation_date" : 1761675937,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}