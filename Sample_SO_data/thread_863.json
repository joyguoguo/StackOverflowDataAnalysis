{
  "question" : {
    "question_id" : 79765409,
    "title" : "How to make Beam Stack Search optimal and complete",
    "body" : "<p>I was reading the paper <a href=\"https://cdn.aaai.org/ICAPS/2005/ICAPS05-010.pdf\" rel=\"noreferrer\">Beam-Stack Search: Integrating Backtracking with Beam Search</a> by Rong Zhou and Eric A. Hansen and I was attempting to implement it in Java (see <a href=\"https://github.com/coderodde/PathFinding.java\" rel=\"noreferrer\">PathFinding.java repository in GitHub</a>, the page README gives instruction on running the app). My code is as follows:</p>\n<pre><code>package io.github.coderodde.pathfinding.finders;\n\nimport static io.github.coderodde.pathfinding.finders.Finder.searchSleep;\nimport io.github.coderodde.pathfinding.heuristics.HeuristicFunction;\nimport io.github.coderodde.pathfinding.logic.GridCellNeighbourIterable;\nimport io.github.coderodde.pathfinding.logic.PathfindingSettings;\nimport io.github.coderodde.pathfinding.logic.SearchState;\nimport io.github.coderodde.pathfinding.logic.SearchStatistics;\nimport io.github.coderodde.pathfinding.model.GridModel;\nimport io.github.coderodde.pathfinding.utils.Cell;\nimport io.github.coderodde.pathfinding.utils.CellType;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Set;\n\n/**\n *\n * @author Rodion &quot;rodde&quot; Efremov\n * @version 1.0.0 (Sep 15, 2025)\n * @since 1.0.0 (Sep 15, 2025)\n */\npublic final class BeamStackSearchFinder implements Finder {\n\n    @Override\n    public List&lt;Cell&gt; findPath(GridModel model, \n                               GridCellNeighbourIterable neighbourIterable, \n                               PathfindingSettings pathfindingSettings, \n                               SearchState searchState, \n                               SearchStatistics searchStatistics) {\n        \n        Deque&lt;BeamStackEntry&gt; beamStack = new ArrayDeque&lt;&gt;();\n        beamStack.push(new BeamStackEntry(0.0, Double.POSITIVE_INFINITY));\n        \n        List&lt;Cell&gt; optimalPath = null;\n        DoubleHolder U = new DoubleHolder();\n        U.value = Double.POSITIVE_INFINITY;\n        \n        while (!beamStack.isEmpty()) {\n            List&lt;Cell&gt; path;\n            System.out.println(&quot;hello&quot;);\n            \n            try {\n                path = search(model, \n                              U,\n                              beamStack,\n                              neighbourIterable,\n                              pathfindingSettings,\n                              searchState,\n                              searchStatistics);\n                \n            } catch (HaltRequestedException ex) {\n                return List.of();\n            }\n            \n            if (searchState.haltRequested()) {\n                return List.of();\n            }\n            \n            while (searchState.pauseRequested()) {\n                searchSleep(pathfindingSettings);\n                System.out.println(&quot;yes 1&quot;);\n                if (searchState.haltRequested()) {\n                    return List.of();\n                }\n            }\n            \n            if (path != null) {\n                optimalPath = path;\n                U.value = getPathCost(path, pathfindingSettings);\n            }\n            \n            while (!beamStack.isEmpty() &amp;&amp; beamStack.peek().fmax &gt;= U.value) {\n                beamStack.pop();\n            }   \n            \n            if (beamStack.isEmpty()) {\n                return optimalPath == null ? List.of() : optimalPath;\n            }\n            \n            BeamStackEntry top = beamStack.peek();\n            top.fmin = top.fmax;\n            top.fmax = U.value;\n        }\n        \n        throw new IllegalStateException(&quot;Should not get here ever&quot;);\n    }\n    \n    private static double \n        getPathCost(List&lt;Cell&gt; path,\n                    PathfindingSettings pathsPathfindingSettings) {\n           \n        double cost = 0.0;\n        \n        for (int i = 0; i &lt; path.size() - 1; ++i) {\n            Cell c1 = path.get(i);\n            Cell c2 = path.get(i + 1);\n            cost += pathsPathfindingSettings.getWeight(c1, c2);\n        }\n        \n        return cost;\n    }\n   \n    private static List&lt;Cell&gt; search(GridModel model,   \n                                     DoubleHolder U,\n                                     Deque&lt;BeamStackEntry&gt; beamStack,\n                                     GridCellNeighbourIterable iterable,\n                                     PathfindingSettings pathfindingSettings,\n                                     SearchState searchState,\n                                     SearchStatistics searchStatistics) {\n        \n        Map&lt;Integer, PriorityQueue&lt;HeapNode&gt;&gt; open = new HashMap&lt;&gt;();\n        Map&lt;Integer, Set&lt;Cell&gt;&gt; closed             = new HashMap&lt;&gt;();\n        Map&lt;Cell, Double&gt; g                        = new HashMap&lt;&gt;();\n        Map&lt;Cell, Cell&gt; p                          = new HashMap&lt;&gt;();\n        \n        HeuristicFunction h = pathfindingSettings.getHeuristicFunction();\n        Cell source = model.getSourceGridCell();\n        Cell target = model.getTargetGridCell();\n        \n        Cell bestGoal = null;\n        int layerIndex = 0;\n        \n        open.put(0, new PriorityQueue&lt;&gt;());\n        open.put(1, new PriorityQueue&lt;&gt;());\n        open.get(0).add(new HeapNode(source, 0.0));\n        \n        closed.put(0, new HashSet&lt;&gt;());\n        g.put(source, 0.0);\n        p.put(source, null);\n        \n        searchStatistics.incrementOpened();\n        \n        while (!open.get(layerIndex).isEmpty() ||\n               !open.get(layerIndex + 1).isEmpty()) {\n            \n            while (!open.get(layerIndex).isEmpty()) {\n                \n                if (searchState.haltRequested()) {\n                    throw new HaltRequestedException();\n                }\n                \n                while (searchState.pauseRequested()) {\n                    searchSleep(pathfindingSettings);\n                    System.out.println(&quot;yes 2&quot;);\n                    if (searchState.haltRequested()) {\n                        throw new HaltRequestedException();\n                    }\n                }\n                \n                Cell cell = open.get(layerIndex).remove().cell;\n                closed.get(layerIndex).add(cell);\n                searchStatistics.decrementOpened();\n                searchStatistics.incrementVisited();\n                \n                if (!cell.getCellType().equals(CellType.SOURCE) &amp;&amp;\n                    !cell.getCellType().equals(CellType.TARGET)) {\n                    model.setCellType(cell, CellType.VISITED);\n                }\n                \n                if (cell.equals(target)) {\n                    U.value = g.get(cell);\n                    bestGoal = cell;\n                }\n                \n                iterable.setStartingCell(cell);\n                BeamStackEntry bse = beamStack.peek();\n                \n                for (Cell child : iterable) {\n                    if (searchState.haltRequested()) {\n                        throw new HaltRequestedException();\n                    }\n                    // TODO: Find out why?\n                    searchState.resetState();\n                    \n                    while (searchState.pauseRequested()) {\n                        System.out.println(&quot;yes 3&quot;);\n                        searchSleep(pathfindingSettings);\n                        \n                        if (searchState.haltRequested()) {\n                            throw new HaltRequestedException();\n                        }\n                    } \n                    \n                    double tentativeGscore = g.get(cell) \n                                           + pathfindingSettings\n                                                   .getWeight(cell, \n                                                              child);\n                    \n                    if (tentativeGscore &lt; g.getOrDefault(\n                                            child, \n                                            Double.POSITIVE_INFINITY)) {\n                        \n                        double f = tentativeGscore + h.estimate(child, target);\n                        \n                        searchSleep(pathfindingSettings);\n                        \n                        if (bse.fmin &lt;= f &amp;&amp; f &lt; bse.fmax) {\n                            Queue&lt;HeapNode&gt; nextOpen = open.get(layerIndex + 1);\n                            \n                            // Add for the first time or improve the g-cost:\n                            nextOpen.removeIf(\n                                    heapNode -&gt; heapNode.cell.equals(child));\n                            \n                            nextOpen.add(new HeapNode(child, f));\n                            \n                            g.put(child, tentativeGscore);\n                            p.put(child, cell);\n                            searchStatistics.incrementOpened();\n                            \n                            if (!child.getCellType().equals(CellType.SOURCE) &amp;&amp;\n                                !child.getCellType().equals(CellType.TARGET)) {\n                                model.setCellType(child, CellType.OPENED);\n                            }\n                        }\n                    }\n                }\n                \n                PriorityQueue&lt;HeapNode&gt; nextOpen = open.get(layerIndex + 1);\n                \n                if (nextOpen.size() &gt; pathfindingSettings.getBeamWidth()) {\n                    pruneLayer(model,\n                               nextOpen,\n                               pathfindingSettings,\n                               searchStatistics);\n                }\n            }\n            \n            layerIndex++;\n            open.put(layerIndex + 1, new PriorityQueue&lt;&gt;());\n            closed.put(layerIndex, new HashSet&lt;&gt;());\n            beamStack.push(new BeamStackEntry(0, U.value));\n        }\n        \n        for (PriorityQueue&lt;HeapNode&gt; queue : open.values()) {\n            for (HeapNode heapNode : queue) {\n                Cell cell = heapNode.cell;\n                \n                if (!cell.getCellType().equals(CellType.SOURCE) &amp;&amp;\n                    !cell.getCellType().equals(CellType.TARGET)) {\n                    model.setCellType(cell, CellType.FREE);\n                }\n            }\n        }\n        \n        for (Set&lt;Cell&gt; closedSet : closed.values()) {\n            for (Cell cell : closedSet) {\n                if (!cell.getCellType().equals(CellType.SOURCE) &amp;&amp;\n                    !cell.getCellType().equals(CellType.TARGET)) {\n                    model.setCellType(cell, CellType.FREE);\n                }\n            }\n        }\n        \n        if (bestGoal != null) {\n            List&lt;Cell&gt; path = new ArrayList&lt;&gt;();\n            \n            for (Cell cell = bestGoal; \n                 cell != null; \n                 cell = p.get(cell)) {\n                \n                path.add(cell);\n            }\n            \n            Collections.reverse(path);\n            return path;\n        }\n        \n        return null;\n    }\n    \n    private static void pruneLayer(GridModel model,\n                                   PriorityQueue&lt;HeapNode&gt; open,\n                                   PathfindingSettings pathfindingSettings,\n                                   SearchStatistics searchStatistics) {\n        \n        List&lt;HeapNode&gt; keepList = new ArrayList&lt;&gt;(open);\n        \n        for (HeapNode heapNode : keepList) {\n            Cell cell = heapNode.cell;\n            \n            if (!cell.getCellType().equals(CellType.SOURCE) &amp;&amp;\n                !cell.getCellType().equals(CellType.TARGET)) {\n                model.setCellType(cell, CellType.FREE);\n            }\n        }\n        \n        keepList.sort((a, b) -&gt; Double.compare(a.f, b.f));\n        keepList = keepList.subList(0, pathfindingSettings.getBeamWidth());\n        \n        for (HeapNode heapNode : keepList) {\n            Cell cell = heapNode.cell;\n            \n            if (!cell.getCellType().equals(CellType.SOURCE) &amp;&amp;\n                !cell.getCellType().equals(CellType.TARGET)) {\n                model.setCellType(cell, CellType.OPENED);\n            }\n        }\n        \n        List&lt;HeapNode&gt; pruneList = new ArrayList&lt;&gt;();\n        double fmin = Double.POSITIVE_INFINITY;\n        \n        for (HeapNode heapNode : open) {\n            if (!keepList.contains(heapNode)) {\n                pruneList.add(heapNode);\n                fmin = Math.min(fmin, heapNode.f);\n            }\n        }\n        \n        for (HeapNode heapNode : pruneList) {\n            open.remove(heapNode);\n            Cell cell = heapNode.cell;\n\n            if (!cell.getCellType().equals(CellType.SOURCE) &amp;&amp;\n                !cell.getCellType().equals(CellType.TARGET)) {\n                model.setCellType(cell, CellType.VISITED);\n            }\n        }\n    }\n        \n    private static final class BeamStackEntry {\n        double fmin;\n        double fmax;\n        \n        BeamStackEntry(double fmin, double fmax) {\n            this.fmin = fmin;\n            this.fmax = fmax;\n        }\n    }\n    \n    private static final class DoubleHolder {\n        double value;\n    }\n}\n</code></pre>\n<h4>Reproducing bugs</h4>\n<p>Note that you will have tweak a bit the settings pane:\n<a href=\"https://i.sstatic.net/f5sWFIB6.png\" rel=\"noreferrer\"><img src=\"https://i.sstatic.net/f5sWFIB6.png\" alt=\"Settings pane of PathFinding.java app.\" /></a></p>\n<p>My current implementation seems to be very sensitive to the beam width: if too small, it either returns a suboptimal path or terminates with no path at all.</p>\n<p>Below, the green cell is the source cell, the red one is the target cell, the white cells are the unoccupied cells, the black cells are the walls, the light green cells are the cells in the open list, and the dark gray are the visited cells.</p>\n<h4>No path at all bug:</h4>\n<p>I get this one on beam width of 1:\n<a href=\"https://i.sstatic.net/JpSt7nI2.png\" rel=\"noreferrer\"><img src=\"https://i.sstatic.net/JpSt7nI2.png\" alt=\"No path bug illustration.\" /></a>\nAbove, the green cell is the source cell, and the red cell is the target cell.</p>\n<p>What comes to suboptimality, with beam width of 4, I get:\n<a href=\"https://i.sstatic.net/xFGzNXTi.png\" rel=\"noreferrer\"><img src=\"https://i.sstatic.net/xFGzNXTi.png\" alt=\"Suboptimality bug illustration.\" /></a></p>\n<h4>Desired behaviour</h4>\n<p>The optimal path might look like:\n<a href=\"https://i.sstatic.net/TMYz2btJ.png\" rel=\"noreferrer\"><img src=\"https://i.sstatic.net/TMYz2btJ.png\" alt=\"Optimal path illustration.\" /></a>\nThe above happens only starting with the beam width of 8.</p>\n<p>Some failing unit tests:</p>\n<pre><code>package io.github.coderodde.pathfinding.finders;\n\nimport io.github.coderodde.pathfinding.heuristics.OctileHeuristicFunction;\nimport io.github.coderodde.pathfinding.logic.GridCellNeighbourIterable;\nimport io.github.coderodde.pathfinding.logic.GridNodeExpander;\nimport io.github.coderodde.pathfinding.logic.PathfindingSettings;\nimport io.github.coderodde.pathfinding.logic.SearchState;\nimport io.github.coderodde.pathfinding.logic.SearchStatistics;\nimport io.github.coderodde.pathfinding.model.GridModel;\nimport io.github.coderodde.pathfinding.utils.Cell;\nimport io.github.coderodde.pathfinding.utils.CellType;\nimport java.util.List;\nimport org.junit.Test;\nimport static org.junit.Assert.*;\n\npublic class BeamStackSearchFinderTest {\n    \n    private final PathfindingSettings ps = new PathfindingSettings();\n    private final SearchState searchState = new SearchState();\n    private final SearchStatistics searchStatistics =\n            new SearchStatistics(null, \n                                 null,\n                                 null,\n                                 null);\n    \n    public BeamStackSearchFinderTest() {\n        ps.setDontCrossCorners(false);\n        ps.setAllowDiagonals(true);\n        ps.setFinder(new BeamStackSearchFinder());\n        ps.setHeuristicFunction(new OctileHeuristicFunction());\n        ps.setFrequency(1000);\n    }\n    \n    @Test\n    public void hasSolutionPath() {\n        System.out.println(&quot;hasSolutionPath()&quot;);\n        \n        GridModel model = new GridModel(20, 5);\n        model.moveTarget(17, 2);\n        model.moveSource(15, 2);\n        model.setCellType(16, 2, CellType.WALL);\n        ps.setBeamWidth(1);\n        \n        GridNodeExpander expander = new GridNodeExpander(model, ps);\n        \n        GridCellNeighbourIterable iterable =\n                new GridCellNeighbourIterable(model, \n                                              expander,\n                                              ps);\n        \n        List&lt;Cell&gt; pathBreadthFirstSearch = \n                new BFSFinder()\n                        .findPath(model, \n                                  iterable, \n                                  ps,\n                                  searchState, \n                                  searchStatistics);\n        \n        List&lt;Cell&gt; pathBeamStackSearch = \n                new BeamStackSearchFinder()\n                        .findPath(model, \n                                  iterable, \n                                  ps,\n                                  searchState, \n                                  searchStatistics);\n        \n        System.out.println(&quot;BSS: &quot; + pathBeamStackSearch.size());\n        System.out.println(&quot;BFS: &quot; + pathBreadthFirstSearch.size());\n        \n        assertEquals(pathBreadthFirstSearch.size(),\n                     pathBeamStackSearch.size());\n    }\n    \n    @Test\n    public void debugNoPath() {\n        System.out.println(&quot;debugNoPath()&quot;);\n        \n        GridModel model = new GridModel(53, 33);\n        model.moveTarget(6, 4);\n        model.moveSource(3, 4);\n        model.setCellType(4, 2, CellType.WALL);\n        model.setCellType(4, 3, CellType.WALL);\n        model.setCellType(5, 3, CellType.WALL);\n        model.setCellType(5, 4, CellType.WALL);\n        model.setCellType(5, 5, CellType.WALL);\n        \n        ps.setBeamWidth(1);\n        \n        GridNodeExpander expander = new GridNodeExpander(model, ps);\n        \n        GridCellNeighbourIterable iterable =\n                new GridCellNeighbourIterable(model, \n                                              expander,\n                                              ps);\n        \n        List&lt;Cell&gt; pathBreadthFirstSearch = \n                new BFSFinder()\n                        .findPath(model, \n                                  iterable, \n                                  ps,\n                                  searchState, \n                                  searchStatistics);\n        \n        List&lt;Cell&gt; pathBeamStackSearch = \n                new BeamStackSearchFinder()\n                        .findPath(model, \n                                  iterable, \n                                  ps,\n                                  searchState, \n                                  searchStatistics);\n        \n        System.out.println(&quot;BSS: &quot; + pathBeamStackSearch.size());\n        System.out.println(&quot;BFS: &quot; + pathBreadthFirstSearch.size());\n        \n        assertEquals(pathBreadthFirstSearch.size(),\n                     pathBeamStackSearch.size());\n    }\n    \n    @Test\n    public void suboptimal() {\n        System.out.println(&quot;suboptimal()&quot;);\n        \n        GridModel model = new GridModel(53, 33);\n        model.moveTarget(7, 3);\n        model.moveSource(6, 5);\n        \n        model.setCellType(5, 2, CellType.WALL);\n        model.setCellType(5, 3, CellType.WALL);\n        model.setCellType(6, 3, CellType.WALL);\n        \n        model.setCellType(6, 4, CellType.WALL);\n        model.setCellType(7, 4, CellType.WALL);\n        model.setCellType(7, 5, CellType.WALL);\n        \n        model.setCellType(7, 6, CellType.WALL);\n        model.setCellType(6, 6, CellType.WALL);\n        model.setCellType(5, 7, CellType.WALL);\n        \n        ps.setBeamWidth(1);\n        \n        GridNodeExpander expander = new GridNodeExpander(model, ps);\n        \n        GridCellNeighbourIterable iterable =\n                new GridCellNeighbourIterable(model, \n                                              expander,\n                                              ps);\n        \n        List&lt;Cell&gt; pathBreadthFirstSearch = \n                new BFSFinder()\n                        .findPath(model, \n                                  iterable, \n                                  ps,\n                                  searchState, \n                                  searchStatistics);\n        \n        List&lt;Cell&gt; pathBeamStackSearch = \n                new BeamStackSearchFinder()\n                        .findPath(model, \n                                  iterable, \n                                  ps,\n                                  searchState, \n                                  searchStatistics);\n        \n        System.out.println(&quot;BSS: &quot; + pathBeamStackSearch.size());\n        System.out.println(&quot;BFS: &quot; + pathBreadthFirstSearch.size());\n        \n        assertEquals(pathBreadthFirstSearch.size(),\n                     pathBeamStackSearch.size());\n    }\n}\n</code></pre>\n",
    "tags" : [ "java", "algorithm", "path-finding" ],
    "owner" : {
      "account_id" : 1044029,
      "reputation" : 967,
      "user_id" : 1049393,
      "user_type" : "registered",
      "accept_rate" : 67,
      "profile_image" : "https://www.gravatar.com/avatar/70e20177030730d59c63b1cee24e152f?s=256&d=identicon&r=PG",
      "display_name" : "coderodde",
      "link" : "https://stackoverflow.com/users/1049393/coderodde"
    },
    "is_answered" : true,
    "view_count" : 312,
    "answer_count" : 1,
    "score" : 4,
    "last_activity_date" : 1758915169,
    "creation_date" : 1757954540,
    "link" : "https://stackoverflow.com/questions/79765409/how-to-make-beam-stack-search-optimal-and-complete",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79776316,
    "question_id" : 79765409,
    "body" : "<p>First of all thanks for this question, and your reproducer is superb, This question is more like a text book from uni for graphs. I know using BFS is not really Beam Stack Search but that`s all I can find so far.</p>\n<ol>\n<li>W ≤ 1 → use BFS (or Dijkstra if weighted). Don’t starve on a 1-wide beam. It keeps only one node per layer, so if that single branch is misled or blocked, there’s no alternative to continue. Beam‑Stack’s backtracking relies on pruned nodes to produce the next threshold; with W=1 layers often prune nothing, so you can stall. (No path at all bug)</li>\n<li>Track min f (g+h) among nodes you prune by beam width. If no goal under [fmin, U), restart with U = that min-pruned-f.</li>\n<li>If a layer pruned nothing, carry the current fmin forward (not +∞). This fixes stalls at wider beams (e.g., 8).</li>\n<li>After you find a path, set U = path cost, pop bands with fmax ≥ U, then set top.fmax = U.</li>\n</ol>\n<p>Code</p>\n<pre class=\"lang-java prettyprint-override\"><code>// 1) Narrow beam → BFS fallback\nif (pathfindingSettings.getBeamWidth() &lt;= 1) {\n    return new BFSFinder().findPath(model, neighbourIterable, pathfindingSettings, searchState, searchStatistics);\n}\n\n// 2) Keep min f of pruned nodes; use it as next U when no goal\nif (nextOpen.size() &gt; beamWidth) {\n    double fminPruned = pruneLayer(...); // returns min f of pruned\n    globalMinPrunedF = Math.min(globalMinPrunedF, fminPruned);\n}\n// no goal under current bands\nU.value = globalMinPrunedF; // next threshold\nif (!Double.isInfinite(U.value)) {\n    beamStack.clear();\n    beamStack.push(new Band(0.0, U.value));\n}\n\n// 3) If nothing was pruned in the layer, keep fmin\ndouble nextFmin = Double.isFinite(globalMinPrunedF) ? globalMinPrunedF : beamStack.peek().fmin;\nbeamStack.push(new Band(nextFmin, U.value));\n\n// 4) Tighten after solution\nU.value = cost(path);\nwhile (!stack.isEmpty() &amp;&amp; stack.peek().fmax &gt;= U.value) stack.pop();\nif (!stack.isEmpty()) stack.peek().fmax = U.value; // keep fmin\n</code></pre>\n<p>Below is the full code with comments</p>\n<pre class=\"lang-java prettyprint-override\"><code>package io.github.coderodde.pathfinding.finders;\n\nimport static io.github.coderodde.pathfinding.finders.Finder.searchSleep;\nimport io.github.coderodde.pathfinding.heuristics.HeuristicFunction;\nimport io.github.coderodde.pathfinding.logic.GridCellNeighbourIterable;\nimport io.github.coderodde.pathfinding.logic.PathfindingSettings;\nimport io.github.coderodde.pathfinding.logic.SearchState;\nimport io.github.coderodde.pathfinding.logic.SearchStatistics;\nimport io.github.coderodde.pathfinding.model.GridModel;\nimport io.github.coderodde.pathfinding.utils.Cell;\nimport io.github.coderodde.pathfinding.utils.CellType;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Set;\n\n/**\n *\n * @author Rodion &quot;rodde&quot; Efremov\n * @version 1.0.0 (Sep 15, 2025)\n * @since 1.0.0 (Sep 15, 2025)\n */\npublic final class BeamStackSearchFinder implements Finder {\n\n    @Override\n    public List&lt;Cell&gt; findPath(GridModel model,\n                               GridCellNeighbourIterable neighbourIterable,\n                               PathfindingSettings pathfindingSettings,\n                               SearchState searchState,\n                               SearchStatistics searchStatistics) {\n\n        // For extreme beam widths (e.g., 1), plain BFS is optimal and complete\n        // and provides a robust baseline while the beam-stack strategy may\n        // starve. Delegate to BFS in that case.\n        if (pathfindingSettings.getBeamWidth() &lt;= 1) {\n            return new BFSFinder().findPath(model,\n                    neighbourIterable,\n                    pathfindingSettings,\n                    searchState,\n                    searchStatistics);\n        }\n\n        Deque&lt;BeamStackEntry&gt; beamStack = new ArrayDeque&lt;&gt;();\n        beamStack.push(new BeamStackEntry(0.0, Double.POSITIVE_INFINITY));\n\n        List&lt;Cell&gt; optimalPath = null;\n        DoubleHolder U = new DoubleHolder();\n        U.value = Double.POSITIVE_INFINITY;\n\n        while (!beamStack.isEmpty()) {\n            List&lt;Cell&gt; path;\n\n            try {\n                path = search(model,\n                        U,\n                        beamStack,\n                        neighbourIterable,\n                        pathfindingSettings,\n                        searchState,\n                        searchStatistics);\n\n            } catch (HaltRequestedException ex) {\n                return List.of();\n            }\n\n            if (searchState.haltRequested()) {\n                return List.of();\n            }\n\n            while (searchState.pauseRequested()) {\n                searchSleep(pathfindingSettings);\n                if (searchState.haltRequested()) {\n                    return List.of();\n                }\n            }\n\n            if (path != null) {\n                optimalPath = path;\n                U.value = getPathCost(path, pathfindingSettings);\n            } else {\n                // No solution under current thresholds; if we obtained a\n                // finite next threshold, restart the search with it.\n                if (!Double.isInfinite(U.value)) {\n                    beamStack.clear();\n                    beamStack.push(new BeamStackEntry(0.0, U.value));\n                } else {\n                    // Could not even compute a next threshold -&gt; no path.\n                    return List.of();\n                }\n            }\n\n            // Tighten the search band by the found optimal path cost U.\n            // Pop any frames whose upper bound is not better than U.\n            while (!beamStack.isEmpty() &amp;&amp; beamStack.peek().fmax &gt;= U.value) {\n                beamStack.pop();\n            }\n\n            if (beamStack.isEmpty()) {\n                return optimalPath == null ? List.of() : optimalPath;\n            }\n\n            // Update the current frame’s upper bound to U; keep its fmin as is.\n            BeamStackEntry top = beamStack.peek();\n            top.fmax = U.value;\n        }\n\n        throw new IllegalStateException(&quot;Should not get here ever&quot;);\n    }\n\n    private static double\n    getPathCost(List&lt;Cell&gt; path,\n                PathfindingSettings pathsPathfindingSettings) {\n\n        double cost = 0.0;\n\n        for (int i = 0; i &lt; path.size() - 1; ++i) {\n            Cell c1 = path.get(i);\n            Cell c2 = path.get(i + 1);\n            cost += pathsPathfindingSettings.getWeight(c1, c2);\n        }\n\n        return cost;\n    }\n\n    private static List&lt;Cell&gt; search(GridModel model,\n                                     DoubleHolder U,\n                                     Deque&lt;BeamStackEntry&gt; beamStack,\n                                     GridCellNeighbourIterable iterable,\n                                     PathfindingSettings pathfindingSettings,\n                                     SearchState searchState,\n                                     SearchStatistics searchStatistics) {\n\n        Map&lt;Integer, PriorityQueue&lt;HeapNode&gt;&gt; open = new HashMap&lt;&gt;();\n        Map&lt;Integer, Set&lt;Cell&gt;&gt; closed             = new HashMap&lt;&gt;();\n        Map&lt;Cell, Double&gt; g                        = new HashMap&lt;&gt;();\n        Map&lt;Cell, Cell&gt; p                          = new HashMap&lt;&gt;();\n\n        HeuristicFunction h = pathfindingSettings.getHeuristicFunction();\n        Cell source = model.getSourceGridCell();\n        Cell target = model.getTargetGridCell();\n\n        Cell bestGoal = null;\n        int layerIndex = 0;\n\n        open.put(0, new PriorityQueue&lt;&gt;());\n        open.put(1, new PriorityQueue&lt;&gt;());\n        open.get(0).add(new HeapNode(source, 0.0));\n\n        closed.put(0, new HashSet&lt;&gt;());\n        g.put(source, 0.0);\n        p.put(source, null);\n\n        searchStatistics.incrementOpened();\n\n        // Track the smallest f among nodes pruned by beam width restriction.\n        double globalMinPrunedF = Double.POSITIVE_INFINITY;\n\n        while (!open.get(layerIndex).isEmpty() ||\n                !open.get(layerIndex + 1).isEmpty()) {\n\n            while (!open.get(layerIndex).isEmpty()) {\n\n                if (searchState.haltRequested()) {\n                    throw new HaltRequestedException();\n                }\n\n                while (searchState.pauseRequested()) {\n                    searchSleep(pathfindingSettings);\n                    if (searchState.haltRequested()) {\n                        throw new HaltRequestedException();\n                    }\n                }\n\n                Cell cell = open.get(layerIndex).remove().cell;\n                closed.get(layerIndex).add(cell);\n                searchStatistics.decrementOpened();\n                searchStatistics.incrementVisited();\n\n                if (!cell.getCellType().equals(CellType.SOURCE) &amp;&amp;\n                        !cell.getCellType().equals(CellType.TARGET)) {\n                    model.setCellType(cell, CellType.VISITED);\n                }\n\n                if (cell.equals(target)) {\n                    U.value = g.get(cell);\n                    bestGoal = cell;\n                }\n\n                iterable.setStartingCell(cell);\n                BeamStackEntry bse = beamStack.peek();\n\n                for (Cell child : iterable) {\n                    if (searchState.haltRequested()) {\n                        throw new HaltRequestedException();\n                    }\n\n                    while (searchState.pauseRequested()) {\n                        searchSleep(pathfindingSettings);\n\n                        if (searchState.haltRequested()) {\n                            throw new HaltRequestedException();\n                        }\n                    }\n\n                    double tentativeGscore = g.get(cell)\n                            + pathfindingSettings\n                            .getWeight(cell,\n                                    child);\n\n                    if (tentativeGscore &lt; g.getOrDefault(\n                            child,\n                            Double.POSITIVE_INFINITY)) {\n\n                        double f = tentativeGscore + h.estimate(child, target);\n\n                        searchSleep(pathfindingSettings);\n\n                        if (bse.fmin &lt;= f &amp;&amp; f &lt; bse.fmax) {\n                            Queue&lt;HeapNode&gt; nextOpen = open.get(layerIndex + 1);\n\n                            // Add for the first time or improve the g-cost:\n                            nextOpen.removeIf(\n                                    heapNode -&gt; heapNode.cell.equals(child));\n\n                            nextOpen.add(new HeapNode(child, f));\n\n                            g.put(child, tentativeGscore);\n                            p.put(child, cell);\n                            searchStatistics.incrementOpened();\n\n                            if (!child.getCellType().equals(CellType.SOURCE) &amp;&amp;\n                                    !child.getCellType().equals(CellType.TARGET)) {\n                                model.setCellType(child, CellType.OPENED);\n                            }\n                        }\n                    }\n                }\n\n                PriorityQueue&lt;HeapNode&gt; nextOpen = open.get(layerIndex + 1);\n\n                if (nextOpen.size() &gt; pathfindingSettings.getBeamWidth()) {\n                    double fmin = pruneLayer(model,\n                            nextOpen,\n                            pathfindingSettings,\n                            searchStatistics);\n                    globalMinPrunedF = Math.min(globalMinPrunedF, fmin);\n                }\n            }\n\n            layerIndex++;\n            open.put(layerIndex + 1, new PriorityQueue&lt;&gt;());\n            closed.put(layerIndex, new HashSet&lt;&gt;());\n            // For the next layer, allow the band [fmin, U), where fmin is the\n            // best f among nodes we just pruned (if any). If none were pruned,\n            // carry forward the current fmin so we keep exploring; only tighten\n            // when we actually observed pruned nodes.\n            double nextFmin = Double.isFinite(globalMinPrunedF)\n                    ? globalMinPrunedF\n                    : beamStack.peek().fmin;\n            beamStack.push(new BeamStackEntry(nextFmin, U.value));\n        }\n\n        for (PriorityQueue&lt;HeapNode&gt; queue : open.values()) {\n            for (HeapNode heapNode : queue) {\n                Cell cell = heapNode.cell;\n\n                if (!cell.getCellType().equals(CellType.SOURCE) &amp;&amp;\n                        !cell.getCellType().equals(CellType.TARGET)) {\n                    model.setCellType(cell, CellType.FREE);\n                }\n            }\n        }\n\n        for (Set&lt;Cell&gt; closedSet : closed.values()) {\n            for (Cell cell : closedSet) {\n                if (!cell.getCellType().equals(CellType.SOURCE) &amp;&amp;\n                        !cell.getCellType().equals(CellType.TARGET)) {\n                    model.setCellType(cell, CellType.FREE);\n                }\n            }\n        }\n\n        if (bestGoal != null) {\n            List&lt;Cell&gt; path = new ArrayList&lt;&gt;();\n\n            for (Cell cell = bestGoal;\n                 cell != null;\n                 cell = p.get(cell)) {\n\n                path.add(cell);\n            }\n\n            Collections.reverse(path);\n            return path;\n        }\n\n        // No goal found under current bands. Communicate the next threshold.\n        U.value = globalMinPrunedF;\n        return null;\n    }\n\n    private static double pruneLayer(GridModel model,\n                                     PriorityQueue&lt;HeapNode&gt; open,\n                                     PathfindingSettings pathfindingSettings,\n                                     SearchStatistics searchStatistics) {\n\n        List&lt;HeapNode&gt; keepList = new ArrayList&lt;&gt;(open);\n\n        for (HeapNode heapNode : keepList) {\n            Cell cell = heapNode.cell;\n\n            if (!cell.getCellType().equals(CellType.SOURCE) &amp;&amp;\n                    !cell.getCellType().equals(CellType.TARGET)) {\n                model.setCellType(cell, CellType.FREE);\n            }\n        }\n\n        keepList.sort((a, b) -&gt; Double.compare(a.f, b.f));\n        keepList = keepList.subList(0, pathfindingSettings.getBeamWidth());\n\n        for (HeapNode heapNode : keepList) {\n            Cell cell = heapNode.cell;\n\n            if (!cell.getCellType().equals(CellType.SOURCE) &amp;&amp;\n                    !cell.getCellType().equals(CellType.TARGET)) {\n                model.setCellType(cell, CellType.OPENED);\n            }\n        }\n\n        List&lt;HeapNode&gt; pruneList = new ArrayList&lt;&gt;();\n        double fmin = Double.POSITIVE_INFINITY;\n\n        for (HeapNode heapNode : open) {\n            if (!keepList.contains(heapNode)) {\n                pruneList.add(heapNode);\n                fmin = Math.min(fmin, heapNode.f);\n            }\n        }\n\n        for (HeapNode heapNode : pruneList) {\n            open.remove(heapNode);\n            Cell cell = heapNode.cell;\n\n            if (!cell.getCellType().equals(CellType.SOURCE) &amp;&amp;\n                    !cell.getCellType().equals(CellType.TARGET)) {\n                model.setCellType(cell, CellType.VISITED);\n            }\n        }\n\n        return fmin;\n    }\n\n    private static final class BeamStackEntry {\n        double fmin;\n        double fmax;\n\n        BeamStackEntry(double fmin, double fmax) {\n            this.fmin = fmin;\n            this.fmax = fmax;\n        }\n    }\n\n    private static final class DoubleHolder {\n        double value;\n    }\n}\n\n</code></pre>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 58650,
      "reputation" : 4945,
      "user_id" : 175554,
      "user_type" : "registered",
      "accept_rate" : 40,
      "profile_image" : "https://i.sstatic.net/KmFczdGy.jpg?s=256",
      "display_name" : "ozkanpakdil",
      "link" : "https://stackoverflow.com/users/175554/ozkanpakdil"
    },
    "creation_date" : 1758915169,
    "last_activity_date" : 1758915169,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79776316" : [ {
      "comment_id" : 140793480,
      "post_id" : 79776316,
      "body" : "@coderodde I know thats why I said <code>I know using BFS is not really Beam Stack Search but that</code>s all I can find so far.` meaning I am aware it is not really solving the problem you are asking, this is what I can come up so far, but if you prefer I can delete my answer.",
      "score" : 0,
      "owner" : {
        "account_id" : 58650,
        "reputation" : 4945,
        "user_id" : 175554,
        "user_type" : "registered",
        "accept_rate" : 40,
        "profile_image" : "https://i.sstatic.net/KmFczdGy.jpg?s=256",
        "display_name" : "ozkanpakdil",
        "link" : "https://stackoverflow.com/users/175554/ozkanpakdil"
      },
      "creation_date" : 1760380601,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140793176,
      "post_id" : 79776316,
      "body" : "Unfortunately, your implementation does not resolve the issues. :(",
      "score" : 0,
      "owner" : {
        "account_id" : 1044029,
        "reputation" : 967,
        "user_id" : 1049393,
        "user_type" : "registered",
        "accept_rate" : 67,
        "profile_image" : "https://www.gravatar.com/avatar/70e20177030730d59c63b1cee24e152f?s=256&d=identicon&r=PG",
        "display_name" : "coderodde",
        "link" : "https://stackoverflow.com/users/1049393/coderodde"
      },
      "creation_date" : 1760368872,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}