{
  "question" : {
    "question_id" : 79615635,
    "title" : "Which design pattern can use for search overloading function?",
    "body" : "<p>In a interview, someone asked me this situation. How can you improve this.\nsearch with many filter condition design pattern\nEg: let say search a gym by it distance, by its pincode, by its name, by its feature....</p>\n<pre><code>result search(distance);\nresult search(pincode);\nresult search(name);\nresult search(distance, pincode);\nresult search(distance, name);\n...\n...\nmany other combination\n</code></pre>\n<p>For every use case do I need a create a new search function overloading or I can use some best design pattern here</p>\n",
    "tags" : [ "java", "design-patterns", "system", "lld" ],
    "owner" : {
      "account_id" : 17456759,
      "reputation" : 45,
      "user_id" : 12655401,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/946433565a04be388de0607356f4979c?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "nitesh",
      "link" : "https://stackoverflow.com/users/12655401/nitesh"
    },
    "is_answered" : true,
    "view_count" : 86,
    "closed_date" : 1748105559,
    "answer_count" : 2,
    "score" : 0,
    "last_activity_date" : 1746956561,
    "creation_date" : 1746890432,
    "link" : "https://stackoverflow.com/questions/79615635/which-design-pattern-can-use-for-search-overloading-function",
    "closed_reason" : "Needs details or clarity"
  },
  "answers" : [ {
    "answer_id" : 79615653,
    "question_id" : 79615635,
    "body" : "<p>You definitely don't need to create a separate method or overload for every possible filter combination - that quickly becomes hard to read and maintain.</p>\n<p>You can try using this approach: use the <strong>Builder pattern</strong> to construct the filter object step by step, only setting the fields we care about</p>\n<p>Instead of writing a separate method for every search combination, define a <code>GymSearchFilter</code> class that holds all possible search criteria: <code>distance</code>, <code>pincode</code>, <code>name</code>, and <code>feature</code>:</p>\n<pre><code>public class GymSearchFilter {\n\n    public Integer distance;\n    public String pincode;\n    public String name;\n    public String feature;\n\n    private GymSearchFilter() {}\n\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    public static class Builder {\n        private final GymSearchFilter filter = new GymSearchFilter();\n\n        public Builder distance(int distance) {\n            filter.distance = distance;\n            return this;\n        }\n\n        public Builder pincode(String pincode) {\n            filter.pincode = pincode;\n            return this;\n        }\n\n        public Builder name(String name) {\n            filter.name = name;\n            return this;\n        }\n\n        public Builder feature(String feature) {\n            filter.feature = feature;\n            return this;\n        }\n\n        public GymSearchFilter build() {\n            return filter;\n        }\n    }\n}\n\n</code></pre>\n<p>Then create a single <code>search()</code> method that checks which filters are present and applies them. Inside <code>GymService</code>, use a Java stream to filter a list of gyms based on the values in the filter object:</p>\n<pre><code>public class GymService {\n\n    private List&lt;Gym&gt; gyms = List.of(\n        new Gym(&quot;Gym1&quot;, &quot;12345&quot;, 1, &quot;Gym1&quot;),\n        new Gym(&quot;Gym2&quot;, &quot;54321&quot;, 2, &quot;Gym2&quot;),\n        new Gym(&quot;Gy3&quot;, &quot;12345&quot;, 3, &quot;Gym3&quot;)\n    );\n\n    public List&lt;Gym&gt; search(GymSearchFilter filter) {\n        return gyms.stream()\n            .filter(g -&gt; filter.name == null || g.name.equalsIgnoreCase(filter.name))\n            .filter(g -&gt; filter.pincode == null || g.pincode.equals(filter.pincode))\n            .filter(g -&gt; filter.distance == null || g.distance &lt;= filter.distance)\n            .filter(g -&gt; filter.feature == null || g.feature.contains(filter.feature))\n            .toList();\n    }\n}\n</code></pre>\n<p>How it works:</p>\n<pre><code>public class Main {\n    public static void main(String[] args) {\n        GymService service = new GymService();\n\n        GymSearchFilter filter = GymSearchFilter.builder()\n            .pincode(&quot;12345&quot;)\n            .distance(5)\n            .build();\n\n        List&lt;Gym&gt; result = service.search(filter);\n        result.forEach(System.out::println);\n    }\n}\n\n</code></pre>\n",
    "score" : 4,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 38931631,
      "reputation" : 671,
      "user_id" : 29023248,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/WxoZEuKw.png?s=256",
      "display_name" : "Aleksey Bykov",
      "link" : "https://stackoverflow.com/users/29023248/aleksey-bykov"
    },
    "creation_date" : 1746891261,
    "last_activity_date" : 1746891808,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79616359,
    "question_id" : 79615635,
    "body" : "<p>I do not know if it is the best option, to me it seems simpler to understand and implement, we only need to create an array of <strong>Object</strong> that will have the values of the attributes searched, and another of <strong>enum</strong> indicating what type of attribute we are looking for.</p>\n<pre><code>  // we create the &quot;enum&quot;\nenum Type {\n   DISTANCE,\n   PINCODE,\n   NAME,\n   FEATURE\n}\n\npublic class Gym {\n\n     // this method examines the requested attributes, \n     // and if it does not find a match in any of them, \n     // it returns “false”. \n   boolean search( Object[] values, Type[] types ) {\n      for( int i = 0; i &lt; types.length; i ++ ) {\n         if( types[ i ] == DISTANCE ) {\n            if( distance != (int) values[ i ] ) {\n               return false;\n            }\n         }\n         else if( types[ i ] == PINCODE ) {\n            if(  ! pincode.equals( (String) values[ i ] ) ) {\n               return false;\n            }\n         }\n         else if( types[ i ] == NAME ) {\n            if(  ! name.equals( (String) values[ i ] ) ) {\n               return false;\n            }\n         }\n         else if( types[ i ] == FEATURE ) {\n            if(  ! feature.equals( (String) values[ i ] ) ) {\n               return false;\n            }\n         }\n      }\n      return true;\n   }\n\n   ...\n}\n</code></pre>\n<pre><code>\nclass GymSearchFilter {\n\n   void find() {\n\n        // we create an array of &quot;Type&quot;\n      Type types[] = new Type[]{ NAME, PINCODE };\n\n        // an array of values\n      Object values[] = new Object[] { &quot;Cesar&quot;, &quot;abc&quot; }; \n\n        // we traverse the “Gym” array\n      for( Gym gy : gyms ) {\n\n           // if we find a match, we show the “Gym”.\n         if( gy.search( values, types ) ) {\n            System.out.println( gy );\n            return;\n         }\n      }\n      System.out.println( &quot;n&quot; );\n   }\n}\n\n</code></pre>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 10843443,
      "reputation" : 916,
      "user_id" : 20882864,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/CCQCy.jpg?s=256",
      "display_name" : "Marce Puente",
      "link" : "https://stackoverflow.com/users/20882864/marce-puente"
    },
    "creation_date" : 1746956561,
    "last_activity_date" : 1746956561,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}