{
  "question" : {
    "question_id" : 79720855,
    "title" : "Why does CloudFlare R2 calculate a different SignatureV4 when using awssdk&#39;s S3AsyncClient",
    "body" : "<p>Using <code>software.amazon.awssdk:s3:2.32.11</code> I started with the following code:</p>\n<pre><code>var objectKey = &quot;test.txt&quot;;\nvar path = Path.of(&quot;/tmp/test/log.txt&quot;);\nvar credentials = StaticCredentialsProvider.create(AwsBasicCredentials.create(config.accessKey, config.secretKey));\n\nvar client = S3Client.builder()\n    .endpointOverride(URI.create(config.endpoint))\n    .credentialsProvider(credentials)\n    .region(Region.of(config.region))\n    .serviceConfiguration(S3Configuration.builder().pathStyleAccessEnabled(true).build())\n    .build();\nclient.putObject(b -&gt; b.bucket(config.bucket).key(objectKey), path);\n</code></pre>\n<p>This works, and I get my log file uploaded to R2 as expected.</p>\n<p>However, if I try and swap this out for an S3Async client:</p>\n<pre><code>var objectKey = &quot;test.txt&quot;;\nvar path = Path.of(&quot;/tmp/test/log.txt&quot;);\nvar credentials = StaticCredentialsProvider.create(AwsBasicCredentials.create(config.accessKey, config.secretKey));\n\nvar client = S3AsyncClient.builder()\n    .endpointOverride(URI.create(config.endpoint))\n    .credentialsProvider(credentials)\n    .region(Region.of(config.region))\n    .serviceConfiguration(S3Configuration.builder().pathStyleAccessEnabled(true).build())\n    .build();\nclient.putObject(b -&gt; b.bucket(config.bucket).key(objectKey), path).join();\n</code></pre>\n<p>I get the following error:</p>\n<pre><code>Exception in thread &quot;main&quot; java.util.concurrent.CompletionException: software.amazon.awssdk.services.s3.model.S3Exception: The request signature we calculated does not match the signature you provided. Check your secret access key and signing method. (Service: S3, Status Code: 403, Request ID: null) (SDK Attempt Count: 1)\nat software.amazon.awssdk.utils.CompletableFutureUtils.errorAsCompletionException(CompletableFutureUtils.java:64)\nat software.amazon.awssdk.core.internal.http.pipeline.stages.AsyncExecutionFailureExceptionReportingStage.lambda$execute$0(AsyncExecutionFailureExceptionReportingStage.java:51)\nat java.base/java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:934)\nat java.base/java.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:911)\nat java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)\nat java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)\nat software.amazon.awssdk.utils.CompletableFutureUtils.lambda$forwardExceptionTo$0(CompletableFutureUtils.java:78)\nat java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:863)\nat java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:841)\nat java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)\nat java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2194)\nat software.amazon.awssdk.core.internal.http.pipeline.stages.AsyncRetryableStage$RetryingExecutor.maybeAttemptExecute(AsyncRetryableStage.java:139)\nat software.amazon.awssdk.core.internal.http.pipeline.stages.AsyncRetryableStage$RetryingExecutor.maybeRetryExecute(AsyncRetryableStage.java:157)\nat software.amazon.awssdk.core.internal.http.pipeline.stages.AsyncRetryableStage$RetryingExecutor.lambda$attemptExecute$1(AsyncRetryableStage.java:127)\nat java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:863)\nat java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:841)\nat java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)\nat java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2179)\nat software.amazon.awssdk.core.internal.http.pipeline.stages.MakeAsyncHttpRequestStage.lambda$execute$0(MakeAsyncHttpRequestStage.java:110)\nat java.base/java.util.concurrent.CompletableFuture.uniWhenComplete(CompletableFuture.java:863)\nat java.base/java.util.concurrent.CompletableFuture$UniWhenComplete.tryFire(CompletableFuture.java:841)\nat java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:510)\nat java.base/java.util.concurrent.CompletableFuture.complete(CompletableFuture.java:2179)\nat software.amazon.awssdk.core.internal.http.pipeline.stages.MakeAsyncHttpRequestStage.completeResponseFuture(MakeAsyncHttpRequestStage.java:253)\nat software.amazon.awssdk.core.internal.http.pipeline.stages.MakeAsyncHttpRequestStage.lambda$executeHttpRequest$3(MakeAsyncHttpRequestStage.java:167)\nat java.base/java.util.concurrent.CompletableFuture.uniHandle(CompletableFuture.java:934)\nat java.base/java.util.concurrent.CompletableFuture$UniHandle.tryFire(CompletableFuture.java:911)\nat java.base/java.util.concurrent.CompletableFuture$Completion.run(CompletableFuture.java:482)\nat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)\nat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)\nat java.base/java.lang.Thread.run(Thread.java:1589)\n</code></pre>\n<p>All of the credentials, region, endpoint, nothing changes. Only the client, yet I get a signature validation error. Even if I disable multi-part uploads in the async builder <code>.multipartEnabled(false)</code>, makes no difference, async client still throws the same error.</p>\n<p>The token I'm using has object read &amp; write privileges to this specific bucket.<a href=\"https://i.sstatic.net/lQ0ymur9.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/lQ0ymur9.png\" alt=\"enter image description here\" /></a></p>\n<p>I've tried turning on and off just about every client setting you could think of, but I just can't seem to get the async client to validate. Wondering if I'm perhaps missing something obvious.</p>\n<p><strong>EDIT:</strong> I've managed to successfully upload using the async client by switching the default checksum validation from &quot;WHEN_SUPPORTED&quot; to &quot;WHEN_REQUIRED&quot;: <code>.requestChecksumCalculation(RequestChecksumCalculation.WHEN_REQUIRED)</code></p>\n<p>However, I'm not certain if this is the ideal solution and if there's a way to actually fix the checksum validation instead.</p>\n",
    "tags" : [ "java", "amazon-s3", "aws-sdk", "aws-sdk-java-2.0", "cloudflare-r2" ],
    "owner" : {
      "account_id" : 10034154,
      "reputation" : 631,
      "user_id" : 7419493,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/hiURT.png?s=256",
      "display_name" : "justis",
      "link" : "https://stackoverflow.com/users/7419493/justis"
    },
    "is_answered" : false,
    "view_count" : 79,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1753944734,
    "creation_date" : 1753942902,
    "link" : "https://stackoverflow.com/questions/79720855/why-does-cloudflare-r2-calculate-a-different-signaturev4-when-using-awssdks-s3a",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ ],
  "answer_comments" : { }
}