{
  "question" : {
    "question_id" : 79840265,
    "title" : "Validating JSON Web Tokens in Java",
    "body" : "<p>Does anyone knows why this occurs working with JWTs ?</p>\n<p><strong>Here's the logic behind token creation:</strong></p>\n<pre><code>public String makeToken(String username) {\n\n        long calc = 24 * 60 * 60 * 1000L; // 1 day expiration\n        long date = (System.currentTimeMillis() + calc) / 1000;\n    \n        var token = Jwts.builder()\n                .subject(username)\n                .issuedAt(new Date())\n                .expiration(new Date(date * 1000L))\n                .signWith(supersecretkey)\n                .compact();\n    \n        log.debug(&quot;A cute token has spawned: {}&quot;, token);\n        return token;\n    }\n</code></pre>\n<p><strong>And heres for validating the token:</strong></p>\n<pre class=\"lang-java prettyprint-override\"><code>public Boolean validateToken(String token) {\n        try {\n            Jwts.parser()\n                    .verifyWith(supersecretkey)\n                    .build()\n                    .parseSignedClaims(token);\n        } catch (JwtException e) {\n            log.error(&quot;Invalid JWT token: {}&quot;, token);\n        }\n        return true;\n    }\n</code></pre>\n<p>Now the problem is whenever i call the validateToken method and passing the token explicitly  generated by the makeToken as string it throws the catch error</p>\n<p>like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>var tk = token.makeToken(&quot;Kushane&quot;);\n        var result = token.validateToken(tk);\n\n        log.info(&quot;Token: {}&quot;, tk);\n        log.info(&quot;Result: {}&quot;, result);\n</code></pre>\n<p><strong>Output: token string, true</strong></p>\n<p>but this doesnt work:</p>\n<pre class=\"lang-java prettyprint-override\"><code>var tk = &quot;eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJLdXNoYW5lIiwiaWF0IjoxNzY1MTAwNTcwLCJleHAiOjE3NjUxODY5NzB9.npZp5gTPC-3mjqlLoQVVO2cmSsRfkzOeRZylKOqPf-4&quot;; // same one generated by makeToken earlier\n        var result = token.validateToken(tk);\n\n        log.info(&quot;Token: {}&quot;, tk);\n        log.info(&quot;Result: {}&quot;, result);\n</code></pre>\n<p><strong>Output: Invalid JWT Token</strong></p>\n<p>Does validating JWT's require different data type?</p>\n",
    "tags" : [ "java", "jwt" ],
    "owner" : {
      "account_id" : 44936070,
      "reputation" : 1,
      "user_id" : 32013251,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/5b73d98938d052938a0e7c9b567195db?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Dave Montesa",
      "link" : "https://stackoverflow.com/users/32013251/dave-montesa"
    },
    "is_answered" : true,
    "view_count" : 56,
    "answer_count" : 1,
    "score" : -1,
    "last_activity_date" : 1765118733,
    "creation_date" : 1765114999,
    "link" : "https://stackoverflow.com/questions/79840265/validating-json-web-tokens-in-java",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79840295,
    "question_id" : 79840265,
    "body" : "<p>I think there are 2 problems here:</p>\n<p>Firstly, you should use return true/false in the right place.</p>\n<pre><code>public Boolean validateToken(String token) {\n    try {\n        Jwts.parser()\n                .verifyWith(supersecretkey)\n                .build()\n                .parseSignedClaims(token);\n        return true;\n    } catch (JwtException e) {\n        log.error(&quot;Invalid JWT token: {}&quot;, e.getMessage());\n        return false;\n    }\n}\n</code></pre>\n<p>Secondly, your supersecretkey is being regenerated each time the application starts. if you create it currenly like:</p>\n<pre><code>private SecretKey supersecretkey = Jwts.SIG.HS256.key().build();\n// or\nprivate SecretKey supersecretkey = Keys.secretKeyFor(SignatureAlgorithm.HS256);\n</code></pre>\n<p>in this case, every application restart creates a <strong>new random key</strong>, which invalidates all previously generated tokens.</p>\n<p>Use a persistent secret key: in your application.yml</p>\n<p>Then use it in your methods:</p>\n<pre><code>public String makeToken(String username) {\n    // ...\n    .signWith(getSigningKey())\n    // ..\n}\n\npublic Boolean validateToken(String token) {\n    // ...\n    .verifyWith(getSigningKey())\n    // ...\n}\n</code></pre>\n<pre><code>jwt.secret=your-very-long-secret-key-at-least-256-bits-for-hs256\n\n// In your class\n@Value(&quot;${jwt.secret}&quot;)\nprivate String secretString;\n\nprivate SecretKey getSigningKey() {\n    return Keys.hmacShaKeyFor(secretString.getBytes(StandardCharsets.UTF_8));\n}\n</code></pre>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 25583936,
      "reputation" : 1264,
      "user_id" : 19361968,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/1d19c6d51232c67af617cf944af5a30c?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Murat K.",
      "link" : "https://stackoverflow.com/users/19361968/murat-k"
    },
    "creation_date" : 1765118733,
    "last_activity_date" : 1765118733,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140892669,
    "post_id" : 79840265,
    "body" : "&quot;it throws the catch error&quot; ...and that exception is telling you what went wrong.  Perhaps you should look at it.  Also you really really should include the entire stack trace of the exception in your question, so <i>we</i> know what went wrong.",
    "score" : 0,
    "owner" : {
      "account_id" : 2053598,
      "reputation" : 44971,
      "user_id" : 1831987,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/38b1c37530189ec4471a43a618e33f67?s=256&d=identicon&r=PG",
      "display_name" : "VGR",
      "link" : "https://stackoverflow.com/users/1831987/vgr"
    },
    "creation_date" : 1765203344,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140892175,
    "post_id" : 79840265,
    "body" : "In your code you catch the exception but ignore the information given in the exception object e. At lease add a <code>log.info(&quot;Exception: {}&quot;, e.Message);</code> and then update the question above with the exact output.",
    "score" : 0,
    "owner" : {
      "account_id" : 9899349,
      "reputation" : 22931,
      "user_id" : 7329832,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/eVENC.png?s=256",
      "display_name" : "jps",
      "link" : "https://stackoverflow.com/users/7329832/jps"
    },
    "creation_date" : 1765182312,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140892164,
    "post_id" : 79840265,
    "body" : "What exception does it throws?",
    "score" : 1,
    "owner" : {
      "account_id" : 4497436,
      "reputation" : 20796,
      "user_id" : 3656904,
      "user_type" : "registered",
      "accept_rate" : 67,
      "profile_image" : "https://www.gravatar.com/avatar/8bdbd1f89f8907e8e8b15ab88c084c65?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "talex",
      "link" : "https://stackoverflow.com/users/3656904/talex"
    },
    "creation_date" : 1765181648,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79840295" : [ {
      "comment_id" : 140892666,
      "post_id" : 79840295,
      "body" : "Logging <code>e.getMessage()</code> is wrong.  Always, always, always log the entire exception object (that is, just <code>e</code>), so the stack trace is included in the log.  Knowing exactly where the exception occurred is quite valuable.",
      "score" : 1,
      "owner" : {
        "account_id" : 2053598,
        "reputation" : 44971,
        "user_id" : 1831987,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/38b1c37530189ec4471a43a618e33f67?s=256&d=identicon&r=PG",
        "display_name" : "VGR",
        "link" : "https://stackoverflow.com/users/1831987/vgr"
      },
      "creation_date" : 1765203227,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}