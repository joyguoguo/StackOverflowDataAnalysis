{
  "question" : {
    "question_id" : 79618490,
    "title" : "Minimize Total Blocks Carried Before All Robots Shut Down",
    "body" : "<p>Here's the coding task:</p>\n<p>You are commanding a team of robots. Each robot:</p>\n<p>Can carry a certain number of blocks per second (carry[i])</p>\n<p>Has a battery with some initial level (battery[i])</p>\n<p>You also have a zapper that can target one robot per second, reducing its battery by k units. If a robot’s battery reaches 0 or below, it stops working and no longer contributes to the block carrying.</p>\n<p>Each second:</p>\n<p>You zap one robot (your choice).</p>\n<p>All working robots carry blocks.</p>\n<p>The goal is to zap robots in such a way that the total number of blocks carried before they all shut down (plus one final block to finish the mission) is minimized.</p>\n<pre><code>Example:\nn = 2\ncarry   = [3, 4]\nbattery = [4, 6]\nk = 3\n\nOne possible strategy:\n\nTime    Blocks Carried  Zapped Robot    New Battery\n1       3 + 4 = 7        B              6 → 3\n2       3 + 4 = 7        B              3 → 0 ❌\n3       3                A              4 → 1\n4       3                A              1 → -2 ❌\n5       1 (final)        —              —\n\nTotal blocks carried: 7 + 7 + 3 + 3 + 1 = 21\n</code></pre>\n<p>Rules:\nYou can zap one robot per second</p>\n<p>Robots stop working when battery ≤ 0</p>\n<p>All working robots carry blocks every second</p>\n<p>After all robots stop, you must carry one final block to complete the mission</p>\n<p>Constraints:</p>\n<pre><code>1 ≤ n ≤ 10^5 (number of robots)\n\n1 ≤ carry[i], battery[i] ≤ 5000\n\n1 ≤ k ≤ 5000\n</code></pre>\n<p>This is an interview question asked in hackerrank, I dn't have a link of it to share here.</p>\n<p>This is what I tried, but my code passed only 5 test cases out of 15 and remaining 10 test cases failed with wrong answer.</p>\n<pre><code>import java.util.*;\n\npublic class Main {\n    public static long solve(List&lt;Integer&gt; carry, List&lt;Integer&gt; battery, int k) {\n        int n = carry.size();\n        List&lt;int[]&gt; list = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; n; i++) {\n            int c = carry.get(i);\n            int b = battery.get(i);\n            int t = (b + k - 1) / k; // ceil(h / k)\n            list.add(new int[]{c, t});\n        }\n        \n        list.sort((a, b) -&gt; Integer.compare(b[0], a[0]));\n        \n        long result = 0;\n        long currentActiveTime = 0;\n        \n        for (int[] e : list) {\n            currentActiveTime += e[1];\n            result += e[0] * currentActiveTime;\n        }\n        // Add the final concluding point\n        result += 1;\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(solve(Arrays.asList(3, 4), Arrays.asList(4, 6), 3)); // Should print 21\n        \n        System.out.println(solve(Arrays.asList(1, 2, 3), Arrays.asList(3, 2, 1), 2)); // Should print 12\n        System.out.println(solve(Arrays.asList(75,45,81,29,2,25,84,56,2,37,39,11,6,68,16,63,49,10,68,80), \nArrays.asList(26,72,47,97,75,82,17,32,28,57,18,79,40,68,40,93,91,55,31,57), 18)); // wrong output 17712\n    }\n}\n</code></pre>\n<p>I added some test cases in the main method with the expected answer, I added one sample test case, which is failing:</p>\n<pre><code>System.out.println(solve(Arrays.asList(75,45,81,29,2,25,84,56,2,37,39,11,6,68,16,63,49,10,68,80), \nArrays.asList(26,72,47,97,75,82,17,32,28,57,18,79,40,68,40,93,91,55,31,57), 18)); // wrong output 17712\n</code></pre>\n<p>In log messages, I just found the input and output values, but the actual expected output is hidden for this test case.</p>\n<p>Question:\nHow can I minimize the total number of blocks carried before all robots stop (including the one final block)? Is there an efficient greedy or priority queue-based approach to solve this?</p>\n",
    "tags" : [ "java", "algorithm" ],
    "owner" : {
      "account_id" : 31187804,
      "reputation" : 794,
      "user_id" : 23993901,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/7417aaad0c8ece3fac44f06d05a8ba8b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "CodeCrusader",
      "link" : "https://stackoverflow.com/users/23993901/codecrusader"
    },
    "is_answered" : true,
    "view_count" : 130,
    "answer_count" : 2,
    "score" : 1,
    "last_activity_date" : 1747322293,
    "creation_date" : 1747076082,
    "link" : "https://stackoverflow.com/questions/79618490/minimize-total-blocks-carried-before-all-robots-shut-down",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79618895,
    "question_id" : 79618490,
    "body" : "<p>Consider 2 robots.  The first has carrying capacity c1 and takes b1 zaps to kill.  The second has carrying capacity c2 and take b2 zaps to kill.</p>\n<p>If we kill robot 1 first, and then immediately kill robot 2, the total blocks carried by those robots during the killing time is:</p>\n<p>c1 * b1 + c2 * (b1 + b2)</p>\n<p>On the other hand, if will kill robot 2 first and then immediately kill robot 1, the total blocks carried is:</p>\n<p>c1 * (b1 + b2) + c2 * b2</p>\n<p>It's advantageous to kill robot 1 first if:</p>\n<p>c1 * b1 + c2 * (b1 + b2) &lt; c1 * (b1 + b2) + c2 * b2</p>\n<p>&lt;=&gt; c2 * b1 &lt; c1 *  b2</p>\n<p>&lt;=&gt; c1/b1 &gt; c2/b2</p>\n<p>So for any two robots killed adjacently, we should kill the one with the highest capacity:battery ratio first, where battery is measured in zaps-to-kill.</p>\n<p>Since this relation is transitive (c1/b1 &lt; c2/b2 and c2/b2 &lt; c3/b3 =&gt; c1/b1 &lt; c3/b3), establishing the proper order for each adjacent pair establishes the proper order for the whole list...</p>\n<p>Sort the robots in order of decreasing capacity:battery ratio, and kill them in that order.</p>\n",
    "score" : 11,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 7178634,
      "reputation" : 60910,
      "user_id" : 5483526,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/780a651189f64a2cbf4b7f62cf852005?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Matt Timmermans",
      "link" : "https://stackoverflow.com/users/5483526/matt-timmermans"
    },
    "creation_date" : 1747106679,
    "last_activity_date" : 1747106679,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79618610,
    "question_id" : 79618490,
    "body" : "<p>The problem is to choose which robot to zap when the opportunity arrives, once per second.</p>\n<p>The algorithm to choose the target robot is:</p>\n<p>Each second, zap robot that can carry the most blocks = carry rate * battery level</p>\n<p>In detail:</p>\n<p>Every second, loop over the robots and calculate the product of the robot's carry rate and battery level.  ( Notice that dead robots will have a product of zero )  As you go along, keep track of which robot has the largest product.  Finally zap the robot with the largest product.</p>\n",
    "score" : -2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 9061,
      "reputation" : 21190,
      "user_id" : 16582,
      "user_type" : "registered",
      "accept_rate" : 67,
      "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
      "display_name" : "ravenspoint",
      "link" : "https://stackoverflow.com/users/16582/ravenspoint"
    },
    "creation_date" : 1747082570,
    "last_activity_date" : 1747083985,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140419376,
    "post_id" : 79618490,
    "body" : "Done.  See answer.",
    "score" : 0,
    "owner" : {
      "account_id" : 9061,
      "reputation" : 21190,
      "user_id" : 16582,
      "user_type" : "registered",
      "accept_rate" : 67,
      "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
      "display_name" : "ravenspoint",
      "link" : "https://stackoverflow.com/users/16582/ravenspoint"
    },
    "creation_date" : 1747082583,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140419289,
    "post_id" : 79618490,
    "body" : "@ravenspoint, can you please add more details of the approach",
    "score" : 0,
    "owner" : {
      "account_id" : 31187804,
      "reputation" : 794,
      "user_id" : 23993901,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/7417aaad0c8ece3fac44f06d05a8ba8b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "CodeCrusader",
      "link" : "https://stackoverflow.com/users/23993901/codecrusader"
    },
    "creation_date" : 1747080050,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140419184,
    "post_id" : 79618490,
    "body" : "Each second, zap robot that can carry the most blocks = carry rate * battery level",
    "score" : 0,
    "owner" : {
      "account_id" : 9061,
      "reputation" : 21190,
      "user_id" : 16582,
      "user_type" : "registered",
      "accept_rate" : 67,
      "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
      "display_name" : "ravenspoint",
      "link" : "https://stackoverflow.com/users/16582/ravenspoint"
    },
    "creation_date" : 1747077024,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79618895" : [ {
      "comment_id" : 140422983,
      "post_id" : 79618895,
      "body" : "More info:  This is widely known as &quot;Smith&#39;s Rule&quot;, proven optimal for an equivalent problem by Wayne Smith in 1956: W. E. Smith, “Various Optimizers for Single-Stage Production,” Naval Research Logistics Quarterly, Vol. 3, 1956, No. 1-2, pp. 59-66",
      "score" : 1,
      "owner" : {
        "account_id" : 7178634,
        "reputation" : 60910,
        "user_id" : 5483526,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/780a651189f64a2cbf4b7f62cf852005?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Matt Timmermans",
        "link" : "https://stackoverflow.com/users/5483526/matt-timmermans"
      },
      "creation_date" : 1747169933,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140422210,
      "post_id" : 79618895,
      "body" : "This argument is correct. That any other order isn&#39;t optimal can be seen by the fact switching any pair of robots that doesn&#39;t satisfy the condition, results in a better order. Therefore the only local minimum is the one described. In a finite set with only one local minimum, that local minimum must also be a global one.",
      "score" : 0,
      "owner" : {
        "account_id" : 286249,
        "reputation" : 47816,
        "user_id" : 585411,
        "user_type" : "registered",
        "accept_rate" : 60,
        "profile_image" : "https://i.sstatic.net/xvEpe.jpg?s=256",
        "display_name" : "btilly",
        "link" : "https://stackoverflow.com/users/585411/btilly"
      },
      "creation_date" : 1747153610,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79618610" : [ {
      "comment_id" : 140429867,
      "post_id" : 79618610,
      "body" : "testing with example given in question gives worse result if choosing first when both &quot;<i>can carry</i>&quot; the same (second step: <code>battery = {4, 3}</code> and <code>carry = {3, 4}</code>)  - results in 25 instead of 21",
      "score" : 0,
      "owner" : {
        "account_id" : 31180,
        "reputation" : 29752,
        "user_id" : 85421,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/kKvXH.gif?s=256",
        "display_name" : "user85421",
        "link" : "https://stackoverflow.com/users/85421/user85421"
      },
      "creation_date" : 1747332028,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140420836,
      "post_id" : 79618610,
      "body" : "More battery makes you less desirable to kill, not more. Timmerman&#39;s formula (carry / zaps-to-kill) makes much more sense (and can be proven correct)",
      "score" : 0,
      "owner" : {
        "account_id" : 8546,
        "reputation" : 18030,
        "user_id" : 15472,
        "user_type" : "registered",
        "accept_rate" : 87,
        "profile_image" : "https://www.gravatar.com/avatar/9b4128da626e5b0049cd4fb88033e3b3?s=256&d=identicon&r=PG",
        "display_name" : "tucuxi",
        "link" : "https://stackoverflow.com/users/15472/tucuxi"
      },
      "creation_date" : 1747129849,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140419962,
      "post_id" : 79618610,
      "body" : "For 2 robots with equal carrying capacity, it&#39;s advantageous to kill the one with the lowest battery first, which is the opposite of the order you propose.",
      "score" : 3,
      "owner" : {
        "account_id" : 7178634,
        "reputation" : 60910,
        "user_id" : 5483526,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/780a651189f64a2cbf4b7f62cf852005?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Matt Timmermans",
        "link" : "https://stackoverflow.com/users/5483526/matt-timmermans"
      },
      "creation_date" : 1747106768,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140419649,
      "post_id" : 79618610,
      "body" : "Yes it will. One unit will be carried.  The other way around 100 units will be carried.  The goal is to minimize the units carried.",
      "score" : 0,
      "owner" : {
        "account_id" : 9061,
        "reputation" : 21190,
        "user_id" : 16582,
        "user_type" : "registered",
        "accept_rate" : 67,
        "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
        "display_name" : "ravenspoint",
        "link" : "https://stackoverflow.com/users/16582/ravenspoint"
      },
      "creation_date" : 1747091546,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140419624,
      "post_id" : 79618610,
      "body" : "The first robot has carry rate  times battery of 100, the second has carry rate times battery of a million. If you pick greedily based on carry rate  times battery, which is what you describe, the second robot will get shot first.",
      "score" : 0,
      "owner" : {
        "account_id" : 286249,
        "reputation" : 47816,
        "user_id" : 585411,
        "user_type" : "registered",
        "accept_rate" : 60,
        "profile_image" : "https://i.sstatic.net/xvEpe.jpg?s=256",
        "display_name" : "btilly",
        "link" : "https://stackoverflow.com/users/585411/btilly"
      },
      "creation_date" : 1747090571,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140419578,
      "post_id" : 79618610,
      "body" : "The first robot will be shot in the first second, carrying no blocks.  The second robot will be shot in the 2nd second, after carrying one block.  The other way around and 10 blocks will have been successfully carried.  ( @btilly, I am happy to have my suggestions reviewed carefully, but I would appreciate it if you were to take a moment to express  yourself more politely. )",
      "score" : 0,
      "owner" : {
        "account_id" : 9061,
        "reputation" : 21190,
        "user_id" : 16582,
        "user_type" : "registered",
        "accept_rate" : 67,
        "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
        "display_name" : "ravenspoint",
        "link" : "https://stackoverflow.com/users/16582/ravenspoint"
      },
      "creation_date" : 1747088697,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140419551,
      "post_id" : 79618610,
      "body" : "This algorithm is wrong. Consider what happens if one robot carries 10 blocka and can last 10 turns, while the other carries 1 block and can last a million turns. Your algorithm would shoot the 1 block robot first, but you should shoot the 10 block robot first.",
      "score" : 0,
      "owner" : {
        "account_id" : 286249,
        "reputation" : 47816,
        "user_id" : 585411,
        "user_type" : "registered",
        "accept_rate" : 60,
        "profile_image" : "https://i.sstatic.net/xvEpe.jpg?s=256",
        "display_name" : "btilly",
        "link" : "https://stackoverflow.com/users/585411/btilly"
      },
      "creation_date" : 1747087631,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140419436,
      "post_id" : 79618610,
      "body" : "Edited answer, to make distinction between requirement and algorithm",
      "score" : 0,
      "owner" : {
        "account_id" : 9061,
        "reputation" : 21190,
        "user_id" : 16582,
        "user_type" : "registered",
        "accept_rate" : 67,
        "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
        "display_name" : "ravenspoint",
        "link" : "https://stackoverflow.com/users/16582/ravenspoint"
      },
      "creation_date" : 1747084031,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140419421,
      "post_id" : 79618610,
      "body" : "sorry I am still trying to understand, no where in my question, there is a requirement to do <code>carry rate * battery level</code> so how it solves the problem.",
      "score" : 0,
      "owner" : {
        "account_id" : 31187804,
        "reputation" : 794,
        "user_id" : 23993901,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/7417aaad0c8ece3fac44f06d05a8ba8b?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "CodeCrusader",
        "link" : "https://stackoverflow.com/users/23993901/codecrusader"
      },
      "creation_date" : 1747083544,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}