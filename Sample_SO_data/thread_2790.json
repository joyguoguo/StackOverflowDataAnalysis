{
  "question" : {
    "question_id" : 79595148,
    "title" : "Java ArrayList and LinkedList performance",
    "body" : "<p>I know that it's a never-ending question that comes back every now and then, but I'm really confused about these two. This is what I understand about them.</p>\n<p>In theory:</p>\n<ul>\n<li>LinkedList is faster at adding elements at both ends (since there is no need for occasional resizing and copying of the list, which guarantees O(1) time without any special cases,</li>\n<li>Adding ONE ITEM to the middle of the list is O(n) in both cases, but still faster in ArrayList, since iterating over it is much faster</li>\n<li>Adding many items to the middle is O(1) in LinkedList if we already have a reference to the middle Node</li>\n</ul>\n<p>In practice:</p>\n<ul>\n<li>LinkedList is slower at adding/removing from the end than ArrayList (I guess due to ArrayList using much less memory)</li>\n</ul>\n<p>Which leaves me with one thought: LinkedList, in reality, is only better at adding/removing items from front and adding in the middle if we have a reference to the middle node. However, we can solve the problem of adding/removing in the beginning if we use ArrayDeque instead of it (as long as we don't care about random access). Then, LinkedList will be left with only one advantage - adding in the middle while having a reference there. If there is any other scenario, I should basically never use LinkedList.\nIs my thinking correct?</p>\n",
    "tags" : [ "java", "arrays", "performance", "linked-list", "time-complexity" ],
    "owner" : {
      "account_id" : 20205266,
      "reputation" : 19,
      "user_id" : 14819876,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/5498b2fe60e758c7f44020b3d78b4e3e?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "sebkaminski16",
      "link" : "https://stackoverflow.com/users/14819876/sebkaminski16"
    },
    "is_answered" : false,
    "view_count" : 175,
    "closed_date" : 1745791382,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1745778600,
    "creation_date" : 1745765241,
    "link" : "https://stackoverflow.com/questions/79595148/java-arraylist-and-linkedlist-performance",
    "closed_reason" : "Duplicate"
  },
  "answers" : [ {
    "answer_id" : 79595353,
    "question_id" : 79595148,
    "body" : "<p>In general you are right.<br />\nLinkedList is only in theory faster. Especially in Java, LinkedList has a memory overhead because of the 2 pointers (it is actually a double linkedlist). So the memory usage is worse and in practice degrades the performance.<br />\nArrayList is almost always (there are only very few edge cases) faster and more efficient than LinkedList and also ArrayDeque. And you are right, for these Edge Cases, ArrayDeque is the better choice.<br />\nAs a Bonus Point: ArrayList is backed by a single continguous array in memory. The CPUs are much faster in accessing sequential memory. The hotspot optimizations (the JIT compiler) are working better with the array like memory layouts.</p>\n",
    "score" : -1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 5316725,
      "reputation" : 259,
      "user_id" : 4241377,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/0ae255d91ce1ff9888243f5bd51f77c2?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Mr__Steel",
      "link" : "https://stackoverflow.com/users/4241377/mr-steel"
    },
    "creation_date" : 1745778600,
    "last_activity_date" : 1745778600,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140396117,
    "post_id" : 79595148,
    "body" : "Correct, when adding to the end, the number of elements doesn’t matter. Since the capacity is doubled each time an increment is needed, the total number of per-element write operations is about <code>log₂ n</code>, actually far less because we do not start with a capacity of one and only the few elements added at the beginning are copied each time while the majority of the elements are copied far less, the last added are usually written only once, half of them only experienced at most one copy operation. So, when adding to the end, the total number of writes is always smaller than for <code>LinkedList</code>.",
    "score" : 1,
    "owner" : {
      "account_id" : 3211603,
      "reputation" : 300981,
      "user_id" : 2711488,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
      "display_name" : "Holger",
      "link" : "https://stackoverflow.com/users/2711488/holger"
    },
    "creation_date" : 1746432520,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140386394,
    "post_id" : 79595148,
    "body" : "Additionally, I would say that it doesn&#39;t even matter how many elements there are in the ArrayList vs LinkedList when we add to the end. Storing and working on millions of millions of elements will just make us run out of memory much faster in case of LinkedList. And by the time we have, let&#39;s say, 1 billion elements, then adding new 1 billion elements, even tho ArrayList needs resizing + copying once, will still be faster.",
    "score" : 0,
    "owner" : {
      "account_id" : 20205266,
      "reputation" : 19,
      "user_id" : 14819876,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/5498b2fe60e758c7f44020b3d78b4e3e?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "sebkaminski16",
      "link" : "https://stackoverflow.com/users/14819876/sebkaminski16"
    },
    "creation_date" : 1746085145,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140385649,
    "post_id" : 79595148,
    "body" : "I guess then that the reason for it, is probably, as you mentioned before, that allocating a new element each time (in LinkedList) vs allocating an element (Array) sometimes (in ArrayList, which gets more and more rare as we add more elements).",
    "score" : 0,
    "owner" : {
      "account_id" : 20205266,
      "reputation" : 19,
      "user_id" : 14819876,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/5498b2fe60e758c7f44020b3d78b4e3e?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "sebkaminski16",
      "link" : "https://stackoverflow.com/users/14819876/sebkaminski16"
    },
    "creation_date" : 1746048006,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140385592,
    "post_id" : 79595148,
    "body" : "As @Holger said, I think also, it&#39;s too expensive to insert elements into Linked List in general (unless we are inserting in the middle or beginning). I&#39;ve tried two tests in Java: 1. Add at the end one thousand 2-MB sized into a LinkedList and into an ArrayList: they took approximately the same amount of time (note that eventual copying elements into a new array when resizing involves copying REFERENCES not the actual data). 2. Add at the end 100,000,000 Integer objects (where one weights about 16 bytes): ArrayList was 10x faster than the LinkedList.",
    "score" : 0,
    "owner" : {
      "account_id" : 20205266,
      "reputation" : 19,
      "user_id" : 14819876,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/5498b2fe60e758c7f44020b3d78b4e3e?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "sebkaminski16",
      "link" : "https://stackoverflow.com/users/14819876/sebkaminski16"
    },
    "creation_date" : 1746046691,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140380461,
    "post_id" : 79595148,
    "body" : "Even adding in the middle of a LinkedList via ListIterator is more expensive than you might have considered (even when we ignore cache locality). It requires allocating a node object and initializing its header, prev/next/element references, adjusting the next reference of the previous node and the prev reference of the next node, plus updating the iterator’s state, adding up to a dozen write operations. You’d have to insert a significant number of elements at that location to benefit from the time complexity but when you have to insert a lot of elements, <code>ArrayList</code>’s <code>addAll</code> may still win…",
    "score" : 2,
    "owner" : {
      "account_id" : 3211603,
      "reputation" : 300981,
      "user_id" : 2711488,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
      "display_name" : "Holger",
      "link" : "https://stackoverflow.com/users/2711488/holger"
    },
    "creation_date" : 1745936284,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140376046,
    "post_id" : 79595148,
    "body" : "My 2 cents: The implementation of <code>ArrayList</code> is bad and slow. I implemented my own, and in all tests being about twice as fast. Now, for <b>growing</b> <code>Collection</code>s of <b>really</b> unknown size, I have implemented a <code>LinkedArrayList</code>, that concatenates arrays. So growing it does not involve copying. And for <b>somewhat unknown</b> sizes, I have a system (using <code>java.util.prefs.Preferences</code>) that keeps track of previous requirements (like max list sizes by <code>StackTrace</code>, files found in directories etc), so it further minimizes re-allocation on <code>Collection</code>s that I cannot choose myself.",
    "score" : 0,
    "owner" : {
      "account_id" : 2182934,
      "reputation" : 2660,
      "user_id" : 1932011,
      "user_type" : "registered",
      "accept_rate" : 71,
      "profile_image" : "https://www.gravatar.com/avatar/612163480a1ccb4785fd647a003eefbb?s=256&d=identicon&r=PG",
      "display_name" : "JayC667",
      "link" : "https://stackoverflow.com/users/1932011/jayc667"
    },
    "creation_date" : 1745835746,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140375061,
    "post_id" : 79595148,
    "body" : "@rzwitserloot I&#39;d also like to add that your answer about <a href=\"https://stackoverflow.com/a/79594564/14819876\">cache locality</a> was superb! I haven&#39;t read such an easy-to-understand explanation in a long time! Thank you a lot.",
    "score" : 1,
    "owner" : {
      "account_id" : 20205266,
      "reputation" : 19,
      "user_id" : 14819876,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/5498b2fe60e758c7f44020b3d78b4e3e?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "sebkaminski16",
      "link" : "https://stackoverflow.com/users/14819876/sebkaminski16"
    },
    "creation_date" : 1745811371,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140375001,
    "post_id" : 79595148,
    "body" : "@rzwitserloot I agree my wording was not perfect. Thank you for your answer, though!",
    "score" : 0,
    "owner" : {
      "account_id" : 20205266,
      "reputation" : 19,
      "user_id" : 14819876,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/5498b2fe60e758c7f44020b3d78b4e3e?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "sebkaminski16",
      "link" : "https://stackoverflow.com/users/14819876/sebkaminski16"
    },
    "creation_date" : 1745808353,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140374636,
    "post_id" : 79595148,
    "body" : "@sebkaminski16 Furthermore note that your own text of &quot;If you have the middle node you can swiftly add elements&quot; is misleading. There is no such thing, linkedlist does not have a <code>.nextNode()</code> method. The only way to &#39;translate&#39; that misleading statement of yours is &quot;if you use specifically <code>.listIterator()</code> (and not <code>.iterator()</code>, you can navigate to the middle (which is O(n) slow), but <i>then</i>, yes, you can add multiple items swiftly from there, a trick very few collections can do. The amount of times i&#39;ve seen that exact code (use <code>listIterator</code>, navigate, then insert on the spot) is.. low.",
    "score" : 0,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107186,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1745791564,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140374634,
    "post_id" : 79595148,
    "body" : "@sebkaminski16 See my answer at <a href=\"https://stackoverflow.com/questions/79594341/arraylist-vs-linkedlist-in-terms-of-cache-locality/79594564\">cache locality</a> - LinkedList is effectively never the right answer. It&#39;s not true that ArrayList is always a better answer. It often is, and in more cases than one might think, but not always. However, there are more lists than just LL and AL. There&#39;s ArrayDeque for example. The situations where LL is the best possible data type of all the ones available in <code>java.*</code> are more or less nonexistent.",
    "score" : 0,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107186,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1745791440,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140373939,
    "post_id" : 79595148,
    "body" : "A main problem with linked-lists is the issue of memory locality (causing cache misses and therefore slow access).",
    "score" : 0,
    "owner" : {
      "account_id" : 24619336,
      "reputation" : 36147,
      "user_id" : 18519921,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/nGUxa.jpg?s=256",
      "display_name" : "wohlstad",
      "link" : "https://stackoverflow.com/users/18519921/wohlstad"
    },
    "creation_date" : 1745766510,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79595353" : [ {
      "comment_id" : 140383429,
      "post_id" : 79595353,
      "body" : "@k314159 Yes. To be more precise, it is the one of memory instructions and actually memory-level parallelism (which is a bit different from the CPU architectural PoV).",
      "score" : 0,
      "owner" : {
        "account_id" : 17815984,
        "reputation" : 53370,
        "user_id" : 12939557,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/cdadf199839f6b9bb97198c7254bbf09?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "J&#233;r&#244;me Richard",
        "link" : "https://stackoverflow.com/users/12939557/j%c3%a9r%c3%b4me-richard"
      },
      "creation_date" : 1746005228,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140383136,
      "post_id" : 79595353,
      "body" : "@J&#233;r&#244;meRichard thanks. Just to confirm, by &quot;ILP&quot; do you mean instruction-level parallelism?",
      "score" : 0,
      "owner" : {
        "account_id" : 19118721,
        "reputation" : 12469,
        "user_id" : 13963086,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/9df2c3c4c87d8050b8fd6a59c88c7133?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "k314159",
        "link" : "https://stackoverflow.com/users/13963086/k314159"
      },
      "creation_date" : 1746000670,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140381247,
      "post_id" : 79595353,
      "body" : "@k314159 This is due to pointer chasing: the CPU need to fetch a node so to know the next pointer and be able to fetch the next one. This is an inherently sequential process. Thus, you pay the cumulated cost of the latency of all fetches. This is not the case with ArrayList because the CPU can read multiple pointers of the array and fetch them concurrently. Modern mainstream CPUs can fetch at least a dozen of items concurrently (per core) so the latency per item fetched can be much lower (possibly an order of magnitude faster).",
      "score" : 0,
      "owner" : {
        "account_id" : 17815984,
        "reputation" : 53370,
        "user_id" : 12939557,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/cdadf199839f6b9bb97198c7254bbf09?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "J&#233;r&#244;me Richard",
        "link" : "https://stackoverflow.com/users/12939557/j%c3%a9r%c3%b4me-richard"
      },
      "creation_date" : 1745948660,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140380677,
      "post_id" : 79595353,
      "body" : "@J&#233;r&#244;meRichard it would be interesting to see why ILP is present in ArrayList but not in LinkedList.",
      "score" : 0,
      "owner" : {
        "account_id" : 19118721,
        "reputation" : 12469,
        "user_id" : 13963086,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/9df2c3c4c87d8050b8fd6a59c88c7133?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "k314159",
        "link" : "https://stackoverflow.com/users/13963086/k314159"
      },
      "creation_date" : 1745939116,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140377273,
      "post_id" : 79595353,
      "body" : "Then <i>&quot;ArrayList is backed by a single continguous array in memory&quot;</i> is miss-leading IMHO and while <i>&quot;The CPUs are much faster in accessing sequential memory&quot;</i> is true in general, it is <i>not</i> what makes the ArrayList faster so it is not very relevent here. For example, it would still be fast with strided accesses (or even the structure mentioned by JayC667). What makes it mainly faster is actually the ILP (not present in LinkedLists). Reference packing might help so to make things more cache friendly but this should not be significant compared to object-related memory diffusion issues.",
      "score" : 0,
      "owner" : {
        "account_id" : 17815984,
        "reputation" : 53370,
        "user_id" : 12939557,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/cdadf199839f6b9bb97198c7254bbf09?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "J&#233;r&#244;me Richard",
        "link" : "https://stackoverflow.com/users/12939557/j%c3%a9r%c3%b4me-richard"
      },
      "creation_date" : 1745858131,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140375539,
      "post_id" : 79595353,
      "body" : "Yes of course does the ArrayList only store the pointers to the objects. I never said that the actual data is stored that way.",
      "score" : 0,
      "owner" : {
        "account_id" : 5316725,
        "reputation" : 259,
        "user_id" : 4241377,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/0ae255d91ce1ff9888243f5bd51f77c2?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Mr__Steel",
        "link" : "https://stackoverflow.com/users/4241377/mr-steel"
      },
      "creation_date" : 1745826500,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140374708,
      "post_id" : 79595353,
      "body" : "I am not the downvoter but please note that ArrayList do not actually store the items contiguously, only the pointer to them. The items might be spread in memory. They are still often faster because CPUs can fetch multiple pointers concurrently reducing memory latency stalls meanwhile they cannot do that with LinkedList due to pointer chasing. This is not really a problem when data fits in the L1 cache but really bad when data do not fit in CPU caches. Both are much slower than a truly-contiguous array of native items (e.g. <code>int[]</code>).",
      "score" : 0,
      "owner" : {
        "account_id" : 17815984,
        "reputation" : 53370,
        "user_id" : 12939557,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/cdadf199839f6b9bb97198c7254bbf09?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "J&#233;r&#244;me Richard",
        "link" : "https://stackoverflow.com/users/12939557/j%c3%a9r%c3%b4me-richard"
      },
      "creation_date" : 1745793623,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}