{
  "question" : {
    "question_id" : 79611011,
    "title" : "If one thread uses a lot of stack frames, could that cause stack overflow on an &quot;innocent&quot; thread?",
    "body" : "<p>For context, I have a situation where less-than-trusted user code needs to run on a shared system. The code is subject to various static analysis passes and quality assurances, and some ways it can fail are tolerable, so this question ONLY pertains to stack overflows.</p>\n<p>My question is: If two threads are running in parallel on the JVM, one of which is behaving innocently (shallow stack depth) and the other is in some infinite/very deep recursion which would eventually cause an SO, is it guaranteed that the &quot;guilty&quot; thread will be the one to throw the exception? Or are both threads using up the same shared stack size, and the &quot;innocent&quot; one may just get unlucky and be the first to reach for memory that goes over the limit?</p>\n<p>If it's the latter, is there a way to enforce the other behavior?</p>\n",
    "tags" : [ "java", "jvm", "stack-overflow" ],
    "owner" : {
      "account_id" : 7971577,
      "reputation" : 4336,
      "user_id" : 6016064,
      "user_type" : "registered",
      "accept_rate" : 71,
      "profile_image" : "https://www.gravatar.com/avatar/ef21e8114f58b4d82ea6c3056812f557?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Edward Peters",
      "link" : "https://stackoverflow.com/users/6016064/edward-peters"
    },
    "is_answered" : true,
    "view_count" : 87,
    "answer_count" : 1,
    "score" : 4,
    "last_activity_date" : 1746638508,
    "creation_date" : 1746634773,
    "link" : "https://stackoverflow.com/questions/79611011/if-one-thread-uses-a-lot-of-stack-frames-could-that-cause-stack-overflow-on-an",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79611101,
    "question_id" : 79611011,
    "body" : "<p>From <a href=\"https://docs.oracle.com/javase/specs/jvms/se22/html/jvms-2.html#jvms-2.5.2\" rel=\"noreferrer\">JVMS ยง2.5.2</a>,</p>\n<blockquote>\n<p>Each Java Virtual Machine thread has a private Java Virtual Machine stack, created at the same time as the thread.</p>\n</blockquote>\n<blockquote>\n<p>If the computation in a thread requires a larger Java Virtual Machine stack than is permitted, the Java Virtual Machine throws a <code>StackOverflowError</code>.</p>\n</blockquote>\n<p>The stack is not shared among all the threads. Each thread has its own stack. The &quot;innocent thread&quot; <em>by definition</em> does not use too much stack space on its own, so it will not &quot;require a larger Java Virtual Machine stack than is permitted&quot;, so it will not throw a <code>StackOverflowError</code>.</p>\n<p>But note that:</p>\n<blockquote>\n<p>If Java Virtual Machine stacks can be dynamically expanded, and expansion is attempted but insufficient memory can be made available to effect the expansion, or if insufficient memory can be made available to create the initial Java Virtual Machine stack for a new thread, the Java Virtual Machine throws an <code>OutOfMemoryError</code>.</p>\n</blockquote>\n<p>It could be the case that the &quot;innocent thread&quot; can throw an <code>OutOfMemoryError</code> instead of <code>StackOverflowError</code>. Consider the case where the &quot;innocent thread&quot; calls a method, and the current stack size is not enough to store the frame. This causes the JVM to try to expand the stack (assuming the JVM implements an expanding stack), which in turn causes an <code>OutOfMemoryError</code> because all the memory had been taken up by the stack of the &quot;guilty thread&quot;.</p>\n",
    "score" : 6,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 6651855,
      "reputation" : 292025,
      "user_id" : 5133585,
      "user_type" : "registered",
      "accept_rate" : 96,
      "profile_image" : "https://i.sstatic.net/dfqcw.png?s=256",
      "display_name" : "Sweeper",
      "link" : "https://stackoverflow.com/users/5133585/sweeper"
    },
    "creation_date" : 1746638508,
    "last_activity_date" : 1746638508,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140405051,
    "post_id" : 79611011,
    "body" : "Each thread is allocated its own stack space independently of all other threads and it is dedicated permantently to thread (i.e. it is only returned when the thread terminates). This size is what you can configure using the -Xss startup parameter.",
    "score" : 0,
    "owner" : {
      "account_id" : 7423601,
      "reputation" : 21950,
      "user_id" : 5646962,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/950788cd150c2e596944181dfd8421af?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Thomas Kl&#228;ger",
      "link" : "https://stackoverflow.com/users/5646962/thomas-kl%c3%a4ger"
    },
    "creation_date" : 1746637295,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79611101" : [ {
      "comment_id" : 140406170,
      "post_id" : 79611101,
      "body" : "However, in the latter case you can argue that the &quot;innocent&quot; thread is guilty ... of attempting to expand its stack.  It just gets a different exception.  A &quot;truly&quot; innocent thread might be one where another has grown the stack unreasonably, consuming too much heap space (hypothetically), filling the heap and leading to <code>new</code> to fail for the innocent thread.  It is a different OOME scenario to the one you described.",
      "score" : 0,
      "owner" : {
        "account_id" : 47283,
        "reputation" : 723428,
        "user_id" : 139985,
        "user_type" : "registered",
        "accept_rate" : 69,
        "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
        "display_name" : "Stephen C",
        "link" : "https://stackoverflow.com/users/139985/stephen-c"
      },
      "creation_date" : 1746669764,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}