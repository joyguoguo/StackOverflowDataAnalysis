{
  "question" : {
    "question_id" : 79641756,
    "title" : "Cassandra Java driver: high latency when executing many async reads in a loop",
    "body" : "<p>We're using DSE 6.0.18 (Cassandra version 3.11) and our application is both read and write heavy.</p>\n<p>I have a situation where I need to fire N number of read queries for each API (by partition key) using session.executeAsync(...) in a loop. The number of queries (N) differs for each API based on the use-case. Most of the API's will fire less than 30 queries and some 20% of API's fire large no of queries like up to 50 to 300. For the APIs with a lesser number of queries fired, the overall Cassandra response time is less than 1 to 1.5 secs at max, but for APIs with a larger number of queries, the response time drastically increase to 20 to 30 secs.</p>\n<p>I'm executing individual SELECT queries per partition key (e.g., SELECT * FROM table WHERE id = ?) using executeAsync().</p>\n<p>My questions:</p>\n<ol>\n<li>Why does firing more async reads in parallel degrade performance so drastically?</li>\n<li>Is there a limit on in-flight or async requests from the Cassandra Java driver?</li>\n<li>How can I throttle or batch async reads efficiently without losing parallelism?</li>\n</ol>\n<p>I read in a <a href=\"https://stackoverflow.com/questions/50449964/cassandra-native-transport-request-tuning\">different post</a> on tuning Native Transport Request(NTR), like <code>native_transport_max_threads</code> and <code>max_queued_native_transport_requests</code>. We have default values for these parameters, will tuning these help us?</p>\n<p>Additional information:</p>\n<ol>\n<li>We have 12 node cluster with over 15TB data.</li>\n<li>Data is not evenly distributed and having little issues in the cluster like large partitions, uneven data distribution, older versions. We are working on moving data to newer hardware and fix all these later.</li>\n<li>No custom throttling currently implemented.</li>\n<li>On an average daily 70M to 110M reads are happening.</li>\n<li>The table has large no of cols like 400 and in the query some 300 cols were fetched each time.</li>\n</ol>\n",
    "tags" : [ "java", "cassandra", "database-performance", "datastax", "datastax-java-driver" ],
    "owner" : {
      "account_id" : 16444700,
      "reputation" : 61,
      "user_id" : 11879842,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/nt4jS.jpg?s=256",
      "display_name" : "Dinesh Babu M",
      "link" : "https://stackoverflow.com/users/11879842/dinesh-babu-m"
    },
    "is_answered" : true,
    "view_count" : 102,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1748446153,
    "creation_date" : 1748418957,
    "link" : "https://stackoverflow.com/questions/79641756/cassandra-java-driver-high-latency-when-executing-many-async-reads-in-a-loop",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79642552,
    "question_id" : 79641756,
    "body" : "<p>Async execution of queries does not necessarily imply true parallelism. While executeAsync() is non-blocking, spawning 300 queries could overwhelm the system. Not all threads will be in the RUNNING state simultaneously. Many may be waiting or queued. This queuing likely explains the drastic increase in response time for APIs executing large numbers of queries.</p>\n<p>I would recommend checking CPU utilization, thread pool stats (via nodetool tpstats), and capturing a thread dump to confirm thread contention or queuing bottlenecks on the Cassandra nodes.</p>\n<p>Additionally, Cassandra does not support batch reads (Refer: <a href=\"https://stackoverflow.com/questions/61730799/equivalent-of-batch-statement-for-select-in-cassandra\">Batch select in Cassandra</a>). Also, upgrading hardware may not help much if the application logic and query patterns are inefficient. It would be more effective to optimize the queries, avoid wide rows or fetching 300 columns unless necessary, and limit concurrency with bounded async execution strategies rather than spawning hundreds of concurrent queries without control.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 16860149,
      "reputation" : 181,
      "user_id" : 12191150,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/fec9a6154254eb5fd901f4a0045c0b1f?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Yasin Ahmed",
      "link" : "https://stackoverflow.com/users/12191150/yasin-ahmed"
    },
    "creation_date" : 1748446153,
    "last_activity_date" : 1748446153,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79642552" : [ {
      "comment_id" : 140471378,
      "post_id" : 79642552,
      "body" : "Well, the problem is for our clients, we suggested them to use less no of cols in select unless absolutely necessary. Changing app logic and data model needs to be done in future, but they are expecting for some quick fix like any config changes that might help. I&#39;ll check the CPU util and tpstats and check futher",
      "score" : 0,
      "owner" : {
        "account_id" : 16444700,
        "reputation" : 61,
        "user_id" : 11879842,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/nt4jS.jpg?s=256",
        "display_name" : "Dinesh Babu M",
        "link" : "https://stackoverflow.com/users/11879842/dinesh-babu-m"
      },
      "creation_date" : 1748583462,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}