{
  "question" : {
    "question_id" : 79562203,
    "title" : "Selenium FluentWait is not working as expected",
    "body" : "<p>I'm waiting in my code for an element located by id = MX.</p>\n<p>When I try the FluentWait approach like this:</p>\n<pre><code>FluentWait&lt;WebDriver&gt; fluentWait = new FluentWait&lt;&gt;(driver)\n    .withTimeout(Duration.ofSeconds(30))\n    .pollingEvery(Duration.ofMillis(200))\n    .ignoring(NoSuchElementException.class);\n\nWebElement countryMx = initCountry.getMx();\nfluentWait.until(d -&gt; ExpectedConditions.visibilityOf(countryMx));\nSystem.out.println(&quot;Element MX should be visible by now&quot;);\nfluentWait.until(d -&gt; ExpectedConditions.elementToBeClickable(countryMx));\nSystem.out.println(&quot;Element MX should be clickable by now&quot;);\n\ndo {\n    executor.executeScript(&quot;arguments[0].scrollIntoView(true);&quot;, countryMx);\n} while (!countryMx.isDisplayed());\ncountryMx.click();\n</code></pre>\n<p>It fails at <code>.executeScript()</code> like:</p>\n<pre><code>org.openqa.selenium.NoSuchElementException: no such element: Unable to locate element: {&quot;method&quot;:&quot;css selector&quot;,&quot;selector&quot;:&quot;#MX&quot;}\n</code></pre>\n<p>When I try the alternative approach:</p>\n<pre><code>WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(1));\nwait.until(ExpectedConditions.presenceOfElementLocated(By.id(&quot;MX&quot;)));\n\nWebElement countryMx = initCountry.getMx();\n\ndo {\n    executor.executeScript(&quot;arguments[0].scrollIntoView(true);&quot;, countryMx);\n} while (!countryMx.isDisplayed());\ncountryMx.click();\n</code></pre>\n<p>It works ok.</p>\n<p>Provided I have no fundamental misunderstanding of the way FluentWait works, I'd say something is wrong here, but it seems not obvious to me.</p>\n<p>I know the approach is not exactly the same, but the behaviour should be equivalent. Furthermore, I want an approach and a syntax that are clean for use with the PageObject pattern.</p>\n<p>Furthermore, if I try this non-idiomatic (id=MX is defined in the page object) approach, it fails in the first mentioned way (and not after 30 seconds) so I'd say it just doesn't work.</p>\n<pre class=\"lang-java prettyprint-override\"><code>fluentWait.until(d -&gt; ExpectedConditions.presenceOfElementLocated(By.id(&quot;MX&quot;)));\n</code></pre>\n<p>fails at executeScript().</p>\n",
    "tags" : [ "java", "selenium-webdriver" ],
    "owner" : {
      "account_id" : 2217831,
      "reputation" : 172,
      "user_id" : 1958020,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/0FWpb.jpg?s=256",
      "display_name" : "Greco",
      "link" : "https://stackoverflow.com/users/1958020/greco"
    },
    "is_answered" : true,
    "view_count" : 44,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1744160870,
    "creation_date" : 1744119564,
    "link" : "https://stackoverflow.com/questions/79562203/selenium-fluentwait-is-not-working-as-expected",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79563280,
    "question_id" : 79562203,
    "body" : "<p>You seem to be confused about several things around Selenium and waits.</p>\n<ol>\n<li><code>WebDriverWait</code> is just a more user friendly wrapper around <code>FluentWait</code>. You should use <code>WebDriverWait</code> in pretty much 100% of cases based on my years of experience. <code>FluentWait</code> generally isn't needed.</li>\n<li>I highly doubt the <code>NoSuchElementException</code> is thrown on the <code>.executeScript()</code> line in the code you provided. It was almost assuredly thrown inside <code>initCountry.getMx()</code>.</li>\n<li>There's no need to stack waits... e.g. you wait for visible then clickable. Waiting for clickable means that the element is visible and not disabled (think a disabled INPUT tag aka a button). So, you only need to wait for clickable in that case.</li>\n<li><code>.isDisplayed()</code> doesn't mean it's on the screen, it means that wherever the element is it's not hidden. So, scrolling until it's displayed doesn't do anything.</li>\n<li>In most cases, you don't need to scroll. I would always try to click without scrolling to confirm that a scroll is required.</li>\n<li>Presence means that the element is in the DOM, not that it's visible or otherwise ready to be interacted with. Generally you want to wait for clickable if you are going to click the element, or otherwise wait for visible if you are going to <code>.getText()</code>, etc. You should very rarely use presence unless you have a very specific reason to do so and know what you are doing.</li>\n</ol>\n<p>Your approach in the two examples isn't really close to the same so it's hard to compare the two outputs.</p>\n<p>Here's simplified code that should work.</p>\n<pre><code>WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10));\nWebElement countryMx = wait.until(ExpectedConditions.elementToBeClickable(By.id(&quot;MX&quot;)));\n// this scroll probably isn't needed but if it is, uncomment it\n// executor.executeScript(&quot;arguments[0].scrollIntoView(true);&quot;, countryMx);\ncountryMx.click();\n</code></pre>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2772450,
      "reputation" : 26443,
      "user_id" : 2386774,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/dea7da142cb7e85d5d5a8576e2625431?s=256&d=identicon&r=PG",
      "display_name" : "JeffC",
      "link" : "https://stackoverflow.com/users/2386774/jeffc"
    },
    "creation_date" : 1744160870,
    "last_activity_date" : 1744160870,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140333134,
    "post_id" : 79562203,
    "body" : "Probably I&#39;m mixing approaches and I&#39;m using PageFactory not as intended, I found <a href=\"https://eliasnogueira.com/better-page-objects-strategy-using-ajaxelementlocatorfactory-with-selenium-and-java/\" rel=\"nofollow noreferrer\">this explanation</a> and it seemed to perform a bit better, initially not needing to scroll to the bottom of the page to actually click and move to next screen, but now is performing similarly. It&#39;s a bit extrange, I&#39;ll keep up on trying and reporting.",
    "score" : 0,
    "owner" : {
      "account_id" : 2217831,
      "reputation" : 172,
      "user_id" : 1958020,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/0FWpb.jpg?s=256",
      "display_name" : "Greco",
      "link" : "https://stackoverflow.com/users/1958020/greco"
    },
    "creation_date" : 1744639355,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140312935,
    "post_id" : 79562203,
    "body" : "no reason to use FLuentWait here.  WebDriverWait is already a pre-configured fluent wait.  It&#39;s unclear what &quot;initCountry.getMx();&quot; is, but you don&#39;t need that.  The expected condition will return the webelement.... so you can just do WebElement countryMx = wait.until.... you can also ditch the scroll.  The click() method will already scroll the element into view.  Just use countryMx.click().  You should probably also use elementToBeClickable for your expected condition and use a longer timeout.",
    "score" : 0,
    "owner" : {
      "account_id" : 6077817,
      "reputation" : 1362,
      "user_id" : 4744568,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/125cdb7d43927756913b920de016f420?s=256&d=identicon&r=PG",
      "display_name" : "browsermator",
      "link" : "https://stackoverflow.com/users/4744568/browsermator"
    },
    "creation_date" : 1744132687,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}