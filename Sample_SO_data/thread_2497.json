{
  "question" : {
    "question_id" : 79616475,
    "title" : "Reactive Sink - Avoiding the OverflowException with concurrent emissions",
    "body" : "<p>I have this sink configured in my app:</p>\n<pre class=\"lang-java prettyprint-override\"><code>createdSink = Sinks.many().multicast().onBackpressureBuffer(4096);\n\npublic void activityCreated(ActivityResource createdActivity) {\n    try {\n        var notification = new ActivityCreatedNotification(createdActivity);\n        createdSink.emitNext(notification, getFailureHandler());\n    } catch (Exception e) {\n        log.error(&quot;Emit activity created notification for activity id {} failed&quot;, createdActivity.getId(), e);\n    }\n}\n\nprivate static Sinks.EmitFailureHandler getFailureHandler() {\n    return Sinks.EmitFailureHandler.busyLooping(Duration.ofSeconds(5));\n}\n</code></pre>\n<p>I'm not sure how I can configure it to do what I want, but I was hoping to get some help from here.</p>\n<p>I'm sometimes observing an overflow exception like this:</p>\n<pre class=\"lang-none prettyprint-override\"><code>2025-05-05T05:46:01.312Z ERROR [] [reactor-http-epoll-25]\n[00000000-0000-4000-a000-000000000000][][][TRACE_ID:b42fa551661d9427][][c.e.d.p.a.e.ActivityExternalNotificationService.lambda$prepareExternalNotifications$3(79)]\n - Error while processing activity notification     \nreactor.core.Exceptions$OverflowException: Backpressure overflow during Sinks.Many#emitNext\nat reactor.core.Exceptions.failWithOverflow(Exceptions.java:249)\n</code></pre>\n<p>This is even though I have the backpressure configured, so it probably means that the backpressure queue was already full and elements kept on being emitted to the sink, while one of the subscribers could not handle the rate, right?</p>\n<p>So what I would like in that case is to drop elements, and to avoid the sink from collapsing/terminating.</p>\n<p>Basically I must have this hot publisher, the sink, to be infinite, it can't stop working. And also, I must use the emitNext() with the busy looping, as I'm emitting concurrently to the sink and without it I get FAIL_NON_SERIALIZED errors.</p>\n<p>I see from reactive documentation that for the emitNext() API it states:</p>\n<blockquote>\n<p>When the Sinks.EmitResult is not a success, vanilla reactor-core operators have the following behavior:</p>\n<ul>\n<li><code>Sinks.EmitResult.FAIL_ZERO_SUBSCRIBER</code>: no particular handling. should ideally discard the value but at that point there's no <code>Subscriber</code> from which to get a contextual discard handler.</li>\n<li><code>Sinks.EmitResult.FAIL_OVERFLOW</code>: discard the value (<code>Operators.onDiscard(Object, Context)</code>) then call <code>emitError(Throwable, Sinks.EmitFailureHandler)</code> with a <code>Exceptions.failWithOverflow(String)</code> exception.</li>\n<li><code>Sinks.EmitResult.FAIL_CANCELLED</code>: discard the value (<code>Operators.onDiscard(Object, Context)</code>).</li>\n<li><code>Sinks.EmitResult.FAIL_TERMINATED</code>: drop the value (<code>Operators.onNextDropped(Object, Context)</code>).</li>\n<li><code>Sinks.EmitResult.FAIL_NON_SERIALIZED</code>: throw an <code>Sinks.EmissionException</code> mentioning RS spec rule 1.3. Note that unsafe() never trigger this result. It would be possible for an <code>Sinks.EmitFailureHandler</code> to busy-loop and optimistically wait for the contention to disappear to avoid this case for safe sinks...</li>\n</ul>\n</blockquote>\n<p>So it's unclear to me whether on FAIL_OVERFLOW, the errorHandler is even called at all or not.</p>\n<p>I guess the question is: How can I configure a backpressure queue like the one I have today which is nice to have (buffer some elements instead of dropping right away), but to also avoid the overflow error and to drop instead?</p>\n<p>Is there a way to configure this using the errorHandler? Or by different means?</p>\n",
    "tags" : [ "java", "project-reactor" ],
    "owner" : {
      "account_id" : 20363973,
      "reputation" : 1,
      "user_id" : 14937729,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/548b1451b2465447e85ff9088e7f71a4?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Nick",
      "link" : "https://stackoverflow.com/users/14937729/nick"
    },
    "is_answered" : false,
    "view_count" : 33,
    "closed_date" : 1747079169,
    "answer_count" : 0,
    "score" : -1,
    "last_activity_date" : 1747079137,
    "creation_date" : 1746965785,
    "link" : "https://stackoverflow.com/questions/79616475/reactive-sink-avoiding-the-overflowexception-with-concurrent-emissions",
    "closed_reason" : "Duplicate"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140416834,
    "post_id" : 79616475,
    "body" : "Thanks! it&#39;s similar but different. And the text is clear on that, you can read both and I&#39;m sure you&#39;ll agree",
    "score" : 0,
    "owner" : {
      "account_id" : 20363973,
      "reputation" : 1,
      "user_id" : 14937729,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/548b1451b2465447e85ff9088e7f71a4?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Nick",
      "link" : "https://stackoverflow.com/users/14937729/nick"
    },
    "creation_date" : 1747033386,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}