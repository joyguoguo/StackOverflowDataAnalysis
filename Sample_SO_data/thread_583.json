{
  "question" : {
    "question_id" : 79791487,
    "title" : "Expose custom health group components into Prometheus metrics in Spring Boot",
    "body" : "<p>We have two custom health groups named <code>extended</code> and <code>readiness</code>:</p>\n<ul>\n<li><code>extended</code>: custom dependency-heavy <code>HealthIndicator</code>s provided explicitly via application property</li>\n<li><code>readiness</code>: everything except those defined in the <code>extended</code> group</li>\n</ul>\n<p>Currently calling the <code>/actuator/health/readiness</code> endpoint, the response looks like this (simplified for readability):</p>\n<pre><code>db\n ├ storeDataSource\n └ pizzaDataSource\ndiskSpace\ngracefulShutdownHealthCheck\nhazelcast\njms\n ├ internalActiveMQConnectionFactory\n ├ notifConnectionFactory\n └ platformJmsConnectionFactory\nping\nrefreshScope\n</code></pre>\n<p>We want to expose all the components from the <code>readiness</code> group as a <code>Prometheus</code> metric one by one. But since these components aren't defined explicitly, and the number of them can be increased/decreased by adding/removing <code>Maven</code> dependencies (for example <code>jms</code> or <code>hazelcast</code>), we don't know the exact list of the component's name in compile time.</p>\n<p>Therefore we do the following:</p>\n<pre><code>@Configuration\n@AllArgsConstructor\npublic class HealthGroupMetricsConfig {\n\n    private final MeterRegistry meterRegistry;\n    private final HealthEndpoint healthEndpoint;\n\n    @PostConstruct\n    public void bindReadinessHealth() {\n        HealthComponent component = healthEndpoint.healthForPath(&quot;readiness&quot;);\n        CompositeHealth health = (CompositeHealth) component;\n        \n        health.getComponents().forEach( (key, value) -&gt; {\n            if (value instanceof Health h) {\n                Gauge.builder(&quot;app_health_readiness_component&quot;, h, he -&gt; &quot;UP&quot;.equalsIgnoreCase(h.getStatus().getCode()) ? 1 : 0)\n                        .tag(&quot;component&quot;, key)\n                        .register(meterRegistry);\n            } else if (value instanceof CompositeHealth ch) {\n                Gauge.builder(&quot;app_health_readiness_component&quot;, ch, he -&gt; &quot;UP&quot;.equalsIgnoreCase(ch.getStatus().getCode()) ? 1 : 0)\n                        .tag(&quot;component&quot;, key)\n                        .register(meterRegistry);\n            }\n        });\n    }\n\n}\n</code></pre>\n<p>But in this way the <code>healthForPath</code> method will be called once during <code>@PostConstruct</code>, and all the components will be registered as a <code>Prometheus</code> metric <strong>statically</strong>, which means every time the <code>/actuator/prometheus</code> endpoint is called, the same health statuses (which were evaluated for the first time) will be responded, which is not the desired behaviour, since we want fresh data every time.</p>\n<p>If we just put <code>healthForPath</code> inside <code>Gauge.builder</code> to have a fresh call to <code>/actuator/health/readiness</code>, then it will be called multiple times (as many components we have) unnecessarily.</p>\n<p>Our second approach was to call <code>healthForPath</code> once at the beginning just to collect the names of the health components, and after that injecting them as a bean from the <code>ApplicationContext</code>:</p>\n<pre><code>@Configuration\n@AllArgsConstructor\npublic class HealthGroupMetricsConfig {\n\n    private final MeterRegistry meterRegistry;\n    private final HealthEndpoint healthEndpoint;\n    private final ApplicationContext applicationContext;\n\n    @PostConstruct\n    public void bindReadinessHealth() {\n        HealthComponent component = healthEndpoint.healthForPath(&quot;readiness&quot;);\n        CompositeHealth health = (CompositeHealth) component;\n\n        health.getComponents().keySet().forEach(name -&gt; Gauge.builder(&quot;app_health_readiness_component&quot;, () -&gt; {\n            HealthIndicator hi = applicationContext.getBean(name, HealthIndicator.class);\n            return hi.health().getStatus().equals(UP) ? 1 : 0;\n        })\n                .tag(&quot;component&quot;, name)\n                .register(meterRegistry));\n    }\n\n}\n</code></pre>\n<p>But it turned out not all the components are <code>HealthIndicator</code>s, and the indicator's name doesn't always equal to the health component's name either. Listing all the <code>HealthIndicator</code>s we get the following:</p>\n<pre><code>gracefulShutdownHealthCheck\nhazelcastHealthContributor\ndiskSpaceHealthIndicator\npingHealthContributor\nrefreshScopeHealthIndicator\n</code></pre>\n<p>As you can see the <code>CompositeHealth</code>s (i.e. <code>db</code> and <code>jms</code>) are missing, because for example <code>notifConnectionFactory</code> is not a <code>HealthIndicator</code>, but an <code>oracle.jms.AQjmsConnectionFactory</code>.</p>\n<p>Our final thought was to make an <code>HTTP</code> call in case of every components, since the individual statuses can be evaluated by calling <code>/actuator/health/readiness/&lt;components-name&gt;</code>. In this way we can achieve the desired goal, but we are afraid of some performance issue because of the multiple <code>HTTP</code> calls (if any).</p>\n<p>Any suggestion how to do this?</p>\n<p>We are using Spring Boot version <code>2.7.18</code>.</p>\n",
    "tags" : [ "java", "spring-boot", "prometheus", "metrics", "health-check" ],
    "owner" : {
      "account_id" : 18890249,
      "reputation" : 214,
      "user_id" : 13780725,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/Gh1tC.jpg?s=256",
      "display_name" : "tibotka",
      "link" : "https://stackoverflow.com/users/13780725/tibotka"
    },
    "is_answered" : true,
    "view_count" : 75,
    "answer_count" : 1,
    "score" : 1,
    "last_activity_date" : 1763120342,
    "creation_date" : 1760551613,
    "link" : "https://stackoverflow.com/questions/79791487/expose-custom-health-group-components-into-prometheus-metrics-in-spring-boot",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79819984,
    "question_id" : 79791487,
    "body" : "<p>The solution was the following:</p>\n<pre><code>@Configuration\n@AllArgsConstructor\npublic class HealthGroupMetricsConfiguration {\n\n    private final MeterRegistry meterRegistry;\n    private final HealthEndpoint healthEndpoint;\n\n    @PostConstruct\n    public void registerHealthContributors() {\n        collectHealthContributors((CompositeHealth) healthEndpoint.healthForPath(&quot;readiness&quot;), &quot;readiness&quot;)\n            .forEach(contributor -&gt;\n                Gauge.builder(&quot;app_health_readiness&quot;, contributor, new HealthStatusGaugeMapper(healthEndpoint, contributor))\n                    .strongReference(true)\n                    .description(&quot;Readiness health group contributor's status: UP=1, DOWN=0, OUT_OF_SERVICE=-1, UNKNOWN=-2&quot;)\n                    .tag(&quot;component&quot;, contributor.replace(&quot;readiness.&quot;, &quot;&quot;))\n                    .register(meterRegistry));\n    }\n\n    private List&lt;String&gt; collectHealthContributors(CompositeHealth health, String prefix) {\n        List&lt;String&gt; contributors = new ArrayList&lt;&gt;();\n\n        health.getComponents().forEach((name, component) -&gt; {\n            String fullName = prefix + &quot;.&quot; + name;\n\n            if (component instanceof CompositeHealth ch) {\n                contributors.addAll(collectHealthContributors(ch, fullName));\n            } else {\n                contributors.add(fullName);\n            }\n        });\n\n        return contributors;\n    }\n\n}\n</code></pre>\n<p>and the correspondent <code>HealthStatusGaugeMapper</code> class:</p>\n<pre><code>public class HealthStatusGaugeMapper implements ToDoubleFunction&lt;String&gt; {\n\n    private final HealthEndpoint healthEndpoint;\n    private final String[] paths;\n\n    public HealthStatusGaugeMapper(HealthEndpoint healthEndpoint, String contributor) {\n        this.healthEndpoint = healthEndpoint;\n        this.paths = contributor.split(&quot;\\\\.&quot;);\n    }\n\n    @Override\n    public double applyAsDouble(String binder) {\n        Health hc = (Health) healthEndpoint.healthForPath(paths);\n        Status status = hc.getStatus();\n\n        if (Status.UP.equals(status)) {\n            return 1;\n        } else if (Status.DOWN.equals(status)) {\n            return 0;\n        } else if (Status.OUT_OF_SERVICE.equals(status)) {\n            return -1;\n        } else if (Status.UNKNOWN.equals(status)) {\n            return -2;\n        } else {\n            throw new ExtendedRuntimeException(ErrorType.APP, getClass(),\n                    &quot;Unhandled health status code: &quot; + status.getCode());\n        }\n    }\n\n}\n</code></pre>\n",
    "score" : 1,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 18890249,
      "reputation" : 214,
      "user_id" : 13780725,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/Gh1tC.jpg?s=256",
      "display_name" : "tibotka",
      "link" : "https://stackoverflow.com/users/13780725/tibotka"
    },
    "creation_date" : 1763120342,
    "last_activity_date" : 1763120342,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}