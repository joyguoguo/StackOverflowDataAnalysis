{
  "question" : {
    "question_id" : 79632498,
    "title" : "Updating JPA entity graphs automatically",
    "body" : "<p>Imagine my backend's <code>PUT</code> endpoint receives this <code>UserRequestDto</code>:</p>\n<pre class=\"lang-json prettyprint-override\"><code>{\n  &quot;id&quot;: 12345,\n  &quot;name&quot;: &quot;steve123&quot;,\n  &quot;emailData&quot;: [\n    &quot;steve@gmail.com&quot;,\n    &quot;steve@outlook.com&quot;\n  ]\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.List;\n\n@Getter\n@Setter\npublic class UserRequestDto {\n\n    private Long id;\n    private String name;\n    private List&lt;String&gt; emailData;\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.GenerationType;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.OneToMany;\nimport jakarta.persistence.Table;\nimport lombok.Getter;\nimport lombok.Setter;\n\nimport java.util.List;\n\n@Entity\n@Getter\n@Setter\n@Table(name = &quot;\\&quot;user\\&quot;&quot;)\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    private String name;\n    @OneToMany(mappedBy = &quot;user&quot;, cascade = CascadeType.ALL)\n    private List&lt;EmailData&gt; emailData;\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import jakarta.persistence.Entity;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.GenerationType;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.JoinColumn;\nimport jakarta.persistence.ManyToOne;\nimport jakarta.persistence.Table;\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Entity\n@Getter\n@Setter\n@Table(name = &quot;email_data&quot;)\npublic class EmailData {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    @ManyToOne\n    @JoinColumn(name = &quot;user_id&quot;)\n    private User user;\n    private String email;\n}\n</code></pre>\n<pre class=\"lang-sql prettyprint-override\"><code>-- schema.sql\nCREATE TABLE IF NOT EXISTS &quot;user&quot;\n(\n    id                      BIGINT GENERATED BY DEFAULT AS IDENTITY,\n    name                    VARCHAR(500) UNIQUE NOT NULL,\n    PRIMARY KEY (id)\n);\n\nCREATE TABLE IF NOT EXISTS email_data\n(\n    id                      BIGINT GENERATED BY DEFAULT AS IDENTITY,\n    user_id                 BIGINT NOT NULL REFERENCES &quot;user&quot;(id),\n    email                   VARCHAR(200) UNIQUE NOT NULL,\n    PRIMARY KEY (id)\n);\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import com.example.pixel_user_api.data.dto.request.UserRequestDto;\nimport com.example.pixel_user_api.data.dto.response.UserResponseDto;\nimport com.example.pixel_user_api.service.UserService;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.PutMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(&quot;/api/user&quot;)\n@RequiredArgsConstructor\npublic class UserController {\n\n    private final UserService userService;\n\n    @PutMapping\n    public ResponseEntity&lt;UserResponseDto&gt; updateUser(@RequestBody UserRequestDto userRequestDto) {\n        UserResponseDto userResponseDto = userService.update(userRequestDto);\n        return ResponseEntity.ok(userResponseDto);\n    }\n}\n</code></pre>\n<p>Also imagine Steve's current state corresponds to this:</p>\n<pre class=\"lang-json prettyprint-override\"><code>{\n  &quot;id&quot;: 12345,\n  &quot;name&quot;: &quot;steve123&quot;,\n  &quot;emailData&quot;: [\n    &quot;steve@gmail.com&quot;,\n    &quot;steve@yahoo.com&quot;\n  ]\n}\n</code></pre>\n<p>Here's what my backend is expected to do:</p>\n<ol>\n<li>Keep <code>steve@gmail.com</code> (never try to insert it into <code>email_data</code> again).</li>\n<li>Remove <code>steve@yahoo.com</code>.</li>\n<li>Insert <code>steve@outlook.com</code> if it's not occupied by another user - else return an error response (I can write an advice that catches the DB's errors).</li>\n</ol>\n<p>In my specific (simple) scenario my <code>UserService</code> could:</p>\n<ol>\n<li>Load all of Steve's emails (a DB hit).</li>\n<li>Manually manipulate his <code>EmailData</code> list so that only <code>steve@gmail.com</code> is retained, <code>steve@outlook.com</code> is added (with a null <code>id</code> and non-null <code>user</code>).</li>\n<li>Then let my JPA provider automatically perform all the DML it needs.</li>\n</ol>\n<p>It's straightforward.</p>\n<p>However, imagine there are lots of fields like that one, for example <code>PhoneData</code>:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Entity\n@Getter\n@Setter\n@Table(name = &quot;phone_data&quot;)\npublic class PhoneData {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    @ManyToOne\n    @JoinColumn(name = &quot;user_id&quot;)\n    private User user;\n    private String phone;\n}\n</code></pre>\n<p>Object graph could be much more complex either. One value wrapper, like <code>EmailData</code>, could reference another one. Let's say it references <code>DomainData</code>.</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Entity\n@Getter\n@Setter\n@Table(name = &quot;domain_data&quot;)\npublic class DomainData {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    private String domain; // outlook.com, gmail.com, etc.\n}\n</code></pre>\n<p>The point is if I manually manage all those details, the code may quickly become verbose and hard to maintain.</p>\n<p><strong>How do I achieve my goals concisely and efficiently, keeping manually written code to a minimum?</strong></p>\n<p>Here's what wouldn't work. A first <code>PUT</code> would be fine, but if you tried to <code>PUT</code> the same JSON again, you'd get a unique constraint violation (since <code>email</code> in <code>email_data</code> must be <code>UNIQUE</code>).</p>\n<pre class=\"lang-java prettyprint-override\"><code>import com.example.pixel_user_api.data.dto.request.UserRequestDto;\nimport com.example.pixel_user_api.data.dto.response.UserResponseDto;\n\npublic interface UserService {\n\n    UserResponseDto update(UserRequestDto userRequestDto);\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import com.example.pixel_user_api.data.dto.request.UserRequestDto;\nimport com.example.pixel_user_api.data.dto.response.UserResponseDto;\nimport com.example.pixel_user_api.data.entity.User;\nimport com.example.pixel_user_api.mapper.UserMapper;\nimport com.example.pixel_user_api.repository.UserRepository;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Service\n@Transactional(readOnly = true)\n@RequiredArgsConstructor\npublic class UserServiceImpl implements UserService {\n\n    private final UserRepository repository;\n    private final UserMapper mapper;\n\n    @Override\n    @Transactional(readOnly = false)\n    public UserResponseDto update(UserRequestDto userRequestDto) {\n        User user = mapper.toUser(userRequestDto);\n        User updatedUser = repository.save(user);\n        return mapper.toResponseDto(updatedUser);\n    }\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import com.example.pixel_user_api.data.dto.request.UserRequestDto;\nimport com.example.pixel_user_api.data.dto.response.UserResponseDto;\nimport com.example.pixel_user_api.data.entity.User;\nimport org.mapstruct.Mapper;\n\n@Mapper(uses = EmailMapper.class, componentModel = &quot;spring&quot;)\npublic interface UserMapper {\n\n    User toUser(UserRequestDto userRequestDto);\n    UserResponseDto toResponseDto(User user);\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import com.example.pixel_user_api.data.entity.EmailData;\nimport org.mapstruct.Mapper;\nimport org.mapstruct.Mapping;\n\n@Mapper(componentModel = &quot;spring&quot;)\npublic interface EmailMapper {\n\n    default String toString(EmailData emailData) {\n        return emailData == null ? null : emailData.getEmail();\n    }\n\n    @Mapping(source = &quot;.&quot;, target = &quot;email&quot;)\n    EmailData toEmailData(String email);\n}\n</code></pre>\n",
    "tags" : [ "java", "spring", "hibernate", "jpa" ],
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2683,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "is_answered" : false,
    "view_count" : 57,
    "answer_count" : 0,
    "score" : 1,
    "last_activity_date" : 1747926869,
    "creation_date" : 1747848727,
    "link" : "https://stackoverflow.com/questions/79632498/updating-jpa-entity-graphs-automatically",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140453697,
    "post_id" : 79632498,
    "body" : "if there is a change, such as adding a new one, yes. Your DTO mapper should do that. Or you can make the mapping a Unidirectional 1:M from User-&gt;Email",
    "score" : 0,
    "owner" : {
      "account_id" : 231721,
      "reputation" : 21335,
      "user_id" : 496099,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/efa7510cf47d7bd79e80486246e7e39e?s=256&d=identicon&r=PG",
      "display_name" : "Chris",
      "link" : "https://stackoverflow.com/users/496099/chris"
    },
    "creation_date" : 1748022759,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140453442,
    "post_id" : 79632498,
    "body" : "@Chris however, I would still need to manually set those <code>user</code> back references in objects like <code>EmailData</code>, wouldn&#39;t I?",
    "score" : 0,
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2683,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "creation_date" : 1748017752,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140453326,
    "post_id" : 79632498,
    "body" : "Use the Entity IDs in your JSON objects. For email, maybe make the user&#39;s email the actual ID if it is a natural ID. This would allow you to maintain the relationship between user and email without having to fetch it (except if it is new). You can then put cascade persist to ensure JPA can insert new Emails when merging and get an error if they already exist. Orphan removal will force it to delete entities (email) that is no longer referenced. That works for simple objects/graphs, but for inserts with a complex model, you&#39;ll need more so it can be assigned to a email domain",
    "score" : 1,
    "owner" : {
      "account_id" : 231721,
      "reputation" : 21335,
      "user_id" : 496099,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/efa7510cf47d7bd79e80486246e7e39e?s=256&d=identicon&r=PG",
      "display_name" : "Chris",
      "link" : "https://stackoverflow.com/users/496099/chris"
    },
    "creation_date" : 1748016004,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}