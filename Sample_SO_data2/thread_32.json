{
  "question" : {
    "question_id" : 79844417,
    "title" : "C++ vs Java performance under repeated heave computation",
    "body" : "<p>Is it possible that under repeated heave computation Java out-perform C++ by an order of magnitude? My open-source project is such a benchmark: <a href=\"https://github.com/Chengpu0707/VarianceArithmetic\" rel=\"nofollow noreferrer\">https://github.com/Chengpu0707/VarianceArithmetic</a>:</p>\n<p><img src=\"https://i.sstatic.net/xVeDMvRi.png\" alt=\"enter image description here\" /></p>\n<p>In the above figure, I have compared the execution time of FFT of input data size $2^{order}$. As expected, the execution time increases exponentially as $~2^{order}$.</p>\n<p>The C++ project is compiled with -O3.  Still, it is an order of magnitude slower than Java when the FFT order is larger than 10. I am completely surprised by this result.</p>\n<p>Some other technical details about my computer:</p>\n<ul>\n<li><p>Java version: java version &quot;1.8.0_441&quot;</p>\n</li>\n<li><p>gcc version: gcc.exe (Rev3, Built by MSYS2 project) 13.2.0</p>\n</li>\n<li><p>CPU: 12th Gen Intel(R) Core(TM) i7-1255U (1.70 GHz) 10-core</p>\n</li>\n<li><p>RAM: 16.0 GB (15.7 GB usable)</p>\n</li>\n<li><p>The figure shows the means of 72 runs at each FFT order. When the FFT order is larger than 10, the execution deviation is much smaller than the corresponding execution mean.</p>\n</li>\n<li><p>All codes are single-threaded.</p>\n</li>\n<li><p>The code has no intention to optimize for any of the programming language.</p>\n</li>\n<li><p>My laptop has no GPU, and the codes are not compiled targeting any CPU.</p>\n</li>\n<li><p>Please see the README for how to run each.</p>\n</li>\n</ul>\n<p>The C++ flags as in the task.json of Vs Code:</p>\n<pre><code>            &quot;args&quot;: [\n                &quot;--std&quot;,\n                &quot;c++23&quot;,\n                &quot;-fdiagnostics-color=always&quot;,\n                &quot;-g&quot;,\n                &quot;-O3&quot;,\n            ],\n</code></pre>\n<p>Does this show that Java JIT compiler optimization is superior to C++ static optimization under repeated heave computation?</p>\n",
    "tags" : [ "java", "c++", "performance" ],
    "owner" : {
      "account_id" : 388557,
      "reputation" : 189,
      "user_id" : 747562,
      "user_type" : "registered",
      "accept_rate" : 25,
      "profile_image" : "https://www.gravatar.com/avatar/5c15b03c434ed5ebaa5d74e52e00db6d?s=256&d=identicon&r=PG",
      "display_name" : "CPW",
      "link" : "https://stackoverflow.com/users/747562/cpw"
    },
    "is_answered" : true,
    "view_count" : 246,
    "answer_count" : 9,
    "score" : 1,
    "last_activity_date" : 1765798388,
    "creation_date" : 1765492276,
    "link" : "https://stackoverflow.com/questions/79844417/c-vs-java-performance-under-repeated-heave-computation",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79844425,
    "question_id" : 79844417,
    "body" : "<p>It is always possible to have a good implementation in one language and a bad implementation in another.</p>\n",
    "score" : 9,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 5809836,
      "reputation" : 34105,
      "user_id" : 4581301,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/267cc01507d1d9ddcdeaafdc3beaa7b7?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "user4581301",
      "link" : "https://stackoverflow.com/users/4581301/user4581301"
    },
    "creation_date" : 1765493026,
    "last_activity_date" : 1765493026,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79844428,
    "question_id" : 79844417,
    "body" : "<p>Without looking into the specific benchmark (and I don't even know what heave computation is):</p>\n<ul>\n<li>Because computation-heavy FFT should be dominated by FPU performance, which is essentially a hardware constant, I would not expect such a difference.</li>\n<li>But code that exploits the hardware specifics (hardware-supported floating point lengths, SIMD extensions)  will be faster than generic code; perhaps much faster. gcc can be guided by providing the <code>-march</code> option or more specific options indicating the CPU's capabilities.</li>\n<li>Generally: Yes, in principle, a JIT compiler can perform optimizations that are not accessible to a compile time optimizer. Perhaps the JIT can even see that certain values never change and entirely avoid certain re-computations.</li>\n<li>This may go so far as to hit the typical benchmark problems: The optimization may invalidate the entire benchmark because the actual synthetic, repetitive work is optimized away.</li>\n</ul>\n",
    "score" : 9,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 3795627,
      "reputation" : 16377,
      "user_id" : 3150802,
      "user_type" : "registered",
      "accept_rate" : 55,
      "profile_image" : "https://i.sstatic.net/ulVTa.png?s=256",
      "display_name" : "Peter - Reinstate Monica",
      "link" : "https://stackoverflow.com/users/3150802/peter-reinstate-monica"
    },
    "creation_date" : 1765493656,
    "last_activity_date" : 1765493656,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79844431,
    "question_id" : 79844417,
    "body" : "<p>I recommend posting any optimization switches for building C++ as well as the assembly language for the FFT.  You should compare the C++ assembly language to the Java assembly language.</p>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 79346,
      "reputation" : 58061,
      "user_id" : 225074,
      "user_type" : "registered",
      "accept_rate" : 91,
      "profile_image" : "https://www.gravatar.com/avatar/dea26ac1ef8259140d28aa8b5ba4f1b3?s=256&d=identicon&r=PG",
      "display_name" : "Thomas Matthews",
      "link" : "https://stackoverflow.com/users/225074/thomas-matthews"
    },
    "creation_date" : 1765493889,
    "last_activity_date" : 1765493889,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79844571,
    "question_id" : 79844417,
    "body" : "<p>And Java can optimize for the hardware it runs on automatically, for C++ you have to specify compiler settings so you match the capabilities of your hardware.</p>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 22445574,
      "reputation" : 14036,
      "user_id" : 16649550,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/maclz.jpg?s=256",
      "display_name" : "Pepijn Kramer",
      "link" : "https://stackoverflow.com/users/16649550/pepijn-kramer"
    },
    "creation_date" : 1765515343,
    "last_activity_date" : 1765515343,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79844467,
    "question_id" : 79844417,
    "body" : "<pre><code>All three implementation are single-threaded without GPU-assistance. \nBecause FFT contains independent and logically identical branches, \nperhaps JIT compiler parallelized the execution to the 10-core of my computer.\n\nIf this is true, perhaps it is not necessary to do multi-threaded applications.\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 388557,
      "reputation" : 189,
      "user_id" : 747562,
      "user_type" : "registered",
      "accept_rate" : 25,
      "profile_image" : "https://www.gravatar.com/avatar/5c15b03c434ed5ebaa5d74e52e00db6d?s=256&d=identicon&r=PG",
      "display_name" : "CPW",
      "link" : "https://stackoverflow.com/users/747562/cpw"
    },
    "creation_date" : 1765500202,
    "last_activity_date" : 1765500609,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79844612,
    "question_id" : 79844417,
    "body" : "<p><code>FFT::bitReversedIndices</code> should probably be replaced with a static lookup table. The rest of the code might be faster with <a href=\"https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html\" rel=\"nofollow noreferrer\">simd intrinsics</a></p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 7195349,
      "reputation" : 38298,
      "user_id" : 5494370,
      "user_type" : "registered",
      "profile_image" : "https://graph.facebook.com/10152989584621642/picture?type=large",
      "display_name" : "Alan Birtles",
      "link" : "https://stackoverflow.com/users/5494370/alan-birtles"
    },
    "creation_date" : 1765521392,
    "last_activity_date" : 1765521392,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79844905,
    "question_id" : 79844417,
    "body" : "<p>Java implicitly is using JIT (you are shipping Java virtual machine code which when is run is translated to machine code specific for current CPU). This means that it can use all features of CPU it is deployed on. C++ usually is built with machine code which targets quite old version of CPU, to be compatible with large set of machines. As result optimizer has less opportunities to use more complex CPU instructions.\nIn your test scenario there is no memory management or other resource management, so this JIT give java a big advantage. If you rebuild your C++ program to target more modern CPU then optimizer should should be greatly reduced this gap. If you are testing on same machine where you are building you can feed option <code>-march=native</code>.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1477351,
      "reputation" : 40406,
      "user_id" : 1387438,
      "user_type" : "registered",
      "accept_rate" : 68,
      "profile_image" : "https://www.gravatar.com/avatar/ad806758c356c915ea08a4bfd79131e3?s=256&d=identicon&r=PG",
      "display_name" : "Marek R",
      "link" : "https://stackoverflow.com/users/1387438/marek-r"
    },
    "creation_date" : 1765544360,
    "last_activity_date" : 1765544360,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79844929,
    "question_id" : 79844417,
    "body" : "<p>Parts of Java (JVM) is or at least was written in C and C++. So theoretically a C++ program can do everything that a Java program can, it only matters how those programs are implemented.</p>\n<p>In C and C++ the code does pretty much exactly what you instruct it to do while other programming languages with a higher abstraction level do more stuff automatically (e.g. garbage collector).<br />\nIf the code is written in a good or good optimizable way then C++ can gain some performance by skipping unnecessary automatic steps or details that Java has (e.g. all Java objects have several default methods and properties, no matter if used or not).<br />\nIf the code is written in a bad or hardly optimizable way then the automatic routines of Java may behave better.</p>\n<p>I am no real expert on this part, but as an example I expect that the Java garbage collector and memory management could have a better average performance when there are a lot of similar allocations and deallocations.<br />\nWhen the code is explicitly written in a way to reuse previously used memory then C++ may again be better at this than Java.</p>\n<p>I recommend to use performance profilers to see</p>\n<ul>\n<li>on which portions of the program most of the CPU is spent</li>\n<li>how good the multiple CPUs are used</li>\n<li>how much RAM is used</li>\n</ul>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 32912519,
      "reputation" : 758,
      "user_id" : 25561613,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/0fa475f4e5f0390a69aaf260880db3de?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Thibe",
      "link" : "https://stackoverflow.com/users/25561613/thibe"
    },
    "creation_date" : 1765545941,
    "last_activity_date" : 1765545941,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79847632,
    "question_id" : 79844417,
    "body" : "<p>Random side note: <code>-O3</code> isn't necessarily better than <code>-O2</code> when applied on the whole code instead of just some functions.</p>\n<p>Even with &quot;identical&quot; sources, I strongly suspect that JIT optimisation could completely transform what's actually happening in runtime. It's a significant source of good performance in &quot;slower&quot; languages after all. If you could dig out assembly that's actually getting ran the hottest, perhaps we'd see JIT at work. There's no reason to think one would be universally better than the other - they're working on fundamentally different principles of predicting what would be best for static optimisation vs self-profiling for JIT.</p>\n<p>Did you try to make a very efficient implementation of this FFT in both languages, or is it just some reasonable middle ground between speed and effort? There's quite a lot of performance that can be dug out from basic implementation and some bottlenecks can be removed by changing implementation, sometimes manually when the compiler can't (I did that, unfortunately can't share the code where I did), but it's not like you need to prove that one is better than the other. If you're interested in expanding your benchmark, you can try to dig out some high-performing C++ implementations and compare with them too.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 18620141,
      "reputation" : 752,
      "user_id" : 28092874,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a-/AOh14GhQA9oHfT9vCqqV8Z2WV4urGt521K4ngvKYGDzCtg=k-s256",
      "display_name" : "Xellos",
      "link" : "https://stackoverflow.com/users/28092874/xellos"
    },
    "creation_date" : 1765798388,
    "last_activity_date" : 1765798388,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}