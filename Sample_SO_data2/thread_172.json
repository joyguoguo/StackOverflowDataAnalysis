{
  "question" : {
    "question_id" : 79824120,
    "title" : "Explicit class reference during static initialization not allowed. Why?",
    "body" : "<p><em><strong>Note</strong>. I hope &quot;why&quot; questions do fall into the &quot;other&quot; category.</em></p>\n<p>This compiles.</p>\n<pre class=\"lang-java prettyprint-override\"><code>class MyClass {\n\n    private static final String STRING;\n\n    static {\n        STRING = &quot;abc&quot;;\n    }\n}\n</code></pre>\n<p>This does not.</p>\n<pre class=\"lang-java prettyprint-override\"><code>class MyClass {\n\n    private static final String STRING;\n\n    static {\n        MyClass.STRING = &quot;abc&quot;;\n    }\n}\n</code></pre>\n<pre class=\"lang-none prettyprint-override\"><code>MyClass.java:8: error: cannot assign a value to final variable string\n        MyClass.string = &quot;abc&quot;;\n               ^\n1 error\n</code></pre>\n<p>Why? Was it a deliberate design choice? I would imagine both snippets should be compiled into the same bytecode (similar to how <code>nonstaticMethod()</code> and <code>this.nonstaticMethod()</code> are). <code>javac</code> can tell an initializer from a plain method, so it should have no trouble recognizing assignment in the latter snippet as initialization.</p>\n<p>Does it have something to do with class loaders? Classes loaded by different loaders may have the same fully-qualified name.</p>\n<p>Java 8.</p>\n",
    "tags" : [ "java", "javac", "static-initialization", "static-initializer" ],
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2667,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "is_answered" : true,
    "view_count" : 105,
    "answer_count" : 3,
    "score" : 0,
    "last_activity_date" : 1763594762,
    "creation_date" : 1763533495,
    "link" : "https://stackoverflow.com/questions/79824120/explicit-class-reference-during-static-initialization-not-allowed-why",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79824128,
    "question_id" : 79824120,
    "body" : "<p>Can't tell you why, but it is <a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-16.html\" rel=\"nofollow noreferrer\">documented</a>:</p>\n<blockquote>\n<p><strong>For every access of a local variable or blank final field x, x must be\ndefinitely assigned before the access, or a compile-time error occurs.</strong></p>\n<p>Similarly, every blank final variable must be assigned at most once;\nit must be definitely unassigned when an assignment to it occurs.</p>\n<p>Such an assignment is defined to occur if and only if either the\nsimple name of the variable (or, for a field, its simple name\nqualified by <code>this</code>) occurs on the left hand side of an assignment\noperator.</p>\n</blockquote>\n<p>Note the mention of <strong>simple</strong> name.</p>\n",
    "score" : 3,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 4362282,
      "reputation" : 98626,
      "user_id" : 3558960,
      "user_type" : "registered",
      "accept_rate" : 60,
      "profile_image" : "https://www.gravatar.com/avatar/a98b52149d419c2aad558befe51c8cc5?s=256&d=identicon&r=PG",
      "display_name" : "Robby Cornelissen",
      "link" : "https://stackoverflow.com/users/3558960/robby-cornelissen"
    },
    "creation_date" : 1763534442,
    "last_activity_date" : 1763534442,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79824540,
    "question_id" : 79824120,
    "body" : "<p>Yes, both snippets would compile to the same bytecode. The spec's definitions on how to compile this are strict, and mean the exact same thing.</p>\n<p>However, the section &quot;how does one compile this code into bytecode&quot; and the section &quot;compiler-only enforced business&quot; are two completely unrelated sections.</p>\n<p><code>final</code>, at least the restrictions on it, are in many cases purely a figment of <code>javac</code>'s imagination. checked exceptions are <strong>entirely</strong> the figment of <code>javac</code>'s imagination. Neither the class verifier, nor the runtime, knows anything about the idea and indeed doesn't <em>have</em> checked exceptions.</p>\n<p>In other words, this:</p>\n<pre><code>void foo() {\n  throw new IOException();\n}\n</code></pre>\n<p>only fails to compile because there's an <code>if</code> somewhere in <code>javac</code>'s source code that errors out. The actual part of javac that produces bytecode would have no problem with this, and indeed if you hack the compiler and remove that <code>if</code>, the produced class file would do exactly what you think it would (if you run that method it would.. throw an IOException which propagates up the stack exactly as normal).</p>\n<p>The same principle is at work here. The spec simply decrees (see Robby Cornelissen's link) that the compiler is obligated to refuse the second snippet because it fails to adhere to the rule. It's a real 'doctor it hurts when I smash my face with a hammer' kind of situation: The cure is simply: &quot;... well then do not do that&quot;. The 'fix' is for the compiler to stop refusing this code, the rest of the compilation process has absolutely no issues with it.</p>\n<p>Hence, the rule is a bit bizarre and seems like an oversight by the spec author. The fact that instance methods are allowed to use the <code>this.</code> qualifier, whereas in static space, where the obvious analogue to the <code>this.</code> qualifier is the <code>MyType.</code> qualifier - that's <em>not</em> allowed? That's quite inconsistent.</p>\n<p>Nevertheless, <code>javac</code> follows the spec.</p>\n<p>Thus, we've arrived at the conclusion: Why does it work this way? &quot;Because it does&quot;. There is no bug here, but also no reason to be found. It just is.</p>\n<p>An obvious followup might then be: ... can we change that? This seems like a capricious and arbitrary choice; in many legal systems that is a valid approach to get a high court to decree a law as improper and toss it out, even.</p>\n<p>That might be an option. But it won't be easy.</p>\n<p>An anecdote might help shed some light:</p>\n<p>The OpenJDK bug tracker is no longer for the public (only consortium members can file bugs on them; the public would file bugs with their JVM vendor who may forward them into the OpenJDK tracker). Back when it was, you had to pick a section you're filing the bug under. There <em>was no section for spec at all</em> - you could 'report a bug' against the spec. Only against the compiler, the core library, and so on. I found an actual bug in javac a while ago that is similar to this case (a spec decision that seemed highly inconsistent with the rest of the spec, capriciously).It's since been corrected, by updating the spec, which is also the result you'd want.</p>\n<p>Back then, the following snippet would compile just fine, but a careful reading of the spec would tell you javac should not have compiled it - the JLS did not consider this valid java:</p>\n<pre class=\"lang-java prettyprint-override\"><code>for (int foo[] : listOfIntArrays) {}\n</code></pre>\n<p>You might find that syntax bizarre but it <em>is</em> legal java, at least, in almost every other context (and since the fix of the spec, now also as per the JLS itself). For context, the following snippets are all valid java and have always been, both de jure (the JLS says all the following snippets are legal) and de facto (javac compiles them, JVM runs them):</p>\n<pre class=\"lang-java prettyprint-override\"><code>int[] iAmAnArrayOfIntArrays[];\n\npublic int iReturnAnIntArray() [] { return null; }\nfor (int i = 0, j[] = {1, 2}; ; ) ;\n\n// The idea is, you can put array brackets at the end of any variable declaration\n// -or- at the end of the type of your variable declaration; they mean the same thing,\n// and you can even split them. The compiler adds all brackets together.\n\n// If you're looking for a reason why: Because C allowed this, and java\n// wanted to copy its syntax.\n\n// If you're looking for a reason why C allow it: Oof. The answer is in the 1960s.\n</code></pre>\n<p>The oversight is (or, rather, was) clearly with the spec author of the <code>for (Elem varName : collection)</code> variant, which wasn't in java 1.0 and added later, who at the time failed to take this somewhat exotic java syntax quirk into account.</p>\n<p>I had to file a bug to indicate that technically the compiler was broken as it allowed you to write something the spec says isn't legit java, becuase it was not possible to file a 'bug' against the Java Language Specification.</p>\n<p>I did of course mention it felt like the spec should be updated to follow javac instead of the other way around and fortunately that's how the bug has been handled.</p>\n<p>Point is - it took some effort and the bug report processes aren't really designed to handle &quot;the spec is capricious&quot; style issues. Your situation is even more difficult than the above situation: It's a spec inconsistency where you do not have the benefit of javac disagreeing and doing the consistent thing. In practice if you'd like to see this changed, it would be an actual full language change and thus needs an OpenJDK project (a JEP), or needs to be added to one - you'd need to convince a core author of the OpenJDK source tree (many of them Oracle employees). Possibly wait around for a project focussed on addressing various small language features to come along. Tiny updates like this do occur; the most recent one is that you <em>can</em> now write certain types of statements <em>above</em> your <code>super()</code> / <code>this()</code> call in a constructor, whereas in java 1.0, <code>super()</code>/<code>this()</code> (or the implicit <code>super()</code> you get if you write neither one) <strong>had to be</strong> the very first statement, though that statement could include complicated expressions which was always a bizarre thing.</p>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107136,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1763561042,
    "last_activity_date" : 1763561042,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79824996,
    "question_id" : 79824120,
    "body" : "<p>Another question is why do you want to write redundant syntax?</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 71739,
      "reputation" : 311872,
      "user_id" : 207421,
      "user_type" : "registered",
      "accept_rate" : 82,
      "profile_image" : "https://www.gravatar.com/avatar/5cfe5f7d64f44be04f147295f5c7b88e?s=256&d=identicon&r=PG",
      "display_name" : "user207421",
      "link" : "https://stackoverflow.com/users/207421/user207421"
    },
    "creation_date" : 1763594762,
    "last_activity_date" : 1763594762,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}