{
  "question" : {
    "question_id" : 79551636,
    "title" : "Java different method resolution when using generics",
    "body" : "<p>Given the following Java class:</p>\n<pre><code>public class Foo {\n\n    public static void main(String[] args) {\n        x(generics());\n    }\n\n    public static &lt;T&gt; T generics() {\n        return null;\n    }\n\n    public static void x(Object o) {\n        System.out.println(&quot;Method with Object&quot;);\n    }\n\n    public static void x(char[] c) {\n        System.out.println(&quot;Method with char[]&quot;);\n    }\n\n}\n</code></pre>\n<p>In Java 7, the method called is <code>x(Object)</code>. In Java 8, it's <code>x(char[])</code>.</p>\n<p>I was just curious as to why did it change.</p>\n",
    "tags" : [ "java", "generics" ],
    "owner" : {
      "account_id" : 5901340,
      "reputation" : 179,
      "user_id" : 4644745,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b0a91b823173b61ba93400402447b111?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Flumen",
      "link" : "https://stackoverflow.com/users/4644745/flumen"
    },
    "is_answered" : false,
    "view_count" : 52,
    "closed_date" : 1743632184,
    "answer_count" : 0,
    "score" : 1,
    "last_activity_date" : 1743630781,
    "creation_date" : 1743630781,
    "link" : "https://stackoverflow.com/questions/79551636/java-different-method-resolution-when-using-generics",
    "closed_reason" : "Duplicate"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140293758,
    "post_id" : 79551636,
    "body" : "Let me add something to this already satisfying answer: Java tries to find the most specific type. Check this by letting your IDE assign generics() to a variable, a char[] is created. With your origin code, add a method x(int[] c). The IDE complains that the call to x() is ambigious. Formerly it way not, because there was only one most specific way to resolve what the result of generics() could be. Always keep in mind that generics in java are &quot;nothing&quot; during runtime. Play around with additional overladed methods and assignments of method result. This way you get a pretty good &quot;feeling&quot;.",
    "score" : 1,
    "owner" : {
      "account_id" : 5107114,
      "reputation" : 490,
      "user_id" : 4094874,
      "user_type" : "registered",
      "accept_rate" : 33,
      "profile_image" : "https://i.sstatic.net/GKt6S.jpg?s=256",
      "display_name" : "Guardian667",
      "link" : "https://stackoverflow.com/users/4094874/guardian667"
    },
    "creation_date" : 1743669272,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140292518,
    "post_id" : 79551636,
    "body" : "from the <a href=\"https://www.oracle.com/java/technologies/javase/8-compatibility-guide.html#A999387\" rel=\"nofollow noreferrer\">Compatibility Guide</a> for Java 8, showing similar code example: &quot;<i>This enhancement is aimed at removing annoying asymmetries between method contexts and assignment contexts, and is crucial to allow lambda expressions and method references to be used freely in client code.</i>&quot;",
    "score" : 4,
    "owner" : {
      "account_id" : 31180,
      "reputation" : 29752,
      "user_id" : 85421,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/kKvXH.gif?s=256",
      "display_name" : "user85421",
      "link" : "https://stackoverflow.com/users/85421/user85421"
    },
    "creation_date" : 1743634636,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}