{
  "question" : {
    "question_id" : 79677971,
    "title" : "Intermittent 403 Errors with Spring Security App Deployed on Digital Ocean",
    "body" : "<p>I have my spring boot / security being hosted by digital ocean and I am trying to access it from my local machine. I am seeing intermittent 403 errors for the authenticated endpoints. It is really strange I can send the same exact request in postman with the authorization header and sometimes it will return fine, other times it will return a 403 with the log message &quot;JWT signature: JWT signature does not match locally computed signature. JWT validity cannot be asserted and should not be trusted.&quot; Everything is working fine locally when I have the back end running on my local machine.</p>\n<p>This is how I am generating the tokens</p>\n<pre><code>  private static final SecretKey SECRET_KEY = Jwts.SIG.HS512.key().build();\n\n  public String generateTokenFromUsername(String username) {\n    return Jwts.builder().subject(username).issuedAt(new Date())\n            .expiration(new Date((new Date()).getTime() + jwtExpirationMs)).signWith(SECRET_KEY)\n            .compact();\n  }\n</code></pre>\n<p>And this is how I am validating them (the Security Exception is what is thrown):</p>\n<pre><code>public boolean validateJwtToken(String authToken) {\n    try {\n      Jwts.parser()\n              .verifyWith(SECRET_KEY)\n              .build()\n              .parseSignedClaims(authToken)\n              .getPayload();\n      return true;\n    } catch (SecurityException e) {\n      logger.error(&quot;Invalid JWT signature: {}&quot;, e.getMessage());\n    } catch (MalformedJwtException e) {\n      logger.error(&quot;Invalid JWT token: {}&quot;, e.getMessage());\n    } catch (ExpiredJwtException e) {\n      logger.error(&quot;JWT token is expired: {}&quot;, e.getMessage());\n    } catch (UnsupportedJwtException e) {\n      logger.error(&quot;JWT token is unsupported: {}&quot;, e.getMessage());\n    } catch (IllegalArgumentException e) {\n      logger.error(&quot;JWT claims string is empty: {}&quot;, e.getMessage());\n    }\n\n    return false;\n  }\n</code></pre>\n<p>Any help is greatly appreciated.</p>\n<p>I also logged the Secret Key being used and checked it against the issued JWT on jwt.io is showing the JWT as verified:</p>\n<p><a href=\"https://i.sstatic.net/WijBHNtw.png\" rel=\"nofollow noreferrer\">JWT verification</a></p>\n",
    "tags" : [ "java", "authentication", "spring-security", "jwt", "digital-ocean" ],
    "owner" : {
      "account_id" : 42706091,
      "reputation" : 1,
      "user_id" : 30882869,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f8e97237d267b954942c7d911fc1f9b7?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "user30882869",
      "link" : "https://stackoverflow.com/users/30882869/user30882869"
    },
    "is_answered" : false,
    "view_count" : 69,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1750981618,
    "creation_date" : 1750785184,
    "link" : "https://stackoverflow.com/questions/79677971/intermittent-403-errors-with-spring-security-app-deployed-on-digital-ocean",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79678439,
    "question_id" : 79677971,
    "body" : "<p>Your current code generates the <code>SECRET_KEY</code> dynamically:</p>\n<pre class=\"lang-java prettyprint-override\"><code>private static final SecretKey SECRET_KEY = Jwts.SIG.HS512.key().build();\n</code></pre>\n<p>This line creates a new, random <code>SecretKey</code> every time an instance of your application starts. So each instance on DigitalOcean upon startup will generate its own unique <code>SECRET_KEY</code>. Even with a single instance, every time your application restarts (due to a deployment, update, or crash) a secret key is generated. And this breaks JWT validation when tokens signed by one instance are tried to be verified by another instance or by the same instance after a restart. Because any tokens issued before the restart will become invalid after the restart because the validation key has changed. When you run it locally probably you typically have only one instance, and it usually doesn't restart frequently, so your generated secret key remains consistent during your testing session.</p>\n<ol>\n<li><p><strong>Never hardcode or dynamically generate your secret key at runtime!</strong></p>\n</li>\n<li><p><strong>Before deployment generate single, strong, cryptographically secure key.</strong></p>\n</li>\n<li><p>Securely configure this secret key value as an environment variable in your Digital Ocean deployment.</p>\n</li>\n<li><p>Read this key from the environment variable (or a Spring property that maps to it)</p>\n</li>\n<li><p>Periodically change your secret key by planned scheduled security rotation strategy to reduce the attack surface if a key is ever compromised.</p>\n</li>\n</ol>\n<p><strong>Why it works locally.</strong> Just for one simple reason: you're only running a single instance of your application.</p>\n<ul>\n<li><p>When you launch the app on your local machine, it starts 1 process.</p>\n</li>\n<li><p>This 1 process generates 1 secret key and holds it in memory.</p>\n</li>\n<li><p>Every single request you send (from authentication to accessing data) is handled by that same single process.</p>\n</li>\n</ul>\n<p>Because the same instance both creates and validates the token, the secret key is always a perfect match. The intermittent error is impossible because there's no second instance with a different key for a request to be sent to. That's it.</p>\n<p><strong>Your DigitalOcean setup and sequence of events:</strong></p>\n<ul>\n<li><p>In DigitalOcean infrastructure your application is likely running in an environment that's not a single, static instance and of course behind a load balancer. This's a fundamental difference.</p>\n</li>\n<li><p>Behind the load balancer you have at least 2 instances of your Spring Boot application running. Let's call them <strong>Instance A</strong> and <strong>Instance B</strong>.</p>\n</li>\n</ul>\n<ol>\n<li><p><strong>Startup:</strong></p>\n<ul>\n<li><p><strong>Instance A</strong> starts. It runs the code <code>Jwts.SIG.HS512.key().build()</code> and generates <code>SECRET_KEY_A</code>. Let's say this key is the one in your screenshot, ending in <code>...OnrA</code>.</p>\n</li>\n<li><p><strong>Instance B</strong> starts. It also runs <code>Jwts.SIG.HS512.key().build()</code> and generates its own, completely different, random <code>SECRET_KEY_B</code>.</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Request #1: Login (SUCCESS)</strong></p>\n<ul>\n<li><p>You send your login request from Postman.</p>\n</li>\n<li><p>The DigitalOcean Load Balancer receives the request and, using its round-robin algorithm, routes it to <strong>Instance A</strong>.</p>\n</li>\n<li><p><strong>Instance A</strong> validates the user's credentials, generates a JWT signed with <code>SECRET_KEY_A</code>, and returns it.</p>\n</li>\n<li><p>At this point, you log the token and <code>SECRET_KEY_A</code>. You paste them into jwt.io. Of course it shows &quot;Signature Verified&quot;, the key and token came from the same source. This's what your screenshot proves.</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Request #2: Access authenticated endpoint (FAILURE)</strong></p>\n<ul>\n<li><p>You immediately send a new request to <code>/api/some-data</code> with the token you just received.</p>\n</li>\n<li><p>The load balancer receives this request and routes it to the next server in the rotation: <strong>Instance B</strong>.</p>\n</li>\n<li><p><strong>Instance B</strong> receives the token. It tries to validate the token's signature using its own key, <code>SECRET_KEY_B</code>.</p>\n</li>\n<li><p>Since <code>SECRET_KEY_A</code> is not the same as <code>SECRET_KEY_B</code>, the validation fails.</p>\n</li>\n<li><p><strong>Instance B</strong> logs the error <code>JWT signature does not match locally computed signature</code> and returns a 403 Forbidden.</p>\n</li>\n</ul>\n</li>\n<li><p><strong>Request #3: Access Authenticated Endpoint Again (SUCCESS)</strong></p>\n<ul>\n<li><p>Confused, you hit &quot;Send&quot; in Postman one more time, just a second later.</p>\n</li>\n<li><p>The load balancer receives this request and routes it to the next server: <strong>Instance A</strong>.</p>\n</li>\n<li><p><strong>Instance A</strong> receives the token. It validates the signature using <code>SECRET_KEY_A</code>.</p>\n</li>\n<li><p>The signature matches perfectly.</p>\n</li>\n<li><p>The request succeeds and you get a 200 OK response.</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>This sequence explains the &quot;intermittent&quot; failures happening &quot;back to back.&quot; And it's not about server restarts in this scenario here, it's about which server instance happens to handle your request.</p>\n<p>With my solutions having the static single key it'll no longer matter if first instance signs the token and another one validates it, because they'll both be using the same secret key. It's not only good practice to handle server restarts, it's the direct and required fix for this exact problem.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1207862,
      "reputation" : 4210,
      "user_id" : 1177031,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/79eaae35b3331731ecfb9e360bb8380b?s=256&d=identicon&r=PG",
      "display_name" : "kapandron",
      "link" : "https://stackoverflow.com/users/1177031/kapandron"
    },
    "creation_date" : 1750822316,
    "last_activity_date" : 1750981618,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79678439" : [ {
      "comment_id" : 140545978,
      "post_id" : 79678439,
      "body" : "@user30882869 In my updated answer I provided a detailed explanation and example of typical scenarios and the cause of reproduction the error. I hope this helps to walk you through exactly what&#39;s happening.",
      "score" : 0,
      "owner" : {
        "account_id" : 1207862,
        "reputation" : 4210,
        "user_id" : 1177031,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/79eaae35b3331731ecfb9e360bb8380b?s=256&d=identicon&r=PG",
        "display_name" : "kapandron",
        "link" : "https://stackoverflow.com/users/1177031/kapandron"
      },
      "creation_date" : 1750983722,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140545976,
      "post_id" : 79678439,
      "body" : "@user30882869 Explore more deeply how distributed, cloud-based, load-balanced architecture works and google the best practices to generate and proper using a secret key. Your screenshot just confirms that the token is only valid on the specific instance that created it. But all running instances of the application must always share a single, static, externalized secret key. Only implementing the static, externalized secret key will resolve this issue for horizontally scaled, potentially multi-instance environment.",
      "score" : 0,
      "owner" : {
        "account_id" : 1207862,
        "reputation" : 4210,
        "user_id" : 1177031,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/79eaae35b3331731ecfb9e360bb8380b?s=256&d=identicon&r=PG",
        "display_name" : "kapandron",
        "link" : "https://stackoverflow.com/users/1177031/kapandron"
      },
      "creation_date" : 1750983702,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140545885,
      "post_id" : 79678439,
      "body" : "@user30882869 Your understanding based on the assumption of a single-instance environment, just like your local machine. This logic is sound only if a single application instance is handling all requests. On DigitalOcean  this&#39;s almost never the case. In reality the &quot;back to back requests within seconds&quot; failure is the classic symptom of a load balancer distributing traffic across multiple application instances that don&#39;t share a cryptographic key.",
      "score" : 0,
      "owner" : {
        "account_id" : 1207862,
        "reputation" : 4210,
        "user_id" : 1177031,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/79eaae35b3331731ecfb9e360bb8380b?s=256&d=identicon&r=PG",
        "display_name" : "kapandron",
        "link" : "https://stackoverflow.com/users/1177031/kapandron"
      },
      "creation_date" : 1750978113,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140541870,
      "post_id" : 79678439,
      "body" : "I logged the Secret Key being used and checked it against the issued JWT on token.dev and it is showing the JWT as verified",
      "score" : 0,
      "owner" : {
        "account_id" : 42706091,
        "reputation" : 1,
        "user_id" : 30882869,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/f8e97237d267b954942c7d911fc1f9b7?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "user30882869",
        "link" : "https://stackoverflow.com/users/30882869/user30882869"
      },
      "creation_date" : 1750868056,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140541664,
      "post_id" : 79678439,
      "body" : "This is not what is causing my issue as this is happening on back to back requests within seconds of each other without any server or application restarts so it is still using the same key. Thank you for these considerations though, I will definitely change the way the SecretKey is being done so that it is not changed on server restarts.",
      "score" : 0,
      "owner" : {
        "account_id" : 42706091,
        "reputation" : 1,
        "user_id" : 30882869,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/f8e97237d267b954942c7d911fc1f9b7?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "user30882869",
        "link" : "https://stackoverflow.com/users/30882869/user30882869"
      },
      "creation_date" : 1750863956,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}