{
  "question" : {
    "question_id" : 79839373,
    "title" : "Is it possible to inspect method invocations on a JDBI DAO using aspect-oriented programming?",
    "body" : "<p>We mostly use <code>Jdbi.onDemand</code> with DAO interfaces to interact with our RDS.</p>\n<p>I'm trying to get visibility of when each DAO method is invoked.</p>\n<p>We have hundreds of methods across dozens of interfaces, so adding logs to every invocation individually is impractical.</p>\n<p>I was hoping to use an AOP advice based on JDBI annotations on the interface methods. We have <code>@annotation</code> advice for some controller methods, which works well, but the same approach isn't working for DAO methods.</p>\n<p>I suspect this is because both Spring AOP and JDBI work by creating proxy classes based on the interface, so that JDBI is able to get an instance and use it to interact with the database, but my aspect can't &quot;see&quot; that instance to apply the advice. I'm pretty new to this though and still getting my head round the details.</p>\n<p>Sample project on GitHub: <a href=\"https://github.com/Vaent/jdbi-aop-example\" rel=\"nofollow noreferrer\">https://github.com/Vaent/jdbi-aop-example</a></p>\n<p>Example code snippets (simplified):</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Service\npublic class MyService {\n  @Autowired\n  private Jdbi jdbi;\n\n  public Long getCount() {\n    // MyDAO#getCount is invoked as expected\n    return jdbi.onDemand(MyDAO.class).getCount();\n  }\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>public interface MyDAO {\n  @SqlQuery(&quot;SELECT COUNT(*) FROM myschema.mytable&quot;)\n  public Long getCount();\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>@Aspect\n@Component\npublic class MyAspect {\n  @Before(&quot;@annotation(sqlQuery)&quot;)\n  public void queryAdvice(SqlQuery sqlQuery) {\n    // When the service method is invoked, I expect this to be printed, but nothing happens\n    System.out.println(&quot;Executing query: &quot; + sqlQuery.value());\n  }\n}\n</code></pre>\n<p>I've tried different advice types, different pointcut expressions including <code>bean</code> and <code>execution</code>, using a separate pointcut method, using a custom annotation instead of the JDBI one. Nothing I've tried seems to make any difference.</p>\n<p>Is there a workaround or a way to configure the aspect/interface so that JDBI's on-demand extension can interact with AspectJ/Spring AOP/any other aspect-oriented framework?</p>\n",
    "tags" : [ "java", "spring", "aop", "aspectj", "jdbi" ],
    "owner" : {
      "account_id" : 5866617,
      "reputation" : 33,
      "user_id" : 4620361,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/05a0c824d2c6b767e9b8367544eb458c?s=256&d=identicon&r=PG",
      "display_name" : "Vaent",
      "link" : "https://stackoverflow.com/users/4620361/vaent"
    },
    "is_answered" : true,
    "view_count" : 100,
    "answer_count" : 1,
    "score" : 3,
    "last_activity_date" : 1765392670,
    "creation_date" : 1764975961,
    "link" : "https://stackoverflow.com/questions/79839373/is-it-possible-to-inspect-method-invocations-on-a-jdbi-dao-using-aspect-oriented",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79840058,
    "question_id" : 79839373,
    "body" : "<p>Like I said: Instead of directly creating DAOs via <code>jdbi.onDemand(MyDAO.class)</code> each time they are needed, make the DAO a Spring <code>@Bean</code> and inject it wherever it is needed. This way, Spring AOP can intercept it.</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Configuration\npublic class MyConfig {\n    // ...\n    @Bean\n    public Jdbi jdbi (DataSource dataSource) {\n        Jdbi jdbi = Jdbi.create(dataSource);\n        jdbi.installPlugin(new SqlObjectPlugin());\n        return jdbi;\n    }\n\n    @Bean\n    public MyDAO myDAO (Jdbi jdbi) {\n        return jdbi.onDemand(MyDAO.class);\n    }\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>@Service\npublic class MyService {\n    private final MyDAO myDAO;\n\n    public MyService(MyDAO myDAO) {\n        this.myDAO = myDAO;\n    }\n\n    public Long getCount() {\n        return myDAO.getCount();\n    }\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>@Aspect\n@Component\npublic class MyAspect {\n    @Before(&quot;@annotation(sqlQuery)&quot;)\n    public void queryAdvice(SqlQuery sqlQuery) {\n        System.out.println(&quot;Executing query: &quot; + sqlQuery.value());\n    }\n}\n</code></pre>\n<p>Console log:</p>\n<pre class=\"lang-none prettyprint-override\"><code>...\n2025-12-07 09:58:24.921  INFO 24864 --- [           main] uk.vaent.Main                            : Started Main in 4.969 seconds (JVM running for 6.195)\nExecuting query: SELECT COUNT(*) FROM mytable\n</code></pre>\n<p>See <a href=\"https://github.com/Vaent/jdbi-aop-example/pull/1\" rel=\"nofollow noreferrer\">my pull request</a>.</p>\n<hr />\n<h3>Update for native AspectJ</h3>\n<p>Because the OP asked about a native AspectJ solution which avoids refactoring, I added <a href=\"https://github.com/Vaent/jdbi-aop-example/pull/2\" rel=\"nofollow noreferrer\">another pull request</a>.</p>\n<p>It requires a <code>META-INF/aop.xml</code> file and <code>-javaagent:/path/to/aspectjweaver-1.9.25.jar</code> on the JVM command line.</p>\n<pre class=\"lang-xml prettyprint-override\"><code>&lt;?xml version=&quot;1.0&quot;?&gt;\n\n&lt;aspectj&gt;\n\n  &lt;weaver options=&quot;-showWeaveInfo&quot;&gt;\n    &lt;include within=&quot;uk.vaent..*&quot;/&gt;\n    &lt;!-- Cosmetics: avoid warnings for CGLIB proxies in config class --&gt;\n    &lt;exclude within=&quot;uk.vaent.config..*&quot;/&gt;\n  &lt;/weaver&gt;\n\n  &lt;aspects&gt;\n    &lt;aspect name=&quot;uk.vaent.aspect.MyAspect&quot;/&gt;\n\n    &lt;!-- Spring aspects, copied from spring-aspects-5.3.31.jar. (De-)activate as needed --&gt;\n    &lt;aspect name=&quot;org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect&quot;/&gt;\n    &lt;aspect name=&quot;org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspect&quot;/&gt;\n    &lt;aspect name=&quot;org.springframework.transaction.aspectj.AnnotationTransactionAspect&quot;/&gt;\n    &lt;aspect name=&quot;org.springframework.transaction.aspectj.JtaAnnotationTransactionAspect&quot;/&gt;\n    &lt;aspect name=&quot;org.springframework.cache.aspectj.AnnotationCacheAspect&quot;/&gt;\n    &lt;aspect name=&quot;org.springframework.cache.aspectj.JCacheCacheAspect&quot;/&gt;\n  &lt;/aspects&gt;\n\n&lt;/aspectj&gt;\n</code></pre>\n<pre class=\"lang-xml prettyprint-override\"><code>    &lt;properties&gt;\n        &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n        &lt;!-- Override transitive Spring dependency, Java 17 requires at least AspectJ 1.9.8 --&gt;\n        &lt;aspectj.version&gt;1.9.25&lt;/aspectj.version&gt;\n    &lt;/properties&gt;\n</code></pre>\n<p>Ideally, also update the AspectJ version to avoid problems with 1.9.7 (Java 16) while using compiler target Java 17. I also recommend this for the Spring AOP solution above.</p>\n<p><strong>Caveat:</strong> AspectJ can only intercept a <code>call()</code> method call joinpoint here, not an <code>execution()</code> one, because the generated DAO class implementing the interface will not inherit any method annotations from interface methods. This is not specific to AspectJ but a general limitation of the JVM. Method annotations are never inherited by or copied to implementing classes. Even type (class-level) annotations on interfaces are not inherited. Only type annotations on non-interface class types can optionally be inherited, if the annotation itself bears the <code>@Inherited</code> meta annotation. This is basic knowledge, but many developers do not know about it, therefore I am mentioning it in this context.</p>\n",
    "score" : 1,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 1087271,
      "reputation" : 68594,
      "user_id" : 1082681,
      "user_type" : "registered",
      "accept_rate" : 90,
      "profile_image" : "https://i.sstatic.net/lDK9h.png?s=256",
      "display_name" : "kriegaex",
      "link" : "https://stackoverflow.com/users/1082681/kriegaex"
    },
    "creation_date" : 1765077094,
    "last_activity_date" : 1765392670,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140891006,
    "post_id" : 79839373,
    "body" : "As you can see in my answer, the changes are rather trivial, and corresponding refactoring should be rather trivial and can probably be semi automated using search &amp; replace. IntelliJ IDEA even has structural s&amp;r, which is a bit cryptic but powerful. Spring is a dependency injection framework, so injecting instead of directly instantiating dependencies is a good approach anyway. Collecting technical debt is usually a bad idea (says the agile coach in me). If you still prefer introducing AspectJ over refactoring after evaluating my answer below, please let me know.",
    "score" : 0,
    "owner" : {
      "account_id" : 1087271,
      "reputation" : 68594,
      "user_id" : 1082681,
      "user_type" : "registered",
      "accept_rate" : 90,
      "profile_image" : "https://i.sstatic.net/lDK9h.png?s=256",
      "display_name" : "kriegaex",
      "link" : "https://stackoverflow.com/users/1082681/kriegaex"
    },
    "creation_date" : 1765080658,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140890416,
    "post_id" : 79839373,
    "body" : "If you have any specific ideas about how native AspectJ could solve this, I&#39;d be very interested.",
    "score" : 0,
    "owner" : {
      "account_id" : 5866617,
      "reputation" : 33,
      "user_id" : 4620361,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/05a0c824d2c6b767e9b8367544eb458c?s=256&d=identicon&r=PG",
      "display_name" : "Vaent",
      "link" : "https://stackoverflow.com/users/4620361/vaent"
    },
    "creation_date" : 1765032344,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140890408,
    "post_id" : 79839373,
    "body" : "@kriegaex thanks for the prompts. The <code>Jbdi</code> instance is autowired by Spring, I&#39;ve added an annotation to my snippet to clarify that.  On your suggestion to return <code>jdbi.onDemand(MyDAO.class)</code> from a bean method, do you mean to autowire an instance of <code>MyDAO</code> in the service class and remove the direct usage of <code>Jdbi</code> in that code? I think I get the idea, it could be a good pattern but unfortunately would involve a lot of refactoring of legacy code, so it&#39;s unlikely I&#39;ll be able to go ahead with that approach - I can take it back to the team as a potential future change though.",
    "score" : 0,
    "owner" : {
      "account_id" : 5866617,
      "reputation" : 33,
      "user_id" : 4620361,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/05a0c824d2c6b767e9b8367544eb458c?s=256&d=identicon&r=PG",
      "display_name" : "Vaent",
      "link" : "https://stackoverflow.com/users/4620361/vaent"
    },
    "creation_date" : 1765032041,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140890034,
    "post_id" : 79839373,
    "body" : "Welcome to SO. The question is interesting and the code instructive, but incomplete. A minimal reproducer on GitHub incl. e.g. Maven build file and pre-populated in-memory DBMS would help to reproduce your situation. How is the JDBI object instantiated and injected into your service? I think you should use a <code>@Bean</code> method returning <code>jdbi.onDemand(MyDAO.class)</code> and auto-wire the bean into your service. Spring AOP can only intercept Spring beans/components, otherwise you would need to use native AspectJ instead, which is more powerful.",
    "score" : 1,
    "owner" : {
      "account_id" : 1087271,
      "reputation" : 68594,
      "user_id" : 1082681,
      "user_type" : "registered",
      "accept_rate" : 90,
      "profile_image" : "https://i.sstatic.net/lDK9h.png?s=256",
      "display_name" : "kriegaex",
      "link" : "https://stackoverflow.com/users/1082681/kriegaex"
    },
    "creation_date" : 1764996619,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79840058" : [ {
      "comment_id" : 140899318,
      "post_id" : 79840058,
      "body" : "You&#39;re absolutely right, I must have got them mixed up somehow. Reworking the <code>.java</code> aspect file as a <code>.aj</code> was an attempted fix for my issues based on other worked examples I found and is clearly unnecessary. Thanks for all your support, I&#39;ll mark the answer as accepted :)",
      "score" : 0,
      "owner" : {
        "account_id" : 5866617,
        "reputation" : 33,
        "user_id" : 4620361,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/05a0c824d2c6b767e9b8367544eb458c?s=256&d=identicon&r=PG",
        "display_name" : "Vaent",
        "link" : "https://stackoverflow.com/users/4620361/vaent"
      },
      "creation_date" : 1765531685,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140898964,
      "post_id" : 79840058,
      "body" : "No, the PR is separate from the previous refactoring on a separate branch. They only have the first commit in common, calling the controller from the main class to directly trigger the aspect and see the result. If you just accept the PR on the sample project&#39;s last commit before my changes, it should just work. Why would you rename <code>.java</code> files to <code>.aj</code>? Are you trying to use compile-time weaving with the AspectJ compiler? That would just complicate things for you, if you are an AspectJ newbie, because you would have to change the build process.",
      "score" : 0,
      "owner" : {
        "account_id" : 1087271,
        "reputation" : 68594,
        "user_id" : 1082681,
        "user_type" : "registered",
        "accept_rate" : 90,
        "profile_image" : "https://i.sstatic.net/lDK9h.png?s=256",
        "display_name" : "kriegaex",
        "link" : "https://stackoverflow.com/users/1082681/kriegaex"
      },
      "creation_date" : 1765509904,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140898821,
      "post_id" : 79840058,
      "body" : "Sadly I was unable to get the updated solution working. I noticed that your second pull request with <code>META-INF&#47;aop.xml</code> was on top of the previous refactoring, is it possible you got a false positive when testing the native solution?    Sorry for the delayed reply, I&#39;d been experimenting with other changes around the aop.xml addition, such as replacing the Java aspect with a <code>.aj</code> file. I wanted to push to a branch to show my failed attempts but other priorities have taken over since Monday.",
      "score" : 0,
      "owner" : {
        "account_id" : 5866617,
        "reputation" : 33,
        "user_id" : 4620361,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/05a0c824d2c6b767e9b8367544eb458c?s=256&d=identicon&r=PG",
        "display_name" : "Vaent",
        "link" : "https://stackoverflow.com/users/4620361/vaent"
      },
      "creation_date" : 1765494308,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140892011,
      "post_id" : 79840058,
      "body" : "Please note my answer update, adding a native AspectJ solution. I tested it, it works beautifully without the need to refactor your JDBI calls.",
      "score" : 1,
      "owner" : {
        "account_id" : 1087271,
        "reputation" : 68594,
        "user_id" : 1082681,
        "user_type" : "registered",
        "accept_rate" : 90,
        "profile_image" : "https://i.sstatic.net/lDK9h.png?s=256",
        "display_name" : "kriegaex",
        "link" : "https://stackoverflow.com/users/1082681/kriegaex"
      },
      "creation_date" : 1765169231,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140891548,
      "post_id" : 79840058,
      "body" : "Thanks for posting this code. If we didn&#39;t already have literally hundreds of <code>jdbi.onDemand</code> invocations in service code (which are all more or less similar to my <code>jdbi.onDemand(MyDAO.class).getCount()</code> example) this would be a good simple solution. Unfortunately my team won&#39;t buy in because even if we could automate the refactoring to some extent, it will affect too many lines in too many classes. I really need something which leaves the existing code untouched if possible, which is why I thought AOP would be the way to go although clearly Spring AOP won&#39;t cut it.",
      "score" : 0,
      "owner" : {
        "account_id" : 5866617,
        "reputation" : 33,
        "user_id" : 4620361,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/05a0c824d2c6b767e9b8367544eb458c?s=256&d=identicon&r=PG",
        "display_name" : "Vaent",
        "link" : "https://stackoverflow.com/users/4620361/vaent"
      },
      "creation_date" : 1765124900,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}