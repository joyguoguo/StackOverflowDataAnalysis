{
  "question" : {
    "question_id" : 79749328,
    "title" : "Spring RestClient to deserialize (retrieve) between two completely different types",
    "body" : "<p>There is a third-party REST API, which I have no control over, that exposes an endpoint.</p>\n<p>The endpoint would return either a good response, with HTTP 200, which is an object that looks like:</p>\n<pre><code>{\n  &quot;device&quot;: &quot;sensor-01&quot;,\n  &quot;temperature&quot;: 23.5\n}\n</code></pre>\n<p>However, if there is an error on the API side, it would still return HTTP 200, with a body like this:</p>\n<pre><code>{\n  &quot;message&quot;: &quot;An error occurred&quot;,\n  &quot;code&quot;: 400\n}\n</code></pre>\n<p>Again, I have no control over this API and cannot change this behavior.</p>\n<p>To map the response with Spring, I created the two objects:</p>\n<pre><code>public record GoodPojo(String device, float temperature) {\n}\n</code></pre>\n<pre><code>public record BadPojo(String message, int code) {\n}\n</code></pre>\n<p>However, it seems there is nothing common between the two objects.  It is hard to find a common object, a common parent between the two.</p>\n<p>And for the REST call, I am doing this.</p>\n<pre><code>    public String question() {\n        var result = restClient.get()\n                .uri(&quot;https://the-api.com&quot;)\n                .retrieve()\n                .body(GoodPojo.class);\n\n        return result.toString();\n    }\n</code></pre>\n<p>This works for the good object, but the bad object cannot be converted like this.</p>\n<p>Is there a way in Spring to do something like:</p>\n<pre><code>    public String question() {\n        var result = restClient.get()\n                .uri(&quot;https://the-api.com&quot;)\n                .retrieve()\n                .body(GoodPojo.class | BadPojo.class); //convert into the first one, and if you cannot, convert into the second one\n\n        return result.toString();\n    }\n</code></pre>\n<p>Without having to try to convert this into a good object, and catch the exception, if it fails, to convert to the other object manually?</p>\n<p>Basically, how to convert the HTTP response into different types possible?</p>\n",
    "tags" : [ "java", "spring-boot", "jackson" ],
    "owner" : {
      "account_id" : 14482834,
      "reputation" : 5478,
      "user_id" : 10461625,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/fgo5D.jpg?s=256",
      "display_name" : "PatPanda",
      "link" : "https://stackoverflow.com/users/10461625/patpanda"
    },
    "is_answered" : false,
    "view_count" : 191,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1758339855,
    "creation_date" : 1756395957,
    "link" : "https://stackoverflow.com/questions/79749328/spring-restclient-to-deserialize-retrieve-between-two-completely-different-typ",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79770080,
    "question_id" : 79749328,
    "body" : "<p>You don't have to return a <code>String</code> and throw away type safety. You can add a custom Jackson JSON deserializer that inspects the JSON tree, and returns a POJO accordingly. Let's say the <code>RestRemplate</code> will expect an <code>Either</code>, where <code>Either</code> contains a <code>GoodPojo</code> or a <code>BadPojo</code>. <code>Either</code> here is a crude <a href=\"https://en.wikipedia.org/wiki/Tagged_union\" rel=\"nofollow noreferrer\">Sum/Union type</a>, which is not natively supported in Java (but exists in Python, Scala, TypeScript etc.).</p>\n<pre><code>@JsonDeserialize(using = EitherDeserializer.class)\npublic class Either {\n    private GoodPojo good;\n    private BadPojo bad;\n    ...\n}\n\npublic class EitherDeserializer extends JsonDeserializer&lt;Either&gt; {\n    @Override\n    public Either deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n        Either either = new Either();\n        ObjectCodec codec = jp.getCodec();\n        JsonNode node = codec.readTree(jp);\n        if (node.has(&quot;device&quot;)) {\n            either.setGoodPojo(codec.treeToValue(node, GoodPojo.class));    \n        } else {\n            // BadPojo\n        }\n        return either;\n    }\n}\n</code></pre>\n<p>Alternatively, you can make <code>Either</code> a <a href=\"https://www.baeldung.com/java-marker-interfaces\" rel=\"nofollow noreferrer\">marker interface</a>, and have both POJOs implement it. I'll leave the implementation choice to you.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 446597,
      "reputation" : 25249,
      "user_id" : 839733,
      "user_type" : "registered",
      "accept_rate" : 69,
      "profile_image" : "https://i.sstatic.net/2s6lO.jpg?s=256",
      "display_name" : "Abhijit Sarkar",
      "link" : "https://stackoverflow.com/users/839733/abhijit-sarkar"
    },
    "creation_date" : 1758338826,
    "last_activity_date" : 1758339855,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140704159,
    "post_id" : 79749328,
    "body" : "I think this question might help you with your problem <a href=\"https://stackoverflow.com/questions/78684321/jackson-deserialize-generic-class-with-field-t-as-pojo-or-string-array/78687686#78687686\" title=\"jackson deserialize generic class with field t as pojo or string array\">stackoverflow.com/questions/78684321/&hellip;</a>",
    "score" : 0,
    "owner" : {
      "account_id" : 5569841,
      "reputation" : 8674,
      "user_id" : 4415625,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/0ea1713807527aa1cf52e40579e35ec4?s=256&d=identicon&r=PG",
      "display_name" : "dani-vta",
      "link" : "https://stackoverflow.com/users/4415625/dani-vta"
    },
    "creation_date" : 1756585198,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140704103,
    "post_id" : 79749328,
    "body" : "Lazy mode is just putting all fields in the same class or record. Then you can add a method isSuccess() for convenience.",
    "score" : 1,
    "owner" : {
      "account_id" : 6136413,
      "reputation" : 9587,
      "user_id" : 4785110,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/71b70abe72497023835a6dd8961b7c89?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "maraca",
      "link" : "https://stackoverflow.com/users/4785110/maraca"
    },
    "creation_date" : 1756582378,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140699223,
    "post_id" : 79749328,
    "body" : "You need some common parent, either abstract class or interface. Then configure jackson to convert based on the present properties (not sure, if it&#39;s possible for this case exactly, should be). Or convert manually with custom deserializer, based on present properties again. Depending on what exactly you do with the data, you can add methods to the interface and not care for the exact type. This question should help - <a href=\"https://stackoverflow.com/questions/19379863/how-to-deserialize-interface-fields-using-jacksons-objectmapper\">How to deserialize interface fields using Jackson&#39;s objectMapper?</a>",
    "score" : 3,
    "owner" : {
      "account_id" : 23783500,
      "reputation" : 7109,
      "user_id" : 17795888,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/Xay1V.jpg?s=256",
      "display_name" : "Chaosfire",
      "link" : "https://stackoverflow.com/users/17795888/chaosfire"
    },
    "creation_date" : 1756397626,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}