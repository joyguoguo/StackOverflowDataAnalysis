{
  "question" : {
    "question_id" : 79842788,
    "title" : "stuck at error code 21 using Dahua Java NetSDK",
    "body" : "<p>So I'm trying to read the thermal data from the Dahua IP Cam model TPC-BF5401. I couldn't find any comprehensive documents so I just read the manual tried to follow the examples bundled with the SDK at <a href=\"https://depp.dahuasecurity.com/integration/guide/download/SDK\" rel=\"nofollow noreferrer\">https://depp.dahuasecurity.com/integration/guide/download/SDK</a> (I'm using the x64 Java version on Linux). I managed to read the point-wise temperature using this script</p>\n<pre><code>package com.netsdk.demo.frame;\n\nimport java.io.File;\nimport java.util.Scanner;\n\nimport com.netsdk.lib.NetSDKLib;\nimport com.netsdk.lib.NetSDKLib.*;\nimport com.netsdk.lib.ToolKits;\nimport com.sun.jna.Pointer;\nimport com.sun.jna.ptr.IntByReference;\n\n/**\n * Console demo:\n *  - Init SDK\n *  - Login to camera\n *  - Query temperature at a given (x,y) pixel coordinate on a channel\n *  - Print the result\n */\npublic class QueryTempEx {\n\n    public static final NetSDKLib netSdk = NetSDKLib.NETSDK_INSTANCE;\n\n    private LLong loginHandle = new LLong(0);\n\n    private NET_DEVICEINFO_Ex deviceInfo = new NET_DEVICEINFO_Ex();\n\n    /**\n     * SDK init + log settings (similar to RealplayEx.InitTest)\n     */\n    public void initSdk() {\n        netSdk.CLIENT_Init(DisConnectCallBack.getInstance(), null);\n        netSdk.CLIENT_SetAutoReconnect(HaveReConnectCallBack.getInstance(), null);\n\n        NetSDKLib.LOG_SET_PRINT_INFO setLog = new NetSDKLib.LOG_SET_PRINT_INFO();\n        String logPath = new File(&quot;.&quot;).getAbsoluteFile().getParent()\n                + File.separator + &quot;sdk_log&quot; + File.separator + &quot;sdk.log&quot;;\n        setLog.bSetFilePath = 1;\n        System.arraycopy(logPath.getBytes(), 0, setLog.szLogFilePath, 0, logPath.getBytes().length);\n        setLog.bSetPrintStrategy = 1;\n        setLog.nPrintStrategy = 0;\n\n        if (!netSdk.CLIENT_LogOpen(setLog)) {\n            System.err.println(&quot;Open SDK Log Failed!!!&quot;);\n        }\n    }\n\n    /**\n     * Login to device (similar style to RealplayEx.Login)\n     */\n    public void login(String ip, int port, String user, String password) {\n\n        int nSpecCap = NetSDKLib.EM_LOGIN_SPAC_CAP_TYPE.EM_LOGIN_SPEC_CAP_TCP; // TCP login\n        IntByReference nError = new IntByReference(0);\n\n        loginHandle = netSdk.CLIENT_LoginEx2(\n                ip,\n                port,\n                user,\n                password,\n                nSpecCap,\n                null,\n                deviceInfo,\n                nError);\n\n        if (loginHandle.longValue() != 0) {\n            System.out.printf(&quot;Login Device[%s] Success!\\n&quot;, ip);\n        } else {\n            System.err.printf(&quot;Login Device[%s] Fail. Error[0x%x]\\n&quot;,\n                    ip, netSdk.CLIENT_GetLastError());\n            logoutAndCleanup();\n        }\n    }\n\n    /**\n     * Query temperature at a single (x,y) pixel on a channel..\n     */\n    public NET_RADIOMETRYINFO queryPointTemper(int channel, short x, short y) {\n        int nQueryType = NetSDKLib.NET_QUERY_DEV_RADIOMETRY_POINT_TEMPER;\n\n        NET_IN_RADIOMETRY_GETPOINTTEMPER stIn = new NET_IN_RADIOMETRY_GETPOINTTEMPER();\n        stIn.nChannel = channel;\n        stIn.stCoordinate.nx = x;\n        stIn.stCoordinate.ny = y;\n\n        NET_OUT_RADIOMETRY_GETPOINTTEMPER stOut = new NET_OUT_RADIOMETRY_GETPOINTTEMPER();\n\n        stIn.write();\n        stOut.write();\n\n        boolean bRet = netSdk.CLIENT_QueryDevInfo(\n                loginHandle,\n                nQueryType,\n                stIn.getPointer(),\n                stOut.getPointer(),\n                null,\n                3000);\n\n        if (!bRet) {\n            System.err.printf(&quot;QueryPointTemper Failed! %s\\n&quot;, ToolKits.getErrorCodePrint());\n            return null;\n        }\n\n        stOut.read();\n        return stOut.stPointTempInfo;   // This struct holds the temperature info\n    }\n\n    /**\n     * Logout + cleanup (similar to RealplayEx.LoginOut but without System.exit)\n     */\n    public void logoutAndCleanup() {\n        System.out.println(&quot;End Test&quot;);\n\n        if (loginHandle.longValue() != 0) {\n            netSdk.CLIENT_Logout(loginHandle);\n            loginHandle.setValue(0);\n        }\n\n        System.out.println(&quot;See You...&quot;);\n        netSdk.CLIENT_Cleanup();\n    }\n\n    /**\n     * Disconnect callback (copied from RealplayEx)\n     */\n    private static class DisConnectCallBack implements NetSDKLib.fDisConnect {\n\n        private DisConnectCallBack() {}\n\n        private static class CallBackHolder {\n            private static final DisConnectCallBack instance = new DisConnectCallBack();\n        }\n\n        public static DisConnectCallBack getInstance() {\n            return CallBackHolder.instance;\n        }\n\n        @Override\n        public void invoke(NetSDKLib.LLong lLoginID, String pchDVRIP, int nDVRPort, Pointer dwUser) {\n            System.out.printf(&quot;Device[%s] Port[%d] DisConnect!\\n&quot;, pchDVRIP, nDVRPort);\n        }\n    }\n\n    /**\n     * Reconnect callback (copied from RealplayEx)\n     */\n    private static class HaveReConnectCallBack implements NetSDKLib.fHaveReConnect {\n\n        private HaveReConnectCallBack() {}\n\n        private static class CallBackHolder {\n            private static final HaveReConnectCallBack instance = new HaveReConnectCallBack();\n        }\n\n        public static HaveReConnectCallBack getInstance() {\n            return CallBackHolder.instance;\n        }\n\n        @Override\n        public void invoke(NetSDKLib.LLong m_hLoginHandle, String pchDVRIP, int nDVRPort, Pointer dwUser) {\n            System.out.printf(&quot;ReConnect Device[%s] Port[%d]\\n&quot;, pchDVRIP, nDVRPort);\n        }\n    }\n\n    /**\n     * Main – console app:\n     */\n    public static void main(String[] args) {\n        QueryTempEx app = new QueryTempEx();\n        Scanner scanner = new Scanner(System.in);\n\n        // --- Default login config (you can edit these) ---\n        String ip = &quot;0.0.0.0&quot;;\n        int port = 37777;\n        String username = &quot;admin&quot;;\n        String password = &quot;password&quot;;\n\n        String defaultConfig = String.format(\n                &quot;ip:%s, port:%d, username:%s, password:%s, 需要修改吗?(y/n)&quot;,\n                ip, port, username, password);\n        System.out.println(defaultConfig);\n\n        String answer = &quot;&quot;;\n        do {\n            answer = scanner.nextLine();\n            if (&quot;y&quot;.equalsIgnoreCase(answer) || &quot;yes&quot;.equalsIgnoreCase(answer)) {\n                System.out.println(&quot;please input ip:&quot;);\n                ip = scanner.nextLine().trim();\n\n                System.out.println(&quot;please input port:&quot;);\n                port = Integer.parseInt(scanner.nextLine().trim());\n\n                System.out.println(&quot;please input username:&quot;);\n                username = scanner.nextLine().trim();\n\n                System.out.println(&quot;please input password:&quot;);\n                password = scanner.nextLine().trim();\n                break;\n            } else if (&quot;n&quot;.equalsIgnoreCase(answer) || &quot;no&quot;.equalsIgnoreCase(answer)) {\n                break;\n            }\n            System.out.println(&quot;please input the right word. y/yes/n/no, try again.&quot;);\n        } while (!(answer.equalsIgnoreCase(&quot;y&quot;)\n                || answer.equalsIgnoreCase(&quot;yes&quot;)\n                || answer.equalsIgnoreCase(&quot;no&quot;)\n                || answer.equalsIgnoreCase(&quot;n&quot;)));\n\n        // --- Init + Login ---\n        app.initSdk();\n        app.login(ip, port, username, password);\n\n        // --- Ask for channel + pixel coordinates ---\n        try {\n            System.out.println(&quot;please input channel (default 0):&quot;);\n            String chStr = scanner.nextLine().trim();\n            int channel = chStr.isEmpty() ? 0 : Integer.parseInt(chStr);\n\n            System.out.println(&quot;please input x coordinate (pixel, short):&quot;);\n            short x = Short.parseShort(scanner.nextLine().trim());\n\n            System.out.println(&quot;please input y coordinate (pixel, short):&quot;);\n            short y = Short.parseShort(scanner.nextLine().trim());\n\n            // --- Query temperature ---\n            NET_RADIOMETRYINFO info = app.queryPointTemper(channel, x, y);\n\n            if (info == null) {\n                System.err.println(&quot;Failed to get temperature info.&quot;);\n            } else {\n                System.out.println(&quot;Got radiometry info for point (&quot; + x + &quot;, &quot; + y + &quot;) on channel &quot; + channel);\n\n                // Basic dump (at least this always compiles)\n                System.out.println(&quot;Radiometry info struct: &quot; + info.toString());\n\n            }\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            app.logoutAndCleanup();\n            scanner.close();\n        }\n    }\n}\n\n</code></pre>\n<p>(this script is quite similar to the RealplayEx example that comes along with the SDK if you're familiar. Just filling a point info struct with x and y pixel values, and it returns temp data)</p>\n<p>Now the problem is I want to read region-wise thermal data instead of point-wise data. I add the following function to the script above:</p>\n<pre><code>    public NET_RADIOMETRYINFO queryTemper(int channel, int presetID, int ruleID, int nMeterType) {\n        int nQueryType = NetSDKLib.NET_QUERY_DEV_RADIOMETRY_TEMPER;\n\n        NET_IN_RADIOMETRY_GETTEMPER stIn = new NET_IN_RADIOMETRY_GETTEMPER();\n        stIn.stCondition.nChannel = channel;\n        stIn.stCondition.nMeterType = nMeterType;\n        stIn.stCondition.nPresetId = presetID;\n        stIn.stCondition.nRuleId = ruleID;\n\n\n        NET_OUT_RADIOMETRY_GETTEMPER stOut = new NET_OUT_RADIOMETRY_GETTEMPER();\n\n        stIn.write();\n        stOut.write();\n\n        boolean bRet = netSdk.CLIENT_QueryDevInfo(\n                loginHandle,\n                nQueryType,\n                stIn.getPointer(),\n                stOut.getPointer(),\n                null,\n                3000);\n\n        if (!bRet) {\n            System.err.printf(&quot;QueryTemper Failed! %s\\n&quot;, ToolKits.getErrorCodePrint());\n            return null;\n        }\n\n        stOut.read();\n        return stOut.stTempInfo;   \n    }\n</code></pre>\n<p>and invoke it with</p>\n<pre><code> NET_RADIOMETRYINFO info = app.queryTemper(channel, presetID, ruleID, meterType);\n</code></pre>\n<p>every combination of (channel, presetID, ruleID, meterType) I have tried all return this:</p>\n<pre><code>Login Device[192.168.127.108] Success!\nplease input channel (default 0):\n0\nplease input presetID (default 0):\n1\nplease input ruleID (default 0):\n1\nplease input meterType (default 0):\n1\nQueryTemper Failed! \n{error code: (0x80000000|21).参考  NetSDKLib.java } - {error info:对返回数据的校验出错}\n</code></pre>\n<p>According to online sources, that line of Chinese, along with the error code 21, might indicate that the problem either:</p>\n<ul>\n<li>the camera is not configured correctly</li>\n<li>the response struct is incorrect</li>\n</ul>\n<p>From here I'm stuck. The error comes from inside the dynamic linked library, so I don't know what to do know. Plus I have yet to pinpoint exactly what ruleID and presetID to config to and from the camera, region/rectangle/polygon ruleID and PTZ presetID I assume? And channel seems to always be 0 and meter of type 1, correct me if I'm wrong? Anyone had the same problem, care to share anything?</p>\n",
    "tags" : [ "java", "ip-camera" ],
    "owner" : {
      "account_id" : 20380339,
      "reputation" : 21,
      "user_id" : 14982357,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a-/AOh14Gi3fIvZ65NrCqi_Gazl79KTckX6zDR0tV_zUj94=k-s256",
      "display_name" : "suws",
      "link" : "https://stackoverflow.com/users/14982357/suws"
    },
    "is_answered" : false,
    "view_count" : 60,
    "answer_count" : 0,
    "score" : 1,
    "last_activity_date" : 1765360919,
    "creation_date" : 1765360585,
    "link" : "https://stackoverflow.com/questions/79842788/stuck-at-error-code-21-using-dahua-java-netsdk",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ ],
  "answer_comments" : { }
}