{
  "question" : {
    "question_id" : 79555338,
    "title" : "Java ResultSet getByte throwing outside of valid range for type java.lang.Byte error",
    "body" : "<p>I am running a minor SQL extract from a MySQL DB table. The field in question is set up as char(2) and usually has values from 0 to 12, never &gt; 15. When I run my SQL query, the ResultSet getByte(&quot;column_name&quot;) method seems to be fine for values under 10 but dislikes anything above. Last time I checked an unsigned byte could be as big as 255. The error thrown is:</p>\n<blockquote>\n<p>Unable to execute SQL SELECT at <em>DAO Name and Method</em>: Value '11' is outside of valid range for type java.lang.Byte</p>\n</blockquote>\n<pre><code>byte subCat = xResult.getByte(&quot;column_name&quot;);\n</code></pre>\n<p>Easy to fix as below, which works fine:</p>\n<pre><code>byte subCat = Byte.valueOf(xResult.getString(&quot;column_name&quot;));\n</code></pre>\n<p>Interesting is if I run similar for a column set up as char(3)  with a .getShort() I have no issues. Although max short value is 833, so perhaps I have not hit a certain limitation here yet.</p>\n<p><strong>Note:</strong> I cannot adjust the DB table definition, the columns are based on a real life 25 year old DB2 structure I basing my proof of concept code on and were set as char for business rule reasons.</p>\n<p>Not a major problem, I am just curious as to why this happens.</p>\n<p>PS: Using Azul Zulu Java 17</p>\n",
    "tags" : [ "java", "resultset" ],
    "owner" : {
      "account_id" : 13890381,
      "reputation" : 69,
      "user_id" : 10028542,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/W2lpn.jpg?s=256",
      "display_name" : "GuzziTony",
      "link" : "https://stackoverflow.com/users/10028542/guzzitony"
    },
    "is_answered" : false,
    "view_count" : 182,
    "answer_count" : 0,
    "score" : 2,
    "last_activity_date" : 1743779654,
    "creation_date" : 1743770560,
    "link" : "https://stackoverflow.com/questions/79555338/java-resultset-getbyte-throwing-outside-of-valid-range-for-type-java-lang-byte-e",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140304770,
    "post_id" : 79555338,
    "body" : "@MarkRotteveel Sorry, I got confused with all my testing. In SQLite it accepts two or three digit strings and converts them correctly to numeric values. In MySQL it treats the string as an integral value and rejects it if it is not between -128 to 127. So the string &quot;~&quot; is returned as the value 126, but the string &quot;11&quot; is rejects as out of range.",
    "score" : 1,
    "owner" : {
      "account_id" : 29555382,
      "reputation" : 1005,
      "user_id" : 22651151,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/HH5yW.jpg?s=256",
      "display_name" : "OldBoy",
      "link" : "https://stackoverflow.com/users/22651151/oldboy"
    },
    "creation_date" : 1743947420,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140304724,
    "post_id" : 79555338,
    "body" : "@OldBoy I&#39;m not sure what you mean with &quot;even if greater than 63&quot;, in Java a byte is [-128, 127], as is - usually - a TINYINT.",
    "score" : 0,
    "owner" : {
      "account_id" : 213468,
      "reputation" : 110280,
      "user_id" : 466862,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d873f397779db38cd510d9ee5416fd43?s=256&d=identicon&r=PG",
      "display_name" : "Mark Rotteveel",
      "link" : "https://stackoverflow.com/users/466862/mark-rotteveel"
    },
    "creation_date" : 1743945919,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140304658,
    "post_id" : 79555338,
    "body" : "@MarkRotteveel You are correct about the conversion in that it treats the string as a numeric value without doing any conversion: in MySQL. However, when using the SQLite driver, it appears to convert the number and returns its value, even if greater than 63.",
    "score" : 0,
    "owner" : {
      "account_id" : 29555382,
      "reputation" : 1005,
      "user_id" : 22651151,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/HH5yW.jpg?s=256",
      "display_name" : "OldBoy",
      "link" : "https://stackoverflow.com/users/22651151/oldboy"
    },
    "creation_date" : 1743943413,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140301856,
    "post_id" : 79555338,
    "body" : "@OldBoy No, you need to read the JDBC specification, specifically TABLE B-1 JDBC Types Mapped to Java Types and TABLE B-2 Standard Mapping from Java Types to JDBC Types, which shows you that the corresponding SQL type for a Java <code>byte</code> is a SQL <code>TINYINT</code>. You can apply it on other datatypes (including CHAR/VARCHAR), but then the conversion is still the equivalent as if it is first converted from/to <code>TINYINT</code>, similar as for short/int/long/float/double.",
    "score" : 0,
    "owner" : {
      "account_id" : 213468,
      "reputation" : 110280,
      "user_id" : 466862,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d873f397779db38cd510d9ee5416fd43?s=256&d=identicon&r=PG",
      "display_name" : "Mark Rotteveel",
      "link" : "https://stackoverflow.com/users/466862/mark-rotteveel"
    },
    "creation_date" : 1743837072,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140300318,
    "post_id" : 79555338,
    "body" : "<i>Interesting is if I run similar for a column set up as char(3) with a .getShort() I have no issues. Although max short value is 833, so perhaps I have not hit a certain limitation here yet.</i> In theory, the maximum value of <code>char(3)</code> would be 0xFFFFFF or 16777215, so that might potentially cause overflow problems for <code>short</code>, the maximum value of which is 0x7FFF or 32767, not 833",
    "score" : 0,
    "owner" : {
      "account_id" : 22124137,
      "reputation" : 4244,
      "user_id" : 16376827,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/1ImPw.png?s=256",
      "display_name" : "g00se",
      "link" : "https://stackoverflow.com/users/16376827/g00se"
    },
    "creation_date" : 1743785384,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140300296,
    "post_id" : 79555338,
    "body" : "@MarkRotteveel The documentationstates <i>&quot;Retrieves the value of the designated column in the current row of this ResultSet object as a byte in the Java programming language.&quot;</i>. But that does not really explain what it does to convert a string. Time for some testing I think.",
    "score" : 0,
    "owner" : {
      "account_id" : 29555382,
      "reputation" : 1005,
      "user_id" : 22651151,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/HH5yW.jpg?s=256",
      "display_name" : "OldBoy",
      "link" : "https://stackoverflow.com/users/22651151/oldboy"
    },
    "creation_date" : 1743784749,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140300029,
    "post_id" : 79555338,
    "body" : "@OldBoy Except <code>ResultSet.getByte(...)</code> on a CHAR column should do the equivalent of (SQL) <code>CAST(thecolumn as INT)</code> (or <code>TINYINT</code>) or (Java) <code>Byte.parseByte(String)</code>, not interpret the raw bytes of the string value as a byte. That is, the string value <code>&#39;11&#39;</code> should result in the byte value <code>11</code>.",
    "score" : 1,
    "owner" : {
      "account_id" : 213468,
      "reputation" : 110280,
      "user_id" : 466862,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d873f397779db38cd510d9ee5416fd43?s=256&d=identicon&r=PG",
      "display_name" : "Mark Rotteveel",
      "link" : "https://stackoverflow.com/users/466862/mark-rotteveel"
    },
    "creation_date" : 1743780794,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140299353,
    "post_id" : 79555338,
    "body" : "<i>Last time I checked an unsigned byte could be as big as 255.</i> That might be the case, but Java <i>doesn&#39;t have</i> an unsigned byte type. You should perhaps try <code>byte subCat = (byte) (0xFF &amp; xResult.getByte(&quot;column_name&quot;));</code> Though <code>char(2)</code> is more naturally modelled as <code>short</code>",
    "score" : 0,
    "owner" : {
      "account_id" : 22124137,
      "reputation" : 4244,
      "user_id" : 16376827,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/1ImPw.png?s=256",
      "display_name" : "g00se",
      "link" : "https://stackoverflow.com/users/16376827/g00se"
    },
    "creation_date" : 1743771347,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140299326,
    "post_id" : 79555338,
    "body" : "The character string &quot;11&quot; is <code>0x3131</code> hex or <code>12,593</code> decimal, which is well outside the range for a byte.",
    "score" : 1,
    "owner" : {
      "account_id" : 29555382,
      "reputation" : 1005,
      "user_id" : 22651151,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/HH5yW.jpg?s=256",
      "display_name" : "OldBoy",
      "link" : "https://stackoverflow.com/users/22651151/oldboy"
    },
    "creation_date" : 1743770943,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}