{
  "question" : {
    "question_id" : 79646790,
    "title" : "Eager fetching doesn&#39;t work Spring Data Specification",
    "body" : "<p>This:</p>\n<pre class=\"lang-java prettyprint-override\"><code>    @Override\n    public List&lt;UserResponseDto&gt; find(FindUserRequestDto userRequestDto, Pageable pageable) {\n        Specification&lt;User&gt; specification = buildSpecification(userRequestDto);\n        List&lt;User&gt; users = repository.findAll(specification, pageable);\n        List&lt;UserResponseDto&gt; userDtos = users.stream()\n                .map(userMapper::toResponseDto)\n                .toList();\n        return userDtos;\n    }\n\n    private static Specification&lt;User&gt; buildSpecification(FindUserRequestDto userRequestDto) {\n        return (root, query, criteriaBuilder) -&gt; {\n            var nameBeginsWith = criteriaBuilder.like(root.get(&quot;name&quot;), userRequestDto.getName() + &quot;%&quot;);\n            var bornAfter = criteriaBuilder.greaterThan(root.get(&quot;dateOfBirth&quot;), userRequestDto.getDateOfBirth());\n            var hasEmail = criteriaBuilder.equal(root.join(&quot;emailData&quot;, JoinType.LEFT).get(&quot;email&quot;), userRequestDto.getEmail());\n            var hasPhone = criteriaBuilder.equal(root.join(&quot;phoneData&quot;, JoinType.LEFT).get(&quot;phone&quot;), userRequestDto.getPhone());\n\n            List&lt;jakarta.persistence.criteria.Predicate&gt; predicates = new ArrayList&lt;&gt;();\n            if (userRequestDto.getName() != null) predicates.add(nameBeginsWith);\n            if (userRequestDto.getDateOfBirth() != null) predicates.add(bornAfter);\n            if (userRequestDto.getEmail() != null) predicates.add(hasEmail);\n            if (userRequestDto.getPhone() != null) predicates.add(hasPhone);\n            return criteriaBuilder.and(predicates.toArray(new jakarta.persistence.criteria.Predicate[0]));\n        };\n    }\n</code></pre>\n<p>generates these three queries:</p>\n<pre><code>Hibernate: \n    select\n        u1_0.id,\n        u1_0.date_of_birth,\n        u1_0.name \n    from\n        &quot;user&quot; u1_0 \n    left join\n        email_data ed1_0 \n            on u1_0.id=ed1_0.user_id \n    left join\n        phone_data pd1_0 \n            on u1_0.id=pd1_0.user_id \n    where\n        u1_0.name like ? escape '' \n    offset\n        ? rows \n    fetch\n        first ? rows only\n2025-05-31T18:54:41.186+03:00 TRACE 34688 --- [nio-8080-exec-1] org.hibernate.orm.jdbc.bind              : binding parameter (1:VARCHAR) &lt;- [Steve%]\n2025-05-31T18:54:41.186+03:00 TRACE 34688 --- [nio-8080-exec-1] org.hibernate.orm.jdbc.bind              : binding parameter (2:INTEGER) &lt;- [0]\n2025-05-31T18:54:41.186+03:00 TRACE 34688 --- [nio-8080-exec-1] org.hibernate.orm.jdbc.bind              : binding parameter (3:INTEGER) &lt;- [20]\nHibernate: \n    select\n        pd1_0.user_id,\n        pd1_0.phone \n    from\n        phone_data pd1_0 \n    where\n        pd1_0.user_id=?\n2025-05-31T18:54:41.273+03:00 TRACE 34688 --- [nio-8080-exec-1] org.hibernate.orm.jdbc.bind              : binding parameter (1:BIGINT) &lt;- [16]\nHibernate: \n    select\n        ed1_0.user_id,\n        ed1_0.email \n    from\n        email_data ed1_0 \n    where\n        ed1_0.user_id=?\n2025-05-31T18:54:41.285+03:00 TRACE 34688 --- [nio-8080-exec-1] org.hibernate.orm.jdbc.bind              : binding parameter (1:BIGINT) &lt;- [16]\n</code></pre>\n<p>It's not what I expect. <code>PhoneData</code> and <code>EmailData</code>should be eagerly fetched. Here are the entities:</p>\n<pre class=\"lang-java prettyprint-override\"><code>import jakarta.persistence.CascadeType;\nimport jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.FetchType;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.GenerationType;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.OneToMany;\nimport jakarta.persistence.Table;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.hibernate.annotations.Cache;\nimport org.hibernate.annotations.CacheConcurrencyStrategy;\n\nimport java.time.LocalDate;\nimport java.util.List;\n\n@Entity\n@Getter\n@Setter\n@Table(name = &quot;\\&quot;user\\&quot;&quot;)\n@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    private String name;\n    @Column(name = &quot;date_of_birth&quot;)\n    private LocalDate dateOfBirth;\n    @OneToMany(mappedBy = &quot;user&quot;, fetch = FetchType.EAGER,\n            cascade = CascadeType.ALL, orphanRemoval = true)\n    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)\n    private List&lt;EmailData&gt; emailData;\n    @OneToMany(mappedBy = &quot;user&quot;, fetch = FetchType.EAGER,\n            cascade = CascadeType.ALL, orphanRemoval = true)\n    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)\n    private List&lt;PhoneData&gt; phoneData;\n\n    public void setEmailData(List&lt;EmailData&gt; emailData) {\n        this.emailData.clear();\n        this.emailData.addAll(emailData);\n    }\n\n    public void setPhoneData(List&lt;PhoneData&gt; phoneData) {\n        this.phoneData.clear();\n        this.phoneData.addAll(phoneData);\n    }\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.JoinColumn;\nimport jakarta.persistence.ManyToOne;\nimport jakarta.persistence.Table;\nimport jakarta.validation.constraints.Pattern;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.hibernate.annotations.Cache;\nimport org.hibernate.annotations.CacheConcurrencyStrategy;\n\n@Entity\n@Getter\n@Setter\n@Table(name = &quot;phone_data&quot;)\n@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)\npublic class PhoneData {\n\n    @ManyToOne\n    @JoinColumn(name = &quot;user_id&quot;)\n    private User user;\n    @Id\n    @Pattern(regexp = &quot;\\\\d+&quot;, message = &quot;Phone number must contain digits only&quot;)\n    private String phone;\n\n    public static PhoneData of(String phone, User user) {\n        PhoneData phoneData = new PhoneData();\n        phoneData.setPhone(phone);\n        phoneData.setUser(user);\n        return phoneData;\n    }\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.JoinColumn;\nimport jakarta.persistence.ManyToOne;\nimport jakarta.persistence.Table;\nimport jakarta.validation.constraints.Email;\nimport lombok.Getter;\nimport lombok.Setter;\nimport org.hibernate.annotations.Cache;\nimport org.hibernate.annotations.CacheConcurrencyStrategy;\n\n@Entity\n@Getter\n@Setter\n@Table(name = &quot;email_data&quot;)\n@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)\npublic class EmailData {\n\n    @ManyToOne\n    @JoinColumn(name = &quot;user_id&quot;)\n    private User user;\n    @Id\n    @Email(message = &quot;Email must be valid&quot;)\n    private String email;\n\n    public static EmailData of(String email, User user) {\n        EmailData emailData = new EmailData();\n        emailData.setEmail(email);\n        emailData.setUser(user);\n        return emailData;\n    }\n}\n</code></pre>\n<p>Even though you see caching annotations, it's not a caching question (unless caching somehow messes with joins). If I execute it once more, the latter two queries are not invoked. I guess it means caching works.</p>\n<p>As I understand, Hibernate doesn't join more than one eager <code>@OneToMany</code> relation to avoid the Cartesian product issue. However, it could join at least something. For example, instead of:</p>\n<pre><code>    select\n        u1_0.id,\n        u1_0.date_of_birth,\n        u1_0.name \n</code></pre>\n<p>it could execute this select:</p>\n<pre><code>    select\n        u1_0.id,\n        u1_0.date_of_birth,\n        u1_0.name,\n        pd1_0.user_id,\n        pd1_0.phone \n</code></pre>\n<p>It would reduce the number of queries by one.</p>\n<p>If I simply <code>GET</code> a user, including that same user, by id  (<code>repository.findById(id)</code>), eager fetching works as expected: one of the two <code>@OneToMany</code> entities is joined with <code>User</code>, the other is fetched separately:</p>\n<pre><code>Hibernate: \n    select\n        u1_0.id,\n        u1_0.date_of_birth,\n        u1_0.name,\n        ed1_0.user_id,\n        ed1_0.email \n    from\n        &quot;user&quot; u1_0 \n    left join\n        email_data ed1_0 \n            on u1_0.id=ed1_0.user_id \n    where\n        u1_0.id=?\n2025-05-31T19:34:03.497+03:00 TRACE 23780 --- [nio-8080-exec-5] org.hibernate.orm.jdbc.bind              : binding parameter (1:BIGINT) &lt;- [16]\nHibernate: \n    select\n        pd1_0.user_id,\n        pd1_0.phone \n    from\n        phone_data pd1_0 \n    where\n        pd1_0.user_id=?\n2025-05-31T19:34:03.590+03:00 TRACE 23780 --- [nio-8080-exec-5] org.hibernate.orm.jdbc.bind              : binding parameter (1:BIGINT) &lt;- [16]\n</code></pre>\n<p>It strongly implies Criteria is somehow involved.</p>\n<p>Why does it happen and do I remove at least one query?</p>\n",
    "tags" : [ "java", "postgresql", "hibernate", "spring-data-jpa", "criteria-api" ],
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2683,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "is_answered" : false,
    "view_count" : 57,
    "answer_count" : 1,
    "score" : 1,
    "last_activity_date" : 1748710594,
    "creation_date" : 1748708760,
    "link" : "https://stackoverflow.com/questions/79646790/eager-fetching-doesnt-work-spring-data-specification",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79646816,
    "question_id" : 79646790,
    "body" : "<p>It seems you need to explicitly tell Criteria to fetch:</p>\n<pre><code>root.fetch(&quot;emailData&quot;, JoinType.LEFT);\nvar hasEmail = criteriaBuilder.equal(root.join(&quot;emailData&quot;, JoinType.LEFT).get(&quot;email&quot;), userRequestDto.getEmail());\n</code></pre>\n<p>Apparently, Criteria couldn't care less about <code>fetchType</code></p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2683,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "creation_date" : 1748710594,
    "last_activity_date" : 1748710594,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}