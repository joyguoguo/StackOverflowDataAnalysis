{
  "question" : {
    "question_id" : 79696280,
    "title" : "An simple MCP Client which adds employ using pojo throws json parse error invoking the tool",
    "body" : "<p>I am exploring MCP (Model Context Protocol) using spring ai using the <code>Ollama</code> <code>llama3.2</code> model running in docker container exposed with http://localhost:11434.</p>\n<p>Using STDIO transport, able to perform most of the operation, except one the details as follows.</p>\n<p>The MCP server includes in-memory list for employee, The MCP client uses spring-boot-web-starter to get the input via request body, passing the input using curl command.</p>\n<p>The server service looks like below</p>\n<pre class=\"lang-java prettyprint-override\"><code>\nimport com.demo.mcp.server.data.Employee;\nimport jakarta.annotation.PostConstruct;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.ai.tool.annotation.Tool;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Service\npublic class EmployeeService {\n\n    private static final Logger logger = LoggerFactory.getLogger(EmployeeService.class);\n\n    private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();\n\n    @Tool(name=&quot;t_list_all_employees&quot;, description = &quot;This tool will use the list of employees that is managed in the in memory list within the application&quot;)\n    public List&lt;Employee&gt; getEmployees() {\n        logger.info(&quot;getEmployees() invoked&quot;);\n        return employees;\n    }\n\n    @Tool(name=&quot;t_add_one_employee&quot;, description = &quot;Add an employee to the employee list,&quot;+\n            &quot;before invoking this tool create the employee string with json template in following format&quot; +\n            &quot;{ \\&quot;name\\&quot;: \\&quot;SET-WITH-USER-INPUT\\&quot;, \\&quot;email\\&quot;: \\&quot;SET-WITH-USER-INPUT\\&quot;, \\&quot;phone\\&quot;: \\&quot;SET-WITH-USER-INPUT\\&quot;}\\&quot;&quot; +\n            &quot; with this this method can add the employee to in memory list. For example, if the context include &quot; +\n            &quot;add an employee to the list where the employee name is joe I, email is joe@email.com and phone is 11231&quot; +\n            &quot;The employee name should be provided&quot;)\n    public Employee addEmployee(Employee employee) {\n        logger.info(&quot;Adding employee: {}&quot;, employee);\n        if(employee != null &amp;&amp; employee.name() != null &amp;&amp; !employee.name().isEmpty()) {\n            logger.info(&quot;Employee name is valid: {}&quot;, employee.name());\n        } else {\n            logger.warn(&quot;Invalid employee name provided: {}&quot;, employee);\n            throw new IllegalArgumentException(&quot;Employee name cannot be null or empty&quot;);\n        }\n        employees.add(employee);\n        return employee;\n    }\n\n    @Tool(name=&quot;t_fetch_employee_with_name&quot;, description = &quot;This tool is used to get one employee based on user provided employee name from the in memory list in this app&quot;)\n    public Employee getEmployee(String name) {\n        logger.info(&quot;Getting employee by name: {}&quot;, name);\n        if (name == null || name.isEmpty()) {\n            logger.warn(&quot;Invalid employee name provided: {}&quot;, name);\n            throw new IllegalArgumentException(&quot;Employee name cannot be null or empty&quot;);\n        }\n        return employees.stream()\n                .filter(employee -&gt; employee.name().equalsIgnoreCase(name))\n                .findFirst()\n                .orElse(null);\n    }\n\n    @Tool(name=&quot;t_delete_employee&quot;, description = &quot;This tool will delete the employee matching the user provided name from the in memory list in this app&quot;)\n    public void deleteEmployee(String name) {\n        if (name == null || name.isEmpty()) {\n            logger.warn(&quot;Invalid employee name provided for deletion: {}&quot;, name);\n            throw new IllegalArgumentException(&quot;Employee name cannot be null or empty&quot;);\n        }\n        logger.info(&quot;Deleting employee by name: {}&quot;, name);\n        employees.removeIf(employee -&gt; employee.name().equalsIgnoreCase(name));\n    }\n\n    @PostConstruct\n    public void init() {\n        employees.addAll(List.of(\n                new Employee(&quot;Joy one&quot;,&quot;joy_one@email.com&quot;,&quot;1234567890&quot;),\n                new Employee(&quot;Joy two&quot;,&quot;joe_two@email.com&quot;,&quot;0987654321&quot;),\n                new Employee(&quot;Joy three&quot;,&quot;joy_three@email.com&quot;,&quot;1122334455&quot;),\n                new Employee(&quot;Joy four&quot;,&quot;joy_four@email.com&quot;,&quot;5566778899&quot;),\n                new Employee(&quot;Joy five&quot;,&quot;joy_five@email.com&quot;,&quot;9988776655&quot;)\n        ));\n    }\n\n}\n</code></pre>\n<p>Employee pojo</p>\n<pre class=\"lang-java prettyprint-override\"><code>public record Employee(String name, String email, String phone){}\n</code></pre>\n<p>The client main controller looks like below</p>\n<pre class=\"lang-java prettyprint-override\"><code>import io.modelcontextprotocol.client.McpSyncClient;\nimport org.springframework.ai.chat.client.ChatClient;\nimport org.springframework.ai.chat.prompt.Prompt;\nimport org.springframework.ai.mcp.SyncMcpToolCallbackProvider;\nimport org.springframework.ai.tool.ToolCallback;\nimport org.springframework.ai.tool.ToolCallbackProvider;\nimport org.springframework.ai.tool.definition.ToolDefinition;\nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.List;\n\n@RequestMapping(&quot;/input&quot;)\n@RestController\npublic class InputController {\n\n    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(InputController.class);\n\n    private final ChatClient chatClient;\n    List&lt;McpSyncClient&gt; mcpSyncClients;\n\n    public InputController(ChatClient.Builder chatClientBuilder,\n                           ToolCallbackProvider toolCallbackProvider, \n                           List&lt;McpSyncClient&gt; mcpSyncClients) {\n        this.chatClient = chatClientBuilder.build();\n        this.mcpSyncClients = mcpSyncClients;\n        List&lt;ToolCallback&gt; toolCallbacks = List.of(toolCallbackProvider.getToolCallbacks());\n        if (toolCallbacks.isEmpty()) {\n            System.out.println(&quot;No tools identified.&quot;);\n        } else {\n            for (ToolCallback toolCallback : toolCallbacks) {\n                ToolDefinition toolDefinition = toolCallback.getToolDefinition();\n                System.out.println(&quot;Tool Name: &quot; + toolDefinition.name()+ &quot;\\nDescription: &quot; + toolDefinition.description()+&quot;\\nSchema: &quot; + toolDefinition.inputSchema()+&quot;\\n--------------------&quot;);\n            }\n        }\n    }\n    @PostMapping(&quot;/in&quot;)\n    public String input(@RequestBody String input) {\n        log.info(&quot;Input received: {}&quot;, input);\n        return chatClient.prompt()\n        .user(input)\n        .toolCallbacks(new SyncMcpToolCallbackProvider(mcpSyncClients))\n        .call()\n        .content();\n    }\n}\n</code></pre>\n<ul>\n<li>With the application running could see below response</li>\n</ul>\n<pre class=\"lang-bash prettyprint-override\"><code>$ curl -XPOST http://localhost:8080/input/in -d &quot;can you get all the employees list from the server&quot;\nThe list of all employees on the server is as follows:\n\n1. Joy one - joy_one@email.com - 1234567890\n2. Joy two - joe_two@email.com - 0987654321\n3. Joy three - joy_three@email.com - 1122334455\n4. Joy four - joy_four@email.com - 5566778899\n5. Joy five - joy_five@email.com - 9988776655\n</code></pre>\n<p>When I try to add a new employee, do see the error message. It is evident that the LLM sends the JSON text and that text is not being converted to json.</p>\n<p>I added the Jackson databind to the client code expecting that would some how resolve this issue.</p>\n<pre><code>[client] [pool-2-thread-1] io.modelcontextprotocol.spec.McpSchema   : Received JSON message: {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:&quot;31ade185-6&quot;,&quot;result&quot;:{&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Conversion from JSON to com.demo.mcp.server.data.Employee failed&quot;}],&quot;isError&quot;:true}}\n[client] [pool-2-thread-1] i.m.spec.McpClientSession                : Received Response: JSONRPCResponse[jsonrpc=2.0, id=31ade185-6, result={content=[{type=text, text=Conversion from JSON to com.demo.mcp.server.data.Employee failed}], isError=true}, error=null]\nERROR 1120 --- [client] [nio-8080-exec-2] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: java.lang.IllegalStateException: Error calling tool: [TextContent[audience=null, priority=null, text=Conversion from JSON to com.demo.mcp.server.data.Employee failed]]] with root cause\n\njava.lang.IllegalStateException: Error calling tool: [TextContent[audience=null, priority=null, text=Conversion from JSON to com.demo.mcp.server.data.Employee failed]]\n    at org.springframework.ai.mcp.SyncMcpToolCallback.call(SyncMcpToolCallback.java:118) ~[spring-ai-mcp-1.0.0.jar:1.0.0]\n    at org.springframework.ai.mcp.SyncMcpToolCallback.call(SyncMcpToolCallback.java:126) ~[spring-ai-mcp-1.0.0.jar:1.0.0]\n    at org.springframework.ai.model.tool.DefaultToolCallingManager.lambda$executeToolCall$5(DefaultToolCallingManager.java:224) ~[spring-ai-model-1.0.0.jar:1.0.0]\n    at io.micrometer.observation.Observation.observe(Observation.java:564) ~[micrometer-observation-1.15.1.jar:1.15.1]\n    at org.springframework.ai.model.tool.DefaultToolCallingManager.executeToolCall(DefaultToolCallingManager.java:221) ~[spring-ai-model-1.0.0.jar:1.0.0]\n    at org.springframework.ai.model.tool.DefaultToolCallingManager.executeToolCalls(DefaultToolCallingManager.java:137) ~[spring-ai-model-1.0.0.jar:1.0.0]\n    at org.springframework.ai.ollama.OllamaChatModel.internalCall(OllamaChatModel.java:266) ~[spring-ai-ollama-1.0.0.jar:1.0.0]\n    at org.springframework.ai.ollama.OllamaChatModel.call(OllamaChatModel.java:219) ~[spring-ai-ollama-1.0.0.jar:1.0.0]\n    at org.springframework.ai.chat.client.advisor.ChatModelCallAdvisor.adviseCall(ChatModelCallAdvisor.java:54) ~[spring-ai-client-chat-1.0.0.jar:1.0.0]\n    at org.springframework.ai.chat.client.advisor.DefaultAroundAdvisorChain.lambda$nextCall$1(DefaultAroundAdvisorChain.java:110) ~[spring-ai-client-chat-1.0.0.jar:1.0.0]\n    at io.micrometer.observation.Observation.observe(Observation.java:564) ~[micrometer-observation-1.15.1.jar:1.15.1]\n    at org.springframework.ai.chat.client.advisor.DefaultAroundAdvisorChain.nextCall(DefaultAroundAdvisorChain.java:110) ~[spring-ai-client-chat-1.0.0.jar:1.0.0]\n    at org.springframework.ai.chat.client.DefaultChatClient$DefaultCallResponseSpec.lambda$doGetObservableChatClientResponse$1(DefaultChatClient.java:469) ~[spring-ai-client-chat-1.0.0.jar:1.0.0]\n    at io.micrometer.observation.Observation.observe(Observation.java:564) ~[micrometer-observation-1.15.1.jar:1.15.1]\n    at org.springframework.ai.chat.client.DefaultChatClient$DefaultCallResponseSpec.doGetObservableChatClientResponse(DefaultChatClient.java:467) ~[spring-ai-client-chat-1.0.0.jar:1.0.0]\n    at org.springframework.ai.chat.client.DefaultChatClient$DefaultCallResponseSpec.doGetObservableChatClientResponse(DefaultChatClient.java:446) ~[spring-ai-client-chat-1.0.0.jar:1.0.0]\n    at org.springframework.ai.chat.client.DefaultChatClient$DefaultCallResponseSpec.content(DefaultChatClient.java:441) ~[spring-ai-client-chat-1.0.0.jar:1.0.0]\n    at com.demo.mcp.client.controller.InputController.input(InputController.java:95) ~[classes/:na]\n    ...\n\n</code></pre>\n<p>Question :-</p>\n<ol>\n<li>Is there an option to intercept the response from LLM before invoking the tool service on the server?</li>\n<li>How to configure LLM to convert the text to json matching the Employee record.</li>\n</ol>\n<p>With a new Tool added in the service that uses employee name, email and phone in the argument in this case the user gets added.</p>\n",
    "tags" : [ "java", "ollama", "spring-ai", "model-context-protocol" ],
    "owner" : {
      "account_id" : 3222171,
      "reputation" : 1511,
      "user_id" : 3192775,
      "user_type" : "registered",
      "accept_rate" : 33,
      "profile_image" : "https://i.sstatic.net/8htyd.jpg?s=256",
      "display_name" : "Tim",
      "link" : "https://stackoverflow.com/users/3192775/tim"
    },
    "is_answered" : false,
    "view_count" : 204,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1752598876,
    "creation_date" : 1752096771,
    "link" : "https://stackoverflow.com/questions/79696280/an-simple-mcp-client-which-adds-employ-using-pojo-throws-json-parse-error-invoki",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79702418,
    "question_id" : 79696280,
    "body" : "<p>LLM's normal return as a JSON string instead of a JSON object. Since MCP expects a structured object matching the method's argument type, the conversion fails when a plain JSON string is passed.</p>\n<pre><code>@Tool(name=&quot;t_add_employee_direct&quot;, description = &quot;Add employee using separate name, email and phone fields&quot;)\npublic Employee addEmployeeDirect(String name, String email, String phone) {\n    return new Employee(name, email, phone);\n}\n</code></pre>\n<p>For the second issue you can let Spring handle the conversion by adjusting the tool to accept a <code>Map&lt;String, Object&gt;</code> instead of the <code>Employee</code> record.</p>\n<pre><code>@Tool(name = &quot;t_add_employee_from_map&quot;, description = &quot;Add employee using a map with keys: name, email, phone&quot;)\npublic Employee addEmployeeFromMap(Map&lt;String, Object&gt; employeeMap) {\n    String name = (String) employeeMap.get(&quot;name&quot;);\n    String email = (String) employeeMap.get(&quot;email&quot;);\n    String phone = (String) employeeMap.get(&quot;phone&quot;);\n    return addEmployee(new Employee(name, email, phone));\n}\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 43047570,
      "reputation" : 11,
      "user_id" : 31047903,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/1b87wB3L.jpg?s=256",
      "display_name" : "Vrishant",
      "link" : "https://stackoverflow.com/users/31047903/vrishant"
    },
    "creation_date" : 1752598876,
    "last_activity_date" : 1752598876,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}