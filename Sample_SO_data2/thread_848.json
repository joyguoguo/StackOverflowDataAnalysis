{
  "question" : {
    "question_id" : 79769991,
    "title" : "Problem with WebSocket notification from SpringBoot to frontend",
    "body" : "<p>I have a Spring Boot application that uses <strong>WebSockets</strong> (STOMP over SockJS) for real-time notifications. The application is integrated with <strong>Keycloak</strong> for authentication. The workflow is as follows:</p>\n<ol>\n<li>The JavaScript client connects to the /ws endpoint, providing a JWT token in the Authorization header.</li>\n<li>A ChannelInterceptor on the server validates the token and sets the user's sub (UUID) as the principal for the WebSocket session.</li>\n<li>The client subscribes to the /user/notifications topic.</li>\n<li>When an event occurs, a backend service sends a message to the specific user using SimpMessagingTemplate.convertAndSendToUser(userId, &quot;/notifications&quot;, message). The userId is the user's sub.</li>\n</ol>\n<p>My WebSocketConfig class:</p>\n<pre><code>@Configuration\n@EnableWebSocketMessageBroker\n@Order(Ordered.HIGHEST_PRECEDENCE + 99)\n@RequiredArgsConstructor\npublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer {\n\n    private final JwtDecoder jwtDecoder;\n    private final JwtAuthConverter jwtAuthConverter;\n\n    @Value(&quot;${oxyreimobile.oauth2.keycloak.realm}&quot;)\n    private String realm;\n\n    @Override\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\n        registry.addEndpoint(&quot;/ws&quot;)\n                .setAllowedOriginPatterns(&quot;*&quot;) //TODO da modificare quando si saprà cosa mettere\n                .withSockJS();\n    }\n\n    @Override\n    public void configureMessageBroker(MessageBrokerRegistry registry) {\n        registry.enableSimpleBroker(&quot;/user&quot;);\n        registry.setApplicationDestinationPrefixes(&quot;/app&quot;);\n        registry.setUserDestinationPrefix(&quot;/user&quot;);\n    }\n\n    @Override\n    public void configureClientInboundChannel(ChannelRegistration registration) {\n        registration.interceptors(new ChannelInterceptor() {\n            @Override\n            public Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) {\n                StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);\n                if (StompCommand.CONNECT.equals(accessor.getCommand())) {\n                    String authHeader = accessor.getFirstNativeHeader(&quot;Authorization&quot;);\n                    if (authHeader != null &amp;&amp; authHeader.startsWith(&quot;Bearer &quot;)) {\n                        String token = authHeader.substring(7);\n                        try {\n                            Jwt jwt = jwtDecoder.decode(token);\n                            Authentication authentication = jwtAuthConverter.convert(jwt);\n                            SecurityContextHolder.getContext().setAuthentication(authentication);\n                            accessor.setUser(authentication);\n\n                            System.out.println(&quot;✅ WebSocket CONNECT: Principal = &quot; + authentication.getName());\n                        } catch (Exception e) {\n                            throw new RuntimeException(&quot;JWT non valido: &quot; + e.getMessage());\n                        }\n                    }\n                }\n                return message;\n            }\n        });\n    }\n}\n</code></pre>\n<p>In a service that does business logic i call this method:</p>\n<ul>\n<li>sendNotificationWebSocket(keycloakServices.getSub(emailCaregiver), n);</li>\n</ul>\n<pre><code>private void sendNotificationWebSocket(String userId, Notifications notifica) {\n        System.out.println(&quot;\uD83D\uDCE4 Invio WebSocket a utente: &quot; + userId + &quot; contenuto: &quot; + notifica.getSubject());\n        sim.convertAndSendToUser(\n                userId,\n                &quot;/notifications&quot;,\n                Map.of(&quot;content&quot;, &quot;Nuova notifica: &quot; + notifica.getSubject())\n        );\n    }\n</code></pre>\n<p>I created a frontend example shown below:</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Test WebSocket&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;Test WebSocket&lt;/h1&gt;\n\n  &lt;!-- SockJS --&gt;\n  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/sockjs-client/dist/sockjs.min.js&quot;&gt;&lt;/script&gt;\n  &lt;!-- STOMP --&gt;\n  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/stompjs/lib/stomp.min.js&quot;&gt;&lt;/script&gt;\n\n  &lt;script&gt;\n    const socket = new SockJS('http://localhost:8080/ws');\n    const client = Stomp.over(socket);\n\nconst token = &quot;here the token jwt&quot;;\n\nclient.connect(\n  { Authorization: `Bearer ${token}` },  // &lt;-- il token\n  frame =&gt; {\n    console.log('✅ Connesso al WebSocket:', frame);\n    client.subscribe(`/user/notifications`, msg =&gt; {\n    console.log(&quot;\uD83D\uDCE9 Notifica ricevuta:&quot;, msg.body);\n    });\n  },\n  error =&gt; console.error('❌ Errore connessione WebSocket:', error)\n);\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre>\n<p>Some log in the backend:</p>\n<pre><code>2025-09-19T23:29:26.755+02:00 DEBUG 10008 --- [app] [nio-8080-exec-5] s.w.s.h.LoggingWebSocketHandlerDecorator : New WebSocketServerSockJsSession[id=smnkzqoc]\n✅ WebSocket CONNECT: Principal = 71412206-e72d-478c-b1f2-4447f386424d\n2025-09-19T23:29:29.239+02:00 DEBUG 10008 --- [app] [nboundChannel-2] o.s.m.s.b.SimpleBrokerMessageHandler      : Processing CONNECT session=smnkzqoc\n2025-09-19T23:29:36.053+02:00 DEBUG 10008 --- [app] [nboundChannel-5] o.s.m.s.b.SimpleBrokerMessageHandler      : Processing SUBSCRIBE /user/notifications id=sub-0 session=smnkzqoc\n2025-09-19T23:29:43.693+02:00  INFO 10008 --- [app] [nio-8080-exec-2] c.m.o.o.s.impl.KeycloakServiceImpl        : getSub of the username useruser@live.it\n\uD83D\uDCE4 Invio WebSocket a utente: 71412206-e72d-478c-b1f2-4447f386424d contenuto: E' presente un questionario da compilare, accedi all'apposita area per completare il &lt;B&gt;Questionnaire&lt;/B&gt; \n2025-09-19T23:29:43.920+02:00 DEBUG 10008 --- [app] [nio-8080-exec-2] o.s.m.s.b.SimpleBrokerMessageHandler      : Processing MESSAGE destination=/user/71412206-e72d-478c-b1f2-4447f386424d/notifications session=null payload={&quot;content&quot;:&quot;Nuova notifica: E' presente un questionario da compilare&quot;}\n</code></pre>\n<p>What's wrong with this? I wanted to avoid putting the keycloak sub in the path of the destination to be subscribed from the frontend because I read that this is something handled automatically by Spring, but I can't make it work.</p>\n<p>Thanks in advance!</p>\n",
    "tags" : [ "java", "spring", "spring-boot", "websocket", "stomp" ],
    "owner" : {
      "account_id" : 16711122,
      "reputation" : 1,
      "user_id" : 12078328,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/ee8382803b61175b2a7074181b3cbcd5?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Cristian",
      "link" : "https://stackoverflow.com/users/12078328/cristian"
    },
    "is_answered" : false,
    "view_count" : 95,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1758439515,
    "creation_date" : 1758319067,
    "link" : "https://stackoverflow.com/questions/79769991/problem-with-websocket-notification-from-springboot-to-frontend",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79770717,
    "question_id" : 79769991,
    "body" : "<p>I think the issue might be caused by a mismatch in the userId . To avoid this, try retrieving the user ID using the method below.</p>\n<pre><code> Authentication auth = SecurityContextHolder.getContext().getAuthentication();\n String userId = auth.getName();\n sendNotificationWebSocket(userId,notifica);\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 37827316,
      "reputation" : 46,
      "user_id" : 28449192,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/9d1c7624eda875a1ad4655e39e406520?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Ganesh Karunanidhi",
      "link" : "https://stackoverflow.com/users/28449192/ganesh-karunanidhi"
    },
    "creation_date" : 1758439515,
    "last_activity_date" : 1758439515,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79770717" : [ {
      "comment_id" : 140762238,
      "post_id" : 79770717,
      "body" : "Hi! Second and fifth logs are connection websocket id and the channel where the websocket sends the message. They are equals :/",
      "score" : 0,
      "owner" : {
        "account_id" : 16711122,
        "reputation" : 1,
        "user_id" : 12078328,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/ee8382803b61175b2a7074181b3cbcd5?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Cristian",
        "link" : "https://stackoverflow.com/users/12078328/cristian"
      },
      "creation_date" : 1758902050,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}