{
  "question" : {
    "question_id" : 79749472,
    "title" : "Efficiently iterating over ordered keys in flink MapState",
    "body" : "<p>I am building a Flink application roughly modeled after Flink's <a href=\"https://flink.apache.org/2020/07/30/advanced-flink-application-patterns-vol.3-custom-window-processing/\" rel=\"nofollow noreferrer\">demo fraud detection application</a>, where events come into my system out-of-order, are keyed by some criteria, and then are stored in a <code>KeyedProcessFunction</code>'s <code>MapState&lt;Long, MyEvent&gt; windowState</code>, where the long is a timestamp.</p>\n<p>In the demo application, whenever an event comes in, their ProcessFunction iterates over the MapState's keys, looking for any events that fall within the window, and combining them into the aggregation function:</p>\n<pre><code>int windowCount = 0;\nfor (Long stateEventTime : windowState.keys()) {\n  if (isStateValueInWindow(stateEventTime, windowStartForEvent, currentEventTime)) {\n    windowCount++;\n  }\n}\n</code></pre>\n<p>However, because my events come in <em>badly</em> out-of-order, I expect <code>windowState</code> to contain up to 150,000 entries, and I am concerned about the cost of iterating over all of them each time a new event comes in. I would prefer to store them sorted, and binary-search my way to the first relevant key.</p>\n<p>If the application were purely running in memory, I would store the <code>Map&lt;Long, MyState&gt;</code> in a TreeMap. If I were storing the state in a SQL-like database, I similarly could keep an index of the timestamps and do a <code>select from windowState where timestamp &gt;= windowBegin and timestamp &lt; windowEnd;</code>. Do I have any options for efficiently seeking within the MapState managed by Flink? Is there a better option than <code>MapState</code> for storing my data?</p>\n<p><a href=\"https://cwiki.apache.org/confluence/display/FLINK/FLIP-220%3A+Binary+Sorted+State\" rel=\"nofollow noreferrer\">Binary Sorted State</a> looks like exactly what I want, but it seems like it remains unimplemented.</p>\n",
    "tags" : [ "java", "apache-flink" ],
    "owner" : {
      "account_id" : 187570,
      "reputation" : 5316,
      "user_id" : 425722,
      "user_type" : "registered",
      "accept_rate" : 83,
      "profile_image" : "https://i.sstatic.net/346yd.jpg?s=256",
      "display_name" : "Andrew Rueckert",
      "link" : "https://stackoverflow.com/users/425722/andrew-rueckert"
    },
    "is_answered" : true,
    "view_count" : 66,
    "answer_count" : 2,
    "score" : 0,
    "last_activity_date" : 1756512089,
    "creation_date" : 1756406218,
    "link" : "https://stackoverflow.com/questions/79749472/efficiently-iterating-over-ordered-keys-in-flink-mapstate",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79750685,
    "question_id" : 79749472,
    "body" : "<p>One solution I've used for this kind of problem is to keep an in-memory data structure which is NOT part of your state. E.g. Map&lt;key type, List&gt;. It has to be a map since you'll have only one of these per sub-task, so it's up to you to find the right list given the current key.</p>\n<p>If the mapping doesn't exist (e.g. when your workflow is restarted, and state has been restored) then you'll need to do that more expensive one-time sync from state to the sorted in-memory representation, and also keep them in sync going forward, but it does mean you an do an efficient binary scan to find the events in any given window.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 82425,
      "reputation" : 9550,
      "user_id" : 231762,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b5d195db362831baf779f0e4b491c68a?s=256&d=identicon&r=PG",
      "display_name" : "kkrugler",
      "link" : "https://stackoverflow.com/users/231762/kkrugler"
    },
    "creation_date" : 1756493593,
    "last_activity_date" : 1756493593,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79750855,
    "question_id" : 79749472,
    "body" : "<p>If you are willing to develop a solution that is tied to the implementation details of a specific state backend, there are a couple of additional possibilities. Of course, you'll have to weigh the risk/benefit tradeoffs involved. The approach suggested by Ken Krugler is probably saner.</p>\n<p>One approach would be to go ahead and use TreeMaps in Flink's managed state. If you use the hashmap state backend, then your working state will be TreeMaps on the heap, and so will perform well. However, these TreeMaps will be serialized/deserialized for checkpointing/recovery, which might be painful. And using TreeMaps in state with rocksdb is a very bad idea, since the entire TreeMap will have to go through serde on every read/write.</p>\n<p>Another approach is to leverage the iterators exposed by Flink's MapState interface. The embedded rocksdb state backend stores your state in SST files -- static sorted tables. The iterators provided on MapState delegate to the native rocksdb iterators, and thus yield results in sorted order -- sorted by the serialized keys. Maybe you can exploit this to good advantage. Note that MapState also offers iterators with the hashmap state backend, but in that case the iterator doesn't yield the entries in any particular order.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2274094,
      "reputation" : 44297,
      "user_id" : 2000823,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/BHxCqzuW.jpg?s=256",
      "display_name" : "David Anderson",
      "link" : "https://stackoverflow.com/users/2000823/david-anderson"
    },
    "creation_date" : 1756512089,
    "last_activity_date" : 1756512089,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140702474,
    "post_id" : 79749472,
    "body" : "@DavidAnderson I am still weighing between Heap and RocksDb, and good performance here might push me in one direction or the other.",
    "score" : 0,
    "owner" : {
      "account_id" : 187570,
      "reputation" : 5316,
      "user_id" : 425722,
      "user_type" : "registered",
      "accept_rate" : 83,
      "profile_image" : "https://i.sstatic.net/346yd.jpg?s=256",
      "display_name" : "Andrew Rueckert",
      "link" : "https://stackoverflow.com/users/425722/andrew-rueckert"
    },
    "creation_date" : 1756493472,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140699941,
    "post_id" : 79749472,
    "body" : "Which state backend do you plan to use? There are possibilities, but they will only out-perform this current design for specific state backends.",
    "score" : 0,
    "owner" : {
      "account_id" : 2274094,
      "reputation" : 44297,
      "user_id" : 2000823,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/BHxCqzuW.jpg?s=256",
      "display_name" : "David Anderson",
      "link" : "https://stackoverflow.com/users/2000823/david-anderson"
    },
    "creation_date" : 1756416663,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}