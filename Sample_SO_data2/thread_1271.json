{
  "question" : {
    "question_id" : 79728491,
    "title" : "Interfacing with legacy transitive dependencies",
    "body" : "<p>I'm using Java 17 with maven 3.9.9. My maven project <code>libfoo</code> is used as a library by other end-user applications say <code>myapp.jar</code>.</p>\n<p><code>libfoo</code> has no choice but to depend on a <code>bar:bar-core:1.2.3</code> whose code is out of my control (e.g. a proprietary client SDK), and <code>1.2.3</code> is the latest version. That artifact from hell is known to brings legacy transitive dependencies e.g.</p>\n<ol>\n<li>vulnerable version of <code>logback</code> and <code>jackson-databind</code> (evil) and</li>\n<li><code>common-zoo:common-zoo:0.0.1</code> (evil), with <code>myapp.jar</code> itself depends on <code>common-zoo:common-zoo:5.9.0</code> (good)</li>\n</ol>\n<p><strong>My question is that</strong>, is there any technique I can use, to <em>seal</em> all the evilness within <code>libfoo.jar</code> itself as implementation details of libfoo, such that</p>\n<ol>\n<li><code>myapp</code> sees <code>libfoo</code> as a single uber jar with 0 transitive dependency</li>\n<li><code>myapp.jar</code> is not awared of evil classes on its runtime classpath, and links only to dependencies declared in its own pom, e.g. <code>common-zoo:5.9.0</code>.</li>\n</ol>\n<p><strong>Known problems with shade+relocate</strong>:</p>\n<ol>\n<li><code>bar-core</code> is known to use <code>Class.forName('com..XXX')</code>, thus relocating class with maven-shade-plugin breaks the code.</li>\n<li><a href=\"https://stackoverflow.com/questions/28241764/maven-is-there-a-way-to-easily-create-an-uber-jar-with-all-the-dependencies\">shading all dependencies is error-prune</a></li>\n</ol>\n",
    "tags" : [ "java", "maven" ],
    "owner" : {
      "account_id" : 11335666,
      "reputation" : 552,
      "user_id" : 8311608,
      "user_type" : "registered",
      "accept_rate" : 75,
      "profile_image" : "https://www.gravatar.com/avatar/0d2ac35246d702dccdfe2a80f23c8a4c?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "SedriX",
      "link" : "https://stackoverflow.com/users/8311608/sedrix"
    },
    "is_answered" : true,
    "view_count" : 76,
    "answer_count" : 2,
    "score" : 3,
    "last_activity_date" : 1754645583,
    "creation_date" : 1754565942,
    "link" : "https://stackoverflow.com/questions/79728491/interfacing-with-legacy-transitive-dependencies",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79728551,
    "question_id" : 79728491,
    "body" : "<p>You can have a look at how maven manages to deal with ancient plugins and their dependencies. It encapsulates those by using <a href=\"https://codehaus-plexus.github.io/plexus-classworlds/\" rel=\"nofollow noreferrer\">plexus-classworlds</a>:</p>\n<blockquote>\n<p>The Classworlds model does away with the hierarchy normally associated with ClassLoaders. Instead, ClassWorld provides a pool of ClassRealms which can import arbitrary packages from other ClassRealms. Effectively, Classworlds turns the old-style hierarchy into a directed graph.</p>\n</blockquote>\n<p>In your case you would create one classrealm to contain all your normal library stuff. And you create another realm for everything of <code>bar:bar-core:1.2.3</code> and the dependencies it brings along. In this scenario it might be beneficial to have a facade encapsulating <code>bar-core</code>.</p>\n<p>However since you are creating a library I'm not sure how well you can hide the use of plexus-classworlds or if the consumers of your library need to adapt (at least a bit) as well.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1580843,
      "reputation" : 13706,
      "user_id" : 1466267,
      "user_type" : "registered",
      "accept_rate" : 91,
      "profile_image" : "https://www.gravatar.com/avatar/c47d1f7544a8c4a1bb7a41d511f53604?s=256&d=identicon&r=PG",
      "display_name" : "SpaceTrucker",
      "link" : "https://stackoverflow.com/users/1466267/spacetrucker"
    },
    "creation_date" : 1754569019,
    "last_activity_date" : 1754569019,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79729587,
    "question_id" : 79728491,
    "body" : "<p>Not unless you do class loader magic.</p>\n<p>Creating a library uber jar with external dependencies is usually a bad idea because you will have two versions of the same class on the classpath (from your uber jar, taken from <code>common-zoo:common-zoo:0.0.1</code>, and the one from <code>common-zoo:5.9.0</code> ) and it is essentially random which version gets loaded and used.</p>\n<p>The way around it is shading, but you said that breaks the code.</p>\n<p>You can, though, set specific dependencies to scope <code>runtime</code>, meaning that they are not on the compile classpath for myapp.jar. But this only works if myapp.jar does not try to use a different (newer) version of the same library.</p>\n",
    "score" : 1,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 888714,
      "reputation" : 36707,
      "user_id" : 927493,
      "user_type" : "registered",
      "accept_rate" : 61,
      "profile_image" : "https://i.sstatic.net/sxsnm.png?s=256",
      "display_name" : "JF Meier",
      "link" : "https://stackoverflow.com/users/927493/jf-meier"
    },
    "creation_date" : 1754645583,
    "last_activity_date" : 1754645583,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140652001,
    "post_id" : 79728491,
    "body" : "The trouble with legacy today is that you likely face the dreaded javax -&gt; jakarta switch that overcomplicated life to the maximum. That kind of breaks any kind of uber hack that someone might know. To overcome the javax -&gt; jakarta upgrade, one can only big bang. If that big bang can only happen 3 months from now... you will have to finish your work three months from now.",
    "score" : 0,
    "owner" : {
      "account_id" : 187094,
      "reputation" : 5301,
      "user_id" : 424903,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/8oHZF.png?s=256",
      "display_name" : "Gimby",
      "link" : "https://stackoverflow.com/users/424903/gimby"
    },
    "creation_date" : 1754662588,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140650722,
    "post_id" : 79728491,
    "body" : "@JFMeier Say <code>bar-core</code> is an internal jar written by other teams in the same company, e.g. a client connected to a complicated proprietary cache middleware. In the end, we know it&#39;s <code>bar-core</code>&#39;s  problem of not maintaining up-to-date dependency, and they may eventually fix this 3 months later; but for now I just want to finish my part of work.",
    "score" : 0,
    "owner" : {
      "account_id" : 11335666,
      "reputation" : 552,
      "user_id" : 8311608,
      "user_type" : "registered",
      "accept_rate" : 75,
      "profile_image" : "https://www.gravatar.com/avatar/0d2ac35246d702dccdfe2a80f23c8a4c?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "SedriX",
      "link" : "https://stackoverflow.com/users/8311608/sedrix"
    },
    "creation_date" : 1754620000,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140649339,
    "post_id" : 79728491,
    "body" : "&quot;libfoo has no choice but to depend on a bar:bar-core:1.2.3&quot; Why? Why can&#39;t you replace this library with some other library or your own code?",
    "score" : 0,
    "owner" : {
      "account_id" : 888714,
      "reputation" : 36707,
      "user_id" : 927493,
      "user_type" : "registered",
      "accept_rate" : 61,
      "profile_image" : "https://i.sstatic.net/sxsnm.png?s=256",
      "display_name" : "JF Meier",
      "link" : "https://stackoverflow.com/users/927493/jf-meier"
    },
    "creation_date" : 1754577179,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140649207,
    "post_id" : 79728491,
    "body" : "Can&#39;t you just add dependencies to newer versions of <code>logback</code>, <code>jackson-databind</code> and <code>common-zoo:common-zoo</code> in your own pom? Any local version will override any transitive version. The only issue is if the transitive version is not binary compatible with the newer overridden version. If you really want to ensure you don&#39;t get any transitive dependencies from <code>bar:bar-core</code> you can add exclusions for its transitive dependencies.",
    "score" : 1,
    "owner" : {
      "account_id" : 1211967,
      "reputation" : 9964,
      "user_id" : 1180351,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
      "display_name" : "Rob Spoor",
      "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
    },
    "creation_date" : 1754574302,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}