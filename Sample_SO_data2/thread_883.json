{
  "question" : {
    "question_id" : 79757452,
    "title" : "What is the correct approach to use Enums in Database with JPA?",
    "body" : "<p>I am working on a Spring Boot + JPA application, and I am confused about the best practice for persisting enums in the database.</p>\n<p>Let’s say I have the following enum in Java:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public enum SellerStatus {\n    PENDING_REVIEW,\n    APPROVED,\n    REJECTED;\n}\n</code></pre>\n<hr />\n<p><strong>Approach 1:</strong> Using <code>@Enumerated(EnumType.STRING)</code></p>\n<pre class=\"lang-java prettyprint-override\"><code>@Entity\npublic class Seller {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(name = &quot;status&quot;)\n    @Enumerated(EnumType.STRING)\n    private SellerStatus status;\n\n    // getters/setters\n}\n</code></pre>\n<p>This stores the enum as a <code>VARCHAR</code> column in the DB. It’s simple and works well, but it has issues:</p>\n<ul>\n<li><p>Storage overhead (storing long strings instead of small ids).</p>\n</li>\n<li><p>If I rename an enum constant (<code>APPROVED</code> → <code>ACCEPTED</code>, <code>REJECTED</code> → <code>DELETED</code>) when the table has millions of rows, updating the DB will be painful.</p>\n</li>\n</ul>\n<p><strong>Approach 2</strong>: Using a lookup table for enum values</p>\n<p>I could also create a separate <code>SellerStatus</code> table in the DB:</p>\n<p>Table: <code>seller_status</code></p>\n<pre class=\"lang-sql prettyprint-override\"><code>id   |   name\n--------------------\n1    | PENDING_REVIEW\n2    | APPROVED\n3    | REJECTED\n</code></pre>\n<p>And then reference it in the <code>seller</code> table as a foreign key:</p>\n<pre class=\"lang-sql prettyprint-override\"><code>seller\n---------\nid | name | status_id\n</code></pre>\n<p>Now in Java, I can map like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Entity\npublic class Seller {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = &quot;status_id&quot;)\n    private SellerStatusEntity status;\n}\n</code></pre>\n<p>But here, <code>SellerStatusEntity</code> becomes an entity, not an enum. It feels wrong since these values are fixed and rarely change. Also, this adds an extra join query.</p>\n<p><strong>Approach 3</strong>: Enum with IDs and <code>@Converter</code></p>\n<p>Another idea is to keep the enum in Java but assign IDs that match the DB table:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Getter\n@AllArgsConstructor\npublic enum SellerStatus {\n    PENDING_REVIEW(1),\n    APPROVED(2),\n    REJECTED(3);\n\n    private final int id;\n}\n\n</code></pre>\n<p>Then use a custom JPA <code>@Converter</code> to map between enum and integer in the DB:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Converter(autoApply = true)\npublic class SellerStatusConverter implements AttributeConverter&lt;SellerStatus, Integer&gt; {\n\n    @Override\n    public Integer convertToDatabaseColumn(SellerStatus status) {\n        return status != null ? status.getId() : null;\n    }\n\n    @Override\n    public SellerStatus convertToEntityAttribute(Integer dbData) {\n        return Arrays.stream(SellerStatus.values())\n                     .filter(s -&gt; s.getId() == dbData)\n                     .findFirst()\n                     .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Unknown status id: &quot; + dbData));\n    }\n}\n\n</code></pre>\n<p>This way:</p>\n<ul>\n<li><p>DB stays normalized (integer column with foreign key to lookup table).</p>\n</li>\n<li><p>Java code still uses enums.</p>\n</li>\n<li><p>But whenever I add a new enum constant, I also need to update the DB table manually.</p>\n</li>\n</ul>\n<hr />\n<p><strong>My Question:</strong></p>\n<p>Out of these approaches, which one is best practice in real-world applications with large datasets?</p>\n<ul>\n<li><p>Should I just stick with <code>@Enumerated(EnumType.STRING)</code> and accept rename/update issues?</p>\n</li>\n<li><p>Or is maintaining a lookup table + <code>@Converter</code> the right approach even if it adds some DB management overhead?</p>\n</li>\n<li><p>Is there a cleaner pattern for handling enums in JPA that avoids both extra joins and painful renames?</p>\n</li>\n</ul>\n",
    "tags" : [ "java", "hibernate", "jpa", "enums" ],
    "owner" : {
      "account_id" : 24265481,
      "reputation" : 28,
      "user_id" : 18214445,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a-/AOh14GiouJXZZh3ATFuqFaCdFcNS8gykO6ODkHiolfAPMBw=k-s256",
      "display_name" : "Rishabh Rastogi",
      "link" : "https://stackoverflow.com/users/18214445/rishabh-rastogi"
    },
    "is_answered" : true,
    "view_count" : 129,
    "closed_date" : 1757247333,
    "answer_count" : 1,
    "score" : 1,
    "last_activity_date" : 1757319700,
    "creation_date" : 1757150635,
    "link" : "https://stackoverflow.com/questions/79757452/what-is-the-correct-approach-to-use-enums-in-database-with-jpa",
    "closed_reason" : "Opinion-based"
  },
  "answers" : [ {
    "answer_id" : 79757458,
    "question_id" : 79757452,
    "body" : "<p>Stick with <code>@Enumerated(EnumType.STRING)</code>. The values (<code>PENDING_REVIEW</code>, <code>APPROVED</code>, <code>REJECTED</code>) are stable and not business-configurable. Renames can be handled via a one-time DB migration if it ever happens. The extra complexity of lookup tables or converters isn’t worth it unless requirements change.</p>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 43795486,
      "reputation" : 37,
      "user_id" : 31421306,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/4cxB8FLj.jpg?s=256",
      "display_name" : "Tejasmita",
      "link" : "https://stackoverflow.com/users/31421306/tejasmita"
    },
    "creation_date" : 1757151239,
    "last_activity_date" : 1757151239,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140718889,
    "post_id" : 79757452,
    "body" : "Please trim your code to make it easier to find your problem. Follow these guidelines to create a <a href=\"https://stackoverflow.com/help/minimal-reproducible-example\">minimal reproducible example</a>.",
    "score" : 0,
    "owner" : {
      "account_id" : -1,
      "reputation" : 1,
      "user_id" : -1,
      "user_type" : "moderator",
      "profile_image" : "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=256&d=identicon&r=PG",
      "display_name" : "Community",
      "link" : "https://stackoverflow.com/users/-1/community"
    },
    "creation_date" : 1757161737,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140718792,
    "post_id" : 79757452,
    "body" : "&quot;But whenever I add a new enum constant, I also need to update the DB table manually.&quot;  Why is that? The database stores an integer, you just need to make sure that the range is wide enough. But with just 3 constants now, a field that can store values up to 16 or 64 (the limit for <code>RegularEnumSet</code>) should be enough. That said, I always just go for option 1.",
    "score" : 0,
    "owner" : {
      "account_id" : 1211967,
      "reputation" : 10014,
      "user_id" : 1180351,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
      "display_name" : "Rob Spoor",
      "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
    },
    "creation_date" : 1757156777,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140718785,
    "post_id" : 79757452,
    "body" : "I&#39;m glad you missed option 1a: use <code>@Enumerated(EnumType.ORDINAL)</code>. That has a risk similar to renaming enum constants - reordering constants.",
    "score" : 0,
    "owner" : {
      "account_id" : 1211967,
      "reputation" : 10014,
      "user_id" : 1180351,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
      "display_name" : "Rob Spoor",
      "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
    },
    "creation_date" : 1757156613,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140718708,
    "post_id" : 79757452,
    "body" : "Hi Rishasbh, thank you for contributing to StackOverflow. Unfortunately, the platform doesn&#39;t allow posts with multiple questions. It is best to edit your post to focus on a problem at a time with a <b>single</b> question. Also, avoid questions that lead to opinion-based answers, like: &quot;What is the correct approach... ?&quot;, &quot;Should I stick with... ?&quot;, &quot;is there a cleaner way/pattern... ?&quot;, etc. As it is, your question might get closed with the reason &quot;Needs more focus&quot; or &quot;Opinion-based&quot;.",
    "score" : 1,
    "owner" : {
      "account_id" : 5569841,
      "reputation" : 8654,
      "user_id" : 4415625,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/0ea1713807527aa1cf52e40579e35ec4?s=256&d=identicon&r=PG",
      "display_name" : "dani-vta",
      "link" : "https://stackoverflow.com/users/4415625/dani-vta"
    },
    "creation_date" : 1757151384,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79757458" : [ {
      "comment_id" : 140720180,
      "post_id" : 79757458,
      "body" : "Agree.  Furthermore, the ”storage overhead” is negligible—APPROVED and REJECTED use the same amount of storage as an integer (although varchar also stores a length byte).  PENDING_REVIEW uses roughly twice the space.  So, ten million records with that value would incur an 80 MB storage increase.  Surely that’s insignificant in 2025.",
      "score" : 1,
      "owner" : {
        "account_id" : 2053598,
        "reputation" : 44936,
        "user_id" : 1831987,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/38b1c37530189ec4471a43a618e33f67?s=256&d=identicon&r=PG",
        "display_name" : "VGR",
        "link" : "https://stackoverflow.com/users/1831987/vgr"
      },
      "creation_date" : 1757253284,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}