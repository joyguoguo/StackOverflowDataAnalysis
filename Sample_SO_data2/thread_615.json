{
  "question" : {
    "question_id" : 79791973,
    "title" : "Updating ComboBox item rendering",
    "body" : "<p>Suppose I have a JavaFX <code>ComboBox</code> that stores custom objects. Objects are rendered in a way that involves their property X.</p>\n<p>I now mutate property X for the selected object. How do I make the combo reflect the change visually? Preferably, in a non-kludgy way, e.g. removing and inserting the item back in its place.</p>\n<p>Keep in mind, the object is a simple data object with multiple properties only a handful of which are involved in rendering. The object class could be used outside of a JavaFX context. It would be a bit weird if some of its properties were of observable JavaFX types, such as <code>StringProperty</code>.</p>\n<pre class=\"lang-java prettyprint-override\"><code>import javafx.application.Application;\nimport javafx.beans.value.ObservableValue;\nimport javafx.geometry.Insets;\nimport javafx.geometry.Pos;\nimport javafx.scene.Scene;\nimport javafx.scene.control.ComboBox;\nimport javafx.scene.control.Label;\nimport javafx.scene.control.TextField;\nimport javafx.scene.layout.HBox;\nimport javafx.scene.layout.VBox;\nimport javafx.stage.Stage;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class FXComboBoxDemo extends Application {\n\n    static ComboBox&lt;Person&gt; personCombo;\n    static TextField nameField;\n\n    @Override\n    public void start(Stage primaryStage) {\n        VBox root = createRoot();\n        primaryStage.setScene(new Scene(root));\n        primaryStage.setTitle(&quot;ComboBox Demo&quot;);\n        primaryStage.show();\n    }\n\n    private static VBox createRoot() {\n        VBox root = new VBox(10);\n        HBox nameRow = createNameRow();\n        ComboBox&lt;Person&gt; personCombo = createPersonCombo();\n        root.getChildren().add(personCombo);\n        root.getChildren().add(nameRow);\n        root.paddingProperty().setValue(new Insets(10));\n        return root;\n    }\n\n    private static HBox createNameRow() {\n        HBox nameRow = new HBox(10);\n        nameRow.setAlignment(Pos.CENTER_LEFT);\n        Label nameLabel = new Label(&quot;Name&quot;);\n        nameRow.getChildren().add(nameLabel);\n        nameRow.getChildren().add(createNameField());\n        return nameRow;\n    }\n\n    private static TextField createNameField() {\n        nameField = new TextField();\n        nameField.textProperty().addListener(FXComboBoxDemo::onNameChange);\n        return nameField;\n    }\n\n    private static void onNameChange(ObservableValue&lt;? extends String&gt; observable, String oldValue, String newValue) {\n        personCombo.getSelectionModel().getSelectedItem().setName(newValue);\n    }\n\n    private static ComboBox&lt;Person&gt; createPersonCombo() {\n        personCombo = new ComboBox&lt;&gt;();\n        personCombo.getItems().addAll(createPeople());\n        personCombo.valueProperty().addListener(FXComboBoxDemo::onPersonChange);\n        personCombo.getSelectionModel().selectFirst();\n        return personCombo;\n    }\n\n    private static void onPersonChange(ObservableValue&lt;? extends Person&gt; observable, Person oldValue, Person newValue) {\n        nameField.textProperty().set(newValue.getName())\n    }\n\n    private static List&lt;Person&gt; createPeople() {\n        List&lt;Person&gt; people = new ArrayList&lt;&gt;();\n        people.add(new Person(&quot;Alice&quot;));\n        people.add(new Person(&quot;Bob&quot;));\n        people.add(new Person(&quot;Charlie&quot;));\n        return people;\n    }\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>public class Person {\n\n    // in a more realistic scenario, it would contain more properties\n    private String name;\n\n    public Person(String name) {\n        this.name = name;\n    }\n\n    // getters, setters\n\n    @Override\n    public String toString() {\n        return name;\n    }\n}\n</code></pre>\n<p>Even if I change the name, the rendering in the combo box stays the same. I want it to be updated automatically.</p>\n<p><a href=\"https://i.sstatic.net/GP4pVRPQ.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/GP4pVRPQ.png\" alt=\"enter image description here\" /></a></p>\n<p>Java 8.</p>\n",
    "tags" : [ "java", "javafx" ],
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2683,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "is_answered" : true,
    "view_count" : 203,
    "answer_count" : 3,
    "score" : -1,
    "last_activity_date" : 1760709423,
    "creation_date" : 1760606500,
    "link" : "https://stackoverflow.com/questions/79791973/updating-combobox-item-rendering",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79792044,
    "question_id" : 79791973,
    "body" : "<p><em><strong>Preface:</strong> I wrote this code with Java 25 and JavaFX 25, but I tried to make it Java 8 compatible (e.g., no <code>var</code>, no <code>_</code> for unused lambda parameters, etc.). I believe it's also compatible with JavaFX 8. Let me know if there are problems.</em></p>\n<h2>Observables</h2>\n<p>JavaFX is basically designed from the ground up to work with <a href=\"https://openjfx.io/javadoc/25/javafx.base/javafx/beans/Observable.html\" rel=\"nofollow noreferrer\">observables</a>. Customizing how a <a href=\"https://openjfx.io/javadoc/25/javafx.controls/javafx/scene/control/ComboBox.html\" rel=\"nofollow noreferrer\"><code>ComboBox</code></a> displays its items involves configuring its <a href=\"https://openjfx.io/javadoc/25/javafx.controls/javafx/scene/control/ComboBox.html#buttonCellProperty\" rel=\"nofollow noreferrer\"><code>buttonCell</code></a> and <a href=\"https://openjfx.io/javadoc/25/javafx.controls/javafx/scene/control/ComboBox.html#cellFactoryProperty\" rel=\"nofollow noreferrer\"><code>cellFactory</code></a> properties. This is implemented in such a way that you do not have external access to the <a href=\"https://openjfx.io/javadoc/25/javafx.controls/javafx/scene/control/ListView.html\" rel=\"nofollow noreferrer\"><code>ListView</code></a> instance nor, except for the button cell, any of the <a href=\"https://openjfx.io/javadoc/25/javafx.controls/javafx/scene/control/ListView.html\" rel=\"nofollow noreferrer\"><code>ListCell</code></a> instances. Which means you need an indirect way of notifying the cells they need to update, and that is typically done by making the necessary properties observable.</p>\n<p>For example, if you have the following model item:</p>\n<pre class=\"lang-java prettyprint-override\"><code>import javafx.beans.property.SimpleStringProperty;\nimport javafx.beans.property.StringProperty;\n\npublic class Item {\n\n  private final StringProperty text = new SimpleStringProperty(this, &quot;text&quot;, &quot;&quot;);\n  public final void setText(String text) { this.text.set(text); }\n  public final String getText() { return text.get(); }\n  public final StringProperty textProperty() { return text; }\n\n  public Item() {}\n  public Item(String text) { setText(text); }\n}\n</code></pre>\n<p>Then one way to ensure updates to an <code>Item</code> are reflected in the UI is to have the custom <code>ListCell</code> observe the necessary properties of its item.</p>\n<pre class=\"lang-java prettyprint-override\"><code>import javafx.animation.PauseTransition;\nimport javafx.application.Application;\nimport javafx.scene.Scene;\nimport javafx.scene.control.ComboBox;\nimport javafx.scene.control.ListCell;\nimport javafx.scene.layout.StackPane;\nimport javafx.stage.Stage;\nimport javafx.util.Duration;\n\npublic class App extends Application {\n\n  @Override\n  public void start(Stage primaryStage) {\n    ComboBox&lt;Item&gt; box = new ComboBox&lt;&gt;();\n    for (int i = 1; i &lt;= 25; i++) {\n      box.getItems().add(new Item(&quot;Item #&quot; + i));\n    }\n    box.setValue(box.getItems().get(0));\n    // The cells used for the dropdown list view.\n    box.setCellFactory(lv -&gt; new ListCell&lt;Item&gt;() {\n\n      @Override\n      protected void updateItem(Item item, boolean empty) {\n        super.updateItem(item, empty);\n        if (empty || item == null) {\n          textProperty().unbind();\n          setText(null);\n        } else {\n          textProperty().bind(item.textProperty());\n        }\n      }\n    });\n    // The cell used for the selected value. Use the cell factory for consistency.\n    box.setButtonCell(box.getCellFactory().call(null));\n\n    StackPane root = new StackPane(box);\n    primaryStage.setScene(new Scene(root, 500, 300));\n    primaryStage.show();\n\n    // Simulate update to model items.\n    PauseTransition action = new PauseTransition(Duration.seconds(5));\n    action.setOnFinished(e -&gt; {\n      for (Item item : box.getItems()) {\n        item.setText(item.getText() + &quot; [UPDATED]&quot;);\n      }\n      System.out.println(&quot;Items updated.&quot;);\n    });\n    action.play();\n  }\n}\n</code></pre>\n<p>Another approach is to set an <a href=\"https://openjfx.io/javadoc/25/javafx.base/javafx/collections/FXCollections.html#observableArrayList(javafx.util.Callback)\" rel=\"nofollow noreferrer\">extractor</a> on the box's items.</p>\n<pre class=\"lang-java prettyprint-override\"><code>import javafx.animation.PauseTransition;\nimport javafx.application.Application;\nimport javafx.beans.Observable;\nimport javafx.collections.FXCollections;\nimport javafx.collections.ObservableList;\nimport javafx.scene.Scene;\nimport javafx.scene.control.ComboBox;\nimport javafx.scene.control.ListCell;\nimport javafx.scene.layout.StackPane;\nimport javafx.stage.Stage;\nimport javafx.util.Callback;\nimport javafx.util.Duration;\n\npublic class App extends Application {\n\n  @Override\n  public void start(Stage primaryStage) {\n    // The extractor causes the ObservableList to fire an update change whenever\n    // one of the observables in the array are invalidated. The update change causes\n    // the ComboBox's list cells to update. This behavior is somewhat dependent on\n    // implementation details, I believe.\n    Callback&lt;Item, Observable[]&gt; extractor = item -&gt; new Observable[] {item.textProperty()};\n    ObservableList&lt;Item&gt; items = FXCollections.observableArrayList(extractor);\n    for (int i = 1; i &lt;= 25; i++) {\n      items.add(new Item(&quot;Item #&quot; + i));\n    }\n\n    ComboBox&lt;Item&gt; box = new ComboBox&lt;&gt;(items);\n    box.setValue(items.get(0));\n    // The cells used for the dropdown list view.\n    box.setCellFactory(lv -&gt; new ListCell&lt;Item&gt;() {\n\n      @Override\n      protected void updateItem(Item item, boolean empty) {\n        super.updateItem(item, empty);\n        if (empty || item == null) {\n          setText(null);\n        } else {\n          setText(item.getText());\n        }\n      }\n    });\n    // The cell used for the selected value. Use the cell factory for consistency.\n    box.setButtonCell(box.getCellFactory().call(null));\n\n    StackPane root = new StackPane(box);\n    primaryStage.setScene(new Scene(root, 500, 300));\n    primaryStage.show();\n\n    // Simulate update to model items.\n    PauseTransition action = new PauseTransition(Duration.seconds(5));\n    action.setOnFinished(e -&gt; {\n      for (Item item : items) {\n        item.setText(item.getText() + &quot; [UPDATED]&quot;);\n      }\n      System.out.println(&quot;Items updated.&quot;);\n    });\n    action.play();\n  }\n}\n</code></pre>\n<p>That is all to say, you may want to consider creating a type dedicated for use with a <code>ComboBox</code>. Then map between that type and your current type as needed.</p>\n<h2>Workaround - No Observables</h2>\n<p>However, I can think of at least one workaround that doesn't involve creating a model type that uses JavaFX properties. You can fire an <a href=\"https://openjfx.io/javadoc/25/javafx.base/javafx/event/Event.html\" rel=\"nofollow noreferrer\"><code>Event</code></a> at the <code>ComboBox</code> that each <code>ListCell</code> would watch for. The <code>ListCell</code> would fully update the UI when it observes that event.</p>\n<p>For example:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class Item {\n\n  private String text = &quot;&quot;;\n  public final void setText(String text) { this.text = text; }\n  public final String getText() { return text; }\n\n  public Item() {}\n  public Item(String text) { setText(text); }\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import javafx.animation.PauseTransition;\nimport javafx.application.Application;\nimport javafx.event.Event;\nimport javafx.event.EventHandler;\nimport javafx.event.EventType;\nimport javafx.event.WeakEventHandler;\nimport javafx.scene.Scene;\nimport javafx.scene.control.ComboBox;\nimport javafx.scene.control.ListCell;\nimport javafx.scene.layout.StackPane;\nimport javafx.stage.Stage;\nimport javafx.util.Duration;\n\npublic class App extends Application {\n\n  // A custom EventType for the event indicating the items were updated. May even want to\n  // create a custom Event subtype as well, though that's not necessary.\n  private static final EventType&lt;Event&gt; ITEMS_UPDATED = new EventType&lt;&gt;(&quot;ITEMS_UPDATED&quot;);\n\n  @Override\n  public void start(Stage primaryStage) {\n    ComboBox&lt;Item&gt; box = new ComboBox&lt;&gt;();\n    for (int i = 1; i &lt;= 25; i++) {\n      box.getItems().add(new Item(&quot;Item #&quot; + i));\n    }\n    box.setValue(box.getItems().get(0));\n    // The cells used for the dropdown list view.\n    box.setCellFactory(lv -&gt; new ListCell&lt;Item&gt;() {\n\n      // The handler responsible for forcing this cell to update.\n      private final EventHandler&lt;Event&gt; onItemsUpdated = e -&gt; updateItem(getItem(), isEmpty());\n\n      {\n        // Register a weak handler to avoid keeping this cell in memory unnecessarily.\n        box.addEventHandler(ITEMS_UPDATED, new WeakEventHandler&lt;&gt;(onItemsUpdated));\n      }\n\n      @Override\n      protected void updateItem(Item item, boolean empty) {\n        super.updateItem(item, empty);\n        if (empty || item == null) {\n          setText(null);\n        } else {\n          setText(item.getText());\n        }\n      }\n    });\n    // The cell used for the selected value. Use the cell factory for consistency.\n    box.setButtonCell(box.getCellFactory().call(null));\n    // May as well prevent event from bubbling up past the ComboBox to avoid unnecessary work.\n    box.addEventHandler(ITEMS_UPDATED, Event::consume);\n\n    StackPane root = new StackPane(box);\n    primaryStage.setScene(new Scene(root, 500, 300));\n    primaryStage.show();\n\n    // Simulate update to model items.\n    PauseTransition action = new PauseTransition(Duration.seconds(5));\n    action.setOnFinished(e -&gt; {\n      for (Item item : box.getItems()) {\n        item.setText(item.getText() + &quot; [UPDATED]&quot;);\n      }\n      // Fire the event to notify the box's cells they need to update.\n      box.fireEvent(new Event(ITEMS_UPDATED));\n      System.out.println(&quot;Items updated.&quot;);\n    });\n    action.play();\n  }\n}\n</code></pre>\n<p>You would be responsible for firing the event whenever the items are updated and the UI needs to update as well.</p>\n",
    "score" : 4,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49904,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1760611239,
    "last_activity_date" : 1760612241,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79792525,
    "question_id" : 79791973,
    "body" : "<p>I generally recommend that domain objects in a JavaFX application should use the JavaFX property pattern. The built-in observability allows you to set things up so that the UI will update automatically on changes in the properties, freeing the code from explicit UI refreshes and greatly decreasing the amount of coupling. If your client-side JavaFX application is, for example, communicating with a server side application, I would use different domain object representations on the client (using JavaFX properties) and server (using &quot;traditional&quot; Java beans) side. An interesting side note is that (in some cases) you can use the same serialization representation for both domain objects: for example using the Jackson JSON [de]serialization library with &quot;property access&quot;, the same JSON representation will work both for the client-side (JavaFX property) object and the server-side (&quot;traditional&quot; Java Bean) object.</p>\n<p>If you really want to avoid JavaFX properties on the client side, I would strongly advocate setting up your own mechanism by which you can create notifications that the data have changed with as little coupling as possible. Here is an a solution that is somewhat similar to the &quot;Workaround: No Observables&quot; solution <a href=\"https://stackoverflow.com/a/79792044/2189127\">provided by @slaw</a>. The main differences are that it uses built-in invalidation listeners, instead of a custom event, and maintains proper decoupling by invalidating a model instead of firing an event on the view (there is no <code>comboBox.fireEvent(...)</code> which tightly couples one part of the view to another).</p>\n<p>The overall structure is similar to how you might implement an MVC-type approach in a UI toolkit without built-in observable properties, such as Swing. The idea is to create a model class (<code>PresentationModel</code> here) which provides the data and the ability to register listeners. The application can inform the model that the data has changed, and the UI can register listeners with the model so that it updates the view if the model has changed data. While this is a little more effort than would be required if the domain object used JavaFX properties, it does maintain decoupling from different parts of the UI.</p>\n<p>The domain object is a JavaFX-agnostic class (a regular Java bean) that does not depend on JavaFX properties (or any other classes):</p>\n<pre><code>public class Person {\n    private String name;\n\n    public Person(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n</code></pre>\n<p>This solution does leverage some aspects of JavaFX's built-in observability. By wrapping the items list for the combo box in a <code>ListBinding</code>, which exposes an <code>invalidate()</code> method, there is an easy mechanism to mark the list as being invalid. This implementation detail is completely encapsulated inside the <code>PresentationModel</code> class and is not visible to the code implementing the view. The model is part of the presentation tier, so it makes sense for it to use JavaFX specific classes:</p>\n<pre><code>import javafx.beans.binding.ListBinding;\nimport javafx.collections.FXCollections;\nimport javafx.collections.ObservableList;\n\npublic class PresentationModel {\n    private final ObservableList&lt;Person&gt; peopleList = FXCollections.observableArrayList();\n\n    private final ListBinding&lt;Person&gt; peopleBinding = new ListBinding&lt;Person&gt;() {\n        {\n            bind(peopleList);\n        }\n        @Override\n        protected ObservableList&lt;Person&gt; computeValue() {\n            return peopleList;\n        }\n    };\n\n    public ObservableList&lt;Person&gt; getPeopleList() {\n        return peopleBinding;\n    }\n\n    public void invalidatePeopleList() {\n        peopleBinding.invalidate();\n    }\n\n    // Other methods for accessing other model properties, etc.\n}\n</code></pre>\n<p>The UI code can now simply use the list in the model (which is just exposed as an <code>ObservableList&lt;Person&gt;</code>, as you would expect) for the items list for the combo box:</p>\n<pre><code>        PresentationModel model = new PresentationModel();\n        model.getPeopleList().addAll(\n            new Person(&quot;Alice&quot;),\n            new Person(&quot;Bob&quot;),\n            new Person(&quot;Charlie&quot;)\n        );\n        ComboBox&lt;Person&gt; personCombo = new ComboBox&lt;&gt;();\n        personCombo.setItems(model.getPeopleList());\n</code></pre>\n<p>Any parts of the UI that need to be updated if the contents of the list change (in a way that is not supported directly by the JavaFX observability system) can simply register an invalidation listener with the list. In this case this is just the cells used by the combo box:</p>\n<pre><code>    private static class PersonListCell extends ListCell&lt;Person&gt; {\n\n        public PersonListCell(PresentationModel model) {\n            // Update cell if list is invalidated\n            model.getPeopleList().addListener((Observable _) -&gt; updateItem(getItem(), isEmpty()));\n        }\n\n        @Override\n        protected void updateItem(Person item, boolean empty) {\n            super.updateItem(item, empty);\n            if (empty || item == null) {\n                setText(&quot;&quot;);\n            } else {\n                setText(item.getName());\n            }\n        }\n    }\n</code></pre>\n<p>Now any time the data is changed, notifying the model that this has happened is all that is needed to ensure the UI stays updated:</p>\n<pre><code>        TextField nameField = new TextField();\n        nameField.disableProperty().bind(personCombo.valueProperty().isNull());\n        nameField.textProperty().addListener(\n                (_, _, name) -&gt; {\n                    personCombo.getValue().setName(name);\n                    // invalidate list as a name has changed:\n                    model.invalidatePeopleList();\n                }\n        );\n</code></pre>\n<p>The point here is that the proper decoupling is maintained: the text field and its related code need to know nothing about the combo box (even to the extent of knowing of its existence). All it is required to do is notify the model that it's data might be invalid. Anyone can independently register listeners with the model (or the list it provides) and perform whatever necessary action (such as updating part of the view) if the data might be invalid.</p>\n<p>Here is the complete UI class:</p>\n<pre><code>\nimport javafx.application.Application;\nimport javafx.beans.Observable;\nimport javafx.geometry.Insets;\nimport javafx.scene.Scene;\nimport javafx.scene.control.ComboBox;\nimport javafx.scene.control.Label;\nimport javafx.scene.control.ListCell;\nimport javafx.scene.control.TextField;\nimport javafx.scene.layout.HBox;\nimport javafx.scene.layout.VBox;\nimport javafx.stage.Stage;\n\npublic class HelloApplication extends Application {\n    @Override\n    public void start(Stage stage) {\n        PresentationModel model = new PresentationModel();\n        model.getPeopleList().addAll(\n            new Person(&quot;Alice&quot;),\n            new Person(&quot;Bob&quot;),\n            new Person(&quot;Charlie&quot;)\n        );\n        ComboBox&lt;Person&gt; personCombo = new ComboBox&lt;&gt;();\n        personCombo.setItems(model.getPeopleList());\n\n        personCombo.setCellFactory( _ -&gt; new PersonListCell(model));\n        personCombo.setButtonCell(new PersonListCell(model));\n\n\n        TextField nameField = new TextField();\n        nameField.disableProperty().bind(personCombo.valueProperty().isNull());\n        nameField.textProperty().addListener(\n                (_, _, name) -&gt; {\n                    personCombo.getValue().setName(name);\n                    // invalidate list as a name has changed:\n                    model.invalidatePeopleList();\n                }\n        );\n\n        personCombo.valueProperty().subscribe(\n                p -&gt; nameField.setText(p == null ? &quot;&quot; : p.getName())\n        );\n\n        VBox root = new VBox(5);\n        root.setPadding(new Insets(10));\n        HBox controls = new HBox(5);\n        controls.getChildren().addAll(\n                new Label(&quot;Name:&quot;),\n                nameField\n        );\n        root.getChildren().addAll(personCombo, controls);\n        Scene scene = new Scene(root);\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    private static class PersonListCell extends ListCell&lt;Person&gt; {\n\n        public PersonListCell(PresentationModel model) {\n            // Update cell if list is invalidated\n            model.getPeopleList().addListener((Observable _) -&gt; updateItem(getItem(), isEmpty()));\n        }\n\n        @Override\n        protected void updateItem(Person item, boolean empty) {\n            super.updateItem(item, empty);\n            if (empty || item == null) {\n                setText(&quot;&quot;);\n            } else {\n                setText(item.getName());\n            }\n        }\n    }\n}\n</code></pre>\n<p>And some screenshots indicating it working as expected:</p>\n<p><a href=\"https://i.sstatic.net/IYkvEfwW.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/IYkvEfwW.png\" alt=\"Original combo box\" /></a></p>\n<p><a href=\"https://i.sstatic.net/bdL2hQUr.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/bdL2hQUr.png\" alt=\"Combo box after editing name\" /></a></p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2518243,
      "reputation" : 210916,
      "user_id" : 2189127,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
      "display_name" : "James_D",
      "link" : "https://stackoverflow.com/users/2189127/james-d"
    },
    "creation_date" : 1760644629,
    "last_activity_date" : 1760709423,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79792301,
    "question_id" : 79791973,
    "body" : "<p>This is as close to Swing's <code>repaint()</code> as you can find.</p>\n<pre class=\"lang-java prettyprint-override\"><code>    private static void onNameChange(ObservableValue&lt;? extends String&gt; observable, String oldValue, String newValue) {\n        personCombo.getSelectionModel().getSelectedItem().setName(newValue);\n        // this line\n        personCombo.setButtonCell(personCombo.getCellFactory().call(null));\n    }\n</code></pre>\n<p>It updates the so-called &quot;button cell&quot; (how the selected item is rendered). The item is also updated in the dropdown list.</p>\n<p><a href=\"https://i.sstatic.net/ZLLJ4a3m.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/ZLLJ4a3m.png\" alt=\"enter image description here\" /></a></p>\n<p><a href=\"https://i.sstatic.net/82mWhWsT.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/82mWhWsT.png\" alt=\"enter image description here\" /></a></p>\n<p>However, JavaFX being JavaFX, you also need to add these nonsensical lines in the <code>createPersonCombo()</code> for this to work. If your codebase has some cell factories or <em>cell factory</em> factories, it can be made more visually appealing.</p>\n<pre class=\"lang-java prettyprint-override\"><code>    private static ComboBox&lt;Person&gt; createPersonCombo() {\n        personCombo = new ComboBox&lt;&gt;();\n        \n        // these two statements\n        personCombo.setCellFactory(lv -&gt; new ListCell&lt;Person&gt;() {\n            @Override\n            protected void updateItem(Person item, boolean empty) {\n                super.updateItem(item, empty);\n                setText(item == null ? null : item.getName());\n            }\n        });\n        personCombo.setButtonCell(personCombo.getCellFactory().call(null));\n\n        personCombo.getItems().addAll(createPeople());\n        personCombo.valueProperty().addListener(FXComboBoxDemo::onPersonChange);\n        personCombo.getSelectionModel().selectFirst();\n        return personCombo;\n    }\n</code></pre>\n<p>I was surprised to find out that if you don't explicitly set a cell factory, it stays <code>null</code> (which will throw NPE at <code>personCombo.getCellFactory().call(null)</code>). There <em>is</em> a default cell factory, but it's not set as a cell factory property value and instead created each time on each <code>updateButtonCell()</code> call. See <code>com.sun.javafx.scene.control.skin.ComboBoxListViewSkin#updateButtonCell</code>.</p>\n",
    "score" : -2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2683,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "creation_date" : 1760627094,
    "last_activity_date" : 1760706272,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140802495,
    "post_id" : 79791973,
    "body" : "I think the &quot;no observables&quot; criteria is a red herring. The example code already hides the implementation of name behind a getter/letter pair. So any &quot;weirdness&quot; from the Property nature of name wouldn&#39;t happen.",
    "score" : 0,
    "owner" : {
      "account_id" : 16559,
      "reputation" : 2173,
      "user_id" : 36223,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/bh9Vd.png?s=256",
      "display_name" : "DaveB",
      "link" : "https://stackoverflow.com/users/36223/daveb"
    },
    "creation_date" : 1760724151,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140799315,
    "post_id" : 79791973,
    "body" : "Was already writing an answer, so I used a class named <code>Item</code> instead of <code>Person</code>. I also used an animation to simulate a delayed update to the items instead of user interaction. The first part of my answer basically suggests creating a dedicated type with JavaFX properties to use with <code>ComboBox</code>. But the second part of my answer gives a workaround that uses events.",
    "score" : 0,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49904,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1760611446,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140799288,
    "post_id" : 79791973,
    "body" : "@Slaw included an MRE",
    "score" : 0,
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2683,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "creation_date" : 1760610804,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140799198,
    "post_id" : 79791973,
    "body" : "@Slaw the object is a simple data object with multiple properties only a handful of which are involved in rendering. It could be used outside of a JavaFX context. It would be a bit weird if some of its properties were of JavaFX types, such as <code>StringProperty</code>",
    "score" : 0,
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2683,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "creation_date" : 1760608054,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140799174,
    "post_id" : 79791973,
    "body" : "What kind of change are you looking for? Just a text change or are custom visuals involved? Regardless, the property will need to be observable somehow. One option is to make it a <a href=\"https://openjfx.io/javadoc/25/javafx.base/javafx/beans/property/StringProperty.html\" rel=\"nofollow noreferrer\"><code>StringProperty</code></a>.",
    "score" : 0,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49904,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1760607609,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79792301" : [ {
      "comment_id" : 140801850,
      "post_id" : 79792301,
      "body" : "@SergeyZolotarev Again, you are making assumptions about how your application will evolve in the future. The design you are advocating is unmaintainable.",
      "score" : 0,
      "owner" : {
        "account_id" : 2518243,
        "reputation" : 210916,
        "user_id" : 2189127,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
        "display_name" : "James_D",
        "link" : "https://stackoverflow.com/users/2189127/james-d"
      },
      "creation_date" : 1760704887,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140801665,
      "post_id" : 79792301,
      "body" : "@Slaw <i>&quot;If an unselected item is modified&quot;</i> Not going to happen, you only edit the selected person",
      "score" : 0,
      "owner" : {
        "account_id" : 10187542,
        "reputation" : 2683,
        "user_id" : 20692967,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
        "display_name" : "Sergey Zolotarev",
        "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
      },
      "creation_date" : 1760698415,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140801463,
      "post_id" : 79792301,
      "body" : "Warning: This will only update the button cell. If an unselected item is modified this won&#39;t cause the dropdown&#39;s cells to update. The most correct approach is still to use observables as designed, even if that&#39;s more verbose. (I&#39;m also not sure how this is really any better than my event-based workaround, which doesn&#39;t have the aforementioned problem).",
      "score" : 1,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49904,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1760691979,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79792525" : [ {
      "comment_id" : 140801996,
      "post_id" : 79792525,
      "body" : "@SergeyZolotarev Only for domain objects being used in complex controls, for which the default cell doesn&#39;t suffice. That said, it&#39;s typically not a good idea to rely on <code>toString()</code> for the UI display, so you quite often end up with custom cells for domain objects. In larger projects, I usually end up with a utility method to create those factories from a function, something like <code>public class Cells { public static Callback&lt;ListView&lt;T&gt;, ListCell&lt;T&gt;&gt; listCellFactory(Function&lt;T, String&gt; textMapping) { ... }}</code>. Then you can do <code>combo.setCellFactory(Cells.listCellFactory(Person::getName))&zwnj;&#8203;;</code>",
      "score" : 2,
      "owner" : {
        "account_id" : 2518243,
        "reputation" : 210916,
        "user_id" : 2189127,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
        "display_name" : "James_D",
        "link" : "https://stackoverflow.com/users/2189127/james-d"
      },
      "creation_date" : 1760708567,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140801975,
      "post_id" : 79792525,
      "body" : "@SergeyZolotarev <code>PersonListCell</code> was so named because it represents a list cell for displaying person objects. Your solution also defines essentially the same class, but as an anonymous class. I made it an inner class as it&#39;s used more than once (for the combo box list cells, and for the button cell); a local class would perhaps be even better. This just feels a bit more natural than setting the factory, then invoking the factory to retrieve an instance.",
      "score" : 1,
      "owner" : {
        "account_id" : 2518243,
        "reputation" : 210916,
        "user_id" : 2189127,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
        "display_name" : "James_D",
        "link" : "https://stackoverflow.com/users/2189127/james-d"
      },
      "creation_date" : 1760708037,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140801968,
      "post_id" : 79792525,
      "body" : "But don&#39;t you still need a separate cell class for each domain type? How would a generic cell know which <code>getX()</code> to call on the <code>PresentationModel</code>?",
      "score" : 0,
      "owner" : {
        "account_id" : 10187542,
        "reputation" : 2683,
        "user_id" : 20692967,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
        "display_name" : "Sergey Zolotarev",
        "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
      },
      "creation_date" : 1760707914,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140801949,
      "post_id" : 79792525,
      "body" : "@SergeyZolotarev The intention was just to indicate how you might implement accessing a list in a way where you wanted to be able to &quot;manually&quot; invalidate it; the natural place to do this would be within the existing application model class, which would typically have several more property-accessor and mutator (&quot;property&quot; here including complex types, such as lists, etc) methods. The class name <code>PresentationModel</code> was supposed to indicate the class was application-scoped. I added a comment to (hopefully) clarify.",
      "score" : 0,
      "owner" : {
        "account_id" : 2518243,
        "reputation" : 210916,
        "user_id" : 2189127,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
        "display_name" : "James_D",
        "link" : "https://stackoverflow.com/users/2189127/james-d"
      },
      "creation_date" : 1760707613,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140801898,
      "post_id" : 79792525,
      "body" : "Your model contained a <code>getPeople()</code> method, and the cell class similarly had the word <code>Person</code> in its name. That&#39;s why I thought you suggested models and cells that are aware of their specific domain type",
      "score" : 0,
      "owner" : {
        "account_id" : 10187542,
        "reputation" : 2683,
        "user_id" : 20692967,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
        "display_name" : "Sergey Zolotarev",
        "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
      },
      "creation_date" : 1760706554,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140801845,
      "post_id" : 79792525,
      "body" : "@SergeyZolotarev You don&#39;t create a separate model for each domain object. There should be a single model (one class and one instance of it) for the application. The model provides the view access to the domain objects. Similarly, you don&#39;t create a cell class for each domain object; you typically create a cell class for some/most complex controls such as combo boxes, lists, tables, etc. This is all standard UI architecture which is independent of the toolkit you are using.",
      "score" : 0,
      "owner" : {
        "account_id" : 2518243,
        "reputation" : 210916,
        "user_id" : 2189127,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
        "display_name" : "James_D",
        "link" : "https://stackoverflow.com/users/2189127/james-d"
      },
      "creation_date" : 1760704720,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140801253,
      "post_id" : 79792525,
      "body" : "Thank you. Though, I can&#39;t imagine creating two additional classes (the model and the cell) for <i>each</i> domain data object that can be stored in a combobox. I still believe my solution is the lesser evil",
      "score" : 0,
      "owner" : {
        "account_id" : 10187542,
        "reputation" : 2683,
        "user_id" : 20692967,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
        "display_name" : "Sergey Zolotarev",
        "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
      },
      "creation_date" : 1760686304,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79792044" : [ {
      "comment_id" : 140800360,
      "post_id" : 79792044,
      "body" : "A similar method to the &quot;no observable workaround&quot; can be achieved by wrapping the observable list of items in a trivial <code>ListBinding</code>, and then binding the combo box&#39;s items to that binding. Then instead of a custom event, you can invalidate the binding and use an invalidation listener on the list in the cells. (This just uses the binding to provide an API-based listener instead of one on a custom event.)",
      "score" : 1,
      "owner" : {
        "account_id" : 2518243,
        "reputation" : 210916,
        "user_id" : 2189127,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
        "display_name" : "James_D",
        "link" : "https://stackoverflow.com/users/2189127/james-d"
      },
      "creation_date" : 1760638352,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140800023,
      "post_id" : 79792044,
      "body" : "@SergeyZolotarev It is <i>now</i>, but it may not be in the future, when you add more features to your application. At any rate, you expose details of the view to parts of your application that should have no knowledge of it. What if you later decide not to have a combo box (e.g. you decide a list view would be better in its place)? Now you have to change code in a completely unrelated part of the application. Any explicit call to refresh the UI necessarily introduces undesirable coupling in the design.",
      "score" : 0,
      "owner" : {
        "account_id" : 2518243,
        "reputation" : 210916,
        "user_id" : 2189127,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
        "display_name" : "James_D",
        "link" : "https://stackoverflow.com/users/2189127/james-d"
      },
      "creation_date" : 1760627270,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140800006,
      "post_id" : 79792044,
      "body" : "@James_D <i>&quot;any time the property changed&quot;</i> which is <i>one</i> time, when form data is &quot;submitted&quot; (however you define it: focus loss, button clicks, etc.)",
      "score" : 0,
      "owner" : {
        "account_id" : 10187542,
        "reputation" : 2683,
        "user_id" : 20692967,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
        "display_name" : "Sergey Zolotarev",
        "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
      },
      "creation_date" : 1760626882,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140799839,
      "post_id" : 79792044,
      "body" : "@SergeyZolotarev I disagree with the assumption that using a call such as <code>combo.repaint()</code> would be less complex than the solution shown here. Where would you have to put this call? You would need to arrange for it to be called any time the property changed, which would either mean putting it in the <code>setName()</code> method, or (probably worse), including it any place in the code where you might change the <code>name</code>. This means the <code>Person</code> class, or other parts of your code, would assume the <code>Person</code> instances were being displayed in a combo box. In the long run, this would make your code more",
      "score" : 0,
      "owner" : {
        "account_id" : 2518243,
        "reputation" : 210916,
        "user_id" : 2189127,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
        "display_name" : "James_D",
        "link" : "https://stackoverflow.com/users/2189127/james-d"
      },
      "creation_date" : 1760623391,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140799342,
      "post_id" : 79792044,
      "body" : "You don&#39;t really control the painting/rendering in JavaFX, unlike in other UI frameworks like Swing (if I&#39;m not mistaken; I&#39;m not as familiar with Swing). In JavaFX, you just update state and it handles the painting/rendering for you. But that means you need a way to update the state, and in this case that is made much easier with observables. That said, some controls (not <code>ComboBox</code>) offer methods like <a href=\"https://openjfx.io/javadoc/25/javafx.controls/javafx/scene/control/ListView.html#refresh()\" rel=\"nofollow noreferrer\"><code>ListView::refresh()</code></a>, but having to use such methods typically indicates a design problem.",
      "score" : 1,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49904,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1760612336,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140799322,
      "post_id" : 79792044,
      "body" : "Thank you. Though it&#39;s way more complicated than I expected. I was hoping for some <code>combo.repaint()</code> call or something as concise",
      "score" : 0,
      "owner" : {
        "account_id" : 10187542,
        "reputation" : 2683,
        "user_id" : 20692967,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
        "display_name" : "Sergey Zolotarev",
        "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
      },
      "creation_date" : 1760611634,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}