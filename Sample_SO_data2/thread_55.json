{
  "question" : {
    "question_id" : 79842689,
    "title" : "How to optimize a complex insurance quotation workflow with multiple dependent validations and API/database calls?",
    "body" : "<p>I’m working on enhancing a life insurance quotation workflow using Spring Boot 3 with JPA/Hibernate.<br />\nThe workflow involves several dependent steps:</p>\n<ul>\n<li><p>Customer eligibility checks</p>\n</li>\n<li><p>Product → Plan → Rider hierarchy loading</p>\n</li>\n<li><p>Rule-based premium calculation</p>\n</li>\n<li><p>Age-based premium loading</p>\n</li>\n<li><p>Reinsurance or limit validations</p>\n</li>\n<li><p>Final premium aggregation</p>\n</li>\n</ul>\n<p>When multiple riders and rule sets are involved, the workflow results in several chained service calls and repeated database lookups. This causes the quotation API to respond slowly (~1.4–2 seconds).</p>\n<p>Example entity structure:</p>\n<pre><code>@Entity\npublic class Product {\n    @Id\n    private Long id;\n\n    @OneToMany(mappedBy=&quot;product&quot;)\n    private List&lt;Plan&gt; plans;\n}\n\n@Entity\npublic class Plan {\n    @Id\n    private Long id;\n\n    @ManyToOne\n    private Product product;\n\n    @OneToMany(mappedBy=&quot;plan&quot;)\n    private List&lt;Rider&gt; riders;\n}\n\n@Entity\npublic class Rider {\n    @Id\n    private Long id;\n\n    @ManyToOne\n    private Plan plan;\n}\n</code></pre>\n<p>Repository using <code>@EntityGraph</code>:</p>\n<pre><code>@Repository\npublic interface ProductRepository extends JpaRepository&lt;Product, Long&gt; {\n\n    @EntityGraph(attributePaths = {&quot;plans&quot;, &quot;plans.riders&quot;})\n    Optional&lt;Product&gt; findById(Long id);\n}\n</code></pre>\n<p>Even though I’m using <code>@EntityGraph</code>, Hibernate executes multiple SQL queries for the nested <code>plans → riders</code> collections (N+1 problem). This contributes to slow API response times (~1.4–2 seconds for quotations with multiple riders).</p>\n<p>Instead I want Hibernate to fetch the entire hierarchy in a single query, reducing the quotation API response time to under 800ms, while maintaining JPA entity mappings.</p>\n",
    "tags" : [ "java", "spring-boot", "performance", "hibernate", "spring-data-jpa" ],
    "owner" : {
      "account_id" : 36609037,
      "reputation" : 1,
      "user_id" : 27826660,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/VCrqyPDt.jpg?s=256",
      "display_name" : "Kaveesha Sanduni Kodikara",
      "link" : "https://stackoverflow.com/users/27826660/kaveesha-sanduni-kodikara"
    },
    "is_answered" : false,
    "view_count" : 53,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1765773343,
    "creation_date" : 1765354783,
    "link" : "https://stackoverflow.com/questions/79842689/how-to-optimize-a-complex-insurance-quotation-workflow-with-multiple-dependent-v",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79847390,
    "question_id" : 79842689,
    "body" : "<p>You can’t reliably force Hibernate to load <strong>multiple nested <code>@OneToMany</code> collections in a single SQL join</strong>. With <code>Product → Plan → Rider</code>, Hibernate either issues multiple queries or risks a cartesian explosion, even with <code>@EntityGraph</code>.</p>\n<p><strong>What works in practice:</strong></p>\n<ul>\n<li><p>Use <strong>batch fetching</strong> to eliminate N+1:</p>\n<pre><code>@BatchSize(size = 50)\n@OneToMany(mappedBy=&quot;product&quot;)\nprivate List&lt;Plan&gt; plans;\n\n</code></pre>\n<p>and/or <code>hibernate.default_batch_fetch_size</code>.</p>\n</li>\n<li><p>Or use <strong><code>FetchMode.SUBSELECT</code></strong> on nested collections to collapse loads into a few queries.</p>\n</li>\n<li><p>If you truly need one round-trip, <strong>fetch a DTO projection</strong> (join query) and assemble the hierarchy in memory.</p>\n</li>\n<li><p>Switching <code>List</code> → <code>Set</code> (or adding <code>@OrderColumn</code>) can also help avoid “bag” limitations.</p>\n</li>\n</ul>\n<p>For quotation workflows, DTOs + batching typically get you well under 800ms.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1807468,
      "reputation" : 335,
      "user_id" : 1644280,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f18fe15e4ebd5283482de3fc4a939058?s=256&d=identicon&r=PG",
      "display_name" : "Lavi Kumar",
      "link" : "https://stackoverflow.com/users/1644280/lavi-kumar"
    },
    "creation_date" : 1765773343,
    "last_activity_date" : 1765773343,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140895918,
    "post_id" : 79842689,
    "body" : "As mentioned in the staging ground, please add the queries this generates and the queries you want to generate (which would have pointed out \uD83D\uDC46\uD83C\uDFFB).",
    "score" : 0,
    "owner" : {
      "account_id" : 397206,
      "reputation" : 67253,
      "user_id" : 761202,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/7ed58e42118df51f78d7cecbce3a67c1?s=256&d=identicon&r=PG",
      "display_name" : "AD7six",
      "link" : "https://stackoverflow.com/users/761202/ad7six"
    },
    "creation_date" : 1765362770,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140895711,
    "post_id" : 79842689,
    "body" : "It cannot fetch the whole hierarchy in a single query. You will get a carthesian product which will explode the result set, leading to difficulty in mapping to the correct collection. Hence it does an additional query.",
    "score" : 1,
    "owner" : {
      "account_id" : 3192259,
      "reputation" : 126826,
      "user_id" : 2696260,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/qHEzx.png?s=256",
      "display_name" : "M. Deinum",
      "link" : "https://stackoverflow.com/users/2696260/m-deinum"
    },
    "creation_date" : 1765355197,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}