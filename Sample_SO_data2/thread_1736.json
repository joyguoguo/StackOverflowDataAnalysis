{
  "question" : {
    "question_id" : 79683067,
    "title" : "Search for closest-distance multi-point array in array of multi-point arrays",
    "body" : "<p>Given an arbitrary-length array of same-length arrays containing 3D points in space (i.e., multi-segment lines) within the same min/max bounds, I'm looking for fast ways to find the nearest multi-segment line to a random multi-segment line. That was a mouthful and the best way to convey the setup would be to provide an example:</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.util.Random;\n\npublic class Search {\n    static class Point {\n        static final int MAXIMUM = 100;\n        final int x;\n        final int y;\n        final int z;\n\n        Point(int x, int y, int z) {\n            this.x = verify(x);\n            this.y = verify(y);\n            this.z = verify(z);\n        }\n\n        Point(Random random) {\n            this(\n                    random.nextInt(Point.MAXIMUM),\n                    random.nextInt(Point.MAXIMUM),\n                    random.nextInt(Point.MAXIMUM));\n        }\n\n        int getDistance(Point point) {\n            return Math.abs(x - point.x) + Math.abs(y - point.y) + Math.abs(z - point.z);\n        }\n\n        static int verify(int value) {\n            if ((0 &gt; value) || (MAXIMUM &lt; value)) {\n                throw new IllegalArgumentException();\n            }\n            return value;\n        }\n    }\n\n    static class Line {\n        final Point[] points;\n\n        Line(Point[] points) {\n            this.points = points;\n        }\n\n        Line(Random random, int indices) {\n            points = new Point[indices];\n\n            for (int j = 0; j &lt; points.length; j++) {\n                points[j] = new Point(random);\n            }\n        }\n\n        int getDistance(Line line) {\n            if (points.length != line.points.length) {\n                throw new IllegalArgumentException();\n            }\n\n            int distance = 0;\n\n            for (int i = 0; i &lt; points.length; i++) {\n                distance += points[i].getDistance(line.points[i]);\n            }\n\n            return distance;\n        }\n    }\n\n    static class DataSet {\n        final int indices;\n        final Line[] lines;\n\n        DataSet(Line[] lines) {\n            // TODO - Verify all lines have the same number of points\n            indices = lines[0].points.length;\n            this.lines = lines;\n        }\n\n        DataSet(Random random) {\n            indices = 1 + random.nextInt(99);\n            lines = new Line[1 + random.nextInt(999999)];\n\n            for (int i = 0; i &lt; lines.length; i++) {\n                lines[i] = new Line(random, indices);\n            }\n        }\n\n        Line findClosest(Line line) {\n            int closestDistance = Integer.MAX_VALUE;\n            Line closestLine = null;\n\n            for (Line nextLine : lines) {\n                int distance = line.getDistance(nextLine);\n\n                if ((Integer.MAX_VALUE == closestDistance) || (distance &lt; closestDistance)) {\n                    closestDistance = distance;\n                    closestLine = nextLine;\n                }\n            }\n\n            return closestLine;\n        }\n    }\n\n    public static void main(String[] arguments) {\n        final Random random = new Random();\n        final DataSet dataSet = new DataSet(random);\n        final Line arbitraryLine1 = new Line(random, dataSet.indices);\n        final Line arbitraryLine2 = new Line(random, dataSet.indices);\n        final Line arbitraryLineM = new Line(random, dataSet.indices);\n\n        dataSet.findClosest(arbitraryLine1);\n        dataSet.findClosest(arbitraryLine2);\n        dataSet.findClosest(arbitraryLineM);\n    }\n}\n</code></pre>\n<p>The <code>findClosest</code> linear search works but I'm certain there is something faster. I believe there is no possibility of a binary search since there appears to be no way to appropriately order the data set. In looking for a better search algorithm I've turned up nothing for this use case. A k-d tree <a href=\"https://en.wikipedia.org/wiki/K-d_tree\" rel=\"noreferrer\">https://en.wikipedia.org/wiki/K-d_tree</a> looked promising but all the examples I see are for finding the closest point in a set of points to an arbitrary point. Maybe it's useful but if so, I'm not understanding how to expand it to multiple points, i.e., multi-segment lines.</p>\n<p>I used a lot of random generation here for simplification and for emphasis, but my XYZ  values are not limited to [0, 100]. I could normalize it to anything if that's useful, such as [0, 1000], [-100, 100], [-1.0, 1.0], etc.</p>\n<p>The order of the points in each line is important, but the array of lines can be sorted. That is to say, if my data set changes, I'm happy to rearrange the lines if that's required by the search algorithm.</p>\n<p>And finally, although not depicted in the code, I would like the option to find Q number of nearest lines and not solely the single closest.</p>\n<p>Can someone point me to something better, ideally in Java?</p>\n",
    "tags" : [ "java", "algorithm", "geometry" ],
    "owner" : {
      "account_id" : 4478582,
      "reputation" : 93,
      "user_id" : 4540359,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/0c3d6ba2c9047ede5bfb8eb0c46d8ce3?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "user4540359",
      "link" : "https://stackoverflow.com/users/4540359/user4540359"
    },
    "is_answered" : true,
    "view_count" : 154,
    "answer_count" : 1,
    "score" : 9,
    "last_activity_date" : 1751393734,
    "creation_date" : 1751119595,
    "link" : "https://stackoverflow.com/questions/79683067/search-for-closest-distance-multi-point-array-in-array-of-multi-point-arrays",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79684927,
    "question_id" : 79683067,
    "body" : "<blockquote>\n<p>to find the nearest multi-segment line to a random multi-segment line.</p>\n</blockquote>\n<p>We can use an octree to avoid searching through every line segment and calculating the distance to the random line segment.  Like this:</p>\n<ul>\n<li><p>Construct a octree containing all the endpoints in the array of multi-segment lines.  Each endpoint should have pointers to its one or two partners.</p>\n</li>\n<li><p>Use the octree to quickly find the nearest endpoints to the endpoints of the random multi-segment line.  There will be several of these, in general, but a tiny fraction of all the endpoints</p>\n</li>\n<li><p>Reconstruct the line segments using their partner pointers.</p>\n</li>\n<li><p>Run the usual distance between two line segments on the reconstructed line segments abd the random line segment.</p>\n</li>\n</ul>\n<p>This produces the guaranteed best result.  If you are prepared to accept the occasional sub-optimal answer, then you can simplify it further by storing in the octree the midpoint of eaxh line segment and than calculate the distance from the midpoint to the random line segment - a simpler calculation than the distance between two line segments.  How good an approximation will be depends on how long your line segments are.</p>\n<p>======================</p>\n<p>FYI here is some C++ code to build an octree from a vector of paths ( line segments )</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>void cSolver::buildOctree()\n{\n    // construct point cloud from paths of line segments\n    std::vector&lt;c3Point&gt; vp;\n    for (int path = 0; path &lt; myLines.size(); path++)\n        for (int seg = 0; seg &lt; myLines[path].size(); seg++)\n        {\n            myIndices.push_back(std::make_pair(path, seg));\n            vp.push_back(c3Point(\n                myLines[path][seg],\n                myIndices.size() - 1));\n        }\n\n    // construct octree containing point cloud\n    myOctree = new c3Cell(\n        c3Point(0, 0, 0), /// octree centered at origin\n        200,                    /// octree extent, cube with sides 200 units\n        vp);                    /// points\n}\n</code></pre>\n<p>Here is the code for quickly finding near neighbors of a point</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>void cSolver::searchOctree(const cxyz &amp;target, int extent)\n{\n    auto neighbors = myOctree-&gt;find(\n        c3Cell(\n            c3Point(target),\n            extent));\n\n    std::cout &lt;&lt; neighbors.size() &lt;&lt; &quot; points found near &quot; &lt;&lt; target.x &lt;&lt;&quot; &quot;&lt;&lt; target.y &lt;&lt;&quot; &quot;&lt;&lt; target.z &lt;&lt;&quot; \\n&quot;;\n    for (auto *p : neighbors)\n    {\n        int data = p-&gt;userData;\n        std::cout &lt;&lt; *p\n                  &lt;&lt; &quot; path:&quot; &lt;&lt; myIndices[data].first\n                  &lt;&lt; &quot;, segment:&quot; &lt;&lt; myIndices[data].second\n                  &lt;&lt; &quot;\\n&quot;;\n    }\n}\n</code></pre>\n<p>For this input, adapted from your example</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>    // path 1 [0, 0, 0], [97, 97, 97], [98, 98, 98], [99, 99, 99], [100, 100, 100], [1, 1, 1]\n\n    std::vector&lt;cxyz&gt; path1 = {\n        cxyz(0, 0, 0),\n        cxyz(97, 97, 97),\n        cxyz(98, 98, 98),\n        cxyz(99, 99, 99),\n        cxyz(100, 100, 100),\n        cxyz(1, 1, 1),\n    };\n    std::vector&lt;cxyz&gt; path2 = {\n        cxyz(0, 0, 0),\n        cxyz(100, -100, 100),\n        cxyz(200, 200, 200)};\n    myLines.push_back(path1);\n    myLines.push_back(path2);\n</code></pre>\n<p>The output is</p>\n<pre><code>4 points found near 96 96 96 \n(97,97,97) path:0, segment:1\n(98,98,98) path:0, segment:2\n(99,99,99) path:0, segment:3\n(100,100,100) path:0, segment:4\n</code></pre>\n<p>Complete code at <a href=\"https://codeberg.org/JamesBremner/Linify\" rel=\"noreferrer\">https://codeberg.org/JamesBremner/Linify</a></p>\n",
    "score" : 5,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 9061,
      "reputation" : 21190,
      "user_id" : 16582,
      "user_type" : "registered",
      "accept_rate" : 67,
      "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
      "display_name" : "ravenspoint",
      "link" : "https://stackoverflow.com/users/16582/ravenspoint"
    },
    "creation_date" : 1751294379,
    "last_activity_date" : 1751393734,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140553473,
    "post_id" : 79683067,
    "body" : "You are right.  Storing arrays of points in the octree is unnecessarily complicated.  I have posted an answer describing how I would do it.",
    "score" : 0,
    "owner" : {
      "account_id" : 9061,
      "reputation" : 21190,
      "user_id" : 16582,
      "user_type" : "registered",
      "accept_rate" : 67,
      "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
      "display_name" : "ravenspoint",
      "link" : "https://stackoverflow.com/users/16582/ravenspoint"
    },
    "creation_date" : 1751294457,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140553393,
    "post_id" : 79683067,
    "body" : "@ravenspoint You&#39;ve sent me down the rabbit hole. I&#39;ve been reading about octrees and looking at example implementations: <a href=\"https://www.wobblyduckstudios.com/Octrees.php\" rel=\"nofollow noreferrer\">wobblyduckstudios.com/Octrees.php</a> <a href=\"https://github.com/mvrozanti/octree\" rel=\"nofollow noreferrer\">github.com/mvrozanti/octree</a> and some others. I&#39;m still not seeing how to expand the point examples to arrays of points (i.e., paths as btilly nicely put it). If my paths neatly fit into an octant then I can hazily visualize, but my paths can potentially zig and zag all over the place. Am I still missing something?",
    "score" : 0,
    "owner" : {
      "account_id" : 4478582,
      "reputation" : 93,
      "user_id" : 4540359,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/0c3d6ba2c9047ede5bfb8eb0c46d8ce3?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "user4540359",
      "link" : "https://stackoverflow.com/users/4540359/user4540359"
    },
    "creation_date" : 1751292774,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140549633,
    "post_id" : 79683067,
    "body" : "An octree can be used to find anything located in a 3D space.  It all depends on what you point to in the leaves.  You can point to a 3D point, with all its attributes, or you can point to an array of points representing line segments.  In the latter you will need to be careful not to let the octree cell get smaller than the enclosing rectangle.  For simplicity, you can start by limiting the min cell size to the largest enclosing cube of all your line segments.  All of this is implementation detail.",
    "score" : 1,
    "owner" : {
      "account_id" : 9061,
      "reputation" : 21190,
      "user_id" : 16582,
      "user_type" : "registered",
      "accept_rate" : 67,
      "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
      "display_name" : "ravenspoint",
      "link" : "https://stackoverflow.com/users/16582/ravenspoint"
    },
    "creation_date" : 1751124699,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140549622,
    "post_id" : 79683067,
    "body" : "@ravenspoint An octree can be used to find nearest points. But we&#39;re not comparing points. We are comparing arrays of points, which are interpreted as a path with a fixed number of straight lines in it.",
    "score" : 1,
    "owner" : {
      "account_id" : 286249,
      "reputation" : 47816,
      "user_id" : 585411,
      "user_type" : "registered",
      "accept_rate" : 60,
      "profile_image" : "https://i.sstatic.net/xvEpe.jpg?s=256",
      "display_name" : "btilly",
      "link" : "https://stackoverflow.com/users/585411/btilly"
    },
    "creation_date" : 1751124099,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140549555,
    "post_id" : 79683067,
    "body" : "You are going to need an octree.  A octree is used to partition a three-dimensional space by recursively subdividing it into eight regions. The leaf cell contains a point.  <a href=\"https://codeberg.org/JamesBremner/quadtree/src/branch/main/README.md\" rel=\"nofollow noreferrer\">codeberg.org/JamesBremner/quadtree/src/branch/main/README.md</a>",
    "score" : 1,
    "owner" : {
      "account_id" : 9061,
      "reputation" : 21190,
      "user_id" : 16582,
      "user_type" : "registered",
      "accept_rate" : 67,
      "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
      "display_name" : "ravenspoint",
      "link" : "https://stackoverflow.com/users/16582/ravenspoint"
    },
    "creation_date" : 1751121662,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140549513,
    "post_id" : 79683067,
    "body" : "You are going to hit <a href=\"https://en.wikipedia.org/wiki/Curse_of_dimensionality\" rel=\"nofollow noreferrer\">en.wikipedia.org/wiki/Curse_of_dimensionality</a>, because each point adds more dimensions. I wouldn&#39;t be optimistic that there is a good program. Instead I&#39;d suggest a heuristic of some kind like starting with close center of masses for the shape.",
    "score" : 1,
    "owner" : {
      "account_id" : 286249,
      "reputation" : 47816,
      "user_id" : 585411,
      "user_type" : "registered",
      "accept_rate" : 60,
      "profile_image" : "https://i.sstatic.net/xvEpe.jpg?s=256",
      "display_name" : "btilly",
      "link" : "https://stackoverflow.com/users/585411/btilly"
    },
    "creation_date" : 1751120068,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79684927" : [ {
      "comment_id" : 140574935,
      "post_id" : 79684927,
      "body" : "This was a Java solution. I also wanted to eliminate recursion in the search. I initially tried solely using Manhattan distances instead of Euclidean where I had and have still not correctly implemented the former (my environment was based on Manhattan distance, hence my gravity towards this). But I&#39;ve switch to the latter and all seems well.",
      "score" : 0,
      "owner" : {
        "account_id" : 4478582,
        "reputation" : 93,
        "user_id" : 4540359,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/0c3d6ba2c9047ede5bfb8eb0c46d8ce3?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "user4540359",
        "link" : "https://stackoverflow.com/users/4540359/user4540359"
      },
      "creation_date" : 1752005924,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140574687,
      "post_id" : 79684927,
      "body" : "&quot; Java supports interfacing with C and C++ via the JNI (Java Native Interface)&quot;  Did you use this to leverage my Octree code?  Maybe, instead, you tried to spin up your own Octree in Java code, which would indeed be a challenge.",
      "score" : 0,
      "owner" : {
        "account_id" : 9061,
        "reputation" : 21190,
        "user_id" : 16582,
        "user_type" : "registered",
        "accept_rate" : 67,
        "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
        "display_name" : "ravenspoint",
        "link" : "https://stackoverflow.com/users/16582/ravenspoint"
      },
      "creation_date" : 1752000416,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140574660,
      "post_id" : 79684927,
      "body" : "Well done!  I am curious as to why this seemed to be difficult for your &quot;environment&quot;  Do you mean Java?  Or did something else make difficulties for you?",
      "score" : 0,
      "owner" : {
        "account_id" : 9061,
        "reputation" : 21190,
        "user_id" : 16582,
        "user_type" : "registered",
        "accept_rate" : 67,
        "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
        "display_name" : "ravenspoint",
        "link" : "https://stackoverflow.com/users/16582/ravenspoint"
      },
      "creation_date" : 1752000075,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140574644,
      "post_id" : 79684927,
      "body" : "OK, finally I was able to hobble together a working adaptation for my environment but it follows your general solution outline. This is a big improvement to my linear search. Thank you for your help!",
      "score" : 0,
      "owner" : {
        "account_id" : 4478582,
        "reputation" : 93,
        "user_id" : 4540359,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/0c3d6ba2c9047ede5bfb8eb0c46d8ce3?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "user4540359",
        "link" : "https://stackoverflow.com/users/4540359/user4540359"
      },
      "creation_date" : 1751999793,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140556982,
      "post_id" : 79684927,
      "body" : "I&#39;ll adapt an implementation to my environment and report back.",
      "score" : 0,
      "owner" : {
        "account_id" : 4478582,
        "reputation" : 93,
        "user_id" : 4540359,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/0c3d6ba2c9047ede5bfb8eb0c46d8ce3?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "user4540359",
        "link" : "https://stackoverflow.com/users/4540359/user4540359"
      },
      "creation_date" : 1751410969,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140556507,
      "post_id" : 79684927,
      "body" : "So, on the first pass, set the search extent to half the length of the longest segment.",
      "score" : 0,
      "owner" : {
        "account_id" : 9061,
        "reputation" : 21190,
        "user_id" : 16582,
        "user_type" : "registered",
        "accept_rate" : 67,
        "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
        "display_name" : "ravenspoint",
        "link" : "https://stackoverflow.com/users/16582/ravenspoint"
      },
      "creation_date" : 1751392333,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140556499,
      "post_id" : 79684927,
      "body" : "I think the extent of the search you choose should be based on your performance requirement.  If it is too small then your risk missing the closest segment with endpoints far away.  If it is too large you will have to calculate too many distances between segments.  It will depend on how long your segments are.  I imagine that if you have long segments, you should break the long ones up into multiple segments.   Parameter fine tuning will be required.",
      "score" : 0,
      "owner" : {
        "account_id" : 9061,
        "reputation" : 21190,
        "user_id" : 16582,
        "user_type" : "registered",
        "accept_rate" : 67,
        "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
        "display_name" : "ravenspoint",
        "link" : "https://stackoverflow.com/users/16582/ravenspoint"
      },
      "creation_date" : 1751392165,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140556426,
      "post_id" : 79684927,
      "body" : "<code>If 0 found, then iteratively increase until I get 1 or Q neighbors?</code> Well, until I get the desired number of results is what I mean.",
      "score" : 0,
      "owner" : {
        "account_id" : 4478582,
        "reputation" : 93,
        "user_id" : 4540359,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/0c3d6ba2c9047ede5bfb8eb0c46d8ce3?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "user4540359",
        "link" : "https://stackoverflow.com/users/4540359/user4540359"
      },
      "creation_date" : 1751390117,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140556381,
      "post_id" : 79684927,
      "body" : "Thank you for further investigation. I misunderstood your statement, &quot;Construct a octree containing all the endpoints in the array of multi-segment lines&quot; thinking you meant the first and last points of each path. So with <code>[0, 0, 0], [97, 97, 97], [98, 98, 98], [99, 99, 99], [100, 100, 100], [1, 1, 1]</code> that would be <code>[0, 0, 0]</code> and <code>[1, 1, 1]</code>, but you mean effectively all points in all paths. Got it. So I should select some carefully chosen <code>extent</code> that hopes to include at least some neighbors but not too many. If 0 found, then iteratively increase until I get 1 or Q neighbors?",
      "score" : 0,
      "owner" : {
        "account_id" : 4478582,
        "reputation" : 93,
        "user_id" : 4540359,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/0c3d6ba2c9047ede5bfb8eb0c46d8ce3?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "user4540359",
        "link" : "https://stackoverflow.com/users/4540359/user4540359"
      },
      "creation_date" : 1751388736,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140555946,
      "post_id" : 79684927,
      "body" : "Added demo code to answer.",
      "score" : 0,
      "owner" : {
        "account_id" : 9061,
        "reputation" : 21190,
        "user_id" : 16582,
        "user_type" : "registered",
        "accept_rate" : 67,
        "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
        "display_name" : "ravenspoint",
        "link" : "https://stackoverflow.com/users/16582/ravenspoint"
      },
      "creation_date" : 1751378880,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140555812,
      "post_id" : 79684927,
      "body" : "Thanks for the update.  The paths look more like paths :)  But, what&#39;s with   <code>[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]</code>  This is just one point and both paths go through that point exactly.",
      "score" : 0,
      "owner" : {
        "account_id" : 9061,
        "reputation" : 21190,
        "user_id" : 16582,
        "user_type" : "registered",
        "accept_rate" : 67,
        "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
        "display_name" : "ravenspoint",
        "link" : "https://stackoverflow.com/users/16582/ravenspoint"
      },
      "creation_date" : 1751376010,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140555761,
      "post_id" : 79684927,
      "body" : "They were intended to confirm my understanding. I chose values that obviously convey the relationships of the endpoints vs the relationships of the path closeness, and highlight what I pondered might be discrepancies of the approach. If you don&#39;t want repeats, no problem- path 1 is <code>[0, 0, 0], [97, 97, 97], [98, 98, 98], [99, 99, 99], [100, 100, 100], [1, 1, 1]</code> and path 2 <code>[99, 99, 99], [0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [100, 100, 100]</code>. It shouldn&#39;t matter because you said &quot;guaranteed&quot; which would mean in <i>all</i> cases. But it&#39;s looking like it isn&#39;t even necessarily in <i>most</i> cases.",
      "score" : 0,
      "owner" : {
        "account_id" : 4478582,
        "reputation" : 93,
        "user_id" : 4540359,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/0c3d6ba2c9047ede5bfb8eb0c46d8ce3?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "user4540359",
        "link" : "https://stackoverflow.com/users/4540359/user4540359"
      },
      "creation_date" : 1751374914,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140555574,
      "post_id" : 79684927,
      "body" : "Your example is wierd.  Most of the line segments are zero length.  The so-called random path just the origin repeated multiple times. The paths just shuttle from and back from the same two points.  It is nonsense.",
      "score" : 0,
      "owner" : {
        "account_id" : 9061,
        "reputation" : 21190,
        "user_id" : 16582,
        "user_type" : "registered",
        "accept_rate" : 67,
        "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
        "display_name" : "ravenspoint",
        "link" : "https://stackoverflow.com/users/16582/ravenspoint"
      },
      "creation_date" : 1751370648,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140554562,
      "post_id" : 79684927,
      "body" : "@user4540359 That was supposed to end with, &quot;No?&quot;",
      "score" : 0,
      "owner" : {
        "account_id" : 4478582,
        "reputation" : 93,
        "user_id" : 4540359,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/0c3d6ba2c9047ede5bfb8eb0c46d8ce3?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "user4540359",
        "link" : "https://stackoverflow.com/users/4540359/user4540359"
      },
      "creation_date" : 1751335646,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140554346,
      "post_id" : 79684927,
      "body" : "My data set example is a bit contrived with only 2 paths. But if I understand, your implementation filters in for comparison only the data set paths with the nearest endpoints. Conversely, it filters out data set paths with non-nearest endpoints. Given my example, the algorithm would filter in and ultimately select path 1 given that its endpoints are nearest (and in this case actually matching) whereas it would filter out path 2 given that its endpoints are not nearest (and in this case actually the farthest possible, assuming 100 is the maximum), even though path 2 is closest. No",
      "score" : 0,
      "owner" : {
        "account_id" : 4478582,
        "reputation" : 93,
        "user_id" : 4540359,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/0c3d6ba2c9047ede5bfb8eb0c46d8ce3?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "user4540359",
        "link" : "https://stackoverflow.com/users/4540359/user4540359"
      },
      "creation_date" : 1751322457,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140554281,
      "post_id" : 79684927,
      "body" : "Note that the octree does not give you just the very closest point, it gives you the subset of points that are closest to the search point, so you can limit your calculations only to relevant line segments.  When you follow the last two steps of the algorithm, you will get the line segment that is closest.",
      "score" : 0,
      "owner" : {
        "account_id" : 9061,
        "reputation" : 21190,
        "user_id" : 16582,
        "user_type" : "registered",
        "accept_rate" : 67,
        "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
        "display_name" : "ravenspoint",
        "link" : "https://stackoverflow.com/users/16582/ravenspoint"
      },
      "creation_date" : 1751319029,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140553725,
      "post_id" : 79684927,
      "body" : "Interesting. I think I follow the implementation. However, you said &quot;This produces the guaranteed best result.&quot; Given a data set of path 1 <code>[0, 0, 0], [100, 100, 100], [100, 100, 100], [100, 100, 100], [100, 100, 100], [0, 0, 0]</code>  and path 2 <code>[100, 100, 100], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [100, 100, 100]</code>, given your setup won&#39;t random path <code>[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]</code> match path 1 since its endpoints are closest, even though as a whole the closest match is path 2?",
      "score" : 0,
      "owner" : {
        "account_id" : 4478582,
        "reputation" : 93,
        "user_id" : 4540359,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/0c3d6ba2c9047ede5bfb8eb0c46d8ce3?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "user4540359",
        "link" : "https://stackoverflow.com/users/4540359/user4540359"
      },
      "creation_date" : 1751299768,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}