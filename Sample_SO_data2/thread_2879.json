{
  "question" : {
    "question_id" : 79590636,
    "title" : "Are there any jOOQ conventions on how to batch-insert 1 to n relations to the database?",
    "body" : "<p>I regularly face the use case in our backend application that it needs to save a lot of data at once that is scattered around multiple tables, but mostly its a 1 to n relationship, or recursive data structures.</p>\n<p>I need to do a batch-insert, because in some cases individual inserts are too slow, but to insert data to the second table, I need the generated ids from the first table to project the relationship correctly.</p>\n<p>Right now I just batch insert the first table and then assign the returned ids to the records that belong in the second table. (See Example below)</p>\n<p>I don't really like this approach, because I have no idea if:</p>\n<ul>\n<li>The returned Ids are correctly ordered (or if there is different behaviour based on the database or database configuration or other side effects from triggers or stored procedures)</li>\n<li>The database inserts the data in the exact order how they are ordered in the insert statement</li>\n<li>I need to write a lot of boilerplate code, there might be an easier solution that I don't see right now</li>\n<li>Worst case is that I reference the wrong data</li>\n</ul>\n<p>So my question is:</p>\n<p>Is there a best practice way to batch insert such data structures fast with jOOQ, without blindly relying on the order of data, or how the database beneath handles the data?</p>\n<ul>\n<li>Should I play it safe, scrap the idea and should always insert the data sequentially? (Author 1 -&gt; Books, Author 2 -&gt; Books ...)</li>\n<li>Should I use an extra column to connect entries and fill these beforehand, so that the autogenerated ids are not needed for this step?\n<ul>\n<li>We want to try this approach with uuids, but are unsure how that affects performance</li>\n</ul>\n</li>\n</ul>\n<p><strong>Batch Example:</strong></p>\n<pre><code>+------------+        writes        +-------------+\n|  Authors   |---------------------&lt;|   Books     |\n+------------+        (1:N)         +-------------+\n| author_id  |                      | book_id     |\n| name       |                      | title       |\n| bio        |                      | author_id*  |\n+------------+                      +-------------+\n</code></pre>\n<pre><code>--MySQL\ncreate table author\n(\n    id    bigint auto_increment primary key,\n    name  varchar(32) not null,\n    bio   varchar(32) not null\n);\n\ncreate table book\n(\n    id bigint auto_increment primary key,\n    title varchar(32) not null,\n    author_id bigint not null,\n    constraint fk_author_book\n        foreign key (author_id) references author (id)\n            on delete cascade\n)\n</code></pre>\n<p>In order to persist the books, we need the author_ids first, so currently we do that:</p>\n<pre class=\"lang-java prettyprint-override\"><code>List&lt;Author&gt; authors =\n        List.of(\n                new Author(&quot;Author 1&quot;, &quot;Bio 1&quot;, List.of(new Book(&quot;Book1&quot;), new Book(&quot;Book2&quot;))),\n                new Author(&quot;Author 2&quot;, &quot;Bio 2&quot;, List.of(new Book(&quot;Book3&quot;), new Book(&quot;Book4&quot;))),\n                new Author(&quot;Author 3&quot;, &quot;Bio 3&quot;, List.of(new Book(&quot;Book5&quot;), new Book(&quot;Book6&quot;)))\n        );\n\nvar authorIDs = jooq.insertInto(AUTHOR,\n                                AUTHOR.ID,\n                                AUTHOR.NAME,\n                                AUTHOR.BIO\n                    )\n                    .valuesOfRecords(authors.stream()\n                                            .map(author -&gt; new AuthorRecord((Long) null, author.name, author.bio))\n                                            .collect(Collectors.toList()))\n                    .returningResult(AUTHOR.ID)\n                    .fetchInto(Long.class);\n\nvar bookRecords = new LinkedList&lt;BookRecord&gt;();\nfor (int i = 0; i &lt; authorIDs.size(); i++) {\n    var authorId = authorIDs.get(i);\n    for (var book : authors.get(i).books) {\n    // Here is the culprit, we rely on the ids and inserted rows to be in the correct order, \n    // otherwise we link wrong data together\n        bookRecords.add(new BookRecord((Long) null, book.name, authorId));\n    }\n}\n\njooq.insertInto(BOOK,\n                BOOK.ID,\n                BOOK.TITLE,\n                BOOK.AUTHOR_ID\n    )\n    .valuesOfRecords(bookRecords)\n    .execute();\n</code></pre>\n<p><strong>Sequential Approach with prepared statements</strong></p>\n<p>We also tried a &quot;sequential&quot; approach with two prepared statements, but the performance is a lot worse with a lot of data (~45 seconds vs. 1.5 seconds with 20k authors with 2 books each, the same logic without keepStatement(true) took ~56 seconds)</p>\n<pre class=\"lang-java prettyprint-override\"><code>private void preparedStatement(List&lt;Author&gt; authors) {  \n    try (var insertAuthorQuery =  \n                 jooq.insertInto(AUTHOR,  \n                                 AUTHOR.ID,  \n                                 AUTHOR.NAME,  \n                                 AUTHOR.BIO)  \n                     .values((Long) null, null, null)  \n                     .returningResult(AUTHOR.ID)  \n                     .keepStatement(true)  \n    ) {  \n        try (var insertBookQuery =  \n                     jooq.insertInto(BOOK,  \n                                     BOOK.ID,  \n                                     BOOK.TITLE,  \n                                     BOOK.AUTHOR_ID  \n                         ).values((Long) null, null, null)  \n                         .returningResult(BOOK.ID)  \n                         .keepStatement(true)) {  \n            authors.forEach(author -&gt; {  \n\n                insertAuthorQuery.getBindValues();  \n                insertAuthorQuery.bind(2, author.name);  \n                insertAuthorQuery.bind(3, author.bio);  \n  \n                var authorID = insertAuthorQuery.fetchOneInto(Long.class);  \n  \n                author.books.forEach(book -&gt; {  \n                    insertBookQuery.bind(2, book.name);  \n                    insertBookQuery.bind(3, authorID);  \n                    insertBookQuery.execute();  \n                });  \n            });  \n        }  \n    }  \n}\n</code></pre>\n",
    "tags" : [ "java", "mysql", "jooq" ],
    "owner" : {
      "account_id" : 14293669,
      "reputation" : 1,
      "user_id" : 30338467,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/c940c98aebe6f380c0937ec8225d2652?s=256&d=identicon&r=PG",
      "display_name" : "xnn",
      "link" : "https://stackoverflow.com/users/30338467/xnn"
    },
    "is_answered" : false,
    "view_count" : 101,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1745498778,
    "creation_date" : 1745498778,
    "link" : "https://stackoverflow.com/questions/79590636/are-there-any-jooq-conventions-on-how-to-batch-insert-1-to-n-relations-to-the-da",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140639795,
    "post_id" : 79590636,
    "body" : "&lt;snide&gt;Yet another example of how the framework can be more hassle than going directly to the database.&lt;/snide&gt;  Seriously; there are more than 100 frameworks; good luck on finding someone who can help this this Question.",
    "score" : 0,
    "owner" : {
      "account_id" : 529143,
      "reputation" : 143656,
      "user_id" : 1766831,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/1ee974306d2def46eb69534fbcf95cc5?s=256&d=identicon&r=PG",
      "display_name" : "Rick James",
      "link" : "https://stackoverflow.com/users/1766831/rick-james"
    },
    "creation_date" : 1754283681,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140365804,
    "post_id" : 79590636,
    "body" : "Query 1 - insert all authors only. Query 2 - insert all books, query author_id from authors table. On MySQL side this may look like <a href=\"https://dbfiddle.uk/7eM0a3cx\" rel=\"nofollow noreferrer\">dbfiddle.uk/7eM0a3cx</a> or <a href=\"https://dbfiddle.uk/FPugAKX0\" rel=\"nofollow noreferrer\">dbfiddle.uk/FPugAKX0</a> PS. author.name or (author.name, author.bio) must be unique.",
    "score" : 0,
    "owner" : {
      "account_id" : 9744358,
      "reputation" : 43176,
      "user_id" : 10138734,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/sf6Zj.jpg?s=256",
      "display_name" : "Akina",
      "link" : "https://stackoverflow.com/users/10138734/akina"
    },
    "creation_date" : 1745504068,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140365637,
    "post_id" : 79590636,
    "body" : "Yeah, its just a minimal example to outline the problem.",
    "score" : 0,
    "owner" : {
      "account_id" : 14293669,
      "reputation" : 1,
      "user_id" : 30338467,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/c940c98aebe6f380c0937ec8225d2652?s=256&d=identicon&r=PG",
      "display_name" : "xnn",
      "link" : "https://stackoverflow.com/users/30338467/xnn"
    },
    "creation_date" : 1745501722,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140365538,
    "post_id" : 79590636,
    "body" : "Are you sure, that this is an 1:N relation? What happens if a book have 2 or more authors?",
    "score" : 0,
    "owner" : {
      "account_id" : 12005380,
      "reputation" : 3764,
      "user_id" : 8783885,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/fvEUy.png?s=256",
      "display_name" : "Wiimm",
      "link" : "https://stackoverflow.com/users/8783885/wiimm"
    },
    "creation_date" : 1745500575,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}