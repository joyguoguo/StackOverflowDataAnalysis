{
  "question" : {
    "question_id" : 79843739,
    "title" : "Quarkus native compilation requires explicit declaration of Classes to be registered for Reflection",
    "body" : "<p>I'm using Quarkus enabling native compilation. At runtime I noticed some exceptions that required me to register classes for reflection e.g:</p>\n<pre><code>@RegisterForReflection(    \n   targets = { MyClass.class, MyClass2.class, ...\n</code></pre>\n<p>This solved the runtime issue.</p>\n<p>However this approach doesn't scale and seems unsafe. In some cases I might have a lot of classes requiring registration and of course doing it manually/explicitly creates the risk of missing one class and thus  eventually getting a runtime exception.</p>\n<p>Is there a best pratice around this?</p>\n",
    "tags" : [ "java", "reflection", "quarkus", "quarkus-native" ],
    "owner" : {
      "account_id" : 29337457,
      "reputation" : 1,
      "user_id" : 22477554,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/AAcHTteOK1VyoTk7fspaK1eteY_d6J_g_T35N9Pnn44x6BlU=k-s256",
      "display_name" : "dev4fun",
      "link" : "https://stackoverflow.com/users/22477554/dev4fun"
    },
    "is_answered" : true,
    "view_count" : 43,
    "answer_count" : 2,
    "score" : 0,
    "last_activity_date" : 1765530888,
    "creation_date" : 1765440392,
    "link" : "https://stackoverflow.com/questions/79843739/quarkus-native-compilation-requires-explicit-declaration-of-classes-to-be-regist",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79843813,
    "question_id" : 79843739,
    "body" : "<p>It's worth looking at your use case and thinking about whether you actually need native compilation. Even in JVM mode, Quarkus has impressively fast startup and low memory usage, without the effort of native compilation. JVM mode also has higher throughput than native, so for high-load scenarios, it's almost always a better choice.</p>\n<p>Having said that, for some use cases, native definitely is best. For example, for command line applications, or serverless scenarios, or applications with very low load, native is a great fit. For most common libraries, Quarkus has pre-built integrations which handle the support for native mode (the full list is at <a href=\"https://quarkus.io/extensions/\" rel=\"nofollow noreferrer\">https://quarkus.io/extensions/</a>).</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1115215,
      "reputation" : 11642,
      "user_id" : 1104727,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/4298a3f5e864fa84f25b90f48288c0d4?s=256&d=identicon&r=PG",
      "display_name" : "Holly Cummins",
      "link" : "https://stackoverflow.com/users/1104727/holly-cummins"
    },
    "creation_date" : 1765446766,
    "last_activity_date" : 1765446766,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79844717,
    "question_id" : 79843739,
    "body" : "<p>You can use the <a href=\"https://quarkus.io/guides/native-reference#native-image-agent-integration\" rel=\"nofollow noreferrer\">native-image-agent</a>.</p>\n<p>The agent watches the jvm during unit tests and automatically extracts reflection config.</p>\n<p>There is still a risk that your image may break if you add new classes that are not invoked as part of your unit tests, but if you have good test coverage you should be good.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1897626,
      "reputation" : 625,
      "user_id" : 1714215,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/3abb95824343323bac48dec1c2d6df48?s=256&d=identicon&r=PG",
      "display_name" : "Jens M&#248;ller",
      "link" : "https://stackoverflow.com/users/1714215/jens-m%c3%b8ller"
    },
    "creation_date" : 1765530888,
    "last_activity_date" : 1765530888,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}