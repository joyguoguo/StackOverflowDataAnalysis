{
  "question" : {
    "question_id" : 79776868,
    "title" : "Why is Java unable to infer the type when comparing Map.Entry objects?",
    "body" : "<p>Why does the following cause a compilation error?</p>\n<p>One</p>\n<pre><code>Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n    List&lt;Integer&gt; numList = map.entrySet().stream()\n            .sorted(Comparator.comparing(Map.Entry::getValue).reversed())  //this part\n            .map(Map.Entry::getKey)\n            .toList();\n</code></pre>\n<p>Error:</p>\n<pre><code>java: incompatible types: cannot infer type-variable(s) T,U\n(argument mismatch; invalid method reference\n  method getValue in interface java.util.Map.Entry&lt;K,V&gt; cannot be applied to given types\n    required: no arguments\n    found:    java.lang.Object\n    reason: actual and formal argument lists differ in length)\n</code></pre>\n<p>But why are the following snippets working fine?</p>\n<p>Two</p>\n<pre><code>Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n    List&lt;Integer&gt; numList = map.entrySet().stream()\n            .sorted(Comparator.comparing(Map.Entry&lt;Integer, Integer&gt;::getValue).reversed())\n            .map(Map.Entry::getKey)\n            .toList();\n</code></pre>\n<p>Three</p>\n<pre><code>Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n    List&lt;Integer&gt; numList = map.entrySet().stream()\n            .sorted(Comparator.comparing(Map.Entry::getValue))\n            .map(Map.Entry::getKey)\n            .toList();\n</code></pre>\n<p>It seems like <code>sorted()</code> needs a <code>Comparator&lt;Map.Entry&lt;Integer, Integer&gt;</code>. But why are no generics needed in case Three? Does Java infer the type <code>Map.Entry&lt;Integer, Integer&gt;</code>? If so, why can't Java infer the type in case One?</p>\n",
    "tags" : [ "java", "generics" ],
    "owner" : {
      "account_id" : 35631705,
      "reputation" : 93,
      "user_id" : 27317649,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/6be1264537ed1be1887d9e52f22a8e2f?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Joshua",
      "link" : "https://stackoverflow.com/users/27317649/joshua"
    },
    "is_answered" : true,
    "view_count" : 193,
    "answer_count" : 2,
    "score" : 9,
    "last_activity_date" : 1760368954,
    "creation_date" : 1758988755,
    "link" : "https://stackoverflow.com/questions/79776868/why-is-java-unable-to-infer-the-type-when-comparing-map-entry-objects",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79776899,
    "question_id" : 79776868,
    "body" : "<p>It's.. complicated.</p>\n<h2>I just want to get on with it</h2>\n<p>The short answer is: Because the specification says so and it's unlikely to change anytime soon. You will simply have to ensure the type system knows what the full type of that function is, which you can do with explicit <code>&lt;Integer, Integer&gt;</code> as you did in snippet 2, or by assigning the function first:</p>\n<pre><code>Function&lt;Map.Entry&lt;Integer, Integer&gt;, Integer&gt; entryToValue = Map.Entry::getValue;\n\nvar map = new HashMap&lt;Integer, Integer&gt;();\nList&lt;Integer&gt; numList = map.entrySet().stream()\n            .sorted(Comparator.comparing(entryToValue).reversed())\n            .map(Map.Entry::getKey)\n            .toList();\n</code></pre>\n<p>That's probably not what you were looking for (the above is quite a bit longer and still effectively requires a whole bunch of types in <code>&lt;&gt;</code>; you cannot just replace that very first variable declaration with <code>var</code>).</p>\n<h2>I want to know why</h2>\n<p>The way lambdas (either <code>::</code> or <code>-&gt;</code> based) work in Java is that the concept does not <em>itself</em> have any type. We can witness this:</p>\n<pre><code>Object o = () -&gt; System.out.println(&quot;Hello, World!&quot;);\n</code></pre>\n<p>Does not compile.</p>\n<p>Instead the way lambdas work in Java is that they must be 'retrofitabble' into a so-called &quot;functional type&quot;, and they simply <em>are that</em>. Which is why this <em>does</em> work:</p>\n<pre><code>Runnable r = () -&gt; System.out.println(&quot;Hello, World!&quot;);\n// or\nObject o = (Runnable) () -&gt; System.out.println(&quot;Hello, World!&quot;);\n</code></pre>\n<p>But, lambdas <em>also</em> allow you to omit the variable name. You can write:</p>\n<pre><code>Consumer&lt;String&gt; printer = x -&gt; System.out.println(x);\n</code></pre>\n<p>and you do not <em>have to</em> write <code>String x</code> there. You can just leave it. But, <code>x</code> <strong>is</strong> a string. The compiler 'figured it out'. It can only do that if it already knows that functional type.</p>\n<h2>Inside out, outside in</h2>\n<p>Ordinarily expressions are resolved inside out. Take <code>2 + 2</code> for example. In Java, <code>+</code> has 2 completely, totally unrelated meanings: 'add 2 numbers together' and 'concatenate 2 strings'. The compiler figures out which one you meant by working 'inside out'. If you write <code>(foo.getBar().getBaz() + 5)</code>, it will <strong>first</strong> figure out what <code>foo.getBar().getBaz()</code> is, and only then figure out what that + means (it'd be string concat if getBaz returns a string, addition if it returns a number, and a compiler error if it returns anything else). In fact, this is turtles all the way down: To know what <code>foo.getBar().getBaz()</code> means, the compiler first figures out what <code>foo.getBar()</code> means and finally to figure <em>that</em> out, it figures out what <code>foo</code> is (what type it has), and only then does the compiler actually know what you tried to do there and can compile it.</p>\n<p>But with lambdas, that cannot work. The compiler cannot look at <code>x -&gt; System.out.println(x)</code> and figure out that this is a <code>Consumer&lt;String&gt;</code>. It can be many things. There are an infinite amount of types in existence that 'take 1 argument and return void'. From context we don't even know the type of x, so there's no possibility to delve in. In fact, imagine this:</p>\n<pre><code>class Example {\n  static String method1(Integer x) { return &quot;&quot;; }\n  static AtomicInteger method1(Boolean y) { return new AtomicInteger(); }\n}\n</code></pre>\n<p>The code <code>v -&gt; Example.method1(v)</code> - what is the signature of that? It's not possible to tell. It's perhaps a <code>Function&lt;Integer, String&gt;</code>, but it could also be a <code>Function&lt;Boolean, AtomicInteger&gt;</code>.</p>\n<p>Hence, in lambdas specifically, <strong>javac must go outside in instead of the usual inside out</strong>. Javac needs to treat the entire lambda as a schr√∂dinger's function, with no idea about the signature of it, and instead do work on the outside to attempt to figure it out, and only then can it go 'back' and work on the lambda again.</p>\n<p>But this process is ambiguous. Imagine this situation:</p>\n<pre><code>void foo(Function&lt;Integer, String&gt; processor) {}\nvoid foo(Function&lt;Boolean, AtomicInteger&gt; processor) {}\n</code></pre>\n<p>See footnote <sup>[1]</sup></p>\n<p>and then the Java code:</p>\n<pre><code>foo(v -&gt; Example.method1(v));\n</code></pre>\n<p>That code can literally mean 2 <em>completely</em> different things and both are equally valid. The compiler <em>obviously</em> <strong>has to</strong> end in an error here somehow.</p>\n<p>In theory this code:</p>\n<pre><code>foo(v -&gt; Example.method1(v &lt; 0 ? &quot;Neg&quot; : &quot;Pos&quot;));\n</code></pre>\n<p>Is no longer ambiguous, but it would be <strong>very</strong> difficult for the compiler to figure that out. It'd have to essentially try all permutations, realise that all-but-1 end in a compiler error, and then presume that the programmer must know what they are doing and therefore conclude that surely they meant the <code>Integer, String</code> 'version' of what this could mean.</p>\n<p>The compiler does not do that and I rather doubt it ever would.</p>\n<h2>So why <em>does</em> it work in case 3?</h2>\n<p>And now we finally get to the answer. In case 3 it works because the compiler can 'get there', to an unambiguous answer as to what the lambda must be, <em>without</em> having to go inside-out and outside-in simultaneously (which it will not do).</p>\n<p>When the compiler is working on figuring out what:</p>\n<pre><code>            .sorted(Comparator.comparing(Map.Entry::getValue))\n</code></pre>\n<p>means, it does <strong>not</strong> need to worry in any way about trying to disentangle what the signature of that <code>Map.Entry::getValue</code> lambda is meant to be; it can figure it out without knowing this. It knows: Well, <code>sorted</code> is in this case being invoked on a stream of <code>Map.Entry&lt;Integer, Integer&gt;</code> objects (<em>that</em> it can figure out), therefore the only <code>Comparator.comparing</code> call that makes sense here is the one with signature <code>comparing(Function&lt;? super T, ? extends U&gt;)</code>, plugging in the known types: <code>comparing(Function&lt;? super Map.Entry&lt;Integer, X extends Comparable&lt;X&gt;&gt;)</code>, so it can bring that still quite complicated bunch of types to bear on finally tackling 'how do I parse this lambda' and gets there.</p>\n<p>Now we add the <code>.reversed()</code>:</p>\n<pre><code>            .sorted(Comparator.comparing(Map.Entry::getValue).reversed())\n</code></pre>\n<p>and now this no longer compiles. The outside-in approach brings all the plugged-in generics to bear, but has to then attempt to apply this to the <code>.reversed()</code> method and work backwards from <em>that</em>, which is a bridge too far for the compiler.</p>\n<p>In theory some future Java version could be updated to actually (try to) type-analyse so deeply that it would actually figure out. But, if you do that, you get into the territory of a compiler that hangs for years (literally) during the type analysis phase. This is not that hard to do with e.g. the Scala compiler for example. That's bad and it's one of the reasons I somewhat doubt javac will ever try to add the necessary amount of analysis that the situation will ever be different. Separate from the obvious downsides of having a compiler that can take a decade to parse a source file, the extensive Java ecosystem isn't designed for it. IDEs don't, generally, have a 'cancel' button or baked in timeouts.</p>\n<hr />\n<p><sup>[1]</sup> Due to the rules about method overloading, where it's not allowed if the difference exists solely in the generics, this wouldn't compile. But you can trivially make a copy of <code>java.util.function.Function</code> and now it would compile and is just as ambiguous. Adding this detail seemed unnecessarily complicated to something that is already smacking of rocket science.</p>\n",
    "score" : 11,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107206,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1758991716,
    "last_activity_date" : 1760368954,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79776906,
    "question_id" : 79776868,
    "body" : "<p>The reason the first one doesn't work is because of the <a href=\"https://docs.oracle.com/javase/tutorial/java/generics/rawTypes.html\" rel=\"nofollow noreferrer\">Raw Type</a>.</p>\n<p>The reason Case 2 works is because you use <code>Map.Entry&lt;Integer,Integer&gt;</code> to set the type reference.</p>\n<p>The reason Case 3 Works is because you do not use <code>.reversed()</code>. Without <code>.reversed()</code> The compiler can infer the generic type directly from the context (a longer conversation), but with <code>.reversed()</code> the type inference has to resolve before the reversal which forces the Error in <code>Map.Entry::getValue</code> to the fore front.</p>\n",
    "score" : 4,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 13135688,
      "reputation" : 41,
      "user_id" : 9488755,
      "user_type" : "registered",
      "profile_image" : "https://lh4.googleusercontent.com/-XlfcokQqVD8/AAAAAAAAAAI/AAAAAAAAABE/0NVa-eT2KLE/s256-rj/photo.jpg",
      "display_name" : "Brandon Anderson",
      "link" : "https://stackoverflow.com/users/9488755/brandon-anderson"
    },
    "creation_date" : 1758992645,
    "last_activity_date" : 1758994603,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}