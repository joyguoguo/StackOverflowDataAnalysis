{
  "question" : {
    "question_id" : 79755051,
    "title" : "Spring boot ConfigurationProperties map yaml reference anchors to the same object instances",
    "body" : "<p>I have a class <code>APIProperties</code> that is being configured by a yaml file via Spring boot's @ConfigurationProperties decorator:</p>\n<p>ex:</p>\n<pre><code>@Data\n@ConfigurationProperties(prefix = &quot;api&quot;)\npublic class APIProperties {\n    private List&lt;ClassA&gt; classAs;\n    private List&lt;ClassB&gt; classBs;\n}\n\n@Data\npublic class ClassA {\n    private String name;\n    private List&lt;ClassB&gt; classBs;\n}\n\n@Data\npublic class ClassB {\n    private String name;\n    private String data;\n}\n</code></pre>\n<p>config yaml:</p>\n<pre><code>api:\n  classBs:\n    - &amp;B1\n      name: instanceB1\n      data: foo\n    - &amp;B2\n      name: instanceB2\n      data: bar\n  classAs:\n    - name: instanceA1\n      classBs:\n        - *B1\n    - name: instanceA2\n      classBs:\n        - *B1\n</code></pre>\n<p>What I need is for all of the references to *B1 to map to the same instance of an object after the application context is loaded. What I am seeing instead is that three different instances of classB are created, all with the same values for <code>name</code> and <code>data</code>. Is there any way to accomplish this automatically with spring boot and configurationproperties or some similar setup?</p>\n<p>I have tried a couple approaches so far. The first is to add a @PostConstruct init function to APIProperties which will go through all the <code>ClassA</code>'s and replace each <code>ClassB</code> in the its list of <code>classBs</code> with the instance from the 'master' list of <code>ClassB</code>s. Something like:</p>\n<pre><code>@PostConstruct\n    public void init() {\n        for (ClassA a : this.classAs()) {\n           List&lt;ClassB&gt; newList = new ArrayList&lt;&gt;();\n           for (ClassB b : a.getClassBs()) {\n              ClassB canonical = this.classBs.stream().filter(b2 -&gt; b2.getName().equals(b.getName()).findFirst().get();\n              newList.add(canonical);\n           }\n           a.setClassBs(newList);\n        }\n}\n</code></pre>\n<p>This way works and is what I may have to go with. The concern I have is that it is very complicated and feels hacky. In reality, the APIProperties object and config file are much larger and more complex and as they grow in size and complexity I dont think this approach will scale well.</p>\n<p>The second approach I have tried is using a custom String to ObjectB converter. I ran into a 'chicken and egg problem' here where the custom converter needs the APIProperties object to be instantiated already to look up the &quot;canonical&quot; instance, and the APIProperties class needs the converter to be ready when its instantiated from the yml file</p>\n",
    "tags" : [ "java", "spring", "spring-boot", "yaml", "configurationproperties" ],
    "owner" : {
      "account_id" : 31006089,
      "reputation" : 11,
      "user_id" : 23820214,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d63b88a6b6359056a760deb6db32bf47?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Walter Carlson",
      "link" : "https://stackoverflow.com/users/23820214/walter-carlson"
    },
    "is_answered" : true,
    "view_count" : 102,
    "answer_count" : 1,
    "score" : 1,
    "last_activity_date" : 1756939564,
    "creation_date" : 1756930467,
    "link" : "https://stackoverflow.com/questions/79755051/spring-boot-configurationproperties-map-yaml-reference-anchors-to-the-same-objec",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79755142,
    "question_id" : 79755051,
    "body" : "<p>It seems that there is no out-of-the-box or quick solution to enforce Spring using a canonical object, so your approach looks reasonable.</p>\n<p>You could improve however the efficiency of your logic by using a <code>Map</code>:</p>\n<pre><code>@PostConstruct\npublic void init() {\n    Map&lt;String, ClassB&gt; canonicalBMap = classBs.stream()\n            .collect(Collectors.toMap(ClassB::getName, Function.identity()));\n\n    for (ClassA a : classAs) {\n        a.setClassBs(a.getClassBs().stream()\n                .map(b -&gt; canonicalBMap.get(b.getName()))\n                .toList());\n    }\n}\n</code></pre>\n<p>Original approach was <code>O(n * m)</code> - always scanning all <code>classBs</code> for each <code>classA</code>.</p>\n<p>Map-based approach: <code>O(n + m)</code> - build the map once (<code>O(n)</code>), then do <code>O(1)</code> lookups for each reference across all ClassA instances (<code>O(m)</code>).</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 18586978,
      "reputation" : 3850,
      "user_id" : 15000097,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/yFl4M.jpg?s=256",
      "display_name" : "Georgii Lvov",
      "link" : "https://stackoverflow.com/users/15000097/georgii-lvov"
    },
    "creation_date" : 1756939564,
    "last_activity_date" : 1756939564,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140712974,
    "post_id" : 79755051,
    "body" : "For your approach with <code>@PostContruct</code>: You could probably improve at least the performance of it when you have many <code>ClassB</code> objects by using a <code>Map&lt;String, ClassB&gt;</code>.",
    "score" : 1,
    "owner" : {
      "account_id" : 15064163,
      "reputation" : 17111,
      "user_id" : 10871900,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/720202b6e19abc330dcd92e6a1254562?s=256&d=identicon&r=PG",
      "display_name" : "dan1st",
      "link" : "https://stackoverflow.com/users/10871900/dan1st"
    },
    "creation_date" : 1756930563,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}