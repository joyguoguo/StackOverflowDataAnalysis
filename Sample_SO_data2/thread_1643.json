{
  "question" : {
    "question_id" : 79690827,
    "title" : "How to create a file only once when it&#39;s needed?",
    "body" : "<p>I'm working on a Java utility. This utility should read some input files (one or several). Each input file contains three types of strings, representing an integer, a float, and a string. The utility has to filter input strings according to their type, and write all of them in 3 separate files (ints, floats, strings).</p>\n<p>The utility should not create an output file, if there is no specific representing string in the input. In other words, if none of the input files contain an integer-type string, no &quot;integer_output.txt&quot; file should be created.</p>\n<p>So we have to create/open output file only if it's needed, but this &quot;needed&quot; clause can only be discovered at a random moment while reading input lines. And you can't know, when exactly it'll happen, and if it will even happen.</p>\n<p>How can I open an output file only if it's needed, not leading to a huge resources overhead when opening/closing this file?</p>\n<p>My current code version is (simplified):</p>\n<pre class=\"lang-java prettyprint-override\"><code>for (String inputFile : validInputFiles) {\n    try (\n            BufferedReader reader = Files.newBufferedReader(Paths.get(inputFile))\n    ) {\n        String line;\n        while ((line = reader.readLine()) != null) {\n            if (line.matches(&quot;[+-]?\\\\d+&quot;)) { // integer\n                BigInteger num = new BigInteger(line);\n                try {\n                    if (integerCount == 0) {\n                        integerWriter = new FileWriter(fullIntegerFileName);\n                    }\n                    integerCount++;\n                    integerWriter.write(line);\n                    integerWriter.write(System.lineSeparator());\n                    integerWriter.flush();\n                } catch (IOException e) {\n                    System.out.println(&quot;Error while writing to file: &quot; + inputFile);\n                }\n\n            } else if (line.matches(&quot;[+-]?(\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][+-]?\\\\d+)?&quot;)) { // float\n                BigDecimal num = new BigDecimal(line);\n                try {\n                    if (floatCount == 0) {\n                        floatWriter = new FileWriter(fullFloatFileName);\n                    }\n                    floatCount++;\n                    floatWriter.write(line);\n                    floatWriter.write(System.lineSeparator());\n                    floatWriter.flush();\n                } catch (IOException e) {\n                    System.out.println(&quot;Error while writing to file: &quot; + inputFile);\n                }\n\n            } else { // string\n                try {\n                    if (stats.stringCount == 0) {\n                        stringWriter = new FileWriter(fullStringFileName);\n                    }\n                    stringCount++;\n                    stringWriter.write(line);\n                    stringWriter.write(System.lineSeparator());\n                    stringWriter.flush();\n                } catch (IOException e) {\n                    System.out.println(&quot;Error while writing to file: &quot; + inputFile);\n                }\n            }\n        }\n\n    } catch (IOException e) {\n        System.err.println(&quot;Error while reading input file: &quot; + e.getMessage());\n    }\n}\n\ntry {\n    if (integerWriter != null) {\n        integerWriter.close();\n    }\n} catch (IOException e) {\n    System.out.println(&quot;Error while closing file: &quot; + fullIntegerFileName);\n}\n\ntry {\n    if (floatWriter != null) {\n        floatWriter.close();\n    }\n} catch (IOException e) {\n    System.out.println(&quot;Error while closing file: &quot; + fullFloatFileName);\n}\n\ntry {\n    if (stringWriter != null) {\n        stringWriter.close();\n    }\n} catch (IOException e) {\n    System.out.println(&quot;Error while closing file: &quot; + fullStringFileName);\n}\n</code></pre>\n<h3>Main steps here:</h3>\n<ol>\n<li>Read a line from input</li>\n<li>Determine if a line represents integer / float / string.</li>\n<li>When determined:\n<ul>\n<li>check if it's a first int/float/string, then we need to open output file</li>\n<li>write the line to specified output file (assuming it was opened earlier)</li>\n</ul>\n</li>\n<li>Close all output files (if needed) after all input files were filtered.</li>\n</ol>\n<p>The problem is, I know it's recommended to use try-with-resources (TWR) with AutoCloseable, but if I do so, then:</p>\n<ul>\n<li>either I have to open all of the output files with TWR once before all the filtering actions, and create one big TWR-block, covering all actions. But I can't, because I can discover if an output file is needed only while working with input;</li>\n<li>or I have to open and use each output file with TWR each time it's needed (that is, each time I recognized an int/float/string, I write this particular line in specified output). But in this case, output files will be opened a huge amount of times, for each input line. Doesn't it lead to a big overhead?</li>\n</ul>\n<p>At this point, I decided not to use TWR, but to open output files with try-catch only if needed, and close all output files after all filtering actions.</p>\n<p>Isn't that a bad way to do? Because now I have to manage opening/closing manually, and my IntelliJ IDEA warns me, that I should use TWR. Seems like it's bad practice.</p>\n<p>I thought of another way to do this:</p>\n<ul>\n<li>firstly read input files to investigate if they contain at least one int/float/string, but not filtering anything</li>\n<li>open necessary output files with TWR-block</li>\n<li>read input again to filter and write all of the lines.</li>\n</ul>\n<p>But this way leads to double-reading, which I think is bad too.</p>\n<p>And last way I thought of:</p>\n<ul>\n<li>create three temporary output files (File.createTempFile), read and filter input, write it to temporary output</li>\n<li>copy temporary files to true output files (but only if they're not empty)</li>\n</ul>\n<p>But I think it's kinda the same - some sort of double-work.</p>\n<p>Taking all that into account, how can I solve this?</p>\n",
    "tags" : [ "java", "file", "try-catch", "try-with-resources", "autocloseable" ],
    "owner" : {
      "account_id" : 23997865,
      "reputation" : 21,
      "user_id" : 17983179,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a-/AOh14Gi_IoNpuKpdwII0ZmM7Au-64z7e0KIRJB5NKXN9Xg=k-s256",
      "display_name" : "longpastgone",
      "link" : "https://stackoverflow.com/users/17983179/longpastgone"
    },
    "is_answered" : true,
    "view_count" : 198,
    "answer_count" : 1,
    "score" : -2,
    "last_activity_date" : 1751919610,
    "creation_date" : 1751695568,
    "link" : "https://stackoverflow.com/questions/79690827/how-to-create-a-file-only-once-when-its-needed",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79690852,
    "question_id" : 79690827,
    "body" : "<p>I would write a dedicated <code>AutoCloseable</code> class for writing these output files. It would manage a collection of <code>FileWriter</code>s and its <code>close</code> method would close them all.</p>\n<p>Here is an example:</p>\n<pre><code>class OutputFilesWriter implements AutoCloseable {\n    private final HashMap&lt;String, BufferedWriter&gt; writers = new HashMap&lt;&gt;();\n\n    public void writeToFile(String file, String line) throws IOException {\n        // not convenient to use Map.computeIfAbsent here because 'newBufferedWriter' throws a checked exception\n        var writer = writers.get(file);\n        if (writer == null) {\n            writer = Files.newBufferedWriter(\n                    Paths.get(file),\n                    StandardOpenOption.CREATE,\n                    // StandardOpenOption.APPEND, // if you like\n                    StandardOpenOption.WRITE\n            );\n            writers.put(file, writer);\n        }\n        writer.write(line);\n        writer.write(System.lineSeparator());\n    }\n\n    @Override\n    public void close() throws Exception {\n        closeAll(writers.values()).close();\n    }\n\n    // adapted from https://stackoverflow.com/a/41019032/5133585, by Holger\n    private static AutoCloseable closeBoth(AutoCloseable a, AutoCloseable b) {\n        if(a==null) return b;\n        if(b==null) return a;\n        return () -&gt; { try(AutoCloseable first=a) { b.close(); } };\n    }\n\n    private static AutoCloseable closeAll(Collection&lt;? extends AutoCloseable&gt; c) {\n        return c.stream().map(x -&gt; (AutoCloseable)x)\n                .reduce(null, OutputFilesWriter::closeBoth);\n    }\n}\n</code></pre>\n<p>The idea is to manage a <code>hMap&lt;String, BufferedWriter&gt;</code>. Each call to <code>writeToFile</code> specifies a file path and the line to write. If there is already an open writer to that file path, use that. Otherwise create a new writer.</p>\n<p>You can just wrap everything with a big TWR like this:</p>\n<pre><code>try (var writer = new OutputFilesWriter()) {\n    // ...\n\n    // at some point you'd call one of these\n    writer.writeToFile(fullIntegerFileName, line);\n    writer.writeToFile(fullFloatFileName, line);\n    writer.writeToFile(fullStringFileName, line);\n}\n</code></pre>\n",
    "score" : 6,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 6651855,
      "reputation" : 292280,
      "user_id" : 5133585,
      "user_type" : "registered",
      "accept_rate" : 96,
      "profile_image" : "https://i.sstatic.net/dfqcw.png?s=256",
      "display_name" : "Sweeper",
      "link" : "https://stackoverflow.com/users/5133585/sweeper"
    },
    "creation_date" : 1751699491,
    "last_activity_date" : 1751699491,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140569311,
    "post_id" : 79690827,
    "body" : "Absolutely bizarre situation. How are they going to tell whether you created a file or not? Are they going to test your tests? I would just do it the easy way and if they whinge tell them they are wasting your time and your employer&#39;s money.",
    "score" : 0,
    "owner" : {
      "account_id" : 71739,
      "reputation" : 311888,
      "user_id" : 207421,
      "user_type" : "registered",
      "accept_rate" : 82,
      "profile_image" : "https://www.gravatar.com/avatar/5cfe5f7d64f44be04f147295f5c7b88e?s=256&d=identicon&r=PG",
      "display_name" : "user207421",
      "link" : "https://stackoverflow.com/users/207421/user207421"
    },
    "creation_date" : 1751844855,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140567039,
    "post_id" : 79690827,
    "body" : "Instead of “best option”, “bad way”, “bad practice”, and “best way”, ask a specific technical question, while specifying in detail your concerns, priorities, and the criteria by which you would judge a successful Answer.",
    "score" : 1,
    "owner" : {
      "account_id" : 322981,
      "reputation" : 347089,
      "user_id" : 642706,
      "user_type" : "registered",
      "accept_rate" : 58,
      "profile_image" : "https://i.sstatic.net/ZWEI3.jpg?s=256",
      "display_name" : "Basil Bourque",
      "link" : "https://stackoverflow.com/users/642706/basil-bourque"
    },
    "creation_date" : 1751729356,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140566982,
    "post_id" : 79690827,
    "body" : "I would implement it with a class for each type, and in your <b>main</b> you use something like: <b>void writeString( String data ) {       if( ws == null ) {          ws = new WriteString( pathToStringFile );          ws.write( data );          ws.setAdding();       }       else {          ws.write( data );       }    }</b>, when you are done you call the <b>close</b> method of each class.",
    "score" : 0,
    "owner" : {
      "account_id" : 10843443,
      "reputation" : 924,
      "user_id" : 20882864,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/CCQCy.jpg?s=256",
      "display_name" : "Marce Puente",
      "link" : "https://stackoverflow.com/users/20882864/marce-puente"
    },
    "creation_date" : 1751726983,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140566514,
    "post_id" : 79690827,
    "body" : "You really need to get in the habit of thinking in a more object-oriented way. Define auto-closeable consumers, one for each type you want to handle, and make that consumer decide when to open the output, and on its close, it can close the output <i>if</i> it created one.",
    "score" : 1,
    "owner" : {
      "account_id" : 213468,
      "reputation" : 110280,
      "user_id" : 466862,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d873f397779db38cd510d9ee5416fd43?s=256&d=identicon&r=PG",
      "display_name" : "Mark Rotteveel",
      "link" : "https://stackoverflow.com/users/466862/mark-rotteveel"
    },
    "creation_date" : 1751701352,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140566485,
    "post_id" : 79690827,
    "body" : "@user207421 because it&#39;s a test task, and its&#39; description has this clearly written requirement (dull in my opinion). I&#39;m trying to discuss it with my &quot;testers&quot;, but it takes a long time, and i have to be able to use some fallback option. Agreed with you, that the way you suggested is the simpliest and most &quot;natural&quot;",
    "score" : 0,
    "owner" : {
      "account_id" : 23997865,
      "reputation" : 21,
      "user_id" : 17983179,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a-/AOh14Gi_IoNpuKpdwII0ZmM7Au-64z7e0KIRJB5NKXN9Xg=k-s256",
      "display_name" : "longpastgone",
      "link" : "https://stackoverflow.com/users/17983179/longpastgone"
    },
    "creation_date" : 1751700239,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140566469,
    "post_id" : 79690827,
    "body" : "Why not just keep it simple and delete output files if they are empty? Otherwise you&#39;re going to be loading files into memory, which is finite, and fallible, or processing them twice.",
    "score" : 0,
    "owner" : {
      "account_id" : 71739,
      "reputation" : 311888,
      "user_id" : 207421,
      "user_type" : "registered",
      "accept_rate" : 82,
      "profile_image" : "https://www.gravatar.com/avatar/5cfe5f7d64f44be04f147295f5c7b88e?s=256&d=identicon&r=PG",
      "display_name" : "user207421",
      "link" : "https://stackoverflow.com/users/207421/user207421"
    },
    "creation_date" : 1751699406,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140566434,
    "post_id" : 79690827,
    "body" : "I forgot to mention, that my utility has to be able to optionally append output contents to existing output files. &quot;Moving&quot; temporary files sounds good, but how can this be done if we need to append? Probably i&#39;m missing smth, because i don&#39;t have much experience with files in Java",
    "score" : 0,
    "owner" : {
      "account_id" : 23997865,
      "reputation" : 21,
      "user_id" : 17983179,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a-/AOh14Gi_IoNpuKpdwII0ZmM7Au-64z7e0KIRJB5NKXN9Xg=k-s256",
      "display_name" : "longpastgone",
      "link" : "https://stackoverflow.com/users/17983179/longpastgone"
    },
    "creation_date" : 1751696730,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140566426,
    "post_id" : 79690827,
    "body" : "You don&#39;t need to <i>copy</i> the temporary files to the true output files, do you? Just <i>move</i> (e.g. <code>File.renameTo</code>) them to where the true output files are expected to be. That doesn&#39;t count as &quot;double-work&quot;, does it?",
    "score" : 0,
    "owner" : {
      "account_id" : 6651855,
      "reputation" : 292280,
      "user_id" : 5133585,
      "user_type" : "registered",
      "accept_rate" : 96,
      "profile_image" : "https://i.sstatic.net/dfqcw.png?s=256",
      "display_name" : "Sweeper",
      "link" : "https://stackoverflow.com/users/5133585/sweeper"
    },
    "creation_date" : 1751696202,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79690852" : [ {
      "comment_id" : 140567336,
      "post_id" : 79690852,
      "body" : "Can be slightly simplified to <code>return () -&gt; { try (a; b) {}; };</code>, at least on more recent versions of Java. Can also use <code>BufferedWriter::newLine()</code>. I would also probably implement <code>Closeable</code> instead simply because everything is related to I/O.",
      "score" : 1,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49904,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1751742443,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}