{
  "question" : {
    "question_id" : 79769550,
    "title" : "How to read or publish concurrently with partitition key",
    "body" : "<p>I am using Spring Integration to implement the Transactional Outbox Pattern. I have code like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Bean\nIntegrationFlow eventFlow(\n    JdbcChannelMessageStore jdbcChannelMessageStore,\n    ExternalEventPublisher externalEventPublisher,\n    @Qualifier(&quot;transactionManager&quot;) TransactionManager transactionManager) {\n  return IntegrationFlow.from(eventInput())\n      .channel(eventOutput(jdbcChannelMessageStore))\n      .handle(\n          message -&gt; {\n            ExternalEvent externalEvent = (ExternalEvent) message.getPayload();\n            externalEventPublisher.publishEvent(externalEvent);\n          },\n          e -&gt;\n              e.poller(\n                  Pollers.fixedDelay(Duration.ofSeconds(1))\n                      .transactional(transactionManager)))\n      .get();\n}\n</code></pre>\n<p>This works great, if the <code>externalEventPublisher</code> works, the message is removed from the database. If the <code>externalEventPublisher</code> fails the message remains and is retried later.</p>\n<p>However, this is single threaded. So if the <code>externalEventPublisher</code> needs 200ms to publish, I can't publish faster than 5 messages per second.</p>\n<p>I would like to make this concurrent, which I can do by changing the poller to this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>Pollers.fixedDelay(Duration.ofSeconds(1))\n        .maxMessagesPerPoll(20)\n        .taskExecutor(taskExecutor())\n        .transactional(transactionManager)\n</code></pre>\n<p>With this <code>taskExecutor</code> defined:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Bean\nTaskExecutor taskExecutor() {\n  ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n  executor.setCorePoolSize(5);\n  executor.setMaxPoolSize(20);\n  executor.setQueueCapacity(100);\n  executor.setThreadNamePrefix(&quot;event-publisher-&quot;);\n  executor.initialize();\n  return executor;\n}\n</code></pre>\n<p>However, now I lose the ordering of the messages.</p>\n<p>What would be the recommended way (given my <code>ExternalEvent</code> class has some kind of partition key I can use) to ensure the messages for the same partition key end up on the same thread so they will be published in sequence? Of course, the transaction cannot be broken, so if the <code>externalEventPublisher</code> fails, the message should remain in the database table.</p>\n",
    "tags" : [ "java", "spring", "spring-integration" ],
    "owner" : {
      "account_id" : 17750,
      "reputation" : 27240,
      "user_id" : 40064,
      "user_type" : "registered",
      "accept_rate" : 69,
      "profile_image" : "https://www.gravatar.com/avatar/6f118f710d3077f91c0c0d722f7be0a3?s=256&d=identicon&r=PG",
      "display_name" : "Wim Deblauwe",
      "link" : "https://stackoverflow.com/users/40064/wim-deblauwe"
    },
    "is_answered" : true,
    "view_count" : 67,
    "answer_count" : 1,
    "score" : 3,
    "last_activity_date" : 1758367176,
    "creation_date" : 1758287535,
    "link" : "https://stackoverflow.com/questions/79769550/how-to-read-or-publish-concurrently-with-partitition-key",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79769620,
    "question_id" : 79769550,
    "body" : "<p>There is no way to make it working against a message since the poller is exactly for polling that message in transaction and in a thread dedicated from that <code>TaskExecutor</code>. The logic is like this:</p>\n<p>The <code>AbstractPollingEndpoint</code> uses a <code>TaskScheduler</code> to schedule a <code>Runnable</code> for the specific period. This <code>Runnable</code> calls <code>this.taskExecutor.execute(() -&gt; {</code> which in a loop until <code>maxMessagesPerPoll</code> calls <code>pollForMessage()</code>. This one starts a transaction and tries to pull a message from the mentioned <code>MessageStore</code>. But you are right, since those polls might be scheduled in parallel, there is no ordering guarantee. And we really cannot move to some other partition-aware thread since that would break transaction boundaries. That is really a point of Transactional Outbox Pattern: we can remove an event from the store only if it has been published properly.</p>\n<p>You may look into a <code>PartitionedChannel</code> solution, but that is not what would fit into transactions: <a href=\"https://docs.spring.io/spring-integration/reference/channel/implementations.html#partitioned-channel\" rel=\"nofollow noreferrer\">https://docs.spring.io/spring-integration/reference/channel/implementations.html#partitioned-channel</a></p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 3273937,
      "reputation" : 122596,
      "user_id" : 2756547,
      "user_type" : "registered",
      "accept_rate" : 75,
      "profile_image" : "https://www.gravatar.com/avatar/2158ce6e7c048277890eb64458864c1c?s=256&d=identicon&r=PG",
      "display_name" : "Artem Bilan",
      "link" : "https://stackoverflow.com/users/2756547/artem-bilan"
    },
    "creation_date" : 1758291330,
    "last_activity_date" : 1758291330,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79769620" : [ {
      "comment_id" : 140747537,
      "post_id" : 79769620,
      "body" : "@WimDeblauwe I believe anything is possible, but probably not with out-of-the-box components. If you&#39;d like to poll in parallel and then have them removed in those partitioned threads, then you&#39;d have to use a different table structure and have some update to skip already polled messages. Then you&#39;d need to have some mechanism to bring them back to ready state when publish transaction fails. It is always hard to design an async solution when transactions are involved.",
      "score" : 0,
      "owner" : {
        "account_id" : 3273937,
        "reputation" : 122596,
        "user_id" : 2756547,
        "user_type" : "registered",
        "accept_rate" : 75,
        "profile_image" : "https://www.gravatar.com/avatar/2158ce6e7c048277890eb64458864c1c?s=256&d=identicon&r=PG",
        "display_name" : "Artem Bilan",
        "link" : "https://stackoverflow.com/users/2756547/artem-bilan"
      },
      "creation_date" : 1758293545,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140747484,
      "post_id" : 79769620,
      "body" : "There is no way to put some kind of splitter that reads from the database to determine the partition key, but then only starts the transaction for the outbox pattern on the new thread where we also publish the external event?",
      "score" : 0,
      "owner" : {
        "account_id" : 17750,
        "reputation" : 27240,
        "user_id" : 40064,
        "user_type" : "registered",
        "accept_rate" : 69,
        "profile_image" : "https://www.gravatar.com/avatar/6f118f710d3077f91c0c0d722f7be0a3?s=256&d=identicon&r=PG",
        "display_name" : "Wim Deblauwe",
        "link" : "https://stackoverflow.com/users/40064/wim-deblauwe"
      },
      "creation_date" : 1758292128,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}