{
  "question" : {
    "question_id" : 79627942,
    "title" : "How to dynamically populate data in to paragraph of word document in spring boot",
    "body" : "<p>In my Java Spring boot project. I am working on a task to populate dynamic data (coming from front end Request DTO) in to existing Word Document template and that data should be populated before that template available for download(that should be in word format and that template exist with formats(styles fonts image etc). However i am not able to populate data properly.\nWhen I insert the data, the formatting changes in the <code>docx</code> file, and if I am able to maintain the format, the placeholders don't update with the data. I've tried <code>Apache POI</code> and poi-tl, but I haven't been able to resolve it.\nIf you have any suggestions on which library to use ?</p>\n<p>My current implementation uses <code>Apache POI</code> library which replace place holder with data however it is modifying the format of the template (which should not happen). It is happening because i am creating new run here. If i didn't create new run it will not replace place holder with data because each place holder will be part of different run. i am stuck here couldn't move forward.\nPlease can any one help.</p>\n<pre class=\"lang-java prettyprint-override\"><code>    /**\n     * Downloads the Memorandum of Understanding (MoU) template and sends it as a\n     * response. Retrieves the template from the classpath, sets appropriate\n     * response headers, and streams the document content for download.\n     *\n     * @param response the HttpServletResponse used to send the file to the client\n     * @throws CollegeException if the template file is missing or an error occurs\n     *                          while streaming data\n     */\n    @Override\n    public void downloadMouTemplate(HttpServletResponse response, MouTemplateRequestDTO mouTemplateDto) {\n        log.info(&quot;CollegeServiceImpl :: downloadTemplate()&quot;);\n\n        try {\n            ClassPathResource fileResource = new ClassPathResource(&quot;templates/myWordDoc.docx&quot;);\n\n            // Validate if the file exists before proceeding\n            if (!fileResource.exists() || fileResource.contentLength() == 0) {\n                log.error(&quot;MoU template file not found or empty&quot;);\n                throw new CollegeException(&quot;Template file not found&quot;);\n            }\n\n            try (InputStream fileStream = fileResource.getInputStream();\n                    XWPFDocument document = new XWPFDocument(fileStream);\n                    OutputStream outputStream = response.getOutputStream()) {\n\n\n                HashMap&lt;String, String&gt; collegeMap = new HashMap&lt;&gt;();\n                collegeMap.put(&quot;collegeName&quot;, mouTemplateDto.getCollegeName());\n                collegeMap.put(&quot;collegeAddress&quot;, mouTemplateDto.getCollegeAddress());\n                replacePlaceholders(document, collegeMap);\n\n                response.setContentType(&quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document&quot;);\n                response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=\\&quot;myWordDocuement.docx\\&quot;&quot;);\n                response.setStatus(HttpServletResponse.SC_OK);\n\n                document.write(outputStream);\n                response.flushBuffer();\n\n            } catch (IOException e) {\n                log.error(&quot;Error while reading the file&quot;, e.getMessage());\n                throw new CollegeException(&quot;Error while reading the MoU template file&quot;);\n            }\n\n        } catch (CollegeException e) {\n            log.error(&quot;Template Not found exception: {}&quot;, e.getMessage());\n            throw e;\n        } catch (Exception e) {\n            log.error(&quot;Unexpected error while downloading the MoU template&quot;, e.getMessage());\n            throw new CollegeException(&quot;Unexpected error while downloading the MoU template.&quot;);\n        }\n    }\n    \n    private static void replacePlaceholders(XWPFDocument document, Map&lt;String, String&gt; data) {\n        // Replace placeholders in document paragraphs\n        for (XWPFParagraph paragraph : document.getParagraphs()) {\n            replacePlaceholdersInParagraph(paragraph, data);\n        }\n\n        // Replace placeholders inside tables\n        for (XWPFTable table : document.getTables()) {\n            for (XWPFTableRow row : table.getRows()) {\n                for (XWPFTableCell cell : row.getTableCells()) {\n                    for (XWPFParagraph paragraph : cell.getParagraphs()) {\n                        replacePlaceholdersInParagraph(paragraph, data); // Call the correct method\n                    }\n                }\n            }\n        }\n    }\n\n    private static void replacePlaceholdersInParagraph(XWPFParagraph paragraph, Map&lt;String, String&gt; data){ List&lt;XWPFRun&gt; runs = paragraph.getRuns();\n        if (runs != null &amp;&amp; !runs.isEmpty()) {\n            StringBuilder fullText = new StringBuilder();\n\n            for (XWPFRun run : runs) {\n                String runText = run.getText(0);\n                if (runText != null) {\n                    fullText.append(runText);\n                }\n            }\n\n            // Replace placeholders\n            String updatedText = fullText.toString();\n            for (Map.Entry&lt;String, String&gt; entry : data.entrySet()) {\n                updatedText = updatedText.replace(&quot;${&quot; + entry.getKey() + &quot;}&quot;, entry.getValue());\n            }\n\n            // Remove existing runs to maintain formatting\n            for (int i = runs.size() - 1; i &gt;= 0; i--) {\n                paragraph.removeRun(i);\n            }\n\n            // Create a new run with replaced text\n            XWPFRun newRun = paragraph.createRun();\n            newRun.setText(updatedText);\n        }\n    }\n</code></pre>\n<p><strong>Inside MyWordDoc paragraph</strong> -</p>\n<p>${collegName} an educational institution affiliated with VTU and located at ${collegAddress} (hereinafter referred to as &quot;College&quot;).</p>\n",
    "tags" : [ "java", "spring-boot", "apache-poi", "docx4j" ],
    "owner" : {
      "account_id" : 21968025,
      "reputation" : 24,
      "user_id" : 16244952,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/50e879bc22575e3878554a2d609cd641?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "MKSHRI",
      "link" : "https://stackoverflow.com/users/16244952/mkshri"
    },
    "is_answered" : true,
    "view_count" : 248,
    "answer_count" : 3,
    "score" : 0,
    "last_activity_date" : 1747860180,
    "creation_date" : 1747613757,
    "link" : "https://stackoverflow.com/questions/79627942/how-to-dynamically-populate-data-in-to-paragraph-of-word-document-in-spring-boot",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79628005,
    "question_id" : 79627942,
    "body" : "<p>You could probably use docx4j. This works with XML based word document and preserves formatting better.</p>\n<p>importing it using maven:</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.docx4j&lt;/groupId&gt;\n    &lt;artifactId&gt;docx4j&lt;/artifactId&gt;\n    &lt;version&gt;8.3.4&lt;/version&gt; &lt;!-- Check for the latest version --&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>Eg:</p>\n<pre><code>WordprocessingMLPackage wordMLPackage = WordprocessingMLPackage.load(new File(&quot;yourtemplate.docx&quot;));\nMainDocumentPart documentPart = wordMLPackage.getMainDocumentPart();\nHashMap&lt;String, String&gt; mappings = new HashMap&lt;&gt;();\nmappings.put(&quot;${collegeName}&quot;, mouTemplateDto.getCollegeName());\nmappings.put(&quot;${collegeAddress}&quot;, mouTemplateDto.getCollegeAddress());\ndocumentPart.variableReplace(mappings);\nwordMLPackage.save(new File(&quot;output.docx&quot;));\n</code></pre>\n<p>If you still want to stick with Apache POI, try modifying existing runs instead of removing all runs and creating a new one:</p>\n<pre><code>for (XWPFRun run : runs) {\n    String runText = run.getText(0);\n    if (runText != null) {\n        for (Map.Entry&lt;String, String&gt; entry : data.entrySet()) {\n            runText = runText.replace(&quot;${&quot; + entry.getKey() + &quot;}&quot;, entry.getValue());\n        }\n        run.setText(runText, 0); // Preserve formatting he\n    }\n}\n</code></pre>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 11753167,
      "reputation" : 84,
      "user_id" : 8601627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/0a87c7b951efb952a42e67e412b5f867?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "thommu",
      "link" : "https://stackoverflow.com/users/8601627/thommu"
    },
    "creation_date" : 1747621508,
    "last_activity_date" : 1747621508,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79628552,
    "question_id" : 79627942,
    "body" : "<p>I had a similar task in a Java Spring Boot project, where I needed to replace placeholders in a .docx Word template with AI-generated content, while preserving the original formatting.</p>\n<p>Here's the code I used — though I'm not entirely sure if it fits your specific case:</p>\n<pre><code>/**\n * Replace placeholders in the template.\n *\n * @param document    the Word document\n * @param placeholder the placeholder text to be replaced\n * @param replacement the replacement text\n */\nprivate static void replacePlaceholder(XWPFDocument document, String placeholder, String replacement) {\n    for (XWPFParagraph paragraph : document.getParagraphs()) {\n        String paragraphText = paragraph.getText();\n        if (paragraphText.contains(placeholder)) {\n            // Get all runs in the paragraph\n            List&lt;XWPFRun&gt; runs = paragraph.getRuns();\n            if (runs == null || runs.isEmpty()) {\n                continue;\n            }\n            // Concatenate all run texts and perform replacement\n            String fullText = &quot;&quot;;\n            for (XWPFRun run : runs) {\n                fullText += run.getText(0) == null ? &quot;&quot; : run.getText(0);\n            }\n            // Replace the placeholder with actual content\n            fullText = fullText.replace(placeholder, replacement);\n            // Remove all original runs (keep the first one for styling reference)\n            for (int i = runs.size() - 1; i &gt; 0; i--) {\n                paragraph.removeRun(i);\n            }\n            // Handle line breaks\n            String[] split = fullText.split(&quot;\\n&quot;);\n            // Rebuild runs while preserving original formatting and handling line breaks and indentation\n            for (int i = 0; i &lt; split.length; i++) {\n                XWPFRun newRun = paragraph.createRun();\n                newRun.setText(split[i]);\n                // Copy original formatting\n                copyRunStyle(runs.get(0), newRun);\n                if (i &lt; (split.length - 1)) {\n                    newRun.addBreak(); // Add line break\n                }\n            }\n            paragraph.removeRun(0);\n        }\n    }\n}\n\n/**\n * Copy the style of a source XWPFRun to a target run.\n */\nprivate static void copyRunStyle(XWPFRun source, XWPFRun target) {\n    target.setBold(source.isBold());\n    target.setItalic(source.isItalic());\n    target.setUnderline(source.getUnderline());\n    target.setColor(source.getColor());\n    target.setFontSize(source.getFontSize());\n    target.setFontFamily(source.getFontFamily());\n    target.setTextPosition(source.getTextPosition());\n    target.setCapitalized(source.isCapitalized());\n    target.setCharacterSpacing(source.getCharacterSpacing());\n}\n</code></pre>\n<p>You can check out my full working implementation here — it might help: <a href=\"https://github.com/nx-xn2002/DocuSmart/blob/main/backend/src/main/java/com/nx/docusmart/controller/GenerateController.java\" rel=\"nofollow noreferrer\">https://github.com/nx-xn2002/DocuSmart/blob/main/backend/src/main/java/com/nx/docusmart/controller/GenerateController.java</a></p>\n",
    "score" : -1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 39104094,
      "reputation" : 9,
      "user_id" : 29109900,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/956d29a63a84133dff9373301dac147c?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "NiXiang",
      "link" : "https://stackoverflow.com/users/29109900/nixiang"
    },
    "creation_date" : 1747650664,
    "last_activity_date" : 1747662475,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79629863,
    "question_id" : 79627942,
    "body" : "<p>I found a workaround. The issue was that the placeholder was getting split and becoming part of a different run.<br />\nFirst, I sysout each run and found - ${ - run1, collegName - run2 , } - run 3. So, inside the Word document, I removed the placeholder &quot;${collegeName}&quot; and replaced it with just &quot;collegeName&quot;. And in the service I just checked, is this word part of the run, If yes, I replaced the text. It worked, but I feel this is not the correct way to do it. I want to know how to make these 3 runs ${ - run 1, collegName - run 2, } - run 3, into a single run.</p>\n<p>Before -<br />\n<code>// Replace placeholders </code><br />\n<code>String updatedText = fullText.toString(); </code><br />\n<code>for (Map.Entry&lt;String, String&gt; entry : data.entrySet()) { </code><br />\n<code>       updatedText = updatedText.replace(&quot;${&quot; + entry.getKey() + &quot;}&quot;, entry.getValue());</code><br />\n<code>}</code></p>\n<p>Now -<br />\n<code>for (int i = 0; i &lt; runs.size(); i++) { </code><br />\n<code>    XWPFRun run = runs.get(i);</code><br />\n<code>    String runText = run.getText(0);</code><br />\n<code>    if (runText != null) {</code><br />\n<code>       for (Map.Entry&lt;String, String&gt; entry : data.entrySet()) {</code><br />\n<code>            String placeholder = entry.getKey();</code><br />\n<code>            if (runText.contains(placeholder)) {</code><br />\n<code>            runText = runText.replace(placeholder, entry.getValue());</code><br />\n<code>            run.setText(runText, 0); // Replace text without affecting formatting</code><br />\n<code>       }</code><br />\n<code>   }</code><br />\n<code>}</code></p>\n<p>And I think answer given by @<a href=\"https://stackoverflow.com/users/29109900/nixiang\">NiXiang</a> also should work, as he is Concatenating all run texts and perform replacement.</p>\n",
    "score" : -1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 21968025,
      "reputation" : 24,
      "user_id" : 16244952,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/50e879bc22575e3878554a2d609cd641?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "MKSHRI",
      "link" : "https://stackoverflow.com/users/16244952/mkshri"
    },
    "creation_date" : 1747720888,
    "last_activity_date" : 1747720888,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79628005" : [ {
      "comment_id" : 140444454,
      "post_id" : 79628005,
      "body" : "See <a href=\"https://github.com/plutext/docx4j/blob/VERSION_11_5_4/docx4j-samples-docx4j/src/main/java/org/docx4j/samples/VariablePrepareRuns.java\" rel=\"nofollow noreferrer\">github.com/plutext/docx4j/blob/VERSION_11_5_4/&hellip;</a> and <a href=\"https://www.docx4java.org/forums/docx-java-f6/turnoff-rsid-s-spell-check-grammar-check-in-generated-xml-t46.html\" rel=\"nofollow noreferrer\">docx4java.org/forums/docx-java-f6/&hellip;</a>",
      "score" : 0,
      "owner" : {
        "account_id" : 30580,
        "reputation" : 15934,
        "user_id" : 1031689,
        "user_type" : "registered",
        "accept_rate" : 67,
        "profile_image" : "https://www.gravatar.com/avatar/8b46683bbe93f7520ebfe3c1c3f454c1?s=256&d=identicon&r=PG",
        "display_name" : "JasonPlutext",
        "link" : "https://stackoverflow.com/users/1031689/jasonplutext"
      },
      "creation_date" : 1747785532,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140437986,
      "post_id" : 79628005,
      "body" : "Thanks for the reply. I had tried modifying existing runs instead of removing all runs and creating a new one (in Apache POI) , it will keep the format but it will not populate the data.  I got to know the root cause - it is because of the splitting of the place holder (it seems inherent behavior of Word doc), so I am getting  ${ - run 1 , collegName - run 2 ,  } - run 3, that is why I am not able to replace place holder with the proper data. but how I can make these work like single run , I am not getting that. Because of this  I am not getting even if I use doc4j. I tried all GPTs.",
      "score" : 0,
      "owner" : {
        "account_id" : 21968025,
        "reputation" : 24,
        "user_id" : 16244952,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/50e879bc22575e3878554a2d609cd641?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "MKSHRI",
        "link" : "https://stackoverflow.com/users/16244952/mkshri"
      },
      "creation_date" : 1747630519,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}