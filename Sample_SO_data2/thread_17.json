{
  "question" : {
    "question_id" : 79835369,
    "title" : "Using FitWidth and FitHeight results in a snapshot with a smaller rendered image than expected",
    "body" : "<h2>Intro</h2>\n<p>The following code implements a <code>draw-by-brush</code> on an image using a canvas. The Idea is to stack a <a href=\"https://openjfx.io/javadoc/25/javafx.graphics/javafx/scene/canvas/Canvas.html\" rel=\"nofollow noreferrer\">Canvas</a> object over an <a href=\"https://openjfx.io/javadoc/25/javafx.graphics/javafx/scene/image/ImageView.html\" rel=\"nofollow noreferrer\">ImageView</a>, draw on it, and finally render the <a href=\"https://openjfx.io/javadoc/25/javafx.graphics/javafx/scene/layout/StackPane.html\" rel=\"nofollow noreferrer\">StackPane</a> (image + canvas) using the <a href=\"https://openjfx.io/javadoc/25/javafx.graphics/javafx/scene/SnapshotParameters.html\" rel=\"nofollow noreferrer\">SnapshotParameters</a> and <a href=\"https://openjfx.io/javadoc/25/javafx.graphics/javafx/scene/image/WritableImage.html\" rel=\"nofollow noreferrer\">WritableImage</a>.</p>\n<h2>Code</h2>\n<p>The <code>saveSnapshot(StackPane stack, int width, int height)</code> method simply creates a <code>WritableImage</code> with the specified width and height (matching the original image's dimensions), and takes a <code>snapshot</code> of the <code>StackPane</code> on it.</p>\n<p>This is the full code:</p>\n<pre><code>import javafx.application.Application;\nimport javafx.beans.binding.Bindings;\nimport javafx.beans.binding.DoubleBinding;\nimport javafx.embed.swing.SwingFXUtils;\nimport javafx.geometry.Pos;\nimport javafx.scene.Scene;\nimport javafx.scene.SnapshotParameters;\nimport javafx.scene.canvas.Canvas;\nimport javafx.scene.canvas.GraphicsContext;\nimport javafx.scene.control.Button;\nimport javafx.scene.image.Image;\nimport javafx.scene.image.ImageView;\nimport javafx.scene.image.WritableImage;\nimport javafx.scene.input.MouseButton;\nimport javafx.scene.layout.StackPane;\nimport javafx.scene.layout.VBox;\nimport javafx.scene.paint.Color;\nimport javafx.stage.Stage;\n\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Objects;\n\npublic class DrawOverImageCanvas extends Application {\n    private double lastX;\n    private double lastY;\n\n    @Override\n    public void start(Stage stage) {\n        Image image = new Image(Objects.requireNonNull(getClass().getResourceAsStream(&quot;yourPath&quot;)));\n        int height = (int) image.getHeight();\n        int width = (int) image.getWidth();\n\n        System.out.println(&quot;width: &quot; + width + &quot; height: &quot; + height);\n\n        if (image.isError())\n            System.err.println(&quot;Could not load image: &quot; + image.getException());\n\n        ImageView imageView = new ImageView(image);\n        imageView.setPreserveRatio(true);\n        imageView.setSmooth(true);\n        imageView.setFitWidth(500);\n\n        Canvas canvas = new Canvas();\n        GraphicsContext gc = canvas.getGraphicsContext2D();\n        gc.setLineWidth(3);\n        gc.setStroke(Color.RED);\n\n        canvas.setOnMousePressed(e -&gt; {\n            if (e.getButton() == MouseButton.PRIMARY) {\n                lastX = e.getX();\n                lastY = e.getY();\n            }\n        });\n\n        canvas.setOnMouseDragged(e -&gt; {\n            if (e.getButton() == MouseButton.PRIMARY) {\n                double x = e.getX();\n                double y = e.getY();\n                gc.strokeLine(lastX, lastY, x, y);\n                lastX = x;\n                lastY = y;\n            }\n        });\n\n        StackPane stack = new StackPane(imageView, canvas);\n        stack.setAlignment(Pos.CENTER);\n        stack.setStyle(&quot;-fx-background-color: transparent;&quot;);\n\n        DoubleBinding imageWidth = Bindings.createDoubleBinding(\n                () -&gt; imageView.getLayoutBounds().getWidth(),\n                imageView.layoutBoundsProperty()\n        );\n\n        DoubleBinding imageHeight = Bindings.createDoubleBinding(\n                () -&gt; imageView.getLayoutBounds().getHeight(),\n                imageView.layoutBoundsProperty()\n        );\n\n        stack.minWidthProperty().bind(imageWidth);\n        stack.prefWidthProperty().bind(imageWidth);\n        stack.maxWidthProperty().bind(imageWidth);\n\n        stack.minHeightProperty().bind(imageHeight);\n        stack.prefHeightProperty().bind(imageHeight);\n        stack.maxHeightProperty().bind(imageHeight);\n\n        canvas.widthProperty().bind(imageWidth);\n        canvas.heightProperty().bind(imageHeight);\n\n        Button saveButton = new Button(&quot;Save PNG&quot;);\n        saveButton.setOnAction(e -&gt; saveSnapshot(stack, width, height));\n\n        Button clearButton = new Button(&quot;Clear Drawing&quot;);\n        clearButton.setOnAction(e -&gt; {\n            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());\n        });\n\n        VBox root = new VBox(10, stack, new VBox(5, saveButton, clearButton));\n        root.setAlignment(Pos.CENTER);\n        root.setStyle(&quot;-fx-padding: 10; -fx-background-color: #333333;&quot;);\n\n        Scene scene = new Scene(root);\n        stage.setTitle(&quot;Draw over Image with Canvas&quot;);\n        stage.setScene(scene);\n        stage.sizeToScene();\n        stage.show();\n    }\n\n    private void saveSnapshot(StackPane stack, int width, int height) {\n        SnapshotParameters params = new SnapshotParameters();\n        params.setFill(Color.TRANSPARENT);\n\n        WritableImage writableImage = new WritableImage(width, height);\n        stack.snapshot(params, writableImage);\n\n        BufferedImage bufferedImage = SwingFXUtils.fromFXImage(writableImage, null);\n        File outFile = new File(&quot;500.png&quot;);\n\n        try {\n            ImageIO.write(bufferedImage, &quot;png&quot;, outFile);\n            System.out.println(&quot;Saved to: &quot; + outFile.getAbsolutePath());\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<h2>Issue</h2>\n<p>The issue is that when the image's <code>FitWidth</code> and <code>FitHeight</code> are set to values smaller than their actual width and height, the snapshot captures the entire <code>StackPane</code>, using the <code>FitWidth</code> and <code>FitHeight</code> values rather than the image's actual width and height, since the <code>StackPane</code> size is bound to the <code>ImageView</code>'s.</p>\n<p>The resulting snapshot image will keep its original size (since the <code>WritableImage</code> size matches the image's), but with a <code>StackPane</code> rendered inside it because <code>FitWidth</code> and <code>FitHeight</code> were smaller than the image's actual height and width.</p>\n<p>The screenshot below is from my PC's file explorer, showing different results generated by using various Fit Width values from 200 to 500, compared to the original image at its actual size. All the images have the same dimensions, but the rendered ones <code>StackPane</code> varies depending on the value used for the <code>setFitWidth</code>.</p>\n<p><img src=\"https://i.sstatic.net/F0ZH4c9V.png\" alt=\"enter image description here\" /></p>\n<p>Is there a way for the rendered StackPane to occupy the full height and width as the original image?</p>\n",
    "tags" : [ "java", "javafx", "canvas", "snapshot" ],
    "owner" : {
      "account_id" : 12506291,
      "reputation" : 799,
      "user_id" : 9103039,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
      "display_name" : "Starnec",
      "link" : "https://stackoverflow.com/users/9103039/starnec"
    },
    "is_answered" : true,
    "view_count" : 51,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1764690717,
    "creation_date" : 1764634042,
    "link" : "https://stackoverflow.com/questions/79835369/using-fitwidth-and-fitheight-results-in-a-snapshot-with-a-smaller-rendered-image",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79835979,
    "question_id" : 79835369,
    "body" : "<p>The size of the stack pane is determined by its content; the content is the image <strong>view</strong> and the canvas. Both of those have size determined by the values you pass to <code>fitWidth</code> and <code>fitHeight</code>. So the content of the node you are snapshotting is determined by those values. Any additional space in the image you use for snapshotting will just be empty.</p>\n<p>If I understand the requirements correctly, you want to create an image on disk that contains the original image, at its original size, along with the &quot;annotations&quot; from the canvas. Note that to do this, you will need to somehow scale the annotations to be the same size as the original image.</p>\n<p>One approach is:</p>\n<ol>\n<li>Snapshot the canvas to an image.</li>\n<li>Create an image view to hold the image of the canvas.</li>\n<li>Set the <code>fitWidth</code> and <code>fitHeight</code> of that image view to be the size of the original image.\n<ul>\n<li>This will scale the snapshot of the canvas to be the same size as the original image.</li>\n</ul>\n</li>\n<li>Create another <code>ImageView</code> to display the original image at its original (i.e. default) size.</li>\n<li>Create a new stack pane to hold the two image views.</li>\n<li>Snapshot the new stack pane.</li>\n</ol>\n<pre><code>    private void saveSnapshot(Image image, Canvas annotations) {\n        SnapshotParameters params = new SnapshotParameters();\n        params.setFill(Color.TRANSPARENT);\n\n        Image canvasImage = annotations.snapshot(params, null);\n        ImageView annotationsView = new ImageView(canvasImage);\n        annotationsView.setFitWidth(image.getWidth());\n        annotationsView.setFitHeight(image.getHeight());\n\n        ImageView imageView = new ImageView(image);\n\n        StackPane stack = new StackPane(imageView, annotationsView);\n        stack.setStyle(&quot;-fx-background-color: transparent;&quot;);\n\n        Scene scene = new Scene(stack);\n\n        Image snapshot = stack.snapshot(params, null);\n\n        BufferedImage bufferedImage = SwingFXUtils.fromFXImage(snapshot, null);\n        File outFile = new File(&quot;500.png&quot;);\n\n        try {\n            ImageIO.write(bufferedImage, &quot;png&quot;, outFile);\n            System.out.println(&quot;Saved to: &quot; + outFile.getAbsolutePath());\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n</code></pre>\n<p>Here is a complete working example with this approach:</p>\n<pre><code>import javafx.application.Application;\nimport javafx.beans.binding.Bindings;\nimport javafx.beans.binding.DoubleBinding;\nimport javafx.embed.swing.SwingFXUtils;\nimport javafx.geometry.Pos;\nimport javafx.scene.Scene;\nimport javafx.scene.SnapshotParameters;\nimport javafx.scene.canvas.Canvas;\nimport javafx.scene.canvas.GraphicsContext;\nimport javafx.scene.control.Button;\nimport javafx.scene.image.Image;\nimport javafx.scene.image.ImageView;\nimport javafx.scene.input.MouseButton;\nimport javafx.scene.layout.StackPane;\nimport javafx.scene.layout.VBox;\nimport javafx.scene.paint.Color;\nimport javafx.stage.Stage;\n\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Objects;\n\npublic class DrawOverImageCanvas extends Application {\n    private double lastX;\n    private double lastY;\n\n    @Override\n    public void start(Stage stage) {\n        Image image = new Image(Objects.requireNonNull(getClass().getResourceAsStream(&quot;yourPath&quot;)));\n\n\n        if (image.isError())\n            System.err.println(&quot;Could not load image: &quot; + image.getException());\n\n        ImageView imageView = new ImageView(image);\n        imageView.setPreserveRatio(true);\n        imageView.setSmooth(true);\n        imageView.setFitWidth(500);\n\n        Canvas canvas = new Canvas();\n        GraphicsContext gc = canvas.getGraphicsContext2D();\n        gc.setLineWidth(3);\n        gc.setStroke(Color.RED);\n\n        canvas.setOnMousePressed(e -&gt; {\n            if (e.getButton() == MouseButton.PRIMARY) {\n                lastX = e.getX();\n                lastY = e.getY();\n            }\n        });\n\n        canvas.setOnMouseDragged(e -&gt; {\n            if (e.getButton() == MouseButton.PRIMARY) {\n                double x = e.getX();\n                double y = e.getY();\n                gc.strokeLine(lastX, lastY, x, y);\n                lastX = x;\n                lastY = y;\n            }\n        });\n\n        StackPane stack = new StackPane(imageView, canvas);\n        stack.setAlignment(Pos.CENTER);\n        stack.setStyle(&quot;-fx-background-color: transparent;&quot;);\n\n        DoubleBinding imageWidth = Bindings.createDoubleBinding(\n                () -&gt; imageView.getLayoutBounds().getWidth(),\n                imageView.layoutBoundsProperty()\n        );\n\n        DoubleBinding imageHeight = Bindings.createDoubleBinding(\n                () -&gt; imageView.getLayoutBounds().getHeight(),\n                imageView.layoutBoundsProperty()\n        );\n\n        stack.minWidthProperty().bind(imageWidth);\n        stack.prefWidthProperty().bind(imageWidth);\n        stack.maxWidthProperty().bind(imageWidth);\n\n        stack.minHeightProperty().bind(imageHeight);\n        stack.prefHeightProperty().bind(imageHeight);\n        stack.maxHeightProperty().bind(imageHeight);\n\n        canvas.widthProperty().bind(imageWidth);\n        canvas.heightProperty().bind(imageHeight);\n\n        Button saveButton = new Button(&quot;Save PNG&quot;);\n        saveButton.setOnAction(e -&gt; saveSnapshot(image, canvas));\n\n        Button clearButton = new Button(&quot;Clear Drawing&quot;);\n        clearButton.setOnAction(e -&gt; {\n            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());\n        });\n\n        VBox root = new VBox(10, stack, new VBox(5, saveButton, clearButton));\n        root.setAlignment(Pos.CENTER);\n        root.setStyle(&quot;-fx-padding: 10; -fx-background-color: #333333;&quot;);\n\n        Scene scene = new Scene(root);\n        stage.setTitle(&quot;Draw over Image with Canvas&quot;);\n        stage.setScene(scene);\n        stage.sizeToScene();\n        stage.show();\n    }\n\n    private void saveSnapshot(Image image, Canvas annotations) {\n        SnapshotParameters params = new SnapshotParameters();\n        params.setFill(Color.TRANSPARENT);\n\n        Image canvasImage = annotations.snapshot(params, null);\n        ImageView annotationsView = new ImageView(canvasImage);\n        annotationsView.setFitWidth(image.getWidth());\n        annotationsView.setFitHeight(image.getHeight());\n\n        ImageView imageView = new ImageView(image);\n\n        StackPane stack = new StackPane(imageView, annotationsView);\n        stack.setStyle(&quot;-fx-background-color: transparent;&quot;);\n\n        Scene scene = new Scene(stack);\n\n        Image snapshot = stack.snapshot(params, null);\n\n        BufferedImage bufferedImage = SwingFXUtils.fromFXImage(snapshot, null);\n        File outFile = new File(&quot;500.png&quot;);\n\n        try {\n            ImageIO.write(bufferedImage, &quot;png&quot;, outFile);\n            System.out.println(&quot;Saved to: &quot; + outFile.getAbsolutePath());\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<p>Note that if the canvas is upscaled a large amount, the quality may not be ideal. In particular, the width of lines will be scaled by the same amount as the scaling between the original image and the image view in the application. (Similarly if you were to add points, the radius of the points would be scaled, etc.) So in this implementation, the line width is 3 units <em>in the coordinate system of the image view in the application</em>. Using an <code>ImageView</code> to perform the scaling at least gives you control over the smoothing etc. to a small extent.</p>\n<p>A more complex approach would be to either track all the lines drawn on the canvas (or perhaps to retrieve them from the existing canvas) and recreate those on a new canvas with appropriately transformed coordinates. Whether or not this additional effort is worthwhile depends a lot on your use case.</p>\n<p>Here is a rudimentary implementation of this second idea. This just assumes all &quot;annotations&quot; are drawn as lines; you may need something more complicated in the real application. In this implementation, the line width ends up being 3 pixels <em>in the coordinate system of the image you write to disk</em>.</p>\n<pre><code>import javafx.application.Application;\nimport javafx.beans.binding.Bindings;\nimport javafx.beans.binding.DoubleBinding;\nimport javafx.embed.swing.SwingFXUtils;\nimport javafx.geometry.Point2D;\nimport javafx.geometry.Pos;\nimport javafx.scene.Scene;\nimport javafx.scene.SnapshotParameters;\nimport javafx.scene.canvas.Canvas;\nimport javafx.scene.canvas.GraphicsContext;\nimport javafx.scene.control.Button;\nimport javafx.scene.image.Image;\nimport javafx.scene.image.ImageView;\nimport javafx.scene.input.MouseButton;\nimport javafx.scene.layout.StackPane;\nimport javafx.scene.layout.VBox;\nimport javafx.scene.paint.Color;\nimport javafx.stage.Stage;\n\nimport javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class DrawOverImageCanvas extends Application {\n\n    @Override\n    public void start(Stage stage) {\n        Image image = new Image(Objects.requireNonNull(getClass().getResourceAsStream(&quot;yourPath&quot;)));\n\n\n        if (image.isError())\n            System.err.println(&quot;Could not load image: &quot; + image.getException());\n\n        ImageView imageView = new ImageView(image);\n        imageView.setPreserveRatio(true);\n        imageView.setSmooth(true);\n        imageView.setFitWidth(500);\n\n        Canvas canvas = createCanvas();\n        GraphicsContext gc = canvas.getGraphicsContext2D();\n\n        List&lt;Point2D&gt; points = new ArrayList&lt;&gt;();\n\n        canvas.setOnMousePressed(e -&gt; {\n            if (e.getButton() == MouseButton.PRIMARY) {\n                points.add(new Point2D(e.getX(), e.getY()));\n            }\n        });\n\n        canvas.setOnMouseDragged(e -&gt; {\n            if (e.getButton() == MouseButton.PRIMARY) {\n                double x = e.getX();\n                double y = e.getY();\n                Point2D lastPoint = points.getLast();\n                gc.strokeLine(lastPoint.getX(), lastPoint.getY(), x, y);\n                points.add(new Point2D(x, y));\n            }\n        });\n\n        StackPane stack = new StackPane(imageView, canvas);\n        stack.setAlignment(Pos.CENTER);\n        stack.setStyle(&quot;-fx-background-color: transparent;&quot;);\n\n        DoubleBinding imageWidth = Bindings.createDoubleBinding(\n                () -&gt; imageView.getLayoutBounds().getWidth(),\n                imageView.layoutBoundsProperty()\n        );\n\n        DoubleBinding imageHeight = Bindings.createDoubleBinding(\n                () -&gt; imageView.getLayoutBounds().getHeight(),\n                imageView.layoutBoundsProperty()\n        );\n\n        stack.minWidthProperty().bind(imageWidth);\n        stack.prefWidthProperty().bind(imageWidth);\n        stack.maxWidthProperty().bind(imageWidth);\n\n        stack.minHeightProperty().bind(imageHeight);\n        stack.prefHeightProperty().bind(imageHeight);\n        stack.maxHeightProperty().bind(imageHeight);\n\n        canvas.widthProperty().bind(imageWidth);\n        canvas.heightProperty().bind(imageHeight);\n\n        Button saveButton = new Button(&quot;Save PNG&quot;);\n        saveButton.setOnAction(e -&gt; saveSnapshot(image, points, image.getWidth() / canvas.getWidth(), image.getHeight() / canvas.getHeight()));\n\n        Button clearButton = new Button(&quot;Clear Drawing&quot;);\n        clearButton.setOnAction(e -&gt; {\n            gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());\n            points.clear();\n        });\n\n        VBox root = new VBox(10, stack, new VBox(5, saveButton, clearButton));\n        root.setAlignment(Pos.CENTER);\n        root.setStyle(&quot;-fx-padding: 10; -fx-background-color: #333333;&quot;);\n\n        Scene scene = new Scene(root);\n        stage.setTitle(&quot;Draw over Image with Canvas&quot;);\n        stage.setScene(scene);\n        stage.sizeToScene();\n        stage.show();\n    }\n\n    private Canvas createCanvas() {\n        Canvas canvas = new Canvas();\n        GraphicsContext gc = canvas.getGraphicsContext2D();\n        gc.setLineWidth(3);\n        gc.setStroke(Color.RED);\n        return canvas;\n    }\n\n    private void saveSnapshot(Image image, List&lt;Point2D&gt; points, double scaleX, double scaleY) {\n        \n        SnapshotParameters params = new SnapshotParameters();\n        params.setFill(Color.TRANSPARENT);\n\n        Canvas canvas = createCanvas();\n        canvas.setWidth(image.getWidth());\n        canvas.setHeight(image.getHeight());\n        GraphicsContext gc = canvas.getGraphicsContext2D();\n        for (int i = 1 ; i &lt; points.size(); i++) {\n            Point2D first = points.get(i-1);\n            Point2D second = points.get(i);\n\n            gc.strokeLine(first.getX() * scaleX, first.getY() * scaleY, second.getX() * scaleX, second.getY() * scaleY);\n        }\n\n        ImageView imageView = new ImageView(image);\n\n        StackPane stack = new StackPane(imageView, canvas);\n        stack.setStyle(&quot;-fx-background-color: transparent;&quot;);\n\n        Scene scene = new Scene(stack);\n\n        Image snapshot = stack.snapshot(params, null);\n\n        BufferedImage bufferedImage = SwingFXUtils.fromFXImage(snapshot, null);\n        File outFile = new File(&quot;500.png&quot;);\n\n        try {\n            ImageIO.write(bufferedImage, &quot;png&quot;, outFile);\n            System.out.println(&quot;Saved to: &quot; + outFile.getAbsolutePath());\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n</code></pre>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2518243,
      "reputation" : 210891,
      "user_id" : 2189127,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
      "display_name" : "James_D",
      "link" : "https://stackoverflow.com/users/2189127/james-d"
    },
    "creation_date" : 1764685694,
    "last_activity_date" : 1764690717,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79835979" : [ {
      "comment_id" : 140884124,
      "post_id" : 79835979,
      "body" : "@Starnec I misunderstood at first (so I deleted the comment). <i>&quot;When it comes to the line&#39;s width, when the canvas is scaled, is it possible to make the LineWidth of the GraphicsContext dependent on the ratio between the actual and rendered sizes?&quot;</i> In the first solution, no, because you are re-using the same canvas that is displayed in the app, and the lines have already been drawn at that point. In the second solution, yes, of course: just create the canvas with a different stroke width as needed (instead of creating the canvas with the same stroke width).",
      "score" : 0,
      "owner" : {
        "account_id" : 2518243,
        "reputation" : 210891,
        "user_id" : 2189127,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
        "display_name" : "James_D",
        "link" : "https://stackoverflow.com/users/2189127/james-d"
      },
      "creation_date" : 1764708174,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140883660,
      "post_id" : 79835979,
      "body" : "Thank you very much for your answer. You understood my requirements, which I did not think you did when I first read your comment. When it comes to the line&#39;s width, when the canvas is scaled, is it possible to make the <code>LineWidth</code> of the <code>GraphicsContext</code> dependent on the ratio between the actual and rendered sizes? Because I intend to include this functionality based on my <a href=\"https://stackoverflow.com/questions/79800110/zoom-by-slider-goes-awry-when-binding-the-slider-to-the-scale-property\">previous</a> question.",
      "score" : 0,
      "owner" : {
        "account_id" : 12506291,
        "reputation" : 799,
        "user_id" : 9103039,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/TqlDK.jpg?s=256",
        "display_name" : "Starnec",
        "link" : "https://stackoverflow.com/users/9103039/starnec"
      },
      "creation_date" : 1764692000,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}