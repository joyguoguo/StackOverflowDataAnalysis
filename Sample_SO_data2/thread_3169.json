{
  "question" : {
    "question_id" : 79569818,
    "title" : "Inclusion of @FormDataParam annotation(s) results in 400 Bad Request (Jersey 3.1.10, Java 17, Tomcat 10) for multipart/form-data requests",
    "body" : "<p>I have an existing REST API (has been around for years now and I'm the original author) which has multiple end-points. I just added a new end-point for uploading files. The end-point method resource is currently defined as (for just testing the end-point response):</p>\n<pre><code>    @POST\n    @Path(&quot;/v1/upload&quot;)\n    @Consumes(MediaType.MULTIPART_FORM_DATA)\n    public Response upload (\n                     @FormDataParam(&quot;file&quot;)\n             InputStream file,\n             @FormDataParam(&quot;file&quot;)\n             FormDataContentDisposition disposition) {\n        \n        \n        return Response.ok().build();\n    }\n</code></pre>\n<p>As soon as a request comes in (sample shown below), Tomcat or Jersey sends back a 400 Bad Request response before even entering into the end-point method. The only thing written to any Tomcat log is in the general &quot;access_log&quot; where it inserts a log entry about the end-point request URL and the response code of 400. I have checked all other Tomcat logs and there is no other log entries anywhere which describe WHY a 400 is being returned.</p>\n<p>Tomcat returns an HTML response, which seems to be a &quot;one size fits all&quot; error message, in the 400 response:</p>\n<p>The server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).</p>\n<p>Sample file upload request:</p>\n<pre><code>POST http://localhost/&lt;removed path for SO post&gt;/v1/upload?_=1744409038175&amp;cid=m9dc0kkulvrjar8sxgl&amp;tkn=974016a9-5a49-45d4-98c9-dba380735578 HTTP/1.1\nHost: localhost\nConnection: keep-alive\nContent-Length: 717939\nsec-ch-ua-platform: &quot;Windows&quot;\nX-Requested-With: XMLHttpRequest\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36\nAccept: application/json, text/plain, */*\nsec-ch-ua: &quot;Google Chrome&quot;;v=&quot;135&quot;, &quot;Not-A.Brand&quot;;v=&quot;8&quot;, &quot;Chromium&quot;;v=&quot;135&quot;\nContent-Type: multipart/form-data\nsec-ch-ua-mobile: ?0\nOrigin: http://localhost\nSec-Fetch-Site: same-origin\nSec-Fetch-Mode: cors\nSec-Fetch-Dest: empty\nReferer: http://localhost/&lt;removed path for SO post&gt;/\nAccept-Encoding: gzip, deflate, br, zstd\nAccept-Language: en-US,en-GB;q=0.9,en;q=0.8\nCookie: &lt;a couple of cookies&gt;\n\n------WebKitFormBoundarydDDQsAC7Rqf3IM5I\nContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;Sample file.pdf&quot;\nContent-Type: application/pdf\n\n&lt;Encoded File Content Here&gt;\n\n----WebKitFormBoundarydDDQsAC7Rqf3IM5I--\n</code></pre>\n<p>If I change the end-point method signature (i.e., to remove the @FormDataParam annotations and only have 1 InputStream parameter) to the following:</p>\n<pre><code>    @POST\n    @Path(&quot;/v1/upload&quot;)\n    @Consumes(MediaType.MULTIPART_FORM_DATA)\n    public Response upload (\n             InputStream file) {\n        \n        return Response.ok().build();\n    }\n</code></pre>\n<p>The above will work and Tomcat won't send back a 400. However, I can't define any other method parameters or make use of the @FormDataParam annotation. Actually, with the above method signature, if I were to add the <code>@FormDataParam(&quot;file&quot;)</code> to the above <code>InputStream file</code> parameter, then I will get a 400 again.</p>\n<p>I'm pretty sure I have all of the necessary JAR dependencies (relevant parts from the pom.xml below) for Jersey to handle multipart requests. I don't understand what is going wrong here, and I'm not getting enough log information to determine WHY!</p>\n<p>pom.xml with Jersey-relevant dependencies:</p>\n<pre><code>    &lt;dependencyManagement&gt;\n        &lt;dependencies&gt;\n        &lt;!-- https://mvnrepository.com/artifact/org.glassfish.jersey/jersey-bom --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.glassfish.jersey&lt;/groupId&gt;\n            &lt;artifactId&gt;jersey-bom&lt;/artifactId&gt;\n            &lt;version&gt;3.1.10&lt;/version&gt;\n            &lt;type&gt;pom&lt;/type&gt;\n            &lt;scope&gt;import&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;/dependencies&gt;\n    &lt;/dependencyManagement&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;\n            &lt;artifactId&gt;jersey-container-servlet-core&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n        &lt;groupId&gt;org.glassfish.jersey.containers&lt;/groupId&gt;\n        &lt;artifactId&gt;jersey-container-servlet&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.glassfish.jersey.inject&lt;/groupId&gt;\n            &lt;artifactId&gt;jersey-hk2&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;\n            &lt;artifactId&gt;jersey-media-json-binding&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.glassfish.jersey.media&lt;/groupId&gt;\n        &lt;artifactId&gt;jersey-media-multipart&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;!-- https://mvnrepository.com/artifact/org.glassfish.jaxb/jaxb-runtime --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.glassfish.jaxb&lt;/groupId&gt;\n        &lt;artifactId&gt;jaxb-runtime&lt;/artifactId&gt;\n        &lt;version&gt;4.0.5&lt;/version&gt;\n    &lt;/dependency&gt;\n        ...\n</code></pre>\n<p>Actually, it seems that anytime the @FormDataParam annotation is used, a 400 response occurs.</p>\n",
    "tags" : [ "java", "tomcat", "post", "jersey", "multipartform-data" ],
    "owner" : {
      "account_id" : 5994178,
      "reputation" : 61,
      "user_id" : 4709365,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/a947864748929af7b1e4837c59e85dc3?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Brien Halstead",
      "link" : "https://stackoverflow.com/users/4709365/brien-halstead"
    },
    "is_answered" : true,
    "view_count" : 111,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1747687069,
    "creation_date" : 1744412571,
    "link" : "https://stackoverflow.com/questions/79569818/inclusion-of-formdataparam-annotations-results-in-400-bad-request-jersey-3-1",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79573949,
    "question_id" : 79569818,
    "body" : "<p>OK - this took some digging to figure out what was going wrong.</p>\n<p>The problem was that the &quot;part&quot; in the multipart request wasn't being recognized by Jersey (via any <code>FormDataParam</code> annotations, OR if I were to directly access the request parts via the current <code>HttpServletRequest</code>) because the request coming from the browser wasn't indicating the &quot;boundary&quot; for the first/primary Content-Type header (which the part and its boundary name is dynamically being added by the browser later in the request for the file &quot;part&quot;, i.e., some random boundary name like &quot;------WebKitFormBoundarymUBOEP84Y3yt6c4A&quot;).</p>\n<p>The reason that the browser wasn't indicating the correct (or any) boundary for the primary/first Content-Type header in the request was because Angular (via the $http provider) will automatically set the Content-Type to &quot;application/json;charset=utf-8&quot; during a POST/PUT request if the &quot;data&quot; provided to the $http function is an Object that doesn't resolve to the string representation of &quot;[object File]&quot;, and no other Content-Type header has been explicitly included/added in the $http call.</p>\n<p>In my case, the data object's string representation is &quot;[object FormData]&quot;, which causes the primary/first Content-Type header to be set to &quot;application/json&quot; by Angular (which leads to Jersey to not parse the request for any &quot;parts&quot; that may have been sent), instead of being set correctly to <code>Content-Type: multipart/form-data; boundary=----WebKitFormBoundarymUBOEP84Y3yt6c4A</code> by the browser (by not including ANY Content-Type header in my JS code during the $http POST call). If I were to explicitly set the Content-Type header to &quot;multipart/form-data&quot;, then it will still fail because it's missing the &quot;boundary&quot; attribute, and I don't know the value of the boundary because it's being dynamically generated by the browser.</p>\n<p>To fix the issue: I needed to remove the default headers that Angular was automatically applying to all POST/PUT requests by deleting the associated default properties from the Angular &quot;$httpProvider&quot; config object:</p>\n<pre><code>delete $httpProvider.defaults.headers.post[&quot;Content-Type&quot;];\ndelete $httpProvider.defaults.headers.put[&quot;Content-Type&quot;];\n</code></pre>\n<p>Now, I didn't want to set another, default Content-Type header for ALL POST/PUT requests because I don't want some other incorrect content type to end up being sent in other, non-file-upload cases - so I just deleted the existing, hard-coded POST/PUT defaults (with the &quot;delete&quot; statements above), and then I ended up setting my own defaults for content type handling during my POST/PUT calls to $http based upon similar, but different, logic from what Angular was doing.</p>\n<p>I also had to replace the default Angular request transformer during the Angular &quot;config&quot; hook with one that will properly handle FormData objects during POST/PUT requests, somewhat following Angular's original logic for parameterizing JSON objects to be added as form parameters to POST/PUT requests:</p>\n<pre><code>$httpProvider.defaults.transformRequest = function (data) {\n    if (angular.isObject(data)) {\n        let strData = String(data);\n        if (strData == &quot;[object File]&quot; || strData == &quot;[object FormData]&quot;) {\n            return data;\n        }\n        return $httpParamSerializerProvider.$get()(data);\n    }\n    return data;\n};\n</code></pre>\n<p>With the Content-Type header being set correctly with a boundary in the POST file upload requests from the browser, Jersey is now parsing the requests correctly, and I can use the @FormDataParam annotations without Jersey automatically sending back a 400 response when it thinks that the request is not a multipart request.</p>\n",
    "score" : 0,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 5994178,
      "reputation" : 61,
      "user_id" : 4709365,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/a947864748929af7b1e4837c59e85dc3?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Brien Halstead",
      "link" : "https://stackoverflow.com/users/4709365/brien-halstead"
    },
    "creation_date" : 1744661723,
    "last_activity_date" : 1744664012,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}