{
  "question" : {
    "question_id" : 79791333,
    "title" : "Howto add SSL support for simple Android web server written in Java",
    "body" : "<p>I have written a minimalistic HTTP web server in Java. The app works fine for example on my Android phone. When my phone is connected to my local network I can just start the app and use a browser running on my computer to connect to it. Depending on the Ip address of my phone the Url might for example be <a href=\"http://192.168.1.100:8082/test\" rel=\"nofollow noreferrer\">http://192.168.1.100:8082/test</a>.\nThe code consists mainly of two classes. One that is is waiting for connections:</p>\n<pre><code>public class ListenerThread extends Thread\n{\n    public void run()\n    {\n        try\n        {\n            ServerSocket serverSocket = ServerSocketFactory.getDefault().createServerSocket(8082);\n            for (;;)\n            {\n                Socket connected = serverSocket.accept();\n                new ClientThread(connected).start();\n            }\n\n        } catch (IOException e)\n        {\n        }\n    }\n}\n</code></pre>\n<p>And another class that handles these connections:</p>\n<pre><code>public class ClientThread extends Thread\n{\n    private final Socket socket;\n\n    public ClientThread(Socket socket)\n    {\n        this.socket = socket;\n    }\n\n    @Override\n    public void run()\n    {\n        try\n        {\n            DataInputStream in = new DataInputStream(socket.getInputStream());\n            DataOutputStream out = new DataOutputStream(socket.getOutputStream());\n\n            byte[] buffer = new byte[2000];\n\n            for(;;)\n            {\n                int read = in.read(buffer, 0, buffer.length);\n                if (read &lt;= 0) break;\n\n                String recData = new String(buffer, 0, read, StandardCharsets.UTF_8);\n                if (recData.length() &gt;= 4 &amp;&amp; recData.substring(0, 4).compareToIgnoreCase(&quot;GET &quot;) == 0)\n                {\n                    reply(out,&quot;Moin Moin&quot;);\n                }\n            }\n\n            in.close();\n            out.close();\n            socket.close();\n\n        } catch (IOException e)\n        {\n        }\n    }\n\n    private void reply(DataOutputStream output, String content)\n    {\n        SimpleDateFormat gmtFormat = new SimpleDateFormat(&quot;E, d MMM yyyy HH:mm:ss 'GMT'&quot;, Locale.getDefault());\n        gmtFormat.setTimeZone(TimeZone.getTimeZone(&quot;GMT&quot;));\n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8), false);\n        pw.append(&quot;HTTP/1.1 200\\r\\n&quot;);\n\n        pw.append(&quot;Content-Type: text/plain; charset=utf-8\\r\\n&quot;);\n        pw.append(&quot;Access-Control-Allow-Origin: *\\r\\n&quot;);\n        pw.append(&quot;Date: &quot;).append(gmtFormat.format(new Date())).append(&quot;\\r\\n&quot;);\n        pw.append(&quot;Connection: keep-alive\\r\\n&quot;);\n        byte[] bytes = content.getBytes(StandardCharsets.UTF_8);\n        pw.append(&quot;Content-Length: &quot;).append(String.valueOf(bytes.length)).append(&quot;\\r\\n&quot;);\n        pw.append(&quot;Server: MoinMoin\\r\\n&quot;);\n        pw.append(&quot;\\r\\n&quot;);\n        pw.flush();\n\n        try\n        {\n            output.write(bytes);\n\n        } catch (IOException e)\n        {\n        }\n    }\n}\n</code></pre>\n<p>To start the listener all I have to do is:</p>\n<pre><code>    private ListenerThread listener = null;\n\n    [..]\n\n    listener = new ListenerThread();\n    listener.start();\n</code></pre>\n<p>So far so good.</p>\n<p>But now I want to upgrade this to https because browsers don't like unencrypted connections these days. Just using <code>SSLServerSocketFactory</code> instead of <code>ServerSocketFactory</code> and so on doesn't do the trick. There must be more. The browser tells me that the connection is not secure. I guess he's right. I need to provide a certificate somehow. Maybe a self signed certificate is sufficient for playing. But how am I supposed to apply it? Every hint is very welcome.</p>\n<p>Please don't worry about the fact that the code presented answers every get request with the same phrase, that doesn't matter for my question about enabling https requests.</p>\n<p>Update: So it seems nobody thinks having a thread offering a https server could be useful ... although other environments support this more or less out-of-the-box (python) or have project templates for similar thinks included (Visual Studio) ...</p>\n",
    "tags" : [ "java", "android" ],
    "owner" : {
      "account_id" : 3506277,
      "reputation" : 1062,
      "user_id" : 2931762,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/55f5ec3a5ba563d16b3f8d2d16d43672?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "PrfctByDsgn",
      "link" : "https://stackoverflow.com/users/2931762/prfctbydsgn"
    },
    "is_answered" : true,
    "view_count" : 94,
    "answer_count" : 2,
    "score" : 0,
    "last_activity_date" : 1762747700,
    "creation_date" : 1760541738,
    "link" : "https://stackoverflow.com/questions/79791333/howto-add-ssl-support-for-simple-android-web-server-written-in-java",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79815178,
    "question_id" : 79791333,
    "body" : "<p>You’re right: just swapping in <code>SSLServerSocketFactory</code> isn’t enough. For HTTPS you need:</p>\n<ol>\n<li><p>a server certificate + private key (in a keystore),</p>\n</li>\n<li><p>a TLS context that uses that key, and</p>\n</li>\n<li><p>a certificate the <strong>browser actually trusts</strong> (or you’ll get the “not secure” warning).</p>\n</li>\n</ol>\n<p>Below is a minimal, working path for a LAN-only toy server on Android + desktop browser.</p>\n<h2>1) Generate a cert that matches how you’ll connect</h2>\n<p>If you type the <strong>IP address</strong> in the browser (e.g., <code>https://192.168.1.100:8443/test</code>), your certificate <strong>must</strong> have that IP in the Subject Alternative Name (SAN). Browsers ignore <code>CN</code> and require SAN.</p>\n<h3>Option A: “Locally-trusted” (best DX on your own machines)</h3>\n<p>Use <strong>mkcert</strong> (it creates a local CA and adds it to your OS trust store, so the browser won’t warn):</p>\n<pre><code>mkcert -install\nmkcert 192.168.1.100 myphone.local\n# produces: 192.168.1.100+1-key.pem and 192.168.1.100+1.pem\n# Convert to PKCS#12 keystore for Java:\nopenssl pkcs12 -export \\\n  -inkey 192.168.1.100+1-key.pem \\\n  -in 192.168.1.100+1.pem \\\n  -out server.p12 \\\n  -name moin \\\n  -passout pass:changeit\n</code></pre>\n<h3>Option B: Plain self-signed (you’ll get a warning unless you import it)</h3>\n<pre><code>keytool -genkeypair -alias moin -keyalg RSA -keysize 2048 -validity 3650 \\\n  -storetype PKCS12 -keystore server.p12 -storepass changeit \\\n  -dname &quot;CN=192.168.1.100&quot; \\\n  -ext &quot;SAN=IP:192.168.1.100&quot;\n</code></pre>\n<blockquote>\n<p>Put <code>server.p12</code> into your Android project (e.g., <code>app/src/main/res/raw/server.p12</code>).</p>\n</blockquote>\n<h2>2) Load the keystore and create an <code>SSLServerSocket</code></h2>\n<p>Here’s a minimal HTTPS listener thread that mirrors your structure. It uses TLS 1.2+/1.3 and spawns your same <code>ClientThread</code> (which can remain unchanged; <code>SSLSocket</code> still provides <code>getInputStream()</code> / <code>getOutputStream()</code>).</p>\n<pre><code>public class HttpsListenerThread extends Thread {\n    private final SSLServerSocket serverSocket;\n\n    public HttpsListenerThread(Context ctx) {\n        try {\n            char[] pass = &quot;changeit&quot;.toCharArray(); // use your real password\n\n            KeyStore ks = KeyStore.getInstance(&quot;PKCS12&quot;);\n            try (InputStream is = ctx.getResources().openRawResource(R.raw.server)) {\n                ks.load(is, pass);\n            }\n\n            KeyManagerFactory kmf = KeyManagerFactory.getInstance(\n                    KeyManagerFactory.getDefaultAlgorithm());\n            kmf.init(ks, pass);\n\n            SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;);\n            sc.init(kmf.getKeyManagers(), null, null);\n\n            SSLServerSocketFactory sf = sc.getServerSocketFactory();\n            serverSocket = (SSLServerSocket) sf.createServerSocket(8443);\n\n            // lock to modern protocols\n            serverSocket.setEnabledProtocols(new String[] { &quot;TLSv1.3&quot;, &quot;TLSv1.2&quot; });\n\n            // (optional) narrow ciphers, require client auth, etc.\n\n        } catch (Exception e) {\n            throw new RuntimeException(&quot;Failed to init HTTPS server&quot;, e);\n        }\n    }\n\n    @Override public void run() {\n        try {\n            for (;;) {\n                SSLSocket s = (SSLSocket) serverSocket.accept();\n                s.setUseClientMode(false);\n                // Optional: force handshake now so errors show early\n                // s.startHandshake();\n                new ClientThread(s).start();\n            }\n        } catch (IOException e) {\n            // log it\n        }\n    }\n}\n</code></pre>\n<p>Start it like your HTTP version (prefer a different port, e.g., 8443):</p>\n<pre><code>listener = new HttpsListenerThread(getApplicationContext());\nlistener.start();\n</code></pre>\n<p>Your existing <code>ClientThread</code> can stay the same. It will read/write HTTP/1.1 bytes over the TLS stream.</p>\n<h2>3) Connect from the browser</h2>\n<ul>\n<li><p>Use <code>https://192.168.1.100:8443/test</code></p>\n</li>\n<li><p>If you used <strong>mkcert</strong>, install its local CA on the <strong>desktop</strong> you’re browsing from (mkcert’s <code>-install</code> already did this). No warning.</p>\n</li>\n<li><p>If you used a <strong>self-signed</strong> cert, the browser will warn. You can add a security exception (or import the cert into the OS/browser trust store).</p>\n</li>\n</ul>\n<blockquote>\n<p>Public CAs (e.g., Let’s Encrypt) generally <strong>won’t</strong> issue certs for raw private IPs. If you ever expose this externally with a DNS name you control, use a real CA via ACME and you’ll be warning-free for everyone.</p>\n</blockquote>\n<hr />\n<h2>Common gotchas</h2>\n<ul>\n<li><p><strong>SAN missing</strong> → browsers reject with “not secure” even if CN matches.</p>\n</li>\n<li><p><strong>Wrong host</strong> → the name (or IP) you type must be in SAN.</p>\n</li>\n<li><p><strong>Android packaging</strong> → ensure <code>server.p12</code> ends up in <code>res/raw</code> and you load it with the correct resource id and password.</p>\n</li>\n<li><p><strong>Permissions</strong> → your app needs <code>android.permission.INTERNET</code>. (Binding to low ports like 443 may be restricted; stick to 8443.)</p>\n</li>\n<li><p><strong>Keep-Alive</strong> → if you announce <code>Connection: keep-alive</code>, either properly support multiple requests on one connection or switch to <code>Connection: close</code>.</p>\n</li>\n<li><p><strong>HTTP parsing</strong> → your demo is fine for a toy, but a real server should parse request lines/headers robustly.</p>\n</li>\n</ul>\n<hr />\n<h2>Alternatives (if you don’t want to manage TLS yourself)</h2>\n<ul>\n<li><p><strong>Terminate TLS on a reverse proxy</strong> (Caddy/Nginx) running on a PC/RPi on your LAN and proxy to your Android app’s HTTP on <code>8082</code>. The proxy handles certs; your app stays simple.</p>\n</li>\n<li><p>Use a tiny embedded server that already supports TLS (e.g., <strong>NanoHTTPD</strong> has HTTPS support via keystore).</p>\n</li>\n</ul>\n",
    "score" : 1,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 234980,
      "reputation" : 7907,
      "user_id" : 501483,
      "user_type" : "registered",
      "accept_rate" : 92,
      "profile_image" : "https://www.gravatar.com/avatar/a78df27dd733596d67f7d67eb5eac7ae?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "dharmendra",
      "link" : "https://stackoverflow.com/users/501483/dharmendra"
    },
    "creation_date" : 1762747700,
    "last_activity_date" : 1762747700,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79791907,
    "question_id" : 79791333,
    "body" : "<p>SSL does not work with private IP ranges, but requires a static, publicly routable IP address.<br/>\nThis means, that on Android one could only use a self-signed SSL certicate, that cannot be verified.<br/>\nThis certificate would subsequently need to be added into every device connnecting the server.</p>\n<p>Better stop the abuse and deploy the server to the public internet, instead of running it on an end-device. This is by design and there is nothing to do about it, unless you could supply a static, publicly routable IP address, most likely through an ethernet cable ...</p>\n<hr />\n<p>I'm not saying &quot;it's impossible&quot; but it's probably too much of a hassle to be worth it ...<br/>\nYou'd need something alike this <a href=\"https://service.anker.com/product-description/a085g000004x2CsAAI/powerexpand-usbc-to-25-gbps-ethernet-adapter\" rel=\"nofollow noreferrer\">NIC</a>, plus a DSL contract with static/fixed IP address.<br/>\nUnless providing such environment, all attempts to sign off a valid certificate will fail.</p>\n<p>While only messing around and experimenting, permitting <a href=\"https://developer.android.com/privacy-and-security/risks/cleartext-communications\" rel=\"nofollow noreferrer\">cleartext communications</a> may be a whole lot less troublesome and is no security problem on a local network, which is your own. It's not uncommon to have two network configurations, for development and production, where the debug build may have such a lentient configuration, so that one can test with a local web-server.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 263656,
      "reputation" : 79573,
      "user_id" : 549372,
      "user_type" : "registered",
      "accept_rate" : 100,
      "profile_image" : "https://www.gravatar.com/avatar/430cfd8b3056a0425f950cb1c6abd208?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Martin Zeitler",
      "link" : "https://stackoverflow.com/users/549372/martin-zeitler"
    },
    "creation_date" : 1760601180,
    "last_activity_date" : 1760602499,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140797925,
    "post_id" : 79791333,
    "body" : "You&#39;re right ... this is just me playing around. No plans to publish anything. Don&#39;t worry. But anyways ... there are things like foreground services (<a href=\"https://developer.android.com/develop/background-work/services/fgs\" rel=\"nofollow noreferrer\">developer.android.com/develop/background-work/services/fgs</a>)&zwnj;&#8203;. And a thread that is just sitting there waiting for a connection doesn&#39;t drain the battery or steal performance at all.",
    "score" : 0,
    "owner" : {
      "account_id" : 3506277,
      "reputation" : 1062,
      "user_id" : 2931762,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/55f5ec3a5ba563d16b3f8d2d16d43672?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "PrfctByDsgn",
      "link" : "https://stackoverflow.com/users/2931762/prfctbydsgn"
    },
    "creation_date" : 1760554279,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140797904,
    "post_id" : 79791333,
    "body" : "Just an FYI-  unless this is a personal project to learn Android, I do not suggest writing a server on Android.  Long running processes are against the entire design philosophy of the OS.  You won&#39;t get any reliability out of a server on Android.  You&#39;re better off on a Linux box of any sort.  And if the reason you&#39;re doing it is just to provide data to another app locally, there&#39;s better ways of doing that on Android than http servers",
    "score" : 0,
    "owner" : {
      "account_id" : 1790714,
      "reputation" : 94752,
      "user_id" : 1631193,
      "user_type" : "registered",
      "accept_rate" : 71,
      "profile_image" : "https://www.gravatar.com/avatar/ac9dfee58394495fa69f12f58a928be3?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Gabe Sechan",
      "link" : "https://stackoverflow.com/users/1631193/gabe-sechan"
    },
    "creation_date" : 1760553129,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140797568,
    "post_id" : 79791333,
    "body" : "Obviously this is a stripped down version of the actual code. No need to complain about lacking exception handling.",
    "score" : 0,
    "owner" : {
      "account_id" : 3506277,
      "reputation" : 1062,
      "user_id" : 2931762,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/55f5ec3a5ba563d16b3f8d2d16d43672?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "PrfctByDsgn",
      "link" : "https://stackoverflow.com/users/2931762/prfctbydsgn"
    },
    "creation_date" : 1760543226,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140797553,
    "post_id" : 79791333,
    "body" : "Also: 1) Your&#39;re not using any <code>DataOutputStream</code> methods, so you can use the plain old stream returned from the socket (perhaps wrapped in a <code>BufferedInputStream</code>) 2) please look at a tutorial on try-with-resources, the current code leaks socket handles 3) <code>catch(SomeException ex){}</code> is almost always a bad idea.",
    "score" : 0,
    "owner" : {
      "account_id" : 30223964,
      "reputation" : 252,
      "user_id" : 23162960,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/2451acfac254a6fc75757ecf89d75f9a?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Jannik S.",
      "link" : "https://stackoverflow.com/users/23162960/jannik-s"
    },
    "creation_date" : 1760542870,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140797538,
    "post_id" : 79791333,
    "body" : "That being said, I see no actual handling of the client http request here, so the fact that this works is happstance. You&#39;ll need to read the client request until the &lt;CR&gt;&lt;LF&gt;&lt;CR&gt;&lt;LF&gt; that terminates the headers (and then examine the headers on wether there is a body) or else you can easily read too little.",
    "score" : 0,
    "owner" : {
      "account_id" : 30223964,
      "reputation" : 252,
      "user_id" : 23162960,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/2451acfac254a6fc75757ecf89d75f9a?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Jannik S.",
      "link" : "https://stackoverflow.com/users/23162960/jannik-s"
    },
    "creation_date" : 1760542538,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140797528,
    "post_id" : 79791333,
    "body" : "This question is similar to: <a href=\"https://stackoverflow.com/questions/53323855/sslserversocket-and-certificate-setup\">SSLServerSocket and certificate setup</a>. If you believe it’s different, please <a href=\"https://stackoverflow.com/posts/79791333/edit\">edit</a> the question, make it clear how it’s different and/or how the answers on that question are not helpful for your problem.",
    "score" : 0,
    "owner" : {
      "account_id" : 30223964,
      "reputation" : 252,
      "user_id" : 23162960,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/2451acfac254a6fc75757ecf89d75f9a?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Jannik S.",
      "link" : "https://stackoverflow.com/users/23162960/jannik-s"
    },
    "creation_date" : 1760542225,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79791907" : [ {
      "comment_id" : 140800508,
      "post_id" : 79791907,
      "body" : "Thanks for you efforts but this kind of advise is not what I asked for. Cannot accept this as answer.",
      "score" : 0,
      "owner" : {
        "account_id" : 3506277,
        "reputation" : 1062,
        "user_id" : 2931762,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/55f5ec3a5ba563d16b3f8d2d16d43672?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "PrfctByDsgn",
        "link" : "https://stackoverflow.com/users/2931762/prfctbydsgn"
      },
      "creation_date" : 1760643107,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79815178" : [ {
      "comment_id" : 140847217,
      "post_id" : 79815178,
      "body" : "Works. Perfect. Thanks.",
      "score" : 0,
      "owner" : {
        "account_id" : 3506277,
        "reputation" : 1062,
        "user_id" : 2931762,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/55f5ec3a5ba563d16b3f8d2d16d43672?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "PrfctByDsgn",
        "link" : "https://stackoverflow.com/users/2931762/prfctbydsgn"
      },
      "creation_date" : 1762792523,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140846642,
      "post_id" : 79815178,
      "body" : "Looks promising. Thank you! I&#39;ll try to implement it according to your description tonight.",
      "score" : 0,
      "owner" : {
        "account_id" : 3506277,
        "reputation" : 1062,
        "user_id" : 2931762,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/55f5ec3a5ba563d16b3f8d2d16d43672?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "PrfctByDsgn",
        "link" : "https://stackoverflow.com/users/2931762/prfctbydsgn"
      },
      "creation_date" : 1762775465,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}