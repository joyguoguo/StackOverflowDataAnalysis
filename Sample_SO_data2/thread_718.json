{
  "question" : {
    "question_id" : 79783378,
    "title" : "Square not rendered in OpenGL",
    "body" : "<p>I'm trying to program a simple game in java using lwjgl and OpenGL but I'm not able to render a square to the window. Can someone help?</p>\n<p>The render function in render class is called evert frame and the init function in render class is called only once at the beginnig.</p>\n<p>Error message</p>\n<pre class=\"lang-none prettyprint-override\"><code>ERROR: Vertex shader compilation failed.\nERROR: 0:1: '#version' : bad profile name; use es, core, or compatibility\nERROR: 0:1: '#version' : bad tokens following profile -- expected newline\nERROR: 0:1: '' : compilation terminated\nERROR: 3 compilation errors.  No code generated.\n\nERROR: Fragment shader compilation failed.\nERROR: 0:1: '#version' : bad profile name; use es, core, or compatibility\nERROR: 0:1: '#version' : bad tokens following profile -- expected newline\nERROR: 0:1: '' : compilation terminated \nERROR: 3 compilation errors.  No code generated.\n\nERROR: Linking of shaders failed.\n</code></pre>\n<p>Render class</p>\n<pre><code>import java.nio.FloatBuffer;\nimport java.nio.IntBuffer;\n\nimport static org.lwjgl.opengl.GL15.*;\nimport static org.lwjgl.opengl.GL20.*;\nimport static org.lwjgl.opengl.GL30.glBindVertexArray;\nimport static org.lwjgl.opengl.GL30.glGenVertexArrays;\n\npublic class Render {\n    private Shader shader;\n\n    private float[] vertexArray = {\n            0.5f, -0.5f, 0.0f,\n            -0.5f, 0.5f, 0.0f,\n            0.5f, 0.5f, 0.0f,\n            -0.5f, -0.5f, 0.0f\n    };\n\n    private int[] elementArray = {\n            2, 1, 0,\n            0, 1, 3\n    };\n\n    private int vaoID, vboID, eboID;\n\n    public Render() {\n        this.shader = new Shader(&quot;defaultVertexShader.glsl&quot;, &quot;defaultFragmentShader.glsl&quot;, &quot;src/main/resources/render/shaders/&quot;);\n    }\n\n    public void init() {\n        shader.compile();\n        shader.link();\n\n        vaoID = glGenVertexArrays();\n        glBindVertexArray(vaoID);\n\n        FloatBuffer vertexBuffer = BufferUtils.createFloatBuffer(vertexArray.length);\n        vertexBuffer.put(vertexArray).flip();\n\n        vboID = glGenBuffers();\n        glBindBuffer(GL_ARRAY_BUFFER, vboID);\n        glBufferData(GL_ARRAY_BUFFER, vertexBuffer, vboID);\n\n        IntBuffer elementBuffer = BufferUtils.createIntBuffer(elementArray.length);\n        elementBuffer.put(elementArray).flip();\n\n        eboID = glGenBuffers();\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, eboID);\n        glBufferData(GL_ELEMENT_ARRAY_BUFFER, elementBuffer, eboID);\n\n        glVertexAttribPointer(0, 3, GL_FLOAT, false, 12, 0);\n        glEnableVertexAttribArray(0);\n    }\n\n    public void render() {\n        shader.use();\n        glBindVertexArray(vaoID);\n        glEnableVertexAttribArray(0);\n\n        glDrawElements(GL_TRIANGLES, elementArray.length, GL_UNSIGNED_INT, 0);\n\n        glDisableVertexAttribArray(0);\n        glBindVertexArray(0);\n        shader.detach();\n    }\n}\n</code></pre>\n<p>Shader class</p>\n<pre><code>import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.Scanner;\n\nimport static org.lwjgl.opengl.GL11.GL_FALSE;\nimport static org.lwjgl.opengl.GL20.*;\nimport static org.lwjgl.opengl.GL20.glUseProgram;\n\npublic class Shader {\n    private String vertexShaderSrc;\n    private String fragmentShaderSrc;\n\n    private int vertexID, fragmentID, shaderProgram;\n\n    public Shader(String vertexShader, String fragmentShader, String root) {\n        this.vertexShaderSrc = getShader(vertexShader, root);\n        this.fragmentShaderSrc = getShader(fragmentShader, root);\n    }\n\n    public void compile() {\n        vertexID = glCreateShader(GL_VERTEX_SHADER);\n        glShaderSource(vertexID, vertexShaderSrc);\n        glCompileShader(vertexID);\n        int success = glGetShaderi(vertexID, GL_COMPILE_STATUS);\n        if (success == GL_FALSE) {\n            int len = glGetShaderi(vertexID, GL_INFO_LOG_LENGTH);\n            System.out.println(&quot;ERROR: Vertex shader compilation failed.&quot;);\n            System.out.println(glGetShaderInfoLog(vertexID, len));\n        }\n\n        fragmentID = glCreateShader(GL_FRAGMENT_SHADER);\n        glShaderSource(fragmentID, fragmentShaderSrc);\n        glCompileShader(fragmentID);\n        success = glGetShaderi(fragmentID, GL_COMPILE_STATUS);\n        if (success == GL_FALSE) {\n            int len = glGetShaderi(fragmentID, GL_INFO_LOG_LENGTH);\n            System.out.println(&quot;ERROR: Fragment shader compilation failed.&quot;);\n            System.out.println(glGetShaderInfoLog(fragmentID, len));\n        }\n    }\n\n    public void link() {\n        shaderProgram = glCreateProgram();\n        glAttachShader(shaderProgram, vertexID);\n        glAttachShader(shaderProgram, fragmentID);\n        glLinkProgram(shaderProgram);\n        int success = glGetProgrami(shaderProgram, GL_LINK_STATUS);\n        if (success == GL_FALSE) {\n            int len = glGetProgrami(shaderProgram, GL_INFO_LOG_LENGTH);\n            System.out.println(&quot;ERROR: Linking of shaders failed.&quot;);\n            System.out.println(glGetProgramInfoLog(shaderProgram, len));\n        }\n    }\n\n    public void use() {\n        glUseProgram(shaderProgram);\n    }\n\n    public void detach() {\n        glUseProgram(0);\n    }\n\n    private String getShader(String shaderName, String root) {\n        String data = &quot;&quot;;\n        File shaderFile = new File(root + shaderName);\n\n        try (Scanner reader = new Scanner(shaderFile)) {\n            while (reader.hasNextLine()) {\n                data += reader.nextLine();\n            }\n        } catch (FileNotFoundException e) {\n            System.out.println(&quot;An error occurred.&quot;);\n            e.printStackTrace();\n        }\n\n        return data;\n    }\n}\n</code></pre>\n<p>Vertex Shader</p>\n<pre><code>#version 330 core\n\nlayout (location=0) in vec3 pos;\n\nvoid main() {\n    gl_Position = vec4(pos, 1.0f);\n}\n</code></pre>\n<p>Fragment Shader</p>\n<pre><code>#version 330 core\n\nout vec4 color;\n\nvoid main() {\n    color = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n}\n</code></pre>\n<p>Window</p>\n<pre><code>import org.lwjgl.glfw.GLFWErrorCallback;\nimport org.lwjgl.opengl.GL;\n\nimport static org.lwjgl.glfw.Callbacks.glfwFreeCallbacks;\nimport static org.lwjgl.glfw.GLFW.*;\nimport static org.lwjgl.system.MemoryUtil.NULL;\n\npublic class Window {\n    private static Window instance;\n\n    private int width, height;\n    private String title;\n    private long window;\n\n    private Window(int width, int height, String title) {\n        this.width = width;\n        this.height = height;\n        this.title = title;\n    }\n\n    public static Window get(int width, int height, String title) {\n        if (instance == null) instance = new Window(width, height, title);\n\n        return instance;\n    }\n\n    public void init() {\n        GLFWErrorCallback.createPrint(System.err).set();\n\n        if (!glfwInit()) throw new IllegalStateException(&quot;Unable to initialize GLFW&quot;);\n\n        glfwDefaultWindowHints();\n        glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE);\n        glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);\n        glfwWindowHint(GLFW_MAXIMIZED, GLFW_TRUE);\n\n        window = glfwCreateWindow(width, height, title, NULL, NULL);\n        if (window == NULL) throw new RuntimeException(&quot;Failed to create the GLFW window&quot;);\n\n        glfwMakeContextCurrent(window);\n        glfwSwapInterval(1);\n        glfwShowWindow(window);\n\n        GL.createCapabilities();\n    }\n\n    public void destroy() {\n        glfwFreeCallbacks(window);\n        glfwDestroyWindow(window);\n\n        glfwTerminate();\n        glfwSetErrorCallback(null).free();\n    }\n\n    public long getWindow() {\n        return window;\n    }\n}\n</code></pre>\n<p>Game Loop\ninput, update, render, and cleanup methonds are called in a while loop every frame.</p>\n<pre><code>import static org.lwjgl.glfw.GLFW.glfwPollEvents;\nimport static org.lwjgl.glfw.GLFW.glfwSwapBuffers;\nimport static org.lwjgl.opengl.GL11.*;\n\npublic class GameLoop implements IGameLogic {\n    private static GameLoop instance;\n\n    private GameLoop() {\n\n    }\n\n    public static GameLoop get() {\n        if (instance == null) instance = new GameLoop();\n\n        return instance;\n    }\n\n    @Override\n    public void input() {\n        glfwPollEvents();\n    }\n\n    @Override\n    public void update(Scene scene, double deltaTime) {\n        scene.update();\n    }\n\n    @Override\n    public void render(Scene scene, Render render) {\n        glClearColor(1.0f, 1.0f, 1.0f, 0.0f);\n        render.render(scene);\n    }\n\n    @Override\n    public void cleanup(Window window) {\n        glClear(GL_COLOR_BUFFER_BIT);\n        glfwSwapBuffers(window.getWindow());\n    }\n}\n</code></pre>\n",
    "tags" : [ "java", "gradle", "opengl", "glsl", "lwjgl" ],
    "owner" : {
      "account_id" : 44211914,
      "reputation" : 67,
      "user_id" : 31634908,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/58b9e3f6bbec08233289a36e0161e5a7?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Klaus Alles",
      "link" : "https://stackoverflow.com/users/31634908/klaus-alles"
    },
    "is_answered" : true,
    "view_count" : 160,
    "answer_count" : 1,
    "score" : 3,
    "last_activity_date" : 1761386698,
    "creation_date" : 1759729350,
    "link" : "https://stackoverflow.com/questions/79783378/square-not-rendered-in-opengl",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79783888,
    "question_id" : 79783378,
    "body" : "<p>The problem is calling <code>glClear()</code> before doing <code>glfwSwapBuffers()</code>.</p>\n<p>Since you used two clearing-related calls and got them a bit wrong, let me explain what they do, that will probably save you some time when you enable depth-related rendering later on :)</p>\n<ul>\n<li><p><code>glClearColor(...)</code> does not <em>actually</em> clear anything, it only sets the color to be used for the clearing process when <em>actual clearing</em> happens. So this function basically says to OpenGL: &quot;hey, I want to set a color to be used for color buffer clear operations&quot;. That's it.</p>\n</li>\n<li><p>In addition to color buffer(s), a usual framebuffer (the surface you are drawing to, in this case: your window) can also have a depth buffer and a stencil buffer (sometimes combined into a single depth-stencil buffer, e.g. in D24S8 format). Those can be cleared as well:</p>\n<ul>\n<li><p><code>glClearDepth()</code> does the equivalent thing for depth: it says &quot;hey, I want to set a depth value to be used for depth buffer clear operations&quot;. Again - no clearing happens!</p>\n</li>\n<li><p><code>glClearStencil()</code> -&gt; you can already figure out what this one does, don't you?</p>\n</li>\n</ul>\n</li>\n<li><p>After this setup is done, you can clear the current framebuffer with <code>glClear()</code>. This is where clear is being done. In addition to <code>GL_COLOR_BUFFER_BIT</code> you already used, it also accepts <code>GL_DEPTH_BUFFER_BIT</code> and <code>GL_STENCIL_BUFFER_BIT</code> for depth and stencil buffer, respectively. You can combine them by bit-or'ing them together, e.g. <code>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)</code> will clear both color and depth buffers.</p>\n</li>\n</ul>\n<p>The clear is usually made at the beginning of a frame, so in your example <code>glClear()</code> should happen before <code>render.render(scene)</code>, otherwise you will be clearing out everything you rendered with this call.</p>\n<p>Also: you don't need to repeat <code>glClearColor</code> every frame (neither <code>glClearDepth</code>/<code>glClearStencil</code> if you use them). After you set the clear value for either of the buffers, it is saved by the implementation for your current context. Hence, if your clear color stays the same, you are doing unnecessary API calls - one is enough.</p>\n<p>I hope this helps!</p>\n",
    "score" : 1,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 3348167,
      "reputation" : 12343,
      "user_id" : 2812864,
      "user_type" : "registered",
      "accept_rate" : 88,
      "profile_image" : "https://i.sstatic.net/GVsZM.jpg?s=256",
      "display_name" : "Mateusz Grzejek",
      "link" : "https://stackoverflow.com/users/2812864/mateusz-grzejek"
    },
    "creation_date" : 1759768467,
    "last_activity_date" : 1761386698,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140779747,
    "post_id" : 79783378,
    "body" : "The cleanup() method looks strange though, usually you&#39;d expect clear -&gt; draw scene -&gt; swap buffer, but it looks like you are doing drawing, then cleaning and swapping buffers which means you override your drawing with the clean.",
    "score" : 1,
    "owner" : {
      "account_id" : 3043323,
      "reputation" : 22409,
      "user_id" : 2579738,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/oXata.png?s=256",
      "display_name" : "BDL",
      "link" : "https://stackoverflow.com/users/2579738/bdl"
    },
    "creation_date" : 1759760832,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140779738,
    "post_id" : 79783378,
    "body" : "Do the shaders compile now? Any other new errors from glGetError()?",
    "score" : 0,
    "owner" : {
      "account_id" : 3043323,
      "reputation" : 22409,
      "user_id" : 2579738,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/oXata.png?s=256",
      "display_name" : "BDL",
      "link" : "https://stackoverflow.com/users/2579738/bdl"
    },
    "creation_date" : 1759760488,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140779452,
    "post_id" : 79783378,
    "body" : "I was not adding a newline charecter when getting the shader source but the square is still not being drawn.",
    "score" : 0,
    "owner" : {
      "account_id" : 44211914,
      "reputation" : 67,
      "user_id" : 31634908,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/58b9e3f6bbec08233289a36e0161e5a7?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Klaus Alles",
      "link" : "https://stackoverflow.com/users/31634908/klaus-alles"
    },
    "creation_date" : 1759752955,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140779339,
    "post_id" : 79783378,
    "body" : "The error messages suggest (to me at least) that the shader code you&#39;ve shown is <i>not</i> the code that&#39;s actually being compiled.  You might want to use <a href=\"https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShaderSource.xhtml\" rel=\"nofollow noreferrer\"><code>glGetShaderSource</code></a> to view the &#39;real&#39; shader source.",
    "score" : 0,
    "owner" : {
      "account_id" : 8496744,
      "reputation" : 13078,
      "user_id" : 6371123,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/7f90991c1b06c79ae4c6e79fb616d608?s=256&d=identicon&r=PG",
      "display_name" : "G.M.",
      "link" : "https://stackoverflow.com/users/6371123/g-m"
    },
    "creation_date" : 1759749602,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140779211,
    "post_id" : 79783378,
    "body" : "You should have checked that <i>before</i> posting your question.  Please <a href=\"https://stackoverflow.com/posts/79783378/edit\">edit</a> the question to include the full error message(s) as text verbatim and, if possible, also update the code to form a valid <a href=\"https://stackoverflow.com/help/minimal-reproducible-example\">minimal reproducible example</a>.",
    "score" : 4,
    "owner" : {
      "account_id" : 8496744,
      "reputation" : 13078,
      "user_id" : 6371123,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/7f90991c1b06c79ae4c6e79fb616d608?s=256&d=identicon&r=PG",
      "display_name" : "G.M.",
      "link" : "https://stackoverflow.com/users/6371123/g-m"
    },
    "creation_date" : 1759744935,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140779191,
    "post_id" : 79783378,
    "body" : "Thakns but that didn&#39;t work. I think theres somthing wrong with the shaders because if I try to run it, it thwros an error that shaders compulation failed beacuse of the #version 330 core.",
    "score" : 0,
    "owner" : {
      "account_id" : 44211914,
      "reputation" : 67,
      "user_id" : 31634908,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/58b9e3f6bbec08233289a36e0161e5a7?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Klaus Alles",
      "link" : "https://stackoverflow.com/users/31634908/klaus-alles"
    },
    "creation_date" : 1759744331,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140779048,
    "post_id" : 79783378,
    "body" : "You don&#39;t need to pass the buffer id when calling glBufferData, instead you need something like GL15.GL_STATIC_DRAW",
    "score" : 3,
    "owner" : {
      "account_id" : 25716295,
      "reputation" : 46,
      "user_id" : 19474029,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/9BOip.png?s=256",
      "display_name" : "Qweru",
      "link" : "https://stackoverflow.com/users/19474029/qweru"
    },
    "creation_date" : 1759739485,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}