{
  "question" : {
    "question_id" : 79701734,
    "title" : "Is there a reason to use HashSet + List over LinkedHashSet for unique and ordered collection of objects?",
    "body" : "<p>I need to maintain an ordered collection of inputs that disallows duplicates.</p>\n<p>The obvious option is <code>LinkedHashSet</code>, but a less obvious option might be a combination of <code>HashSet</code> and <code>List</code>. Here's an example showing both implementations:</p>\n<pre class=\"lang-java prettyprint-override\"><code>class TestClass{\n    private final Set&lt;ThingIds&gt; setOfThingIds;\n    private final List&lt;Thing&gt; listOfThings;\n    private final Set&lt;Thing&gt; linkedHashSetOfThings;\n\n    // ... constructor instantiates empty objects\n\n    void addThingsViaList(List&lt;Thing&gt; things){\n        for(var thing: things){\n            var id = getThingId(thing);\n            if(setOfThingIds.contains(id)) continue;\n            setOfThingIds.add(id);\n            listOfThings.add(thing);\n        }\n    }\n\n    void addThingsViaSet(List&lt;Thing&gt; things){\n        for(var thing: things){\n            linkedHashSetOfThings.add(thing); // thingId calc added to Thing's equals method\n        }\n    }\n}\n</code></pre>\n<p>When would the first method be useful/required over the second?</p>\n<p>One reason I could think of is if there were some bespoke expensive logic to be used for ids so adding it here would localise it and reduce the performance impact (as opposed to adding it on the <code>equals()</code> method where it would be used everywhere...though this is a weak argument since it could be stored on <code>Thing</code> as a field and invoked lazily from <code>equals()</code>)...are there any other? Especially ones that aren't micro-optimisations?</p>\n",
    "tags" : [ "java" ],
    "owner" : {
      "account_id" : 11512926,
      "reputation" : 123,
      "user_id" : 10560184,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/3399de3e1ec229ab54f7a9926b6a35b8?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Andorrax",
      "link" : "https://stackoverflow.com/users/10560184/andorrax"
    },
    "is_answered" : true,
    "view_count" : 161,
    "closed_date" : 1752599730,
    "answer_count" : 3,
    "score" : 2,
    "last_activity_date" : 1752602150,
    "creation_date" : 1752566350,
    "link" : "https://stackoverflow.com/questions/79701734/is-there-a-reason-to-use-hashset-list-over-linkedhashset-for-unique-and-ordere",
    "closed_reason" : "Opinion-based"
  },
  "answers" : [ {
    "answer_id" : 79701786,
    "question_id" : 79701734,
    "body" : "<p>The first approach has no objective advantages. You end up doing a <code>continue;</code> inside the loop, which is not helpful in making the code readable, you entangle two collections and you will need to worry about they being changed in an undesired manner by devs in a team not aware of the entanglement.</p>\n<p>The second approach is more readable and handles implicitly stuff that you had to handle explicitly in the first approach.</p>\n<p>The only &quot;advantage&quot; the first approach has is that you have a list of ids, but you can derive such an id list from the data-structure in the second list easily whenever you wish.</p>\n<p>So the principles to apply here are:</p>\n<ul>\n<li>&quot;don't solve a problem you do not have&quot;</li>\n<li>&quot;don't reimplement something that was implemented, you spend time, your solution will not necessarily be as good and you duplicate a feature that exists already&quot;</li>\n<li>&quot;separate concerns, with your data-structures aim for their implicitly handling the problems they are capable of solving rather than doing it explicitly at the usage&quot;</li>\n</ul>\n<p>EDIT</p>\n<p>In the comment-section disagreement was expressed on the applicability of the &quot;don't solve a problem you do not have&quot; principle as <code>equals</code> and <code>hashCode</code> is to be overriden just for this reason. However the point has its merit of course, I would argue that if a <code>Thing</code> needs to equal with another if their <code>id</code> matches, then not overriding the <code>equals</code> method is a flaw in the design and it needs to be overriden anyway, because <code>thing1.equals(thing2)</code> could return <code>false</code> even if their <code>id</code> matches if it is not overriden, leading to bugs.</p>\n<p>So even if it was not to be ordered in a unique manner in a set, if we can postulate in general that they are equal when their id is matches, then we should do override <code>equals</code> anyways, so by the time we arrive to the linked hashset problem, we no longer have any doubts about overriding <code>equals</code> or not.</p>\n",
    "score" : 5,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 194308,
      "reputation" : 80530,
      "user_id" : 436560,
      "user_type" : "registered",
      "accept_rate" : 87,
      "profile_image" : "https://i.sstatic.net/2GESV.jpg?s=256",
      "display_name" : "Lajos Arpad",
      "link" : "https://stackoverflow.com/users/436560/lajos-arpad"
    },
    "creation_date" : 1752568972,
    "last_activity_date" : 1752576287,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79701841,
    "question_id" : 79701734,
    "body" : "<p>First the conditions:</p>\n<ul>\n<li>You want to keep the order of a LinkedHashSet: order on addition, a duplicate addition will not change the order.</li>\n<li>ThingId will identify Thing uniquely.</li>\n<li>The ThingId getter should not be a costly calculation.</li>\n</ul>\n<p>Then the first alternative with separation simply does what the second alternative does more succinctly. So the second alternative seems best.</p>\n<p>However there is also the possibility of <strong><code>LinkedHashMap</code></strong>.</p>\n<pre><code>private final Map&lt;ThingId, Thing&gt; linkedHashMapOfThings = new LinkedHashMao&lt;&gt;();\n\nvoid addThingsViaMap(List&lt;Thing&gt; things){\n    for (var thing: things) {\n        linkedHashMapOfThings.put(getThingId(thing), thing);\n    }\n}\n</code></pre>\n<p>This provides a <code>keySet()</code>.</p>\n<p>Depending on the usage, especially Stream operations, having the ThingId might be nice.</p>\n<p>Furthermore the Set implementation is somewhat a Map, so no extra costs.</p>\n",
    "score" : 4,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 960307,
      "reputation" : 110397,
      "user_id" : 984823,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/Z2KYN.jpg?s=256",
      "display_name" : "Joop Eggen",
      "link" : "https://stackoverflow.com/users/984823/joop-eggen"
    },
    "creation_date" : 1752572059,
    "last_activity_date" : 1752572059,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79701792,
    "question_id" : 79701734,
    "body" : "<p>The two snippets are functionally different.</p>\n<p>In the second snippet, you hold an ordered set of unique <code>Thing</code> objects. In the first snippet, you hold an ordered list of <code>Thing</code> objects and use a set to ensure theirs IDs are unique.<br />\nIn other words, the second snippet will allow two different <code>Thing</code>s with the same ID, while the first will not. Whether this is a valid usecase or not depends on your business logic.</p>\n<p>To make the first snippet equivelent to the first one, you'll need to use the set to store <code>Thing</code>s, not their IDs:</p>\n<pre class=\"lang-java prettyprint-override\"><code>class TestClass {\n    private final Set&lt;Thing&gt; setOfThing;\n    private final List&lt;Thing&gt; listOfThings;\n    private final Set&lt;Thing&gt; linkedHashSetOfThings;\n\n    // ... constructor instantiates empty objects\n\n    void addThingsViaList (List&lt;Thing&gt; things) {\n        for (var thing: things) {\n            if(setOfThing.contains(thing)) continue;\n            setOfThingIds.add(thing);\n            listOfThings.add(thing);\n        }\n    }\n\n    // addThingsViaSet implementation omitted for brevity's sake\n}\n</code></pre>\n<p>Comparing this implementation to the implementation of <code>addThingsViaSet</code>, I honestly see no upside to it.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2818342,
      "reputation" : 316066,
      "user_id" : 2422776,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/2353050223ebecb113741c29458de4b2?s=256&d=identicon&r=PG",
      "display_name" : "Mureinik",
      "link" : "https://stackoverflow.com/users/2422776/mureinik"
    },
    "creation_date" : 1752569583,
    "last_activity_date" : 1752602150,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140590841,
    "post_id" : 79701734,
    "body" : "As an aside seeing your <code>LinkedHashSet</code> as a <a href=\"https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/SequencedSet.html\" rel=\"nofollow noreferrer\"><code>SequencedSet</code></a> since Java 21 seems appropriate here and useful for accessing in order. Or using <code>SequencedMap</code> implemented as <code>LinkedHashMap</code>.",
    "score" : 2,
    "owner" : {
      "account_id" : 7612423,
      "reputation" : 87409,
      "user_id" : 5772882,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/8283c64511fa80afed5259d10850168f?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Anonymous",
      "link" : "https://stackoverflow.com/users/5772882/anonymous"
    },
    "creation_date" : 1752581815,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140590682,
    "post_id" : 79701734,
    "body" : "Quite a bit of chat over IDs and equality. Andorrax, is it actually the case that your object can have the same id yet not be equal?",
    "score" : 3,
    "owner" : {
      "account_id" : 22124137,
      "reputation" : 4244,
      "user_id" : 16376827,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/1ImPw.png?s=256",
      "display_name" : "g00se",
      "link" : "https://stackoverflow.com/users/16376827/g00se"
    },
    "creation_date" : 1752578535,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140590392,
    "post_id" : 79701734,
    "body" : "Do neither of those two options! Use <code>LinkedHashMap</code> with the id as key and Thing as value.",
    "score" : 5,
    "owner" : {
      "account_id" : 19118721,
      "reputation" : 12499,
      "user_id" : 13963086,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/9df2c3c4c87d8050b8fd6a59c88c7133?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "k314159",
      "link" : "https://stackoverflow.com/users/13963086/k314159"
    },
    "creation_date" : 1752571339,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140590388,
    "post_id" : 79701734,
    "body" : "Logic can be simpler, there is no point calling set <code>contains</code> then <code>add</code>, just use return code of add for deciding whether to add to the list.",
    "score" : 4,
    "owner" : {
      "account_id" : 5998820,
      "reputation" : 16284,
      "user_id" : 4712734,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f6e922a2cb7e2da59286f27b162aaca5?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "DuncG",
      "link" : "https://stackoverflow.com/users/4712734/duncg"
    },
    "creation_date" : 1752571265,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140590319,
    "post_id" : 79701734,
    "body" : "Does it make sense that Thing&#39;s <code>equals</code> and <code>hashCode</code> methods only look at <code>thingId</code> and nothing else? These two methods will be used for everything, not just for the LinkedHashSet.",
    "score" : 0,
    "owner" : {
      "account_id" : 19118721,
      "reputation" : 12499,
      "user_id" : 13963086,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/9df2c3c4c87d8050b8fd6a59c88c7133?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "k314159",
      "link" : "https://stackoverflow.com/users/13963086/k314159"
    },
    "creation_date" : 1752569766,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79701792" : [ {
      "comment_id" : 140591829,
      "post_id" : 79701792,
      "body" : "@knittl eap! indeed! thanks for noticing.",
      "score" : 0,
      "owner" : {
        "account_id" : 2818342,
        "reputation" : 316066,
        "user_id" : 2422776,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/2353050223ebecb113741c29458de4b2?s=256&d=identicon&r=PG",
        "display_name" : "Mureinik",
        "link" : "https://stackoverflow.com/users/2422776/mureinik"
      },
      "creation_date" : 1752602162,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140591795,
      "post_id" : 79701792,
      "body" : "&quot;In other words, the second snippet will allow two different Things with the same ID, while the second will not.&quot; I think you meant to write &quot;first&quot; for the second &quot;second&quot;",
      "score" : 0,
      "owner" : {
        "account_id" : 39208,
        "reputation" : 269427,
        "user_id" : 112968,
        "user_type" : "registered",
        "accept_rate" : 68,
        "profile_image" : "https://i.sstatic.net/zHTaT.png?s=256",
        "display_name" : "knittl",
        "link" : "https://stackoverflow.com/users/112968/knittl"
      },
      "creation_date" : 1752601317,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140590377,
      "post_id" : 79701792,
      "body" : "Did you not see the comment on the second snippet, which says the Thing&#39;s equals method would have to be changed to use the id?",
      "score" : 0,
      "owner" : {
        "account_id" : 19118721,
        "reputation" : 12499,
        "user_id" : 13963086,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/9df2c3c4c87d8050b8fd6a59c88c7133?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "k314159",
        "link" : "https://stackoverflow.com/users/13963086/k314159"
      },
      "creation_date" : 1752571099,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79701841" : [ {
      "comment_id" : 140590441,
      "post_id" : 79701841,
      "body" : "This is exactly what I would do, with also a <code>getThings()</code> method that returns <code>linkedHashMapOfThings.values()</code> which will return a collection with the desired iteration order.",
      "score" : 1,
      "owner" : {
        "account_id" : 19118721,
        "reputation" : 12499,
        "user_id" : 13963086,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/9df2c3c4c87d8050b8fd6a59c88c7133?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "k314159",
        "link" : "https://stackoverflow.com/users/13963086/k314159"
      },
      "creation_date" : 1752572520,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79701786" : [ {
      "comment_id" : 140593161,
      "post_id" : 79701786,
      "body" : "@Slaw my position is that equals need to work consistently. So if two <code>Thing</code>s are to be equal despite their differences due to their id being equal (so it&#39;s the same <code>Thing</code>, albeit in different states), then <code>equals</code> needs to be overriden anyway. Otherwise, if <code>equals</code> need not to be overriden, but an overriden <code>equals</code> would be needed by the linked hashset, then indeed there is a problem to be addressed as you pointed out. There are neat ways to address that problem btw, but it is beyond the scope of this answer until it is confirmed that the asker indeed needs not to override equals.",
      "score" : 1,
      "owner" : {
        "account_id" : 194308,
        "reputation" : 80530,
        "user_id" : 436560,
        "user_type" : "registered",
        "accept_rate" : 87,
        "profile_image" : "https://i.sstatic.net/2GESV.jpg?s=256",
        "display_name" : "Lajos Arpad",
        "link" : "https://stackoverflow.com/users/436560/lajos-arpad"
      },
      "creation_date" : 1752653831,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140592343,
      "post_id" : 79701786,
      "body" : "I think the case brought up by @k314159 is when two <code>Thing</code> objects can have the same ID but are by design <i>not</i> <code>equals</code> due to <i>other properties</i>. Your edit addresses the case where <code>equals</code> was not overridden in the first place. If <code>equals</code> must be defined by more than just the ID, but the collection must be distinct based only on the ID, then using a sole <code>LinkedHashSet&lt;Thing&gt;</code> may not be an option.",
      "score" : 1,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49904,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1752617411,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140590593,
      "post_id" : 79701786,
      "body" : "@k314159 thanks for your comment. I have edited my answer to reflect my thoughts on your remark.",
      "score" : 1,
      "owner" : {
        "account_id" : 194308,
        "reputation" : 80530,
        "user_id" : 436560,
        "user_type" : "registered",
        "accept_rate" : 87,
        "profile_image" : "https://i.sstatic.net/2GESV.jpg?s=256",
        "display_name" : "Lajos Arpad",
        "link" : "https://stackoverflow.com/users/436560/lajos-arpad"
      },
      "creation_date" : 1752576319,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140590518,
      "post_id" : 79701786,
      "body" : "<i>&quot;don&#39;t solve a problem you do not have&quot;</i> -&gt; but the OP has a problem: the set needs to be unique based on &#39;id&#39;, but they are storing &#39;things&#39;. They therefore need to change the equals and hashCode methods just for this reason. But those methods might be needed for other cases where the whole &#39;thing&#39; needs to be checked and not just the id.",
      "score" : 0,
      "owner" : {
        "account_id" : 19118721,
        "reputation" : 12499,
        "user_id" : 13963086,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/9df2c3c4c87d8050b8fd6a59c88c7133?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "k314159",
        "link" : "https://stackoverflow.com/users/13963086/k314159"
      },
      "creation_date" : 1752574476,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}