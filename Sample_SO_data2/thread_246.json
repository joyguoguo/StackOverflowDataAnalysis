{
  "question" : {
    "question_id" : 79818807,
    "title" : "Java ExecutorService detect asap thread fail",
    "body" : "<p>I have to run x asynchronous threads , which can last several minutes each.<br />\nThey ALL have to terminate properly without exceptions.</p>\n<p>If one fails I have to stop them all immediately and not wait minutes for them to finish a job that will be useless. How can I do it?  This is a piece of my current code:</p>\n<pre><code>ExecutorService executorService = Executors.newFixedThreadPool(iNumThread);\nList&lt;Callable&lt;String&gt;&gt; callableTasks = new ArrayList&lt;&gt;();\nfor (int i = 0; i &lt; iNumThread; i++) {\n    callableTasks.add(new ExecuteJob(...));  \n}\n\nList&lt;Future&lt;String&gt;&gt; resultList = null;\ntry {\n    resultList = executorService.invokeAll(callableTasks);\n} catch (InterruptedException ex) {\n    ex.printStackTrace();\n}\nexecutorService.shutdown();\n\n// This cycle doesn't work for me because it waits for all threads to finish even if one or more have given an exception. \nwhile (!executorService.isTerminated()) {\n    //DO SOMETHING LIKE UPDATE UI, ETC\n}\n//check result\nfor (int i = 0; i &lt; resultList.size(); i++) {\n    Future&lt;String&gt; future = resultList.get(i);\n    try {\n        String result = future.get();\n        if (!result.equals(&quot;OK&quot;)){\n            //ohi ohi\n        }        \n    } catch (InterruptedException | ExecutionException e) {\n        //ohi ohi\n        e.printStackTrace();\n    }\n}\n\n</code></pre>\n<p>What I had thought was to put the for loop inside the while loop but it seems to me that the future.get() method blocks the execution of the thread and I want to keep it faster as possible.</p>\n<p>I hope I've made myself clear. Thank you very much.</p>\n<p>Max</p>\n",
    "tags" : [ "java", "multithreading", "exception", "executorservice" ],
    "owner" : {
      "account_id" : 44663395,
      "reputation" : 51,
      "user_id" : 31870929,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/bf3c15f6c1855c02264482fa72dbc45a?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "MaxSan",
      "link" : "https://stackoverflow.com/users/31870929/maxsan"
    },
    "is_answered" : true,
    "view_count" : 106,
    "answer_count" : 1,
    "score" : 4,
    "last_activity_date" : 1763075134,
    "creation_date" : 1763034356,
    "link" : "https://stackoverflow.com/questions/79818807/java-executorservice-detect-asap-thread-fail",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79818998,
    "question_id" : 79818807,
    "body" : "<h2><code>java.util.concurrent.ExecutorCompletionService</code></h2>\n<p>You can use <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/ExecutorCompletionService.html\" rel=\"nofollow noreferrer\"><code>ExecutorCompletionService</code></a> for that. Here is a little example. Let's first create a simple <code>ExecuteJob</code> class for demonstration.</p>\n<h3>ExecuteJob.java</h3>\n<pre class=\"lang-java prettyprint-override\"><code>public class ExecuteJob implements Callable&lt;String&gt; {\n\n    private final int ID;\n\n    public ExecuteJob(int ID) {\n        this.ID = ID;\n    }\n\n    @Override\n    public String call() {\n        try {\n            Thread.sleep(1000L * this.ID);\n\n            // Let's fail the third thread for demonstration\n//            if (this.ID == 2) {\n//                throw new RuntimeException();\n//            }\n\n            return &quot;OK\\t&quot; + (System.currentTimeMillis() / 1000);\n        } catch (Exception e) {\n            return &quot;NOT OK\\t&quot; + (System.currentTimeMillis() / 1000);\n        }\n    }\n}\n</code></pre>\n<p>This class when executed, sleeps for <code>ID</code> seconds to mimic a running job. I will explain the commented out part later.</p>\n<h3>App.java</h3>\n<pre class=\"lang-java prettyprint-override\"><code>private final static int iNumThread = 6;\n\npublic static void main(String[] args) throws InterruptedException, ExecutionException {\n    ExecutorService es = Executors.newFixedThreadPool(iNumThread);\n    ExecutorCompletionService&lt;String&gt; ecs = new ExecutorCompletionService&lt;&gt;(es);\n\n    for (int i = 0; i &lt; iNumThread; i++) ecs.submit(new ExecuteJob(i));\n\n    for (int i = 0; i &lt; iNumThread; i++) {\n        Future&lt;String&gt; f = ecs.take(); // returns as soon as any task finishes\n        String result = f.get();\n        System.out.println(result);\n\n        if (!result.startsWith(&quot;OK&quot;)) {\n            System.out.println(&quot;One thread failed, cancelling all threads...&quot;);\n            es.shutdownNow();\n            break;\n        }\n    }\n\n    System.out.println(&quot;Gracefully shutting down threads...&quot;);\n    es.shutdown();\n}\n</code></pre>\n<p>Here you can see that we use <code>ExecutorCompletionService</code> for execution of our tasks. <code>submit()</code> method sends a task to run in the background and immediately returns a <code>Future</code> you can use to get its result or cancel it.</p>\n<p>Now when we run this code as is (there is a commented out part on <code>ExecuteJob.java</code>) the output is like this:</p>\n<pre class=\"lang-none prettyprint-override\"><code>OK  1763043309\nOK  1763043310\nOK  1763043311\nOK  1763043312\nOK  1763043313\nOK  1763043314\nGracefully shutting down threads...\n\nProcess finished with exit code 0\n</code></pre>\n<p>There is one second delay between each thread (because of the <code>Thread.sleep()</code> on the <code>ExecutorJob</code>, these are still running asynchronous). Let's un-comment those lines at the <code>ExecutorJob</code> and see what happens.</p>\n<pre class=\"lang-none prettyprint-override\"><code>OK  1763043471\nOK  1763043472\nNOT OK  1763043473\nOne thread failed, cancelling all threads...\nGracefully shutting down threads...\n\nProcess finished with exit code 0\n</code></pre>\n<p>Now when we purposely shut down a thread (the third one) the program doesn't wait for rest of them and shuts all of the threads. Note that <code>ExecutorService.shutdown()</code> method gracefully shuts down the threads. As it says in the docs:</p>\n<blockquote>\n<p>Initiates an orderly shutdown in which previously submitted tasks are executed, but no new tasks will be accepted.</p>\n</blockquote>\n<p><code>ExecutorService.shutdownNow()</code> on the other hand executes all threads <strong>immediatelly</strong>.</p>\n<blockquote>\n<p>Attempts to stop all actively executing tasks, halts the processing of waiting tasks, and returns a list of the tasks that were awaiting execution. This method does not wait for actively executing tasks to terminate.</p>\n</blockquote>\n<p>I hope this answers your question. I may have skip some <code>try/catch</code> for the simplicity of the answer. You should use them in your code. Feel free to ask any question.</p>\n",
    "score" : 4,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 20183595,
      "reputation" : 175,
      "user_id" : 14803523,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/v8YCJiJo.jpg?s=256",
      "display_name" : "iso53",
      "link" : "https://stackoverflow.com/users/14803523/iso53"
    },
    "creation_date" : 1763044515,
    "last_activity_date" : 1763075134,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140854010,
    "post_id" : 79818807,
    "body" : "@BasilBourque indeed. There is a slight chance a feature gets scrapped (string templates anyone?), but the odds of that are not high, especially if there have been 5+ preview versions like this one.",
    "score" : 0,
    "owner" : {
      "account_id" : 1211967,
      "reputation" : 10014,
      "user_id" : 1180351,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
      "display_name" : "Rob Spoor",
      "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
    },
    "creation_date" : 1763118328,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140853330,
    "post_id" : 79818807,
    "body" : "@RobSpoor A Preview feature in Java is fully implemented and fully tested. So you can choose to use it in production. Just be prepared to make updates if future versions of Java change (or remove)  the feature. This Question is indeed solved by Structured Concurrency.",
    "score" : 1,
    "owner" : {
      "account_id" : 322981,
      "reputation" : 346842,
      "user_id" : 642706,
      "user_type" : "registered",
      "accept_rate" : 58,
      "profile_image" : "https://i.sstatic.net/ZWEI3.jpg?s=256",
      "display_name" : "Basil Bourque",
      "link" : "https://stackoverflow.com/users/642706/basil-bourque"
    },
    "creation_date" : 1763074755,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140853026,
    "post_id" : 79818807,
    "body" : "It&#39;s a shame it&#39;s still a preview feature, because this sounds like a job for Structured Concurrency: <a href=\"https://openjdk.org/jeps/525\" rel=\"nofollow noreferrer\">openjdk.org/jeps/525</a>",
    "score" : 1,
    "owner" : {
      "account_id" : 1211967,
      "reputation" : 10014,
      "user_id" : 1180351,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
      "display_name" : "Rob Spoor",
      "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
    },
    "creation_date" : 1763060109,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140852351,
    "post_id" : 79818807,
    "body" : "Maybe using <code>CompletableFuture</code>. You can then use <code>CompletableFuture.anyOf</code> to wait. <a href=\"https://stackoverflow.com/q/49517752/2670892\">see</a>",
    "score" : 0,
    "owner" : {
      "account_id" : 3159259,
      "reputation" : 111551,
      "user_id" : 2670892,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/4iPV5.png?s=256",
      "display_name" : "greg-449",
      "link" : "https://stackoverflow.com/users/2670892/greg-449"
    },
    "creation_date" : 1763036966,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140852350,
    "post_id" : 79818807,
    "body" : "<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#get--\" rel=\"nofollow noreferrer\">Future.get()</a> - Waits if necessary for the computation to complete, and then retrieves its result. You probably want to combine it with <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#isDone--\" rel=\"nofollow noreferrer\">Future.isDone()</a> check.",
    "score" : 0,
    "owner" : {
      "account_id" : 23783500,
      "reputation" : 7109,
      "user_id" : 17795888,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/Xay1V.jpg?s=256",
      "display_name" : "Chaosfire",
      "link" : "https://stackoverflow.com/users/17795888/chaosfire"
    },
    "creation_date" : 1763036960,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79818998" : [ {
      "comment_id" : 140858560,
      "post_id" : 79818998,
      "body" : "@MaxSan If you&#39;re using Java Swing for your UI be aware that the Swing is single threaded and it runs on EDT (Event Dispatch Thread). Heavy tasks must not run on the EDT or the UI freezes. I recommend you use SwingWorker for your background tasks. It has doInBackground() method for your heavy tasks that should be done in the background. And publish() and process() methods for updating UI. I think you should get rid of ExecutorCompletionService and use SwingWorker.",
      "score" : 0,
      "owner" : {
        "account_id" : 20183595,
        "reputation" : 175,
        "user_id" : 14803523,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/v8YCJiJo.jpg?s=256",
        "display_name" : "iso53",
        "link" : "https://stackoverflow.com/users/14803523/iso53"
      },
      "creation_date" : 1763393700,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140858427,
      "post_id" : 79818998,
      "body" : "I take advantage of your kindness.  In my ExecuteJob (the Callable) I&#39;ve a counter and i want to update a progress bar getting the value of the counter in each tasks every x sec.   In my case, but in general, how can I access to a property of a task while the program execution is stopped to waiting in Future&lt;String&gt; f = ecs.take(); ??",
      "score" : 0,
      "owner" : {
        "account_id" : 44663395,
        "reputation" : 51,
        "user_id" : 31870929,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/bf3c15f6c1855c02264482fa72dbc45a?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "MaxSan",
        "link" : "https://stackoverflow.com/users/31870929/maxsan"
      },
      "creation_date" : 1763391425,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}