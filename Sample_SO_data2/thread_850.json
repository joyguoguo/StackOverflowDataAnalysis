{
  "question" : {
    "question_id" : 79769855,
    "title" : "Does Java Object Layout (JOL) work with Java 25 and Compact Object Headers enabled?",
    "body" : "<p>Java 25 was released on September 16, 2025 and included <a href=\"https://openjdk.org/jeps/519\" rel=\"nofollow noreferrer\">JEP 519</a> with Compact Object Headers (COH). The latest release version of <a href=\"https://openjdk.org/projects/code-tools/jol/\" rel=\"nofollow noreferrer\">JOL</a> (0.17) has been released in February, 2023.</p>\n<p>I have compared the output of JOL 0.17 for various objects using Java 25 default options and Java 25 with COH enabled and can see that there are differences. I would like to know if the output below is correct when using JOL 0.17 with Java 25 and COH enabled.</p>\n<p>Compact Object Headers can be enabled in Java 25 using the following flag:</p>\n<p><code>-XX:+UseCompactObjectHeaders</code></p>\n<p>Following the advice in the comments, I wrote the following test class to compare runs using Java 25 with default values, and with Compact Object Headers enabled.</p>\n<pre><code>import java.util.List;\n\nimport org.openjdk.jol.info.GraphLayout;\n\npublic class JOLJdk25Test\n{\n    public enum Generation\n    {\n        GREATEST(&quot;Greatest Generation&quot;, 1901, 1927),\n        SILENT(&quot;Silent Generation&quot;, 1928, 1945),\n        BOOMER(&quot;Baby Boomers&quot;, 1946, 1964),\n        X(&quot;Generation X&quot;, 1965, 1980),\n        MILLENNIAL(&quot;Millennials&quot;, 1981, 1996),\n        Z(&quot;Generation Z&quot;, 1997, 2012),\n        ALPHA(&quot;Generation Alpha&quot;, 2013, 2029);\n\n        private final String name;\n        private final YearRange years;\n\n        Generation(String name, int from, int to)\n        {\n            this.name = name;\n            this.years = new YearRange(from, to);\n        }\n    }\n\n    public record YearRange(int from, int to){};\n\n    public static void main(String[] args)\n    {\n        List&lt;Generation&gt; generations =\n                List.of(Generation.values());\n        System.out.println(\n                GraphLayout.parseInstance(generations).toFootprint());\n    }\n}\n</code></pre>\n<p>The following are the results I see running the <code>main</code> method with vanilla Java 25 and Java 25 with Compact Object Headers enabled.</p>\n<pre><code>JDK 25 Default:\n\njava.util.ImmutableCollections$ListN@4eec7777d footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         7        32       224   JOLJdk25Test$Generation\n         7        24       168   JOLJdk25Test$YearRange\n        14        29       416   [B\n         1        48        48   [Ljava.lang.Object;\n        14        24       336   java.lang.String\n         1        24        24   java.util.ImmutableCollections$ListN\n        44                1216   (total)\n\n\nJDK 25 Compact Object Headers:\n\njava.util.ImmutableCollections$ListN@4eec7777d footprint:\n     COUNT       AVG       SUM   DESCRIPTION\n         7        32       224   JOLJdk25Test$Generation\n         7        16       112   JOLJdk25Test$YearRange\n        14        24       344   [B\n         1        40        40   [Ljava.lang.Object;\n        14        24       336   java.lang.String\n         1        16        16   java.util.ImmutableCollections$ListN\n        44                1072   (total)\n</code></pre>\n<p>The record <code>YearRange</code> instances are different by 8 bytes each. The <code>ImmutableCollections$ListN</code> is also different by 8 bytes. The <code>[B</code>, which I believe the <code>byte</code> array in the <code>String</code> is different, but not exactly the value I expected.</p>\n<p>The questions I have are why the <code>Generation</code> Enum SUM and <code>java.lang.String</code> SUM have the same value for both runs and is this expected? Do the other 8 byte savings look correct? Finally, should I use the latest mainline version of JOL instead of JOL 0.17 when testing with Java 25 and COH enabled?</p>\n<p>Note: To run this code with JOL 0.17, you will need to set the following JVM flag:</p>\n<p><code>-Djol.magicFieldOffset=true</code></p>\n",
    "tags" : [ "java", "jol", "java-25" ],
    "owner" : {
      "account_id" : 1712726,
      "reputation" : 6836,
      "user_id" : 1570415,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/Scl35.jpg?s=256",
      "display_name" : "Donald Raab",
      "link" : "https://stackoverflow.com/users/1570415/donald-raab"
    },
    "is_answered" : true,
    "view_count" : 392,
    "answer_count" : 1,
    "score" : 7,
    "last_activity_date" : 1758488607,
    "creation_date" : 1758308049,
    "link" : "https://stackoverflow.com/questions/79769855/does-java-object-layout-jol-work-with-java-25-and-compact-object-headers-enabl",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79770662,
    "question_id" : 79769855,
    "body" : "<p>After I asked this question, I reached out to one of the project maintainers of JOL. He suggested that I look at <a href=\"https://github.com/openjdk/jol/blob/master/README.md#internals\" rel=\"nofollow noreferrer\">&quot;internals&quot;</a> to see how the Lilliput (Compact Object Headers) object layouts are decoded with JOL. He also suggested trying mainline JOL, as there have been some fixes. I did both. I'm fairly confident now using either JOL 0.17 or locally building JOL mainline to a 0.18-SNAPSHOT with Java 25 with Compact Object Headers enabled, as I saw no difference with this example. I have a better understanding now how JOL is showing the Compact Object Header effect in object layouts. Since I have already taken the jump to build 0.18-SNAPSHOT locally, I will use this version for my own testing going forward as it offers nicer output and has some other fixes. I will show the nicer <code>GraphLayout</code> output for the example using 0.18-SNAPSHOT at the bottom of this answer. It can be compared against the same output I shared using 0.17 in the question above.</p>\n<p>I wrote the following code to see the object layout of the classes in the above examples using <code>ClassLayout</code> from JOL. I believe this code is the programmatic way to access the command line approach described in &quot;internals&quot; above.</p>\n<pre><code>import org.openjdk.jol.info.ClassLayout;\n...\npublic static void main(String[] args)\n{\n    List&lt;Generation&gt; generations =\n            List.of(Generation.values());\n    System.out.println(\n            GraphLayout.parseInstance(generations).toFootprint());\n\n    System.out.println(\n            ClassLayout.parseClass(Generation.class).toPrintable());\n    System.out.println(\n            ClassLayout.parseClass(YearRange.class).toPrintable());\n    System.out.println(\n            ClassLayout.parseClass(String.class).toPrintable());\n    System.out.println(\n            ClassLayout.parseClass(List.of().getClass()).toPrintable());\n}\n</code></pre>\n<p>This code helped explain why the <code>Generation</code> and <code>String</code> instances did not change. The following is the <code>ClassLayout</code> output for <code>Generation</code> with vanilla Java 25 (Defaults), and Java 25 with Compact Object Headers (COH) enabled.</p>\n<pre><code>JDK 25 Defaults (JOL 0.17):\n\nJOLJdk25Test$Generation object internals:\nOFF  SZ                     TYPE DESCRIPTION               VALUE\n  0   8                          (object header: mark)     N/A\n  8   4                          (object header: class)    N/A\n 12   4                      int Enum.ordinal              N/A\n 16   4                      int Enum.hash                 N/A\n 20   4         java.lang.String Enum.name                 N/A\n 24   4         java.lang.String Generation.name           N/A\n 28   4   JOLJdk25Test.YearRange Generation.years          N/A\nInstance size: 32 bytes\nSpace losses: 0 bytes internal + 0 bytes external = 0 bytes total\n\nJDK 25 COH (JOL 0.17):\n\nJOLJdk25Test$Generation object internals:\nOFF  SZ                     TYPE DESCRIPTION               VALUE\n  0   8                          (object header: mark)     N/A\n  8   4                      int Enum.ordinal              N/A\n 12   4                      int Enum.hash                 N/A\n 16   4         java.lang.String Enum.name                 N/A\n 20   4         java.lang.String Generation.name           N/A\n 24   4   JOLJdk25Test.YearRange Generation.years          N/A\n 28   4                          (object alignment gap)\nInstance size: 32 bytes\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\n</code></pre>\n<p>The important thing to notice between JDK 25 Defaults and JDK 25 COH is that the line with <code>(object header: class)</code> is missing with COH. The object header for Java 25 COH takes only <strong>8 bytes</strong>, where the Java 25 Defaults takes <strong>12 bytes</strong>. This is where the memory savings using Compact Object Headers in Java 25 comes from. JOL 0.17 is reporting this just fine. The reason this doesn't result in any memory savings for the <code>Generation</code> class is because of the object alignment of 8 bytes. Only 4 bytes are saved with COH, so this creates an <code>(object alignment gap)</code> of 4 bytes. The same object alignment issue happens with the <code>String</code> class, which results in no savings there.</p>\n<p>The <code>YearRange</code> record does get an 8 byte savings, and the results printed using <code>ClassLayout</code> illustrate this.</p>\n<pre><code>JDK 25 Defaults (JOL 0.17):\n\nJOLJdk25Test$YearRange object internals:\nOFF  SZ   TYPE DESCRIPTION               VALUE\n  0   8        (object header: mark)     N/A\n  8   4        (object header: class)    N/A\n 12   4    int YearRange.from            N/A\n 16   4    int YearRange.to              N/A\n 20   4        (object alignment gap)\nInstance size: 24 bytes\nSpace losses: 0 bytes internal + 4 bytes external = 4 bytes total\n\nJDK 25 COH (JOL 0.17):\n\nJOLJdk25Test$YearRange object internals:\nOFF  SZ   TYPE DESCRIPTION               VALUE\n  0   8        (object header: mark)     N/A\n  8   4    int YearRange.from            N/A\n 12   4    int YearRange.to              N/A\nInstance size: 16 bytes\nSpace losses: 0 bytes internal + 0 bytes external = 0 bytes total   \n</code></pre>\n<p>What we can see here is that <code>YearRange</code> had an initial object alignment gap of 4 bytes. With COH enabled, it was able to save 4 bytes in the object header, and go from 20 bytes to 16, with no alignment gaps.</p>\n<p>I did a diff between 0.17 and 0.18-SNAPSHOT results for the <code>ClassLayout</code> code and saw no difference in the output. There is however a visible difference with the <code>GraphLayout</code> code between 0.17 and 0.18-SNAPSHOT, as we can see below.</p>\n<pre><code>JDK 25 Defaults (JOL 0.18-SNAPSHOT):\n\njava.util.ImmutableCollections.ListN@404b9385d footprint:\n\nTable is sorted by &quot;SUM&quot;.\nPrinting first 30 lines. Use -DprintFirst=# to override.\n\n           COUNT             AVG             SUM    DESCRIPTION\n------------------------------------------------------------------------------------------------\n              14              29             416    byte[]\n              14              24             336    java.lang.String\n               7              32             224    JOLJdk25Test.Generation\n               7              24             168    JOLJdk25Test.YearRange\n               1              48              48    java.lang.Object[]\n               1              24              24    java.util.ImmutableCollections.ListN\n------------------------------------------------------------------------------------------------\n              44             181           1,216    &lt;total&gt;\n\nJDK 25 COH (JOL 0.18-SNAPSHOT):\n\njava.util.ImmutableCollections.ListN@404b9385d footprint:\n\nTable is sorted by &quot;SUM&quot;.\nPrinting first 30 lines. Use -DprintFirst=# to override.\n\n           COUNT             AVG             SUM    DESCRIPTION\n------------------------------------------------------------------------------------------------\n              14              24             344    byte[]\n              14              24             336    java.lang.String\n               7              32             224    JOLJdk25Test.Generation\n               7              16             112    JOLJdk25Test.YearRange\n               1              40              40    java.lang.Object[]\n               1              16              16    java.util.ImmutableCollections.ListN\n------------------------------------------------------------------------------------------------\n              44             152           1,072    &lt;total&gt;\n</code></pre>\n<p>We can see the results in 0.18-SNAPSHOT are well organized, and the descriptions are easier to read for some types (e.g. <code>byte[]</code> instead of <code>[B</code>). It's useful in the new output that the rows are sorted in descending order by the SUM column. This helps us see quickly where the bulk of the memory is being used in the instance.</p>\n<p>You have the code I used so can experiment further if you like. It seems clear to me now after verifying and comparing JOL 0.17 with JOL mainline that JOL <code>ClassLayout</code> or &quot;internals&quot; does a good job showing the layout of the class, and decodes the Compact Object Header object layouts well, just as I was told by the project maintainer. Since I asked the question here before asking the project maintainer, I wanted to do the research necessary to verify what I was told. I hope this question and answer will help other folks understand how to use JOL with Compact Object Headers in Java 25 to understand where they might be able to save memory.</p>\n",
    "score" : 6,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 1712726,
      "reputation" : 6836,
      "user_id" : 1570415,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/Scl35.jpg?s=256",
      "display_name" : "Donald Raab",
      "link" : "https://stackoverflow.com/users/1570415/donald-raab"
    },
    "creation_date" : 1758428081,
    "last_activity_date" : 1758488607,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140749209,
    "post_id" : 79769855,
    "body" : "My bad on the question title. It&#39;s been quite a while since I&#39;ve asked a question here, and I want to leave it in a more useful state than when I asked it. I&#39;ve done more research since the original post. This is forcing me to learn and understand more about how both Java 25 with COH work.  I reached out directly to one of the JOL project maintainers, and got some advice. My feeling was that there may be other folks that have the same question. I will share what I learn and the advice in an answer if the question isn&#39;t closed or gets a better answer first.",
    "score" : 1,
    "owner" : {
      "account_id" : 1712726,
      "reputation" : 6836,
      "user_id" : 1570415,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/Scl35.jpg?s=256",
      "display_name" : "Donald Raab",
      "link" : "https://stackoverflow.com/users/1570415/donald-raab"
    },
    "creation_date" : 1758380855,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140748883,
    "post_id" : 79769855,
    "body" : "The question as asked in the title is a &quot;customer service&quot; question which should be directed to the maintainers of JOL, not posted as a Stack Overflow question.",
    "score" : 0,
    "owner" : {
      "account_id" : 213468,
      "reputation" : 110280,
      "user_id" : 466862,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d873f397779db38cd510d9ee5416fd43?s=256&d=identicon&r=PG",
      "display_name" : "Mark Rotteveel",
      "link" : "https://stackoverflow.com/users/466862/mark-rotteveel"
    },
    "creation_date" : 1758363265,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140748526,
    "post_id" : 79769855,
    "body" : "I have added example cases with comparison runs, and asked a question for anyone who knows the answer.",
    "score" : 3,
    "owner" : {
      "account_id" : 1712726,
      "reputation" : 6836,
      "user_id" : 1570415,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/Scl35.jpg?s=256",
      "display_name" : "Donald Raab",
      "link" : "https://stackoverflow.com/users/1570415/donald-raab"
    },
    "creation_date" : 1758340216,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140748392,
    "post_id" : 79769855,
    "body" : "This is not the right site to contact creators. Try contacting them in some JDK forum. Or ask a question here if you are seeing any issues.",
    "score" : 0,
    "owner" : {
      "account_id" : 372682,
      "reputation" : 26512,
      "user_id" : 721855,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/vZiox.png?s=256",
      "display_name" : "aled",
      "link" : "https://stackoverflow.com/users/721855/aled"
    },
    "creation_date" : 1758325265,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140748187,
    "post_id" : 79769855,
    "body" : "It would be helpful to describe cases for which you see differences.",
    "score" : 2,
    "owner" : {
      "account_id" : 1580843,
      "reputation" : 13706,
      "user_id" : 1466267,
      "user_type" : "registered",
      "accept_rate" : 91,
      "profile_image" : "https://www.gravatar.com/avatar/c47d1f7544a8c4a1bb7a41d511f53604?s=256&d=identicon&r=PG",
      "display_name" : "SpaceTrucker",
      "link" : "https://stackoverflow.com/users/1466267/spacetrucker"
    },
    "creation_date" : 1758315419,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}