{
  "question" : {
    "question_id" : 79568569,
    "title" : "thread on server will stop and I have no idea why",
    "body" : "<p>i am making a client handler for my chat app so I can have more then one client connected but right it just 2 connections and the 2 connections run on 2 threads(1 client per thread) now everything work fine and the server will get info from both client but after a while (1 sec) which every client will talk with the last will stay connected and the server stops the other thread running the other connection and I have no idea why</p>\n<p>Server code</p>\n<pre><code>import java.io.IOException;\nimport java.net.ServerSocket;\n\n\npublic class server{\n   \n    public static ServerSocket serverSocket;\n    public static void main(String[] args)throws IOException{\n    serverSocket = new ServerSocket(1234);        \n    clientHandler clientHandler = new clientHandler();\n    Thread clienThread = new Thread(clientHandler);\n    Thread clienThread2 = new Thread(clientHandler);\n    clienThread.start();\n    clienThread2.start();\n    }\n}\n</code></pre>\n<p>client Handler code</p>\n<pre><code>import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class clientHandler implements Runnable{\n    public static server server = new server();\n    public static Socket socket;\n    public static BufferedReader in;\n    public static PrintWriter out;\n\n    @Override\n    public void run(){\n    try {\n    socket = server.serverSocket.accept();\n    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n    out = new PrintWriter(socket.getOutputStream(), true);\n    while(true){\n        String msg = in.readLine();\n        System.out.println(msg);\n    }\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<p>I tried to use 2 server sockets on 2 different port but got the same problem so please help</p>\n",
    "tags" : [ "java", "sockets", "serversocket" ],
    "owner" : {
      "account_id" : 30710362,
      "reputation" : 11,
      "user_id" : 23547303,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/823b33c0f5555df6cbea9e71737ae00c?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Mike",
      "link" : "https://stackoverflow.com/users/23547303/mike"
    },
    "is_answered" : true,
    "view_count" : 85,
    "answer_count" : 2,
    "score" : 1,
    "last_activity_date" : 1744371051,
    "creation_date" : 1744366011,
    "link" : "https://stackoverflow.com/questions/79568569/thread-on-server-will-stop-and-i-have-no-idea-why",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79568736,
    "question_id" : 79568569,
    "body" : "<p>Usually, you create a single <code>ServerSocket</code> and a loop where</p>\n<ul>\n<li>the server waits for a client to connect</li>\n<li>a client connects</li>\n<li>create your client class, passing it the socket that just connected</li>\n<li>server goes back to waiting</li>\n<li>client handles the new socket io in a separate thread</li>\n</ul>\n<p>You have two threads and each thread calls <code>socket = server.serverSocket.accept();</code> I'm not sure how that works but I don't recommend it.</p>\n<p>I've modified your code with as few changes as I could so you can follow it:</p>\n<pre><code>import java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.PrintWriter;\nimport java.io.InputStreamReader;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class Server\n{\n    public static class ClientHandler implements Runnable\n    {\n        private Socket socket;\n        private Thread thread;\n        \n        public ClientHandler(Socket socket) {\n            this.socket = socket;\n            thread = new Thread(this);\n            thread.start();\n        }\n\n        @Override\n        public void run() {\n            try {\n                BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n                String msg;\n                while ((msg = in.readLine()) != null) {\n                    System.out.println(msg);\n                    out.println(msg);\n                }\n            }\n            catch (IOException ex) {\n                ex.printStackTrace();\n            }\n        }\n    }\n\n    public static void main(String[] args)throws IOException {\n        ServerSocket serverSocket = new ServerSocket(1234);\n        while (true) {\n            Socket socket = serverSocket.accept();\n            ClientHandler clientHandler = new ClientHandler(socket);\n        }\n    }\n}\n\n</code></pre>\n<p>Note: this allows an &quot;infinite&quot; number of clients to connect. If you want to cap it at 2, you'll need to add a little extra logic.</p>\n",
    "score" : 1,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 339859,
      "reputation" : 13563,
      "user_id" : 669576,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/7a5b946d652df565b91a774311e7c442?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "001",
      "link" : "https://stackoverflow.com/users/669576/001"
    },
    "creation_date" : 1744371051,
    "last_activity_date" : 1744371051,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79568695,
    "question_id" : 79568569,
    "body" : "<p><strong>Count the <code>new</code></strong>.</p>\n<p>I count a single new, that means there's just the one handler. That means there's only one field <code>Socket socket</code>, only one field <code>in</code>, and so forth.</p>\n<p>When you write this:</p>\n<pre><code>List&lt;String&gt; list = new ArrayList&lt;String&gt;();\n</code></pre>\n<p>We tend to say &quot;list is an arraylist&quot;. But this is a dangerous oversimplification. Dangerous in that it is misleading.</p>\n<p>It's more accurate to say that list <strong>references</strong> an arraylist. <code>list</code> is like a treasure map. It's just instructions to get to an arraylist instance, it is not itself that list. <code>new ArrayList</code> makes the treasure, <code>list</code> is a map, and <code>=</code> means &quot;draw the location to the treasure on the map&quot;.</p>\n<p>In java, everything is pass by value which means when you hand a parameter to a method, you are making a copy. The thing you are copying, however, is the treasure <em>map</em>.</p>\n<p>Thus, when you write:</p>\n<pre class=\"lang-java prettyprint-override\"><code>List&lt;String&gt; list1 = new ArrayList&lt;String&gt;();\nList&lt;String&gt; list2 = list1;\n\nlist1.add(&quot;Hello&quot;);\nSystem.out.println(list2);\n</code></pre>\n<p>That will print 'hello'. The dot operator (<code>.</code>) is java-ese for &quot;X marks the spot, so go there, dig, open the treasure chest, yell something into it&quot;. <code>list1.add</code> thus asks the treasure chest itself to do a thing (add a value in this case), and when you then walk to the same treasure chest using a copy of the map, you.. end up at the same treasure.</p>\n<p>To really bring it home:</p>\n<pre class=\"lang-java prettyprint-override\"><code>List&lt;String&gt; list = new ArrayList&lt;String&gt;();\ndoStuff();\nSystem.out.println(list);\n\nvoid doStuff(List&lt;String&gt; list) {\n  list.add(&quot;Hello&quot;);\n  list = List.of(&quot;Goodbye&quot;);\n}\n</code></pre>\n<p>That would print <code>Hello</code>. Not <code>Goodbye</code>. Because <code>list.add</code> in the <code>doStuff</code> method walks over to the treasure and does something there, whereas <code>list =</code> doesn't do any digging at all, it simply erases the treasure map and draws a new X on it to a newly made list. <code>list</code>, the variable itself is a copy, and like all parameters and local variables, when the method ends, these variables are discarded. So, that last line in that method does nothing - it makes a list, assigns it to a variable, and then immediately tosses the variable in the bin. The list remains in the sand, no maps remain that can find it.. Eventually the garbage collector will come round and get rid of it.</p>\n<p>All you really need to do is replace:</p>\n<pre class=\"lang-java prettyprint-override\"><code>clientHandler clientHandler = new clientHandler();\nThread clienThread = new Thread(clientHandler);\nThread clienThread2 = new Thread(clientHandler);\n</code></pre>\n<p>With:</p>\n<pre class=\"lang-java prettyprint-override\"><code>Thread clienThread = new Thread(new clientHandler());\nThread clienThread2 = new Thread(new clientHandler());\n</code></pre>\n<p>Count the <code>new</code>: There are now 2x <code>new</code>, so 2 client handlers, 2 sockets, 2 bufferedreaders, and so forth. Which is what you want.</p>\n",
    "score" : -1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107206,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1744369802,
    "last_activity_date" : 1744369802,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79568695" : [ {
      "comment_id" : 140325893,
      "post_id" : 79568695,
      "body" : "Since <code>socket</code>, <code>in</code> and <code>out</code> are all static fields in <code>clientHandler</code> it doesn&#39;t matter how many instances of <code>clientHandler</code> you create: there is still only one <code>socket</code>, <code>in</code> and <code>out</code> field.",
      "score" : 0,
      "owner" : {
        "account_id" : 7423601,
        "reputation" : 21950,
        "user_id" : 5646962,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/950788cd150c2e596944181dfd8421af?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Thomas Kl&#228;ger",
        "link" : "https://stackoverflow.com/users/5646962/thomas-kl%c3%a4ger"
      },
      "creation_date" : 1744397454,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140324248,
      "post_id" : 79568695,
      "body" : "I replace my code with your new code but got the same problem",
      "score" : 0,
      "owner" : {
        "account_id" : 30710362,
        "reputation" : 11,
        "user_id" : 23547303,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/823b33c0f5555df6cbea9e71737ae00c?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Mike",
        "link" : "https://stackoverflow.com/users/23547303/mike"
      },
      "creation_date" : 1744370768,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}