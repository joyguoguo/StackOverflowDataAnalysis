{
  "question" : {
    "question_id" : 79761213,
    "title" : "java vertx webclient stream from server with chunked messages",
    "body" : "<p>I have a vertx server which sends on events to all streamers an information.\nUsing a console all working as wished.\nBut if I use a vertx webclient the client is connected but did not receive anything.</p>\n<p>the web client</p>\n<pre><code>val webClientOpt = WebClientOptions()\n      .setKeepAlive(true)\n      .setUserAgent(&quot;Client/2.0&quot;)\n      .setFollowRedirects(true)\n      .setShared(true)\n</code></pre>\n<p>the client call</p>\n<pre><code>client\n      .get(port, host, UriTemplate.of(s&quot;${path}event-bus/&quot;))\n      .putHeader(&quot;content-type&quot;, &quot;application/json&quot;)\n      .bearerTokenAuthentication(UserBuffer.loggedInUser().jwtToken())\n      .as(BodyCodec.pipe(writeBuffer)).send()\n</code></pre>\n<p>now the writeBuffer and reader</p>\n<pre><code>val writeBuffer = ReactiveWriteStream.writeStream[Buffer](vertx)\nval readStream = ReactiveReadStream.readStream[Buffer]()\n</code></pre>\n<p>Also the stuff to get the data</p>\n<pre><code>readStream.handler(j =&gt; {\n          println(&quot;CONSUMING!!!!&quot;)\n          println(j.toString(&quot;UTF-8&quot;))\n        })\n        writeBuffer.subscribe(readStream)\n</code></pre>\n<p>I know I have to use the BodyCodec.pipe but I think here is my problem. I think I don't use it correctly.</p>\n<hr />\n<p>It was not clearly to me how to use the WriteStream correctly.\nNow I use</p>\n<pre><code>new WriteStream[Buffer]() {\n    override def write(buffer: Buffer): io.vertx.core.Future[Void] = {\n      println(buffer.toString())\n      Future.successful(null).asVertx\n    }\n    override def end(): io.vertx.core.Future[Void] = {\n      Future.successful(null).asVertx\n    }\n    override def setWriteQueueMaxSize(maxSize: Int): WriteStream[Buffer] = this\n    override def writeQueueFull(): Boolean = false\n    override def drainHandler(handler: Handler[Void]): WriteStream[Buffer] = this\n    override def exceptionHandler(handler: Handler[Throwable]): WriteStream[Buffer] = this\n  }\n</code></pre>\n<p>That is what I was looking for.</p>\n<hr />\n",
    "tags" : [ "java", "scala", "vert.x", "vertx-httpclient", "java-vertx-web" ],
    "owner" : {
      "account_id" : 18204642,
      "reputation" : 1,
      "user_id" : 13248210,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/0f4732893349ac0895a643ebdd59c0cf?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Andr&#233; Schmidt",
      "link" : "https://stackoverflow.com/users/13248210/andr%c3%a9-schmidt"
    },
    "is_answered" : false,
    "view_count" : 86,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1762982175,
    "creation_date" : 1757531505,
    "link" : "https://stackoverflow.com/questions/79761213/java-vertx-webclient-stream-from-server-with-chunked-messages",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79818248,
    "question_id" : 79761213,
    "body" : "<p>Here is a solution:</p>\n<pre><code>    private lazy val templatePipe = new WriteStream[Buffer]() {\n    override def write(buffer: Buffer): io.vertx.core.Future[Void] = {\n      val body = readFromString[TemplateEventResponse](buffer.toString())\n      getTemplate(body.uniqueName)\n        .map(_ =&gt; null).asVertx\n    }\n\n    override def end(): io.vertx.core.Future[Void] = {\n      Future.successful(null).asVertx\n    }\n\n    override def setWriteQueueMaxSize(maxSize: Int): WriteStream[Buffer] = this\n\n    override def writeQueueFull(): Boolean = false\n\n    override def drainHandler(handler: Handler[Void]): WriteStream[Buffer] = this\n\n    override def exceptionHandler(handler: Handler[Throwable]): WriteStream[Buffer] = this\n  }\n</code></pre>\n<p>Above, you see the handler and now the way to register from a client to an server.</p>\n<pre><code>    private def updateStream(): Unit = {\n    client\n      .get(port, host, UriTemplate.of(s&quot;${path}event-register/&quot;))\n      .putHeader(&quot;content-type&quot;, &quot;application/json&quot;)\n      .bearerTokenAuthentication(UserBuffer.loggedInUser().jwtToken())\n      .as(BodyCodec.pipe(templatePipe))\n      .send().asScala\n      .onComplete {\n        case Success(data) if data.statusCode() &gt;= 200 &amp;&amp; data.statusCode() &lt; 300 =&gt;\n        case Success(value) =&gt;\n        //TODO meldung machen\n        case Failure(err) =&gt;\n        //TODO meldung machen\n      }\n  }\n</code></pre>\n<p>If you call updateStream() this client register on a server and waits. On each event the handler will start the work. For the server I use this:</p>\n<pre><code>    private val streamers = mutable.HashSet[HttpServerResponse]()\n\n    def registerUpdateEvent(ctx: RoutingContext): Future[?] = {\n    val response = ctx.response()\n      .putHeader(&quot;Content-Type&quot;, &quot;text/json&quot;)\n      .setChunked(true)\n    streamers += response\n    response.endHandler(_ =&gt; {\n      streamers -= response\n    })\n    response.exceptionHandler(_ =&gt; {\n      streamers -= response\n    })\n    Future.successful(&quot;&quot;)\n  }\n\n    override def start(): Unit = {\n    super.start()\n    vertx.eventBus().consumer[SettlementEvent](classOf[SettlementEvent].toString, event =&gt; {\n      persistence.getNumberByEntityId(event.body().entityId).map { nr =&gt;\n        streamers.foreach { stream =&gt;\n          stream.write(\n            writeToString(SettlementEventResponse(nr,event.body.getClass.getSimpleName))\n          )\n        }\n      }\n    })\n  }\n</code></pre>\n<p>The start method has to be adapt to your needings. I listen on every event and fire to all listeners the json SettlementEventResponse. I tested it and it works. Also it is very fast. I hope that helps others.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 18204642,
      "reputation" : 1,
      "user_id" : 13248210,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/0f4732893349ac0895a643ebdd59c0cf?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Andr&#233; Schmidt",
      "link" : "https://stackoverflow.com/users/13248210/andr%c3%a9-schmidt"
    },
    "creation_date" : 1762981549,
    "last_activity_date" : 1762982175,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140851250,
    "post_id" : 79761213,
    "body" : "@stefanobaghino yes i found a solution. I will add them",
    "score" : 0,
    "owner" : {
      "account_id" : 18204642,
      "reputation" : 1,
      "user_id" : 13248210,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/0f4732893349ac0895a643ebdd59c0cf?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Andr&#233; Schmidt",
      "link" : "https://stackoverflow.com/users/13248210/andr%c3%a9-schmidt"
    },
    "creation_date" : 1762981016,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140736880,
    "post_id" : 79761213,
    "body" : "@Andr&#233;Schmidt If you found a solution, can you please answer your own question to the benefit of future readers? :)",
    "score" : 0,
    "owner" : {
      "account_id" : 3908845,
      "reputation" : 13439,
      "user_id" : 3314107,
      "user_type" : "registered",
      "accept_rate" : 80,
      "profile_image" : "https://www.gravatar.com/avatar/5aa98fc797d37e7a7448cb788abac548?s=256&d=identicon&r=PG",
      "display_name" : "stefanobaghino",
      "link" : "https://stackoverflow.com/users/3314107/stefanobaghino"
    },
    "creation_date" : 1757940728,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140729064,
    "post_id" : 79761213,
    "body" : "I have not understand the WriteBuffer. But now I found a way.",
    "score" : 0,
    "owner" : {
      "account_id" : 18204642,
      "reputation" : 1,
      "user_id" : 13248210,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/0f4732893349ac0895a643ebdd59c0cf?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Andr&#233; Schmidt",
      "link" : "https://stackoverflow.com/users/13248210/andr%c3%a9-schmidt"
    },
    "creation_date" : 1757593703,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140728253,
    "post_id" : 79761213,
    "body" : "For clarity, is this a one-shot stream (HTTP chunked) or Server Side Events or Websockets?",
    "score" : 0,
    "owner" : {
      "account_id" : 7034556,
      "reputation" : 15907,
      "user_id" : 5389127,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/391c01e15f62cee096b758c4c2815c2c?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Ga&#235;l J",
      "link" : "https://stackoverflow.com/users/5389127/ga%c3%abl-j"
    },
    "creation_date" : 1757568305,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140727857,
    "post_id" : 79761213,
    "body" : "Please clarify your specific problem or provide additional details to highlight exactly what you need. As it&#39;s currently written, it&#39;s hard to tell exactly what you&#39;re asking.",
    "score" : 0,
    "owner" : {
      "account_id" : -1,
      "reputation" : 1,
      "user_id" : -1,
      "user_type" : "moderator",
      "profile_image" : "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=256&d=identicon&r=PG",
      "display_name" : "Community",
      "link" : "https://stackoverflow.com/users/-1/community"
    },
    "creation_date" : 1757542006,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}