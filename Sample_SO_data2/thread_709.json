{
  "question" : {
    "question_id" : 79784223,
    "title" : "springboot integration Kafka @RetryableTopic is not effective",
    "body" : "<h3>describe</h3>\n<p>springboot integration  Kafka @RetryableTopic is not effective,I cannot control retry count; it is retrying continuously.There are two types of error logs continuously printed in the console: one is 'Unable to deliver to retry queue',and the other is 'Send exception not in transaction'.</p>\n<p>Because I want to send transactional messages, I have configured the ProducerConfig.TRANSACTIONAL_ID_CONFIG in the ProducerFactory and KafkaTemplate, and I have also added the @Transactional annotation on the message consumer side.</p>\n<h3>version</h3>\n<p>JDK1.8   spring-boot-starter-parent:2.7.17 spring-kafka:2.9.13\nbroker:kafka_2.12-3.6.1</p>\n<h2>code</h2>\n<p><a href=\"https://github.com/LimerenceAmumu/Kafka-study\" rel=\"nofollow noreferrer\">https://github.com/LimerenceAmumu/Kafka-study</a></p>\n<h3>consumer</h3>\n<pre><code>    // 消费者组1：处理订单\n        @RetryableTopic(\n            attempts = &quot;4&quot;,  // 总共尝试 4 次（1次原始 + 3次重试）\n            backoff = @Backoff(delay = 1000, multiplier = 2.0), // 1s, 2s, 4s 重试\n            dltTopicSuffix = &quot;.dlt&quot;,  // 死信队列 Topic 名：order-topic.dlt\n            include = {Exception.class}, // 重试所有异常类型,\n            dltStrategy = DltStrategy.FAIL_ON_ERROR  // 处理失败时进入 DLQ\n    )\n    @KafkaListener(\n            topics = &quot;order-topic-new&quot;,\n            groupId = &quot;${spring.kafka.consumer.group-id}&quot;,\n            containerFactory = &quot;kafkaListenerContainerFactory&quot;\n    )\n    public void consumeOrderMessage(ConsumerRecord&lt;String, Order&gt; record, @org.springframework.messaging.handler.annotation.Payload(required = false) Object payload, Acknowledgment acknowledgment) {\n        try {\n            Order order = record.value();\n            log.info(&quot;接收到订单消息: 订单ID={}, 主题={}, 分区={}, 偏移量={}&quot;,\n                    order.getOrderId(),\n                    record.topic(),\n                    record.partition(),\n                    record.offset());\n            // 处理订单\n            processOrder(order);\n\n            //加限定 抛异常\n            if (order.getCustomerName().equals(&quot;ex&quot;)) {\n                throw new RuntimeException(&quot;order process error&quot;);\n            }\n            acknowledgment.acknowledge();\n            log.info(&quot;order process ack: {}&quot;, order.getOrderId());\n        } catch (Exception e) {\n            log.error(&quot;order process error: {}&quot;, e.getMessage(), e);\n            throw e;\n        }\n    }\n</code></pre>\n<h3>config</h3>\n<pre><code>@RequiredArgsConstructor\n@EnableScheduling\n@Configuration\n@EnableKafka\npublic class KafkaConfig extends RetryTopicConfigurationSupport {\n\n    @Value(&quot;${spring.kafka.bootstrap-servers}&quot;)\n    private String bootstrapServers;\n\n    @Value(&quot;${spring.kafka.consumer.group-id}&quot;)\n    private String consumerGroupId;\n\n\n    @Override\n    protected void configureBlockingRetries(BlockingRetriesConfigurer blockingRetries) {\n        blockingRetries\n                .retryOn(Exception.class)\n                .backOff(new FixedBackOff(5000, 2));\n    }\n//    // 创建订单主题\n//    @Bean\n//    public NewTopic orderTopic() {\n//        Map&lt;String, String&gt; configs = new HashMap&lt;&gt;();\n//        configs.put(&quot;retention.ms&quot;, &quot;86400000&quot;);  // 保留1天\n//\n//        return TopicBuilder.name(&quot;order-topic&quot;)\n//                .partitions(3)  // 3个分区\n//                .replicas(1)    // 1个副本\n//                .configs(configs)\n//                .build();\n//    }\n    // 创建订单主题\n    @Bean\n    public NewTopic orderTopicDLQ() {\n        Map&lt;String, String&gt; configs = new HashMap&lt;&gt;();\n        configs.put(&quot;retention.ms&quot;, &quot;86400000&quot;);  // 保留1天\n\n        return TopicBuilder.name(&quot;order-topic-new.dlt&quot;)\n                .partitions(3)  // 3个分区\n                .replicas(1)    // 1个副本\n                .configs(configs)\n                .build();\n    }\n\n\n    // 创建订单确认主题\n    @Bean\n    public NewTopic orderConfirmationTopic() {\n        return TopicBuilder.name(&quot;order-confirmation-topic&quot;)\n                .partitions(2)\n                .replicas(1)\n                .build();\n    }\n\n    // 生产者配置\n    @Bean\n    public ProducerFactory&lt;String, Order&gt; orderProducerFactory() {\n        Map&lt;String, Object&gt; configProps = new HashMap&lt;&gt;();\n        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);\n        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);\n        configProps.put(ProducerConfig.ACKS_CONFIG, &quot;all&quot;);  // 等待所有副本确认\n        configProps.put(ProducerConfig.RETRIES_CONFIG, 3);   // 重试次数\n        configProps.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true);  // 开启幂等性\n        configProps.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, &quot;order-service-transaction&quot;);  // 事务ID配置\n        return new DefaultKafkaProducerFactory&lt;&gt;(configProps);\n    }\n\n    @Bean\n    public KafkaTemplate&lt;String, Order&gt; kafkaTemplate() {\n        return new KafkaTemplate&lt;&gt;(orderProducerFactory());\n    }\n//\n//    @Bean(&quot;defaultRetryTopicKafkaTemplate&quot;)\n//    public KafkaTemplate&lt;String, Order&gt; defaultRetryTopicKafkaTemplate(ProducerFactory&lt;String, Order&gt; producerFactory) {\n//        KafkaTemplate&lt;String, Order&gt; template = new KafkaTemplate&lt;&gt;(producerFactory);\n//        // \uD83D\uDC47 关键：允许非事务发送\n//        template.setAllowNonTransactional(true);\n//        return template;\n//    }\n//    @Bean\n//    public DeadLetterPublishingRecoverer deadLetterPublishingRecoverer(KafkaTemplate&lt;String, Order&gt; retryKafkaTemplate) {\n//        return new DeadLetterPublishingRecoverer(retryKafkaTemplate);\n//    }\n\n    // 消费者配置\n    @Bean\n    public ConsumerFactory&lt;String, Order&gt; orderConsumerFactory() {\n        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();\n        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);\n        props.put(ConsumerConfig.GROUP_ID_CONFIG, consumerGroupId);\n        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);\n        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);\n        props.put(JsonDeserializer.TRUSTED_PACKAGES, &quot;com.example.kafkaorderdemo.model&quot;);\n        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, &quot;earliest&quot;);  // 从最早的消息开始消费\n        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);  // 禁用自动提交\n        return new DefaultKafkaConsumerFactory&lt;&gt;(props);\n    }\n\n    @Bean\n    public ConcurrentKafkaListenerContainerFactory&lt;String, Order&gt; kafkaListenerContainerFactory() {\n        ConcurrentKafkaListenerContainerFactory&lt;String, Order&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;();\n        factory.setConsumerFactory(orderConsumerFactory());\n        factory.setBatchListener(false);\n        factory.setReplyTemplate(kafkaTemplate());\n        // 设置手动确认模式，使Acknowledgment可用\n        factory.getContainerProperties().setAckMode(ContainerProperties.AckMode.MANUAL);\n        return factory;\n    }\n\n    // 事务管理器配置\n    @Bean\n    public KafkaTransactionManager&lt;String, Order&gt; kafkaTransactionManager() {\n        KafkaTransactionManager&lt;String, Order&gt; transactionManager = new KafkaTransactionManager&lt;&gt;(orderProducerFactory());\n        transactionManager.setTransactionSynchronization(AbstractPlatformTransactionManager.SYNCHRONIZATION_ON_ACTUAL_TRANSACTION);\n        return transactionManager;\n    }\n\n}\n</code></pre>\n<h2>errorLogs:</h2>\n<pre><code>2025-10-07 12:01:09 [org.springframework.kafka.KafkaListenerEndpointContainer#1-0-C-1] ERROR o.s.k.r.DeadLetterPublishingRecovererFactory$1 - Dead-letter publication to order-topic-new-retry-0failed for: order-topic-new-0@0\njava.lang.IllegalStateException: No transaction is in process; possible solutions: run the template operation within the scope of a template.executeInTransaction() operation, start a transaction with @Transactional before invoking the template method, run in a transaction started by a listener container when consuming a record\n   at org.springframework.util.Assert.state(Assert.java:76)\n   at org.springframework.kafka.core.KafkaTemplate.getTheProducer(KafkaTemplate.java:782)\n   at org.springframework.kafka.core.KafkaTemplate.doSend(KafkaTemplate.java:674)\n   at org.springframework.kafka.core.KafkaTemplate.send(KafkaTemplate.java:459)\n   at org.springframework.kafka.listener.DeadLetterPublishingRecoverer.publish(DeadLetterPublishingRecoverer.java:654)\n   at org.springframework.kafka.listener.DeadLetterPublishingRecoverer.send(DeadLetterPublishingRecoverer.java:562)\n   at org.springframework.kafka.listener.DeadLetterPublishingRecoverer.sendOrThrow(DeadLetterPublishingRecoverer.java:527)\n   at org.springframework.kafka.listener.DeadLetterPublishingRecoverer.accept(DeadLetterPublishingRecoverer.java:499)\n   at org.springframework.kafka.listener.FailedRecordTracker.attemptRecovery(FailedRecordTracker.java:237)\n   at org.springframework.kafka.listener.FailedRecordTracker.recovered(FailedRecordTracker.java:191)\n   at org.springframework.kafka.listener.SeekUtils.lambda$doSeeks$5(SeekUtils.java:107)\n   at java.util.ArrayList.forEach(ArrayList.java:1257)\n   at org.springframework.kafka.listener.SeekUtils.doSeeks(SeekUtils.java:104)\n   at org.springframework.kafka.listener.SeekUtils.seekOrRecover(SeekUtils.java:207)\n   at org.springframework.kafka.listener.DefaultErrorHandler.handleRemaining(DefaultErrorHandler.java:174)\n   at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeErrorHandler(KafkaMessageListenerContainer.java:2854)\n   at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2722)\n   at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2572)\n   at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2448)\n   at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2078)\n   at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1430)\n   at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1394)\n   at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1291)\n   at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\n   at java.util.concurrent.FutureTask.run(FutureTask.java:266)\n   at java.lang.Thread.run(Thread.java:748)\n2025-10-07 12:01:09 [org.springframework.kafka.KafkaListenerEndpointContainer#1-0-C-1] ERROR o.s.k.listener.DefaultErrorHandler - Failed to determine if this record (order-topic-new-0@0) should be recovererd, including in seeks\norg.springframework.kafka.KafkaException: Dead-letter publication to order-topic-new-retry-0failed for: order-topic-new-0@0\n   at org.springframework.kafka.listener.DeadLetterPublishingRecoverer.verifySendResult(DeadLetterPublishingRecoverer.java:683)\n   at org.springframework.kafka.listener.DeadLetterPublishingRecoverer.publish(DeadLetterPublishingRecoverer.java:666)\n   at org.springframework.kafka.listener.DeadLetterPublishingRecoverer.send(DeadLetterPublishingRecoverer.java:562)\n   at org.springframework.kafka.listener.DeadLetterPublishingRecoverer.sendOrThrow(DeadLetterPublishingRecoverer.java:527)\n   at org.springframework.kafka.listener.DeadLetterPublishingRecoverer.accept(DeadLetterPublishingRecoverer.java:499)\n   at org.springframework.kafka.listener.FailedRecordTracker.attemptRecovery(FailedRecordTracker.java:237)\n   at org.springframework.kafka.listener.FailedRecordTracker.recovered(FailedRecordTracker.java:191)\n   at org.springframework.kafka.listener.SeekUtils.lambda$doSeeks$5(SeekUtils.java:107)\n</code></pre>\n",
    "tags" : [ "java", "spring-boot", "apache-kafka", "spring-kafka" ],
    "owner" : {
      "account_id" : 16845735,
      "reputation" : 11,
      "user_id" : 12179965,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/9a2e8030a42c25b809c88921764cbbcd?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "amumu",
      "link" : "https://stackoverflow.com/users/12179965/amumu"
    },
    "is_answered" : false,
    "view_count" : 73,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1759940351,
    "creation_date" : 1759813921,
    "link" : "https://stackoverflow.com/questions/79784223/springboot-integration-kafka-retryabletopic-is-not-effective",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140780971,
    "post_id" : 79784223,
    "body" : "You may want to try not manually acknowledging the commit and turning off manual mode, it can interfere with the Retryable annotation which handles all that for you.",
    "score" : 0,
    "owner" : {
      "account_id" : 48638,
      "reputation" : 6428,
      "user_id" : 144578,
      "user_type" : "registered",
      "accept_rate" : 79,
      "profile_image" : "https://www.gravatar.com/avatar/87af410c7986beb8583c1015265b64d1?s=256&d=identicon&r=PG",
      "display_name" : "Sebastiaan van den Broek",
      "link" : "https://stackoverflow.com/users/144578/sebastiaan-van-den-broek"
    },
    "creation_date" : 1759818510,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}