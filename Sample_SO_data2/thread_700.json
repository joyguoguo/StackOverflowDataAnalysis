{
  "question" : {
    "question_id" : 79774609,
    "title" : "Exchange a file in a ZIP file quickly",
    "body" : "<p>In a Java program, I need to exchange files in a large ZIP file quickly.</p>\n<p>So if <em>a.txt</em> is a file inside <em>b.zip</em> I want to replace the <em>a.txt</em> with a new version of <em>a.txt</em> inside <em>b.zip</em>. It should happen in a second or less.</p>\n<p>I wonder if the following would be possible:</p>\n<ul>\n<li>Remove the entry of <em>a.txt</em> from the file table.</li>\n<li>Add a new version of <em>a.txt</em> at the end of the existing ZIP file.</li>\n</ul>\n<p>This would leave some &quot;garbage&quot; lying around (as in the contents of the old <em>a.txt</em> file, which does not really matter), but one would not need to copy the whole ZIP file.</p>\n<p>Alternatively, if you cannot just remove the file, one could move it to some directory like <em>garbage/a.txt</em>, which is then ignored by the program reading the ZIP file.</p>\n<p>Can this be done (within Java)?</p>\n",
    "tags" : [ "java", "zip" ],
    "owner" : {
      "account_id" : 888714,
      "reputation" : 36697,
      "user_id" : 927493,
      "user_type" : "registered",
      "accept_rate" : 61,
      "profile_image" : "https://i.sstatic.net/sxsnm.png?s=256",
      "display_name" : "JF Meier",
      "link" : "https://stackoverflow.com/users/927493/jf-meier"
    },
    "is_answered" : true,
    "view_count" : 1649,
    "answer_count" : 7,
    "score" : 14,
    "last_activity_date" : 1764115711,
    "creation_date" : 1758791326,
    "link" : "https://stackoverflow.com/questions/79774609/exchange-a-file-in-a-zip-file-quickly",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79775084,
    "question_id" : 79774609,
    "body" : "<p>Yes, this is possible, but you would need to somehow mark the old version of <code>a.txt</code> as garbage, renaming it to something else. You can also replace its contents with garbage, if that's helpful somehow. The total space taken by the local header and the data, and data descriptor if present, would need to remain exactly the same, so the new path name would need to be the same length or shorter (e.g. making the data longer). You could change the compression method, e.g. making it stored, if you want to change the data. That would make it easier to match the length. Then you'd need to update the lengths and CRC in the local header or data descriptor for the new data.</p>\n<p>You could also remove the the old <code>a.txt</code> from the central directory. I recommend that you do. Then nearly all unzippers will never see it. A streaming unzipper will still see that entry. Streaming unzippers are rarely used though. If you are in control of the application at the other end, you could just make sure that one isn't.</p>\n<p>For the streaming unzippers, you could make the path name length zero. Then the unzipper can't save it. (I think. Does any file system permit a zero-length name? Linux, Windows, and macOS don't at least.) I'm not sure how all streaming unzippers will handle that, but if they error out, at least you're likely to hear about it!</p>\n<p>To implement any of this, you will need to write your own code to parse the zip file format to do this kind of finagling. This includes dealing with the Zip64 extensions and with data descriptors that follow the data. I can provide assistance if you need to come back here with new questions. Adding a new entry at the end is straightforward, but make sure the central directory offset and length is updated in the end records.</p>\n<p>Note: I have provided example code in other answers here.</p>\n",
    "score" : 19,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 1136690,
      "reputation" : 115257,
      "user_id" : 1180620,
      "user_type" : "registered",
      "accept_rate" : 83,
      "profile_image" : "https://i.sstatic.net/FXaAg.jpg?s=256",
      "display_name" : "Mark Adler",
      "link" : "https://stackoverflow.com/users/1180620/mark-adler"
    },
    "creation_date" : 1758817046,
    "last_activity_date" : 1759865775,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79774914,
    "question_id" : 79774609,
    "body" : "<p>There are a few layers to this onion.</p>\n<p>You need to understand how disks works in order to understand the complicated answer to your question. Because the answer is 'it depends'.</p>\n<h2>No time, just tell me</h2>\n<p>What you want is technically sort of possible, but you don't want to. There isn’t any right way to do what you want. And there will never be.</p>\n<p>If that is not satisfactory, read on.</p>\n<h2>Primitive operations needed - 'fast append in the middle'</h2>\n<p>No filesystem I know of offers this functionality; the idea that you can take an existing 10 GB file and add a few bytes in the middle in a fast way (i.e., in a way that does not involve rewriting at least 5 GB worth of bytes).</p>\n<p>That stems from physical impossibilities: Disks, physically, are (segments of) fixed-size sequential blocks of storage. If we take spinning disks with magnetic heads for a moment, as they are easier to explain than SSD cells: That disk physically can take the head and overwrite bytes. It cannot physically construct new platter space out of thin air, make a cut in the disk and suture a new bit of disk in there. Nor can it cut a slice out of the physical disk and suture the two ends together like it's a doctor excising a bit of damaged intestine.</p>\n<p>Hence, you don't get this primitive. File systems can still offer it as a concept (with convoluted data structures, where files are really a sequence of pointers, each pointer pointing at either data or another list-of-pointers; buckets in buckets, which lets you replace a segment that is currently a small sequence of bytes with a pointer structure that combines 'those bytes' plus '... and then these bytes located at a completely different place on the physical disk'. But they don't. That's very complicated and such operations are generally preserved for the application level.</p>\n<h2>Primitive operations needed - 'fast overwrite'</h2>\n<p>As explained in the previous section, <strong>this</strong> is usually available. But not always; some file systems deduplicate files. That means two different actual files internally point at the same data, but they act in all ways like separate files. That means 'overwriting' one of these files <em>should not</em> affect the other file, but that means the file system cannot offer fast overwrite: After all, 'I want to replace the 10th byte in file X' would require first copying the entire file once, updating 'file X' to point at the copy, and then replacing one byte in the copy.</p>\n<p>Another reason fast overwrite is simply not possible is hashing file systems. Disk rot is a thing; some file systems attempt to fight it at the file system level by making hashes or error correction tables for all the data they store, and a 'fast overwrite' therefore wouldn't be all that fast: They need to rehash the entire block/file/whatever granularity the hashing system operates on.</p>\n<p>Yet another is atomicity: File systems want to prevent the idea that 'whoopsie I tripped over a power cable' results in the disk in an invalid state and thus perform all operations in an atomic way. This is easy to do when files are always made fresh ('update the file pointer from A to b' is a thing you can do atomically; writing an arbitrary number of bytes obviously isn't).</p>\n<p>Hence, 'overwrite' is available, but it is rare that a file system offers a separate 'fast overwrite' that fails on such file systems.</p>\n<p>Still, the API is there. <strong>The take away is: Even* <em><strong>if</strong></em> *you are using fast overwrite, it might not actually be fast. It depends on your file system</strong>.</p>\n<h2>Primitive operations needed - 'fast append at end'</h2>\n<p>Appending to the end of a file usually <em>can</em> be done reasonably quickly. With all the caveats of the previous section (if fast overwrite is not possible fast append rarely is either). File systems use a block concept and can easily add a block at the end. On most file systems, it is possible to, e.g., take a 10 GB file, write a handful of bytes at the end, and have that be fast (i.e., have that <em>not</em> involve copying 10 GB worth of bytes).</p>\n<h2>A note about the ZIP file format</h2>\n<p>Given that most file systems cannot do fast append-in-the-middle, the initial obvious answer would seem to be: What you want is impossible. After all, the odds that your new content so happens to compress to a blob that is exactly the same size as the old compressed data, is vanishingly small... and only if it is the same size could we even attempt to use fast-overwrite functionality if it is offered by the file system.</p>\n<p>But not so fast. The ZIP format is a bit weird. And it is weird <em>because</em> it actually tries to cater to this stuff.</p>\n<p>ZIP files consist of a header that identifies a file, followed by the compressed data of that file, followed by another <code>[header, data]</code> blob, all the way through until you get to the end, <em>and then ZIP files have at the end of it the 'central directory' structure (CDS) which repeats all those headers with pointers to where they exist in the file</em>.</p>\n<p>That means you can read a ZIP file in two ways: From the front <em>and</em> from the end.</p>\n<p>ZIP was always meant to be read <em>from the end of it</em>. The reason is for this neat trick:</p>\n<p>To add a file to a ZIP file, you simply start writing the new <code>[header, data]</code> at the <em>start</em> of the CDS, and once you're done, you write the CDS after that. If the file system offers both fast-overwrite and fast-append-at-end, which most filesystems do, this is a very fast operation: Even if you have a 10 GB zip file, adding a small file at the end would not involve copying 10 GB worth of data over! You don't have to read from the start either; you read backwards. The idea is that the CDS isn't that large. This neat trick would obviously be terribly slow if your ZIP file contains 100,000 tiny files. ZIP is a terrible format to store a lot of tiny files.</p>\n<p>Various Java APIs really do offer this, though the basic ZIP stuff <em>does not</em>. You need <a href=\"https://github.com/srikanth-lingala/zip4j\" rel=\"nofollow noreferrer\">Zip4j</a> or other libraries.</p>\n<p>But that's <em>add a file</em>; you want to <em>replace a file</em>.</p>\n<p>Which can also be done but now we do get into problematic territory. If your newly compressed data is <em>smaller</em> than the old, you could just overwrite the old and leave the remainder untouched. Any ZIP tool that reads front-to-back will crash, because it stumbles over the left-over data (i.e., if the old compressed data was 5000 bytes, and the new data is 3000 bytes, the 'left over' 2000 bytes would cause a front-to-back ZIP parser to fail). Possibly you can make a dummy record, but that would not be possible if the left over data is only a handful of bytes.</p>\n<p>But a back-to-front reader wouldn't have any problem with it.</p>\n<p>Still, your ZIP is now 2000 bytes larger than it needed to be and you can't fix <em>that</em> without rewriting the whole thing (or at least rewriting everything from the middle to the end).</p>\n<p>If the new compressed data is <em>larger</em>, it's even worse: You would have to leave the old data in the ZIP file, add the new data to the end, and update the CDS. Your ZIP file is now 'larger than it needs to be': It contains the old compressed data. It's not necessarily a security issue (if the old data is sensitive, just overwrite it with zeroes).</p>\n<p>The problem persists that front-to-back ZIP readers fail.</p>\n<h2>Front-to-back is important</h2>\n<p>Even though ZIP files were never designed to be read front-to-back, nevertheless, the &quot;standard zip&quot; could be read front-to-back without issue. In this modern streaming age, the notion 'ZIP files don't hold any meaning until you read the CDS which is at the very end' is extremely annoying. So front-to-back ZIP readers, even though technically the ZIP specification says that is &quot;illegal&quot;, are common. Also, ZIP as a format allows any number of compression algorithms, but standard ZIP only uses DEFLATE, and most ZIP readers only understand DEFLATE. Thus: There's a standard for the concept of a 'standard zip': ISO/IEC 21320-1.</p>\n<p><strong>ISO/IEC standard zips* <strong><strong>cannot</strong></strong> **play the games I described before!</strong></p>\n<p>Such standard ZIP files <em>must</em> have a CDS and MUST have all data in it be consecutive, without any gaps, starting at 0, and in the order of the CDS, using only compression algorithms 'NONE' or 'DEFLATE', and without any extensions.</p>\n<p>The <code>unzip</code> tool that ships with your OS can read most ZIP files, not just 'ISO/IEC' ZIP files. But producing non-ISO/IEC ZIP files is asking for trouble. It all works great today, you send that ZIP file to something else or attempt to open it with some library and it fails, because that library only reads ISO/IEC ZIP files.</p>\n<p>And, conversely, there are very few libraries out there that let you make non-ISO/IEC ZIP files.</p>\n<p>Thus the conclusion: What you want is possible with <em>many</em> caveats. The list of caveats is so large, and it's a bad idea. To summarize the caveats:</p>\n<ul>\n<li>Various file systems do not offer fast-overwrite and/or fast-append, and it ends then and there: it is <em>not</em> possible to do what you want on such file systems.</li>\n<li>ZIP itself <em>would</em> allow it, but then you end up with a non-ISO/IEC compatible ZIP file which works on many tools, but not all, <em>and</em> the end result would not be as small as it could have been.</li>\n</ul>\n<p>If you are still interested in doing it, you can't use Java's baked in ZIP stuff (such as <code>java.util.zip.ZipFile</code>. You have to use libraries such as <a href=\"https://github.com/srikanth-lingala/zip4j\" rel=\"nofollow noreferrer\">Zip4j</a>.</p>\n<h2>Replacing a file atomically</h2>\n<p>If you want all other processes on the system to witness the update atomically, you can do that, but <em>not</em> if you try to overwrite. You'd make a new ZIP file that contains exactly what you want (all old data copied over, except the thing you want to replace). Then use <code>Files.move(from, to, StandardCopyOptions.ATOMIC_MOVE)</code> which means all processes, when opening that file, either get the complete valid old version or the complete valid new version, it is not possible for them to see data in an invalid state.</p>\n<p>That sounds like the right move here. If you truly need 'fast replace' then 'a ZIP file' was the wrong way to go about it, and you need to go up a few levels. For example, then a database sounds like a better idea, or multiple files in a directory.</p>\n<h2>How to do it right</h2>\n<p>If you don’t have any direct control over the 'input' part of this process (the ZIP file) the answer outlines your limited and highly caveated options. However, if you can change the process, then the right way to do this is to move away from ZIP files. A database-powered solution, or a multi-file based setup would be much preferable. For example, instead of a single ZIP file with, e.g., 50 separate files inside it, have a directory that contains 50 files, each of which is thrown though Java's standard <a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/zip/GZIPOutputStream.html\" rel=\"nofollow noreferrer\"><code>GZipOutputStream</code></a> for compression. The end result would occupy roughly the same amount of disk space, but it would make removing, adding, and updating entries to the structure a trivial virtually caveat-free operation, which can easily be further upgraded with whatever you need (for example, if you need atomicity, you can use the usual <code>Files.move(..., ..., StandardCopyOptions.ATOMIC_MOVE)</code> to do so.</p>\n",
    "score" : 17,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107136,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1758808058,
    "last_activity_date" : 1764114089,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79774699,
    "question_id" : 79774609,
    "body" : "<p>To supplement other answers suggesting you could just read and write to another ZIP file, omitting the desired file and replacing it with new one, here's an example implementation:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public static void replaceInZip(\n        String zipFilePath,\n        String fileNameToReplaceInZip,\n        String newAFilePath) throws IOException {\n    File originalZip = new File(zipFilePath);\n    File tempZip = new File(zipFilePath + &quot;tmp.zip&quot;);\n\n    try (\n            ZipInputStream zis = new ZipInputStream(new FileInputStream(originalZip));\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(tempZip))\n    ) {\n        ZipEntry entry;\n        byte[] buffer = new byte[8192];\n\n        while ((entry = zis.getNextEntry()) != null) {\n            String name = entry.getName();\n\n            // Skip the file we want to replace\n            if (name.equals(fileNameToReplaceInZip)) {\n                continue;\n            }\n\n            // Copy all other entries unchanged\n            zos.putNextEntry(new ZipEntry(name));\n            int len;\n            while ((len = zis.read(buffer)) &gt; 0) {\n                zos.write(buffer, 0, len);\n            }\n            zos.closeEntry();\n        }\n\n        // Now add the new version of a.txt\n        zos.putNextEntry(new ZipEntry(fileNameToReplaceInZip));\n        try (InputStream newFileIn = new FileInputStream(newAFilePath)) {\n            int len;\n            while ((len = newFileIn.read(buffer)) &gt; 0) {\n                zos.write(buffer, 0, len);\n            }\n        }\n        zos.closeEntry();\n    }\n\n     // Replace old ZIP with new one\n     if (!originalZip.delete()) {\n         throw new IOException(&quot;Could not delete original zip&quot;);\n     }\n     if (!tempZip.renameTo(originalZip)) {\n         throw new IOException(&quot;Could not rename temp zip to original&quot;);\n     }\n\n    System.out.println(&quot;a.txt replaced successfully!&quot;);\n}\n</code></pre>\n<p>Usage</p>\n<pre class=\"lang-java prettyprint-override\"><code>replaceInZip(&quot;path to zip&quot;, &quot;a.txt&quot;, &quot;path to new a.txt&quot;);\n</code></pre>\n",
    "score" : 4,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 9606741,
      "reputation" : 41242,
      "user_id" : 7132550,
      "user_type" : "registered",
      "accept_rate" : 75,
      "profile_image" : "https://graph.facebook.com/1063981417044495/picture?type=large",
      "display_name" : "Michał Turczyn",
      "link" : "https://stackoverflow.com/users/7132550/micha%c5%82-turczyn"
    },
    "creation_date" : 1758796887,
    "last_activity_date" : 1764111038,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79776590,
    "question_id" : 79774609,
    "body" : "<p>Here is an example of code in C to rub out named entries from a ZIP file in place. The additional task of appending new entries at the end in place is left as an exercise for the reader.</p>\n<pre class=\"lang-c prettyprint-override\"><code>/* ziprub.c -- rub out ZIP file entries in place\n * Copyright (C) 2025 Mark Adler\n * Version 1.0  26 Sep 2025  Mark Adler\n */\n\n/*\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the author be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Mark Adler\n  madler@alumni.caltech.edu\n */\n\n// Remove entries from a ZIP file in place, without having to copy the entire\n// ZIP file. Each entry is written over with with a zero-length file name and\n// all zeros for data, and the entry is removed from the central directory.\n// This requires that the central directory and end records are at the end of\n// the ZIP file, which is the convention as well as the specification.\n\n// This does not handle encrypted ZIP files, nor ZIP files with a compressed\n// central directory.\n\n// There's nothing wrong with strerror().\n#define _CRT_SECURE_NO_WARNINGS\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdarg.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;fcntl.h&gt;\n\n// Contend with Windows and Visual C.\n#ifdef _WIN32\n#  include &lt;io.h&gt;\n#  include &lt;limits.h&gt;\n#  define open _open\n#  define BINARY _O_BINARY\n#  define off_t __int64\n#  define lseek _lseeki64\n#  define ssize_t ptrdiff_t\n#  define read read_z\nstatic ssize_t read_z(int fd, void *buf, size_t len) {\n    if ((ssize_t)len &lt; 0)\n        return -1;\n    uint8_t *next = buf;\n    while (len) {\n        unsigned get = len &gt; INT_MAX ? INT_MAX : (unsigned)len;\n        int got = _read(fd, next, get);\n        if (got &lt; 0)\n            return -1;\n        next += got;\n        len -= got;\n        if (got &lt; (int)get)\n            break;\n    }\n    return next - (uint8_t *)buf;\n}\n#define write write_z\nstatic ssize_t write_z(int fd, void const *buf, size_t len) {\n    if ((ssize_t)len &lt; 0)\n        return -1;\n    uint8_t const *next = buf;\n    size_t left = len;\n    while (left) {\n        unsigned put = left &gt; INT_MAX ? INT_MAX : (unsigned)left;\n        if (_write(fd, next, put) &lt; (int)put)\n            return -1;\n        next += put;\n        left -= put;\n    }\n    return len;\n}\n#  define close _close\n#  define ftruncate _chsize_s\n#else\n#  include &lt;unistd.h&gt;\n#  define BINARY 0\n#endif\n\n// Exit with a printf-formatted error message to standard error, and an exit code of 1.\nstatic void bail(char *fmt, ...) {\n    fputs(&quot;** ziprub error: &quot;, stderr);\n    va_list ap;\n    va_start(ap, fmt);\n    vfprintf(stderr, fmt, ap);\n    va_end(ap);\n    putc('\\n', stderr);\n    exit(1);\n}\n\n// Return a memory allocation of size bytes.\nstatic void *alloc(size_t size) {\n    void *mem = malloc(size);\n    if (mem == NULL)\n        bail(&quot;out of memory&quot;);\n    return mem;\n}\n\n// Return the size of fd. (fd cannot be a pipe.)\nstatic off_t fsize(int fd) {\n    off_t ret = lseek(fd, 0, SEEK_END);\n    if (ret == -1)\n        bail(&quot;seek error: %s&quot;, strerror(errno));\n    return ret;\n}\n\n// Read up to len bytes from offset pos in fd to buf. Return the number of\n// bytes read.\nstatic size_t load(int fd, off_t pos, uint8_t *buf, size_t len) {\n    if ((ssize_t)len &lt; 0)\n        bail(&quot;len overflow&quot;);\n    if (lseek(fd, pos, SEEK_SET) == -1)\n        bail(&quot;seek error: %s&quot;, strerror(errno));\n    ssize_t got = read(fd, buf, len);\n    if (got &lt; 0)\n        bail(&quot;read error %s&quot;, strerror(errno));\n    return got;\n}\n\n// Read len bytes from offset pos in fd to buf. If this returns, then len bytes\n// were read.\nstatic void grab(int fd, off_t pos, uint8_t *buf, size_t len) {\n    size_t got = load(fd, pos, buf, len);\n    if ((size_t)got != len)\n        bail(&quot;premature EOF -- invalid ZIP file&quot;);\n}\n\n// Write len bytes over what is at offset pos in fd from buf. If this returns,\n// then len bytes were written.\nstatic void over(int fd, off_t pos, uint8_t const *buf, size_t len) {\n    if (lseek(fd, pos, SEEK_SET) == -1)\n        bail(&quot;seek error: %s&quot;, strerror(errno));\n    if (write(fd, buf, len) == -1)\n        bail(&quot;write error %s&quot;, strerror(errno));\n}\n\n// ZIP file structure signatures, lengths, and a marker.\n#define LOCAL 0x04034b50            // Local entry header\n#define CENTRAL 0x02014b50          // Central directory entry header\n#define END 0x06054b50              // End record\n#define END64 0x06064b50            // Zip64 end record\n#define LOC64 0x07064b50            // Zip64 end locator record\n#define DATADESC 0x08074b50         // Data descriptor after compressed data\n#define LOCLEN 30                   // Length of local entry header\n#define CENLEN 46                   // Length of central directory header\n#define ENDLEN 22                   // Length of end record\n#define END64LEN 56                 // Length of Zip64 end record\n#define LOC64LEN 20                 // Length of Zip64 locator record\n#define MAX16 0xffff                // Indicated Zip64 extensions\n#define MAX32 0xffffffff            // Indicates Zip64 extensions\n\n// Get two, four, or eight-byte little-endian unsigned integers from p.\nstatic inline unsigned get2(uint8_t const *p) {\n    return p[0] | (p[1] &lt;&lt; 8);\n}\nstatic inline uint32_t get4(uint8_t const *p) {\n    return get2(p) | ((uint32_t)get2(p + 2) &lt;&lt; 16);\n}\nstatic inline uint64_t get8(uint8_t const *p) {\n    return get4(p) | ((uint64_t)get4(p + 4) &lt;&lt; 32);\n}\n\n// Put two, four, or eight-byte little-endian unsigned integers n at p.\nstatic inline void put2(uint8_t *p, unsigned n) {\n    p[0] = n &amp; 0xff;\n    p[1] = (n &gt;&gt; 8) &amp; 0xff;\n}\nstatic inline void put4(uint8_t *p, uint32_t n) {\n    put2(p, n &amp; 0xffff);\n    put2(p + 2, n &gt;&gt; 16);\n}\nstatic inline void put8(uint8_t *p, uint64_t n) {\n    put4(p, n &amp; 0xffffffff);\n    put4(p + 4, n &gt;&gt; 32);\n}\n\n// Sector size for end record searching. Must be a power of two.\n#define SECTOR 4096\n\n// Search for the ZIP end record, starting from the end of the file. The end\n// record is almost always the last 22 bytes of the file, but we need to search\n// regardless. Return the offset of the end record, or -1 if not found.\nstatic off_t find_end(int fd) {\n    // Get the ZIP file length.\n    off_t len = fsize(fd);\n    if (len &lt; ENDLEN)\n        // Can't be a ZIP file.\n        return -1;\n\n    // Read a sector at a time, starting with the partial sector at the end.\n    uint8_t buf[SECTOR + 3];\n    size_t get = ((len - 1) &amp; (SECTOR - 1)) + 1;\n    off_t pos = len - get;\n    size_t left = 0;\n    for (;;) {\n        // Read the next sector.\n        grab(fd, pos, buf, get);\n        left += get;\n\n        // Search for the end signature backwards through the buffer.\n        while (left &gt;= 4) {\n            if (get4(buf + left - 4) == END)\n                // Found it.\n                return pos + left - 4;\n            left--;\n        }\n\n        // If we're at the start of the file, then there was no end signature.\n        if (pos == 0)\n            return -1;\n\n        // Get the next sector down, retaining up to three bytes from the\n        // current sector, in case the signature crosses a sector boundary.\n        memcpy(buf + SECTOR, buf, left);\n        get = SECTOR;\n        pos -= SECTOR;\n    }\n}\n\n// Central directory and end record information from find_central().\ntypedef struct {\n    uint64_t cbeg;          // Offset of the start of the central directory\n    uint64_t clen;          // Length of the central directory\n    uint64_t cnum;          // Number of entries in the central directory\n    uint64_t zlen;          // Zip64 end record length\n    uint8_t *zend;          // Zip64 end record (allocated)\n    int zip64;              // True if there are Zip64 end fields\n    unsigned elen;          // End record comment length\n    uint8_t *etxt;          // End record comment (allocated)\n} zip_t;\n\n// Return information from the central directory and end records in *zip.\n// Return 0 on success or -1 if not found.\nstatic int find_central(int fd, zip_t *zip) {\n    // Find and read the end record data.\n    off_t pos = find_end(fd);\n    if (pos == -1)\n        return -1;\n    uint8_t buf[END64LEN];\n    grab(fd, pos + 4, buf, ENDLEN - 4);\n\n    // Save the ZIP file comment, if any.\n    zip-&gt;elen = get2(buf + 16);\n    zip-&gt;etxt = alloc(zip-&gt;elen + 1);\n    grab(fd, pos + ENDLEN, zip-&gt;etxt, zip-&gt;elen);\n    zip-&gt;etxt[zip-&gt;elen] = 0;\n\n    // Process the end records, retrieving Zip64 records as needed.\n    if (get2(buf) == MAX16 || get2(buf + 2) == MAX16 ||\n        get2(buf + 4) == MAX16 || get2(buf + 6) == MAX16 ||\n        get4(buf + 8) == MAX32 || get4(buf + 12) == MAX32) {\n        // The information is in the Zip64 end record. Get the locator record.\n        if (pos &lt; LOC64LEN)\n            return -1;\n        pos -= LOC64LEN;\n        grab(fd, pos, buf, LOC64LEN);\n        if (get4(buf) != LOC64 || get4(buf + 4) != 0 ||\n            get4(buf + 16) != 1)\n            return -1;\n        pos = get8(buf + 8);\n\n        // Get and check the Zip64 end record.\n        grab(fd, pos, buf, END64LEN);\n        if (get4(buf) != END64 || get4(buf + 16) != 0 || get4(buf + 20) != 0 ||\n            get8(buf + 24) != get8(buf + 32))\n            // Incorrect signature or multiple disks are indicated.\n            return -1;\n\n        // Extract the information, including the zip64 extensible data sector.\n        // Save the entire Zip64 end record to write it back out later, with\n        // modifications.\n        zip-&gt;cbeg = get8(buf + 48);\n        zip-&gt;clen = get8(buf + 40);\n        zip-&gt;cnum = get8(buf + 32);\n        zip-&gt;zlen = get8(buf + 4) + 12;\n        zip-&gt;zend = alloc(zip-&gt;zlen);\n        memcpy(zip-&gt;zend, buf, END64LEN);\n        grab(fd, pos + END64LEN, zip-&gt;zend + END64LEN, zip-&gt;zlen - END64LEN);\n    }\n    else {\n        // The information is in the end record.\n        if (get2(buf) != 0 || get2(buf + 2) != 0 ||\n            get2(buf + 4) != get2(buf + 6))\n            // Multiple disks are indicated.\n            return -1;\n\n        // Extract the information.\n        zip-&gt;cbeg = get4(buf + 12);\n        zip-&gt;clen = get4(buf + 8);\n        zip-&gt;cnum = get2(buf + 6);\n        zip-&gt;zlen = 0;\n        zip-&gt;zend = NULL;\n    }\n    return 0;\n}\n\n// Local header information from get_local().\ntypedef struct {\n    uint64_t off;           // Local header offset\n    uint64_t len;           // Total length of the local entry\n    uint32_t stamp;         // Last modify time\n} local_t;\n\n// Extract local entry offset and length from central header. Return 0 on\n// success, or -1 if there is a ZIP file structure error.\nstatic int get_local(int fd, uint8_t const *cent, local_t *loc) {\n    loc-&gt;stamp = get4(cent + 12);           // Last modify time\n    uint32_t crc = get4(cent + 16);         // Uncompressed data CRC-32\n    uint64_t clen = get4(cent + 20);        // Compressed length\n    uint64_t ulen = get4(cent + 24);        // Uncompressed length\n    loc-&gt;off = get4(cent + 42);\n    if (loc-&gt;off == MAX32 || clen == MAX32) {\n        // Look through the extra field for a Zip64 extra subfield.\n        uint8_t const *xtra = cent + CENLEN + get2(cent + 28);\n        uint8_t const *xend = xtra + get2(cent + 30);\n        while (xtra + 4 &lt;= xend) {\n            unsigned id = get2(xtra);\n            unsigned len = get2(xtra + 2);\n            if (xtra + 4 + len &gt; xend)\n                return -1;\n            if (id == 1) {\n                // Found Zip64 extra subfield. Set xend to end of subfield.\n                xend = xtra + 4 + len;\n                break;\n            }\n            xtra += 4 + len;\n        }\n        if (xtra + 4 + 8 * ((ulen == MAX32) + (clen == MAX32) +\n                            (loc-&gt;off == MAX32)) &gt; xend)\n            // Missing Zip64 subfield or subfield too short.\n            return -1;\n\n        // Extract the lengths and offset from the Zip64 extra subfield.\n        xtra += 4;\n        if (ulen == MAX32) {\n            ulen = get8(xtra);\n            xtra += 8;\n        }\n        if (clen == MAX32) {\n            clen = get8(xtra);\n            xtra += 8;\n        }\n        if (loc-&gt;off == MAX32)\n            loc-&gt;off = get8(xtra);\n    }\n\n    // Get the local header. Compute and save the total local entry length.\n    uint8_t buf[LOCLEN];\n    grab(fd, loc-&gt;off, buf, LOCLEN);\n    if (get4(buf) != LOCAL)\n        return -1;\n    loc-&gt;len = LOCLEN + get2(buf + 26) + get2(buf + 28) + clen;\n    if (get2(buf + 6) &amp; 8) {\n        // There is a data descriptor. Determine its length to add to the\n        // total. dlen is updated to the data descriptor length. We need to try\n        // all four possibilities, from longest to shortest.\n        size_t dlen = load(fd, loc-&gt;off + loc-&gt;len, buf, 24);\n        if (dlen &gt;= 24 &amp;&amp; get4(buf) == DATADESC &amp;&amp; get4(buf + 4) == crc &amp;&amp;\n                get8(buf + 8) == clen &amp;&amp; get8(buf + 16) == ulen)\n            dlen = 24;\n        else if (dlen &gt;= 20 &amp;&amp; get4(buf) == crc &amp;&amp; get8(buf + 4) == clen &amp;&amp;\n                 get8(buf + 12) == ulen)\n            dlen = 20;\n        else if (dlen &gt;= 16 &amp;&amp; get4(buf) == DATADESC &amp;&amp; get4(buf + 4) == crc &amp;&amp;\n                 get4(buf + 8) == clen &amp;&amp; get4(buf + 12) == ulen)\n            dlen = 16;\n        else if (dlen &gt;= 12 &amp;&amp; get4(buf) == crc &amp;&amp; get4(buf + 4) == clen &amp;&amp;\n                 get4(buf + 8) == ulen)\n            dlen = 12;\n        else\n            // No data descriptor matched.\n            return -1;\n        loc-&gt;len += dlen;\n    }\n\n    // Return the offset and length in *loc.\n    return 0;\n}\n\n// Return a(x) multiplied by b(x) modulo p(x), where p(x) is the CRC\n// polynomial, reflected. For speed, this requires that a not be zero.\nstatic uint32_t multmodp(uint32_t a, uint32_t b) {\n    uint32_t m = (uint32_t)1 &lt;&lt; 31;\n    uint32_t p = 0;\n    for (;;) {\n        if (a &amp; m) {\n            p ^= b;\n            if ((a &amp; (m - 1)) == 0)\n                break;\n        }\n        m &gt;&gt;= 1;\n        b = b &amp; 1 ? (b &gt;&gt; 1) ^ 0xedb88320 : b &gt;&gt; 1;\n    }\n    return p;\n}\n\n// Table of x^2^n modulo p(x). This table repeats for higher values of n.\nstatic const uint32_t x2n_table[] = {\n    0x40000000, 0x20000000, 0x08000000, 0x00800000, 0x00008000,\n    0xedb88320, 0xb1e6b092, 0xa06a2517, 0xed627dae, 0x88d14467,\n    0xd7bbfe6a, 0xec447f11, 0x8e7ea170, 0x6427800e, 0x4d47bae0,\n    0x09fe548f, 0x83852d0f, 0x30362f1a, 0x7b5a9cc3, 0x31fec169,\n    0x9fec022a, 0x6c8dedc4, 0x15d6874d, 0x5fde7a4e, 0xbad90e37,\n    0x2e4e5eef, 0x4eaba214, 0xa8a472c0, 0x429a969e, 0x148d302a,\n    0xc40ba6d0, 0xc4e22c3c\n};\n\n// Return x^(n * 2^k) modulo p(x).\nstatic uint32_t x2nmodp(uint64_t n, unsigned k) {\n    uint32_t p = (uint32_t)1 &lt;&lt; 31;         // x^0 == 1\n    while (n) {\n        if (n &amp; 1)\n            p = multmodp(x2n_table[k &amp; 31], p);\n        n &gt;&gt;= 1;\n        k++;\n    }\n    return p;\n}\n\n// Return the CRC-32 of n zero bytes.\nstatic uint32_t crc32_zeros(uint64_t n) {\n    return ~multmodp(x2nmodp(n, 3), ~(uint32_t)0);\n}\n\n// Write a dummy local entry over the existing entry at *loc.\nstatic void dummy(int fd, local_t const *loc) {\n    // Compute uncompressed length, and whether Zip64 lengths will be needed.\n    uint64_t ulen = loc-&gt;len - LOCLEN;\n    int zip64 = 0;\n    if (ulen &gt;= MAX32) {\n        ulen -= 20;\n        zip64 = 1;\n    }\n\n    // Generate and write the local header.\n    uint8_t buf[SECTOR];\n    put4(buf, LOCAL);\n    put2(buf + 4, 20);\n    put4(buf + 6, 0);                       // No flags, stored\n    put4(buf + 10, loc-&gt;stamp);             // Last mod time\n    put4(buf + 14, crc32_zeros(ulen));\n    put4(buf + 18, zip64 ? MAX32 : (uint32_t)ulen);\n    put4(buf + 22, zip64 ? MAX32 : (uint32_t)ulen);\n    put2(buf + 26, 0);                      // Zero-length file name\n    put2(buf + 28, zip64 ? 20 : 0);\n    off_t pos = loc-&gt;off;\n    over(fd, pos, buf, LOCLEN);\n    pos += LOCLEN;\n    if (zip64) {\n        // Generate and write the Zip64 extra subfield.\n        put2(buf, 1);\n        put2(buf + 2, 16);\n        put8(buf + 4, ulen);\n        put8(buf + 12, ulen);\n        over(fd, pos, buf, 20);\n        pos += 20;\n    }\n\n    // Write ulen zero bytes for the stored data.\n    memset(buf, 0, SECTOR);\n    while (ulen &gt;= SECTOR) {\n        over(fd, pos, buf, SECTOR);\n        ulen -= SECTOR;\n        pos += SECTOR;\n    }\n    over(fd, pos, buf, ulen);\n}\n\n// Check the basic integrity of the central directory. Return 0 on success, or\n// -1 if it doesn't check out.\nstatic int check_central(uint8_t const *cent, uint64_t len, uint64_t num) {\n    while (len) {\n        if (len &lt; CENLEN || get4(cent) != CENTRAL)\n            return -1;\n        uint64_t skip = CENLEN + get2(cent + 28) + get2(cent + 30) +\n                        get2(cent + 32);\n        if (len &lt; skip)\n            return -1;\n        cent += skip;\n        len -= skip;\n        num--;\n    }\n    return num ? -1 : 0;\n}\n\n// Write over the central directory and end records with the new ones, and\n// truncate the file accordingly.\nstatic void tail(int fd, zip_t const *zip, uint8_t const *cent) {\n    // Write the new central directory.\n    over(fd, zip-&gt;cbeg, cent, zip-&gt;clen);\n\n    // Write the end records.\n    off_t pos = zip-&gt;cbeg + zip-&gt;clen;\n    uint8_t buf[ENDLEN];\n    if (zip-&gt;zend != NULL) {\n        // Update and write the Zip64 end of central directory record.\n        put8(zip-&gt;zend + 24, zip-&gt;cnum);\n        put8(zip-&gt;zend + 32, zip-&gt;cnum);\n        put8(zip-&gt;zend + 40, zip-&gt;clen);\n        over(fd, pos, zip-&gt;zend, zip-&gt;zlen);\n\n        // Create and write the Zip64 end of central directory locator.\n        put4(buf, LOC64);\n        put4(buf + 4, 0);\n        put8(buf + 8, pos);\n        put4(buf + 16, 1);\n        pos += zip-&gt;zlen;\n        over(fd, pos, buf, LOC64LEN);\n        pos += LOC64LEN;\n\n        // Create and write an end of central directory record which calls\n        // for Zip64 end records.\n        put4(buf, END);\n        memset(buf + 4, 0xff, 16);          // All fields indicate Zip64\n        put2(buf + 20, zip-&gt;elen);\n        over(fd, pos, buf, ENDLEN);\n        pos += ENDLEN;\n        over(fd, pos, zip-&gt;etxt, zip-&gt;elen);\n        pos += zip-&gt;elen;\n    }\n    else {\n        // Create and write the end of central directory record.\n        put4(buf, END);\n        put4(buf + 4, 0);\n        put2(buf + 8, (unsigned)zip-&gt;cnum);\n        put2(buf + 10, (unsigned)zip-&gt;cnum);\n        put4(buf + 12, (uint32_t)zip-&gt;clen);\n        put4(buf + 16, (uint32_t)zip-&gt;cbeg);\n        put2(buf + 20, zip-&gt;elen);\n        over(fd, pos, buf, ENDLEN);\n        pos += ENDLEN;\n        over(fd, pos, zip-&gt;etxt, zip-&gt;elen);\n        pos += zip-&gt;elen;\n    }\n\n    // Truncate the ZIP file to end at the end.\n    if (ftruncate(fd, pos) != 0)\n        bail(&quot;truncate error: %s&quot;, strerror(errno));\n}\n\nint main(int argc, char **argv) {\n    if (argc == 1) {\n        puts(&quot;Usage: ziprub archive.zip a.txt b.txt\\n&quot;\n             &quot;       to rub out a.txt and b.txt from the archive&quot;);\n        return 0;\n    }\n\n    // Open ZIP file.\n    int fd = open(argv[1], O_RDWR | BINARY);\n    if (fd == -1)\n        bail(&quot;could not open %s: %s&quot;, argv[1], strerror(errno));\n\n    // Look for the central directory.\n    zip_t zip;\n    int ret = find_central(fd, &amp;zip);\n    if (ret == -1)\n        bail(&quot;%s is not a valid and regular ZIP file&quot;, argv[1]);\n\n    // Load the central directory.\n    uint64_t len = zip.clen;\n    uint8_t *cent = alloc(len);\n    grab(fd, zip.cbeg, cent, len);\n    if (check_central(cent, len, zip.cnum))\n        bail(&quot;invalid central directory&quot;);\n\n    // Make a list of rub entry name lengths and local header info. Their\n    // indices correspond to the argv[] indices.\n    size_t *lens = alloc(argc * sizeof(size_t));\n    local_t *locs = alloc(argc * sizeof(local_t));\n    for (int i = 2; i &lt; argc; i++)\n        lens[i] = strlen(argv[i]);\n\n    // Step through the central directory, looking for the names on the command\n    // line that follow the ZIP file name. Rub out those that match.\n    uint8_t *next = cent;\n    uint64_t left = zip.cnum;\n    int mod = 0;                    // True if central directory modified\n    while (left) {\n        local_t loc;\n        if (get_local(fd, next, &amp;loc) == -1)\n            bail(&quot;invalid ZIP structure&quot;);\n        if (loc.off + loc.len &gt; zip.cbeg)\n            bail(&quot;irregular ZIP file: local entries after directory&quot;);\n        unsigned nlen = get2(next + 28);\n        unsigned skip = CENLEN + nlen + get2(next + 30) + get2(next + 32);\n        int i;\n        for (i = 2; i &lt; argc; i++)\n            if (nlen == lens[i] &amp;&amp; memcmp(next + CENLEN, argv[i], nlen) == 0)\n                break;\n        if (i &lt; argc) {\n            // Delete this central directory header.\n            memmove(next, next + skip, (cent + zip.clen) - (next + skip));\n            zip.clen -= skip;\n            zip.cnum--;\n            lens[i] = (size_t)-1;\n            locs[i] = loc;\n            mod = 1;\n        }\n        else\n            // Go to the next one.\n            next += skip;\n        left--;\n    }\n\n    // Note the command line names that were not found.\n    for (int i = 2; i &lt; argc; i++)\n        if (lens[i] != (size_t) - 1)\n            fprintf(stderr, &quot;!! %s not found in ZIP file\\n&quot;, argv[i]);\n\n    if (mod) {\n        // Entries were deleted from the central directory. Only now do we have\n        // courage to muck with the ZIP file, once everything is worked out.\n\n        // Overwrite the deleted local entries with dummy entries that have\n        // zero-length file names.\n        for (int i = 2; i &lt; argc; i++)\n            if (lens[i] == (size_t)-1)\n                dummy(fd, locs + i);\n\n        // Overwrite the old central directory and end records with the new\n        // ones, truncating the ZIP file.\n        tail(fd, &amp;zip, cent);\n    }\n\n    // Clean up.\n    free(locs);\n    free(lens);\n    free(cent);\n    free(zip.zend);\n    free(zip.etxt);\n    close(fd);\n    return 0;\n}\n</code></pre>\n",
    "score" : 4,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1136690,
      "reputation" : 115257,
      "user_id" : 1180620,
      "user_type" : "registered",
      "accept_rate" : 83,
      "profile_image" : "https://i.sstatic.net/FXaAg.jpg?s=256",
      "display_name" : "Mark Adler",
      "link" : "https://stackoverflow.com/users/1180620/mark-adler"
    },
    "creation_date" : 1758958530,
    "last_activity_date" : 1764114900,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79774622,
    "question_id" : 79774609,
    "body" : "<p>In most cases, you can't modify existing archives. You need to create a new one and replace the old one with it.</p>\n<p>If you do it in two steps: remove and add you have to create two ZIP files. I suggest you to just replace the one you need.</p>\n<p>In a loop, read all entities from the ZIP file and write to a new ZIP file</p>\n<ul>\n<li><p>if it is the one you want to replace, skip it and write a new one instead to output</p>\n</li>\n<li><p>otherwise, write it unchanged to the output</p>\n</li>\n</ul>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 4497436,
      "reputation" : 20786,
      "user_id" : 3656904,
      "user_type" : "registered",
      "accept_rate" : 67,
      "profile_image" : "https://www.gravatar.com/avatar/8bdbd1f89f8907e8e8b15ab88c084c65?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "talex",
      "link" : "https://stackoverflow.com/users/3656904/talex"
    },
    "creation_date" : 1758791925,
    "last_activity_date" : 1764110841,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79778405,
    "question_id" : 79774609,
    "body" : "<p>I asked <a href=\"https://en.wikipedia.org/wiki/Claude_(language_model)\" rel=\"nofollow noreferrer\">Claude Sonnet</a> 4.5 to convert my C code in another answer here to Java. That worked surprisingly well! I only had to fix one bug (migration of a constant from 32 to 64 bits). I had to put this in a new answer due to the answer size limitation on Stack Overflow. This is <em>not</em> an AI-generated answer. It is simply a translation of my hand-written code.</p>\n<p>Here is an example of code in Java to rub out named entries from a ZIP file in place. The additional task of appending new entries at the end in place is left as an exercise for the reader.</p>\n<pre><code>/* ZipRub.java -- rub out ZIP file entries in place\n * Copyright (C) 2025 Mark Adler\n * Version 1.1  30 Sep 2025  Mark Adler\n */\n\n/*\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the author be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  Mark Adler\n  madler@alumni.caltech.edu\n */\n\n// Remove entries from a ZIP file in place, without having to copy the entire\n// ZIP file. Each entry is written over with with a zero-length file name and\n// all zeros for data, and the entry is removed from the central directory.\n// This requires that the central directory and end records are at the end of\n// the ZIP file, which is the convention as well as the specification.\n\n// This does not handle encrypted ZIP files, nor ZIP files with a compressed\n// central directory.\n\n/* Version history:\n   1.0  26 Sep 2025  First version\n   1.1  30 Sep 2025  Check for a central directory or Zip64 extensible data\n                     that is too big for Java arrays (2^31-1 elements limit)\n */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class ZipRub {\n\n    // ZIP file structure signatures, lengths, and a marker.\n    private static final long LOCAL = 0x04034b50L;      // Local header sig\n    private static final long CENTRAL = 0x02014b50L;    // Central header sig\n    private static final long END = 0x06054b50L;        // End record sig\n    private static final long END64 = 0x06064b50L;      // Zip64 end sig\n    private static final long LOC64 = 0x07064b50L;      // Zip64 locator sig\n    private static final long DATADESC = 0x08074b50L;   // Data descriptor sig\n    private static final int LOCLEN = 30;               // Local header len\n    private static final int CENLEN = 46;               // Central header len\n    private static final int ENDLEN = 22;               // End record len\n    private static final int END64LEN = 56;             // Zip64 end len\n    private static final int LOC64LEN = 20;             // Zip64 locator len\n    private static final int MAX16 = 0xffff;            // Zip64 indicator\n    private static final long MAX32 = 0xffffffffL;      // Zip64 indicator\n\n    // Exit with a formatted error message to stderr, and an exit code of 1.\n    private static void bail(String format, Object... args) {\n        System.err.print(&quot;** ziprub error: &quot;);\n        System.err.printf(format, args);\n        System.err.println();\n        System.exit(1);\n    }\n\n    // Return the size of fd. (fd cannot be a pipe.)\n    private static long fsize(RandomAccessFile fd) {\n        try {\n            return fd.length();\n        } catch (IOException e) {\n            bail(&quot;seek error: %s&quot;, e.getMessage());\n            return -1;\n        }\n    }\n\n    // Read up to len bytes from offset pos in fd to buf. Return the number of\n    // bytes read.\n    private static int load(RandomAccessFile fd, long pos, byte[] buf,\n                            int len) {\n        try {\n            fd.seek(pos);\n            return fd.read(buf, 0, len);\n        } catch (IOException e) {\n            bail(&quot;read error %s&quot;, e.getMessage());\n            return -1;\n        }\n    }\n\n    // Read len bytes from offset pos in fd to buf. If this returns, then len\n    // bytes were read.\n    private static void grab(RandomAccessFile fd, long pos, byte[] buf,\n                             int len) {\n        int got = load(fd, pos, buf, len);\n        if (got != len)\n            bail(&quot;premature EOF -- invalid ZIP file&quot;);\n    }\n\n    // Write len bytes over what is at offset pos in fd from buf. If this\n    // returns, then len bytes were written.\n    private static void over(RandomAccessFile fd, long pos, byte[] buf,\n                             int len) {\n        try {\n            fd.seek(pos);\n            fd.write(buf, 0, len);\n        } catch (IOException e) {\n            bail(&quot;write error %s&quot;, e.getMessage());\n        }\n    }\n\n    // Get two, four, or eight-byte little-endian unsigned integers from p.\n    private static int get2(byte[] p, int offset) {\n        return (p[offset] &amp; 0xff) | ((p[offset + 1] &amp; 0xff) &lt;&lt; 8);\n    }\n    private static long get4(byte[] p, int offset) {\n        return get2(p, offset) | ((long)get2(p, offset + 2) &lt;&lt; 16);\n    }\n    private static long get8(byte[] p, int offset) {\n        return get4(p, offset) | (get4(p, offset + 4) &lt;&lt; 32);\n    }\n\n    // Put two, four, or eight-byte little-endian unsigned integers n at p.\n    private static void put2(byte[] p, int offset, int n) {\n        p[offset] = (byte)(n &amp; 0xff);\n        p[offset + 1] = (byte)((n &gt;&gt;&gt; 8) &amp; 0xff);\n    }\n    private static void put4(byte[] p, int offset, long n) {\n        put2(p, offset, (int)n);\n        put2(p, offset + 2, (int)(n &gt;&gt;&gt; 16));\n    }\n    private static void put8(byte[] p, int offset, long n) {\n        put4(p, offset, n);\n        put4(p, offset + 4, n &gt;&gt;&gt; 32);\n    }\n\n    // Sector size for end record searching. Must be a power of two.\n    private static final int SECTOR = 4096;\n\n    // Search for the ZIP end record, starting from the end of the file. The\n    // end record is almost always the last 22 bytes of the file, but we need\n    // to search regardless. Return the offset of the end record, or -1 if not\n    // found.\n    private static long find_end(RandomAccessFile fd) {\n        // Get the ZIP file length.\n        long len = fsize(fd);\n        if (len &lt; ENDLEN)\n            // Can't be a ZIP file.\n            return -1;\n\n        // Read a sector at a time, starting with the partial sector at the\n        // end.\n        byte[] buf = new byte[SECTOR + 3];\n        int get = (int)(((len - 1) &amp; (SECTOR - 1)) + 1);\n        long pos = len - get;\n        int left = 0;\n        for (;;) {\n            // Read the next sector.\n            grab(fd, pos, buf, get);\n            left += get;\n\n            // Search for the end signature backwards through the buffer.\n            while (left &gt;= 4) {\n                if (get4(buf, left - 4) == END)\n                    // Found it.\n                    return pos + left - 4;\n                left--;\n            }\n\n            // If we're at the start of the file, then there was no end\n            // signature.\n            if (pos == 0)\n                return -1;\n\n            // Get the next sector down, retaining up to three bytes from the\n            // current sector, in case the signature crosses a sector boundary.\n            System.arraycopy(buf, 0, buf, SECTOR, left);\n            get = SECTOR;\n            pos -= SECTOR;\n        }\n    }\n\n    // Central directory and end record information from find_central().\n    static class zip_t {\n        long cbeg;          // Offset of the start of the central directory\n        long clen;          // Length of the central directory\n        long cnum;          // Number of entries in the central directory\n        long zlen;          // Zip64 end record length\n        byte[] zend;        // Zip64 end record (allocated)\n        int zip64;          // True if there are Zip64 end fields\n        int elen;           // End record comment length\n        byte[] etxt;        // End record comment (allocated)\n    }\n\n    // Return information from the central directory and end records in *zip.\n    // Return 0 on success or -1 if not found.\n    private static int find_central(RandomAccessFile fd, zip_t zip) {\n        // Find and read the end record data.\n        long pos = find_end(fd);\n        if (pos == -1)\n            return -1;\n        byte[] buf = new byte[END64LEN];\n        grab(fd, pos + 4, buf, ENDLEN - 4);\n\n        // Save the ZIP file comment, if any.\n        zip.elen = get2(buf, 16);\n        zip.etxt = new byte[zip.elen + 1];\n        grab(fd, pos + ENDLEN, zip.etxt, zip.elen);\n        zip.etxt[zip.elen] = 0;\n\n        // Process the end records, retrieving Zip64 records as needed.\n        if (get2(buf, 0) == MAX16 || get2(buf, 2) == MAX16 ||\n            get2(buf, 4) == MAX16 || get2(buf, 6) == MAX16 ||\n            get4(buf, 8) == MAX32 || get4(buf, 12) == MAX32) {\n            // The information is in the Zip64 end record. Get the locator\n            // record.\n            if (pos &lt; LOC64LEN)\n                return -1;\n            pos -= LOC64LEN;\n            grab(fd, pos, buf, LOC64LEN);\n            if (get4(buf, 0) != LOC64 || get4(buf, 4) != 0 ||\n                get4(buf, 16) != 1)\n                return -1;\n            pos = get8(buf, 8);\n\n            // Get and check the Zip64 end record.\n            grab(fd, pos, buf, END64LEN);\n            if (get4(buf, 0) != END64 || get4(buf, 16) != 0 ||\n                get4(buf, 20) != 0 || get8(buf, 24) != get8(buf, 32))\n                // Incorrect signature or multiple disks are indicated.\n                return -1;\n\n            // Extract the information, including the zip64 extensible data\n            // sector. Save the entire Zip64 end record to write it back out\n            // later, with modifications.\n            zip.cbeg = get8(buf, 48);\n            zip.clen = get8(buf, 40);\n            zip.cnum = get8(buf, 32);\n            zip.zlen = get8(buf, 4) + 12;\n            if (zip.zlen != (int)zip.zlen)\n                // The extensible data is too large for Java!\n                return -1;\n            zip.zend = new byte[(int)zip.zlen];\n            System.arraycopy(buf, 0, zip.zend, 0, END64LEN);\n            grab(fd, pos + END64LEN, zip.zend, (int)(zip.zlen - END64LEN));\n        }\n        else {\n            // The information is in the end record.\n            if (get2(buf, 0) != 0 || get2(buf, 2) != 0 ||\n                get2(buf, 4) != get2(buf, 6))\n                // Multiple disks are indicated.\n                return -1;\n\n            // Extract the information.\n            zip.cbeg = get4(buf, 12);\n            zip.clen = get4(buf, 8);\n            zip.cnum = get2(buf, 6);\n            zip.zlen = 0;\n            zip.zend = null;\n        }\n        return 0;\n    }\n\n    // Local header information from get_local().\n    static class local_t {\n        long off;           // Local header offset\n        long len;           // Total length of the local entry\n        long stamp;         // Last modification time\n    }\n\n    // Extract local entry offset and length from central header. Return 0 on\n    // success, or -1 if there is a ZIP file structure error.\n    private static int get_local(RandomAccessFile fd, byte[] cent, int centOff,\n                                 local_t loc) {\n        loc.stamp = get4(cent, centOff + 12);           // Last modification time\n        long crc = get4(cent, centOff + 16);            // Uncompressed CRC-32\n        long clen = get4(cent, centOff + 20);           // Compressed length\n        long ulen = get4(cent, centOff + 24);           // Uncompressed length\n        loc.off = get4(cent, centOff + 42);\n        if (loc.off == MAX32 || clen == MAX32) {\n            // Look through the extra field for a Zip64 extra subfield.\n            int xtra = centOff + CENLEN + get2(cent, centOff + 28);\n            int xend = xtra + get2(cent, centOff + 30);\n            while (xtra + 4 &lt;= xend) {\n                int id = get2(cent, xtra);\n                int len = get2(cent, xtra + 2);\n                if (xtra + 4 + len &gt; xend)\n                    return -1;\n                if (id == 1) {\n                    // Found Zip64 extra subfield. Set xend to end of subfield.\n                    xend = xtra + 4 + len;\n                    break;\n                }\n                xtra += 4 + len;\n            }\n            if (xtra + 4 + 8 * ((ulen == MAX32 ? 1 : 0) +\n                                (clen == MAX32 ? 1 : 0) +\n                                (loc.off == MAX32 ? 1 : 0)) &gt; xend)\n                // Missing Zip64 subfield or subfield too short.\n                return -1;\n\n            // Extract the lengths and offset from the Zip64 extra subfield.\n            xtra += 4;\n            if (ulen == MAX32) {\n                ulen = get8(cent, xtra);\n                xtra += 8;\n            }\n            if (clen == MAX32) {\n                clen = get8(cent, xtra);\n                xtra += 8;\n            }\n            if (loc.off == MAX32)\n                loc.off = get8(cent, xtra);\n        }\n\n        // Get the local header. Compute and save the total local entry length.\n        byte[] buf = new byte[LOCLEN];\n        grab(fd, loc.off, buf, LOCLEN);\n        if (get4(buf, 0) != LOCAL)\n            return -1;\n        loc.len = LOCLEN + get2(buf, 26) + get2(buf, 28) + clen;\n        if ((get2(buf, 6) &amp; 8) != 0) {\n            // There is a data descriptor. Determine its length to add to the\n            // total. dlen is updated to the data descriptor length. We need to\n            // try all four possibilities, from longest to shortest.\n            int dlen = load(fd, loc.off + loc.len, buf, 24);\n            if (dlen &gt;= 24 &amp;&amp; get4(buf, 0) == DATADESC &amp;&amp;\n                    get4(buf, 4) == crc &amp;&amp; get8(buf, 8) == clen &amp;&amp;\n                    get8(buf, 16) == ulen)\n                dlen = 24;\n            else if (dlen &gt;= 20 &amp;&amp; get4(buf, 0) == crc &amp;&amp;\n                     get8(buf, 4) == clen &amp;&amp; get8(buf, 12) == ulen)\n                dlen = 20;\n            else if (dlen &gt;= 16 &amp;&amp; get4(buf, 0) == DATADESC &amp;&amp;\n                     get4(buf, 4) == crc &amp;&amp; get4(buf, 8) == clen &amp;&amp;\n                     get4(buf, 12) == ulen)\n                dlen = 16;\n            else if (dlen &gt;= 12 &amp;&amp; get4(buf, 0) == crc &amp;&amp;\n                     get4(buf, 4) == clen &amp;&amp; get4(buf, 8) == ulen)\n                dlen = 12;\n            else\n                // No data descriptor matched.\n                return -1;\n            loc.len += dlen;\n        }\n\n        // Return the offset and length in *loc.\n        return 0;\n    }\n\n    // Return a(x) multiplied by b(x) modulo p(x), where p(x) is the CRC\n    // polynomial, reflected. For speed, this requires that a not be zero.\n    private static int multmodp(int a, int b) {\n        int m = 1 &lt;&lt; 31;\n        int p = 0;\n        for (;;) {\n            if ((a &amp; m) != 0) {\n                p ^= b;\n                if ((a &amp; (m - 1)) == 0)\n                    break;\n            }\n            m &gt;&gt;&gt;= 1;\n            b = (b &amp; 1) != 0 ? (b &gt;&gt;&gt; 1) ^ 0xedb88320 : b &gt;&gt;&gt; 1;\n        }\n        return p;\n    }\n\n    // Table of x^2^n modulo p(x). This table repeats for higher values of n.\n    private static final int[] x2n_table = {\n        0x40000000, 0x20000000, 0x08000000, 0x00800000, 0x00008000,\n        0xedb88320, 0xb1e6b092, 0xa06a2517, 0xed627dae, 0x88d14467,\n        0xd7bbfe6a, 0xec447f11, 0x8e7ea170, 0x6427800e, 0x4d47bae0,\n        0x09fe548f, 0x83852d0f, 0x30362f1a, 0x7b5a9cc3, 0x31fec169,\n        0x9fec022a, 0x6c8dedc4, 0x15d6874d, 0x5fde7a4e, 0xbad90e37,\n        0x2e4e5eef, 0x4eaba214, 0xa8a472c0, 0x429a969e, 0x148d302a,\n        0xc40ba6d0, 0xc4e22c3c\n    };\n\n    // Return x^(n * 2^k) modulo p(x).\n    private static int x2nmodp(long n, int k) {\n        int p = 1 &lt;&lt; 31;                       // x^0 == 1\n        while (n != 0) {\n            if ((n &amp; 1) != 0)\n                p = multmodp(x2n_table[k &amp; 31], p);\n            n &gt;&gt;&gt;= 1;\n            k++;\n        }\n        return p;\n    }\n\n    // Return the CRC-32 of n zero bytes.\n    private static int crc32_zeros(long n) {\n        return ~multmodp(x2nmodp(n, 3), -1);\n    }\n\n    // Write a dummy local entry over the existing entry at *loc.\n    private static void dummy(RandomAccessFile fd, local_t loc) {\n        // Compute uncompressed length, and whether Zip64 lengths will be\n        // needed.\n        long ulen = loc.len - LOCLEN;\n        int zip64 = 0;\n        if (ulen &gt;= MAX32) {\n            ulen -= 20;\n            zip64 = 1;\n        }\n\n        // Generate and write the local header.\n        byte[] buf = new byte[SECTOR];\n        put4(buf, 0, LOCAL);\n        put2(buf, 4, 20);\n        put4(buf, 6, 0);                        // No flags, stored\n        put4(buf, 10, loc.stamp);               // Last modification time\n        put4(buf, 14, crc32_zeros(ulen));\n        put4(buf, 18, zip64 != 0 ? MAX32 : ulen);\n        put4(buf, 22, zip64 != 0 ? MAX32 : ulen);\n        put2(buf, 26, 0);                       // Zero-length file name\n        put2(buf, 28, zip64 != 0 ? 20 : 0);\n        long pos = loc.off;\n        over(fd, pos, buf, LOCLEN);\n        pos += LOCLEN;\n        if (zip64 != 0) {\n            // Generate and write the Zip64 extra subfield.\n            put2(buf, 0, 1);\n            put2(buf, 2, 16);\n            put8(buf, 4, ulen);\n            put8(buf, 12, ulen);\n            over(fd, pos, buf, 20);\n            pos += 20;\n        }\n\n        // Write ulen zero bytes for the stored data.\n        Arrays.fill(buf, (byte)0);\n        while (ulen &gt;= SECTOR) {\n            over(fd, pos, buf, SECTOR);\n            ulen -= SECTOR;\n            pos += SECTOR;\n        }\n        over(fd, pos, buf, (int)ulen);\n    }\n\n    // Check the basic integrity of the central directory. Return 0 on success,\n    // or -1 if it doesn't check out.\n    private static int check_central(byte[] cent, long len, long num) {\n        int offset = 0;\n        while (len &gt; 0) {\n            if (len &lt; CENLEN || get4(cent, offset) != CENTRAL)\n                return -1;\n            long skip = CENLEN + get2(cent, offset + 28) +\n                        get2(cent, offset + 30) + get2(cent, offset + 32);\n            if (len &lt; skip)\n                return -1;\n            offset += skip;\n            len -= skip;\n            num--;\n        }\n        return num != 0 ? -1 : 0;\n    }\n\n    // Write over the central directory and end records with the new ones, and\n    // truncate the file accordingly.\n    private static void tail(RandomAccessFile fd, zip_t zip, byte[] cent) {\n        // Write the new central directory.\n        over(fd, zip.cbeg, cent, (int)zip.clen);\n\n        // Write the end records.\n        long pos = zip.cbeg + zip.clen;\n        byte[] buf = new byte[ENDLEN];\n        if (zip.zend != null) {\n            // Update and write the Zip64 end of central directory record.\n            put8(zip.zend, 24, zip.cnum);\n            put8(zip.zend, 32, zip.cnum);\n            put8(zip.zend, 40, zip.clen);\n            over(fd, pos, zip.zend, (int)zip.zlen);\n\n            // Create and write the Zip64 end of central directory locator.\n            put4(buf, 0, LOC64);\n            put4(buf, 4, 0);\n            put8(buf, 8, pos);\n            put4(buf, 16, 1);\n            pos += zip.zlen;\n            over(fd, pos, buf, LOC64LEN);\n            pos += LOC64LEN;\n\n            // Create and write an end of central directory record which calls\n            // for Zip64 end records.\n            put4(buf, 0, END);\n            Arrays.fill(buf, 4, 20, (byte)0xff);    // Fields indicate Zip64\n            put2(buf, 20, zip.elen);\n            over(fd, pos, buf, ENDLEN);\n            pos += ENDLEN;\n            over(fd, pos, zip.etxt, zip.elen);\n            pos += zip.elen;\n        }\n        else {\n            // Create and write the end of central directory record.\n            put4(buf, 0, END);\n            put4(buf, 4, 0);\n            put2(buf, 8, (int)zip.cnum);\n            put2(buf, 10, (int)zip.cnum);\n            put4(buf, 12, zip.clen);\n            put4(buf, 16, zip.cbeg);\n            put2(buf, 20, zip.elen);\n            over(fd, pos, buf, ENDLEN);\n            pos += ENDLEN;\n            over(fd, pos, zip.etxt, zip.elen);\n            pos += zip.elen;\n        }\n\n        // Truncate the ZIP file to end at the end.\n        try {\n            fd.setLength(pos);\n        } catch (IOException e) {\n            bail(&quot;truncate error: %s&quot;, e.getMessage());\n        }\n    }\n\n    public static void main(String[] args) {\n        if (args.length == 0) {\n            System.out.println(\n                &quot;Usage: ziprub archive.zip a.txt b.txt\\n&quot; +\n                &quot;       to rub out a.txt and b.txt from the archive&quot;);\n            return;\n        }\n\n        // Open ZIP file.\n        RandomAccessFile fd;\n        try {\n            fd = new RandomAccessFile(args[0], &quot;rw&quot;);\n        } catch (IOException e) {\n            bail(&quot;could not open %s: %s&quot;, args[0], e.getMessage());\n            return;\n        }\n\n        // Look for the central directory.\n        zip_t zip = new zip_t();\n        int ret = find_central(fd, zip);\n        if (ret == -1)\n            bail(&quot;%s is not a valid and regular ZIP file&quot;, args[0]);\n\n        // Load the central directory.\n        long len = zip.clen;\n        if (len != (int)len)\n            bail(&quot;central directory too large for Java!&quot;);\n        byte[] cent = new byte[(int)len];\n        grab(fd, zip.cbeg, cent, (int)len);\n        if (check_central(cent, len, zip.cnum) != 0)\n            bail(&quot;invalid central directory&quot;);\n\n        // Make a list of rub entry name lengths and local header info. Their\n        // indices correspond to the argv[] indices.\n        int[] lens = new int[args.length];\n        local_t[] locs = new local_t[args.length];\n        for (int i = 1; i &lt; args.length; i++)\n            lens[i] = args[i].length();\n\n        // Step through the central directory, looking for the names on the\n        // command line that follow the ZIP file name. Rub out those that\n        // match.\n        int next = 0;\n        long left = zip.cnum;\n        int mod = 0;                    // True if central directory modified\n        while (left != 0) {\n            local_t loc = new local_t();\n            if (get_local(fd, cent, next, loc) == -1)\n                bail(&quot;invalid ZIP structure&quot;);\n            if (loc.off + loc.len &gt; zip.cbeg)\n                bail(&quot;irregular ZIP file: local entries after directory&quot;);\n            int nlen = get2(cent, next + 28);\n            int skip = CENLEN + nlen + get2(cent, next + 30) +\n                       get2(cent, next + 32);\n            int i;\n            for (i = 1; i &lt; args.length; i++)\n                if (nlen == lens[i] &amp;&amp;\n                    new String(cent, next + CENLEN, nlen).equals(args[i]))\n                    break;\n            if (i &lt; args.length) {\n                // Delete this central directory header.\n                System.arraycopy(cent, next + skip, cent, next,\n                                 (int)(zip.clen - next - skip));\n                zip.clen -= skip;\n                zip.cnum--;\n                lens[i] = -1;\n                locs[i] = loc;\n                mod = 1;\n            }\n            else\n                // Go to the next one.\n                next += skip;\n            left--;\n        }\n\n        // Note the command line names that were not found.\n        for (int i = 1; i &lt; args.length; i++)\n            if (lens[i] != -1)\n                System.err.printf(&quot;!! %s not found in ZIP file\\n&quot;, args[i]);\n\n        if (mod != 0) {\n            // Entries were deleted from the central directory. Only now do we\n            // have courage to muck with the ZIP file, once everything is\n            // worked out.\n\n            // Overwrite the deleted local entries with dummy entries that have\n            // zero-length file names.\n            for (int i = 1; i &lt; args.length; i++)\n                if (lens[i] == -1)\n                    dummy(fd, locs[i]);\n\n            // Overwrite the old central directory and end records with the new\n            // ones, truncating the ZIP file.\n            tail(fd, zip, cent);\n        }\n\n        // Clean up.\n        try {\n            fd.close();\n        } catch (IOException e) {\n            // Ignore close errors\n        }\n    }\n}\n</code></pre>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1136690,
      "reputation" : 115257,
      "user_id" : 1180620,
      "user_type" : "registered",
      "accept_rate" : 83,
      "profile_image" : "https://i.sstatic.net/FXaAg.jpg?s=256",
      "display_name" : "Mark Adler",
      "link" : "https://stackoverflow.com/users/1180620/mark-adler"
    },
    "creation_date" : 1759167816,
    "last_activity_date" : 1764115711,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79774638,
    "question_id" : 79774609,
    "body" : "<p>You can't &quot;<strong>delete</strong>&quot; or &quot;<strong>modify</strong>&quot; an entry in the archive without creating a new one.</p>\n<p>The typical way to &quot;<strong>update</strong>&quot; a ZIP file in Java is to create a new, temporary ZIP file. You read the old ZIP file entry by entry, writing all the entries you want to keep to the new ZIP file. When you encounter the file you want to replace, you simply write the new version of that file to the new ZIP. Finally, you delete the original ZIP file and rename the new one to the original name.</p>\n<p>Even if you find any other alternative third-party tools which can do this, please avoid as it is technically highly risky.</p>\n",
    "score" : -4,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 38077386,
      "reputation" : 106,
      "user_id" : 28582581,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/1290181c8be3c97ffa01c4ac59488c65?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Vamsi Krishna",
      "link" : "https://stackoverflow.com/users/28582581/vamsi-krishna"
    },
    "creation_date" : 1758793044,
    "last_activity_date" : 1764110944,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140870642,
    "post_id" : 79774609,
    "body" : "Could we consider executing your OS shell commands from java on scope with this question? In this case a procces call to a shell script executing an archive utility can help you...",
    "score" : 0,
    "owner" : {
      "account_id" : 26528740,
      "reputation" : 418,
      "user_id" : 20161294,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/de4778f08759124977cde77c784e6c6e?s=256&d=identicon&r=PG",
      "display_name" : "v-g",
      "link" : "https://stackoverflow.com/users/20161294/v-g"
    },
    "creation_date" : 1764004214,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140763976,
    "post_id" : 79774609,
    "body" : "@gidds True, but the target platform uses Zips.",
    "score" : 1,
    "owner" : {
      "account_id" : 888714,
      "reputation" : 36697,
      "user_id" : 927493,
      "user_type" : "registered",
      "accept_rate" : 61,
      "profile_image" : "https://i.sstatic.net/sxsnm.png?s=256",
      "display_name" : "JF Meier",
      "link" : "https://stackoverflow.com/users/927493/jf-meier"
    },
    "creation_date" : 1758995728,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140763500,
    "post_id" : 79774609,
    "body" : "Frame challenge: If you need to replace files very quickly, is zip really the most suitable storage format?  (For example, might it be more efficient to store the files ‘loose’ in a directory, and then zip them up at some later point?)",
    "score" : 6,
    "owner" : {
      "account_id" : 13722742,
      "reputation" : 18887,
      "user_id" : 10134209,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/XvJ8z.png?s=256",
      "display_name" : "gidds",
      "link" : "https://stackoverflow.com/users/10134209/gidds"
    },
    "creation_date" : 1758972435,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140763154,
    "post_id" : 79774609,
    "body" : "the zip.exe in windows can do that, is using that inside java ok?",
    "score" : 0,
    "owner" : {
      "account_id" : 20265612,
      "reputation" : 3266,
      "user_id" : 14862885,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a-/AOh14GiHATBadJfcEZOkIUeJHPL9YjXgXuNHrgcPBFwN=k-s256",
      "display_name" : "redoc",
      "link" : "https://stackoverflow.com/users/14862885/redoc"
    },
    "creation_date" : 1758951540,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140758930,
    "post_id" : 79774609,
    "body" : "<a href=\"https://stackoverflow.com/q/2223434/5133585\">Related</a>.",
    "score" : 2,
    "owner" : {
      "account_id" : 6651855,
      "reputation" : 291845,
      "user_id" : 5133585,
      "user_type" : "registered",
      "accept_rate" : 96,
      "profile_image" : "https://i.sstatic.net/dfqcw.png?s=256",
      "display_name" : "Sweeper",
      "link" : "https://stackoverflow.com/users/5133585/sweeper"
    },
    "creation_date" : 1758792945,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79774914" : [ {
      "comment_id" : 140765445,
      "post_id" : 79774914,
      "body" : "&quot;and in the order of the CDS&quot; There is nothing in the ISO/IEC standard or the PKWare appnote that says that the local entries have to be in the same order as the corresponding central directory headers. Only that there be same number of entries as headers. Also &quot;NONE&quot; is not a compression method. It&#39;s called &quot;stored&quot; in the appnote and the standard.",
      "score" : 0,
      "owner" : {
        "account_id" : 1136690,
        "reputation" : 115257,
        "user_id" : 1180620,
        "user_type" : "registered",
        "accept_rate" : 83,
        "profile_image" : "https://i.sstatic.net/FXaAg.jpg?s=256",
        "display_name" : "Mark Adler",
        "link" : "https://stackoverflow.com/users/1180620/mark-adler"
      },
      "creation_date" : 1759095449,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140764508,
      "post_id" : 79774914,
      "body" : "@PeterCordes Re: hashing: many modern filesystems do checksum / CRC file data at a block level, e.g. BTRFS and ZFS.  A small unaligned write in the middle of a block will force the OS to load the block anyway, since hardware I/O (including write) usually works at the block level.  (Although sometimes with a 512-byte sector size smaller than the FS block size of typically 4KiB, but the block size is still trivially small compared to the OP&#39;s 10GB zip.)  When writing back dirty data to the file, the OS will CRC only the affected blocks and update the metadata.  This is still fast.",
      "score" : 0,
      "owner" : {
        "account_id" : 78868,
        "reputation" : 376987,
        "user_id" : 224132,
        "user_type" : "registered",
        "accept_rate" : 83,
        "profile_image" : "https://i.sstatic.net/N4ivW.png?s=256",
        "display_name" : "Peter Cordes",
        "link" : "https://stackoverflow.com/users/224132/peter-cordes"
      },
      "creation_date" : 1759041164,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140764499,
      "post_id" : 79774914,
      "body" : "@PeterCordes It&#39;s also overly pessimistic about basic I/O operations like overwriting a block in place to turn the existing entry into a dummy.  That&#39;s efficient on most systems. Ones which do block de-duplication might have to copy-on-write that block if it was deduplicated, otherwise not. Or worst-case an FS doing whole-file deduplication might need to copy the whole file, but manually making a new zip always forces that worst case even on systems where you could have been efficient, for the small upside of a clean zip every time. You can occasionally rewrite to compact with the other strat.",
      "score" : 0,
      "owner" : {
        "account_id" : 78868,
        "reputation" : 376987,
        "user_id" : 224132,
        "user_type" : "registered",
        "accept_rate" : 83,
        "profile_image" : "https://i.sstatic.net/N4ivW.png?s=256",
        "display_name" : "Peter Cordes",
        "link" : "https://stackoverflow.com/users/224132/peter-cordes"
      },
      "creation_date" : 1759040638,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140764497,
      "post_id" : 79774914,
      "body" : "This answer is way too pessimistic, although it has some useful technical info about ZIP file structure.  The OP acknowledges that &quot;commenting out&quot; the original entry and appending a new one will leave garbage in the file.  That&#39;s fine for many use-cases, e.g. testing a program that reads everything from a zip, where you&#39;re modifying the zip file once for every time it&#39;s read. Cheap modifications that make a slightly-inefficient zip file are vastly preferable for such cases.  Mark Adler suggested making the filename 0-length to null out the old entry, or any same-length pathname would work.",
      "score" : 0,
      "owner" : {
        "account_id" : 78868,
        "reputation" : 376987,
        "user_id" : 224132,
        "user_type" : "registered",
        "accept_rate" : 83,
        "profile_image" : "https://i.sstatic.net/N4ivW.png?s=256",
        "display_name" : "Peter Cordes",
        "link" : "https://stackoverflow.com/users/224132/peter-cordes"
      },
      "creation_date" : 1759040196,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140764484,
      "post_id" : 79774914,
      "body" : "@9072997 BTRFS and others (including modern XFS and ext4 I think) which also support <code>FICLONE</code> (<code>cp --reflink=always</code>) can do <code>FALLOC_FL_INSERT_RANGE</code> on a clone of the original file, and then atomically replace the original.  So yeah, these seems 100% viable if you have access to modern Linux&#39;s file I/O operations on a typical filesystem.",
      "score" : 0,
      "owner" : {
        "account_id" : 78868,
        "reputation" : 376987,
        "user_id" : 224132,
        "user_type" : "registered",
        "accept_rate" : 83,
        "profile_image" : "https://i.sstatic.net/N4ivW.png?s=256",
        "display_name" : "Peter Cordes",
        "link" : "https://stackoverflow.com/users/224132/peter-cordes"
      },
      "creation_date" : 1759039253,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140764482,
      "post_id" : 79774914,
      "body" : "@9072997 BTRFS also supports those fallocate operations, and probably most of the other modern Linux filesystems.  So opening up a hole that&#39;s a multiple of 4K, at a 4K alignment boundary, can be done efficiently. (Or whatever fs block size if not 4K.)  If your desired insert point was in the middle of a block, you can just copy bytes into the newly-created hole to restore the tail of the previous file.  You&#39;ll typically have some spare space to fill up, since you can only insert multiples of 4K; Mark Adler suggested a dummy entry with a 0-length filename.  (Insert 1 more block if too few spar",
      "score" : 0,
      "owner" : {
        "account_id" : 78868,
        "reputation" : 376987,
        "user_id" : 224132,
        "user_type" : "registered",
        "accept_rate" : 83,
        "profile_image" : "https://i.sstatic.net/N4ivW.png?s=256",
        "display_name" : "Peter Cordes",
        "link" : "https://stackoverflow.com/users/224132/peter-cordes"
      },
      "creation_date" : 1759038998,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140762854,
      "post_id" : 79774914,
      "body" : "@9072997 I did oversimplify a bit there. As far as I know, it&#39;s a monumentally convoluted task to attempt to use this feature from java. The file API (old nor <code>java.nio.file</code> new) doesn&#39;t offer a way to invoke the COLLAPSE/INSERT primitives, nor to figure out where the block boundaries might be. In contrast, the file API explicitly does allow overwrite and will use fast overwrite unless the underlying file system just cannot do that. The one thing it lacks is a way to say: Give me fast overwrite, and if you can&#39;t, throw. Which it <i>does</i> offer for e.g. atomic move.",
      "score" : 1,
      "owner" : {
        "account_id" : 401843,
        "reputation" : 107136,
        "user_id" : 768644,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
        "display_name" : "rzwitserloot",
        "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
      },
      "creation_date" : 1758922737,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140762500,
      "post_id" : 79774914,
      "body" : "&quot;File systems can still offer it ... But they don&#39;t. &quot; Some do, namely ext4 and xfs on Linux via <code>FALLOC_FL_COLLAPSE_RANGE</code> and <code>FALLOC_FL_INSERT_RANGE</code>. The ranges have to be block-aligned though. You are basically creating a fragmented file the same way the filesystem would if you asked to create a 10G file on a drive without 10G of contiguous free space. The block-aligned thing means you still have to plan to wind up with <i>some</i> garbage, most of the time. Also, while I see your point that overwriting <i>can</i> be slow, it usually isn&#39;t. Most filesystems were designed with random writes in mind.",
      "score" : 3,
      "owner" : {
        "account_id" : 6741155,
        "reputation" : 1024,
        "user_id" : 5194374,
        "user_type" : "registered",
        "profile_image" : "https://lh3.googleusercontent.com/-6mzNXXS2zp8/AAAAAAAAAAI/AAAAAAAAAQ8/bY_hOWNO23I/s256-rj/photo.jpg",
        "display_name" : "9072997",
        "link" : "https://stackoverflow.com/users/5194374/9072997"
      },
      "creation_date" : 1758908865,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140762473,
      "post_id" : 79774914,
      "body" : "The local header is followed by garbage data in this case. You can safely re-write the whole local header to make it longer and eat into the garbage file. You would just need to take care to adjust the rest of the header to refer to an uncompressed file with the length of the remaining garbage.",
      "score" : 1,
      "owner" : {
        "account_id" : 6741155,
        "reputation" : 1024,
        "user_id" : 5194374,
        "user_type" : "registered",
        "profile_image" : "https://lh3.googleusercontent.com/-6mzNXXS2zp8/AAAAAAAAAAI/AAAAAAAAAQ8/bY_hOWNO23I/s256-rj/photo.jpg",
        "display_name" : "9072997",
        "link" : "https://stackoverflow.com/users/5194374/9072997"
      },
      "creation_date" : 1758908123,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140762093,
      "post_id" : 79774914,
      "body" : "Excellent explanation. I want to point out that for features like arbitrarily adding and removing files from an archive, as well as atomic operations, these are motivations behind the SQLite Archive format in contrast to ZIP: <a href=\"https://www.sqlite.org/sqlar.html#advantages_of_sqlite_archives\" rel=\"nofollow noreferrer\">sqlite.org/sqlar.html#advantages_of_sqlite_archives</a>",
      "score" : 0,
      "owner" : {
        "account_id" : 446566,
        "reputation" : 18759,
        "user_id" : 839689,
        "user_type" : "registered",
        "accept_rate" : 71,
        "profile_image" : "https://www.gravatar.com/avatar/eed3ee2db841be15bdb120f3ff38f02e?s=256&d=identicon&r=PG",
        "display_name" : "Nayuki",
        "link" : "https://stackoverflow.com/users/839689/nayuki"
      },
      "creation_date" : 1758898696,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140762059,
      "post_id" : 79774914,
      "body" : "@JFMeier You can&#39;t rewrite the CDS. If you do that, most zip tools will work exactly as you want them to, but front-to-back readers will not. Your CDS will not match the hypothetical CDS you&#39;d construct if you read it front-to-back, and thus your zip would not be ISO/IEC valid. You need to update the CDS <i>and</i> update the zipentry&#39;s own header in tandem, and this means the new header needs to be the same size as the old header, which is not possible unless the new name is exactly the same length as the old name. Or you eat into some convenient irrelevant extra field.",
      "score" : 1,
      "owner" : {
        "account_id" : 401843,
        "reputation" : 107136,
        "user_id" : 768644,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
        "display_name" : "rzwitserloot",
        "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
      },
      "creation_date" : 1758897822,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140762056,
      "post_id" : 79774914,
      "body" : "The extra fields come immediately after the filename entry, hence, when making the <i>original</i> zip you could add a bit of extra space there; enough room so you can overwrite the name from <code>a.txt</code> to <code>garbage&#47;a.txt</code>, &#39;eating&#39; into the overflow space. But you&#39;d have to do that when making the original, you can&#39;t do it retroactively. And you&#39;d need to write your own zip tool, as I&#39;m not aware of any libraries that can do this. You&#39;d end up with an ISO/IEC zip you can &#39;fix&#39; so it remains an ISO/IEC zip, and still do it quickly.",
      "score" : 0,
      "owner" : {
        "account_id" : 401843,
        "reputation" : 107136,
        "user_id" : 768644,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
        "display_name" : "rzwitserloot",
        "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
      },
      "creation_date" : 1758897701,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140762050,
      "post_id" : 79774914,
      "body" : "@JFMeier <i>Can I move the unwanted file (which is in the zip) to a different directory?</i> - If the new complete file name (i.e <code>subDir1&#47;subDir2&#47;filename.txt</code>) is exactly the same length as the old name, it is possible, but you&#39;d have to write your own zip file format tool to do it. The name of an entry in zip terms is stored as a 2-byte &#39;length&#39; value + that many bytes, hence, the requirement: new path name must be equal. You can&#39;t rename <code>a.txt</code> to <code>garbage&#47;a.txt</code>, but you can rename <code>a.txt</code> to <code>z.txt</code>. What yo can also do is add a NOOP extra field when making the zip to give you some space.",
      "score" : 1,
      "owner" : {
        "account_id" : 401843,
        "reputation" : 107136,
        "user_id" : 768644,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
        "display_name" : "rzwitserloot",
        "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
      },
      "creation_date" : 1758897609,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140762022,
      "post_id" : 79774914,
      "body" : "&quot;<i>they need to rehash the entire block/file/whatever granularity the hashing system operates on.</i>&quot; - <a href=\"https://en.wikipedia.org/wiki/Rolling_hash\" rel=\"nofollow noreferrer\">rolling hashes</a> exist",
      "score" : 1,
      "owner" : {
        "account_id" : 1042959,
        "reputation" : 670688,
        "user_id" : 1048572,
        "user_type" : "registered",
        "accept_rate" : 77,
        "profile_image" : "https://www.gravatar.com/avatar/7f2c4de95e8f4f8f5a71c3aaf0ed312a?s=256&d=identicon&r=PG",
        "display_name" : "Bergi",
        "link" : "https://stackoverflow.com/users/1048572/bergi"
      },
      "creation_date" : 1758897135,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140761228,
      "post_id" : 79774914,
      "body" : "@JFMeier My mistake of my previous comment. To add a new directory, you need a segment [header, data] the data is empty. However the header need to be added in between according to the zip standard. Then you need to update the CDS. The main problem is you cannot add the segment in between as the answer explained.",
      "score" : 0,
      "owner" : {
        "account_id" : 19205353,
        "reputation" : 6087,
        "user_id" : 14032355,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/d05b6475e74a8923bbfd69423915b4e8?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "ikhvjs",
        "link" : "https://stackoverflow.com/users/14032355/ikhvjs"
      },
      "creation_date" : 1758872890,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79778405" : [ {
      "comment_id" : 140773951,
      "post_id" : 79778405,
      "body" : "@JFMeier Oddly, I consider this sort of thing to be fun.",
      "score" : 0,
      "owner" : {
        "account_id" : 1136690,
        "reputation" : 115257,
        "user_id" : 1180620,
        "user_type" : "registered",
        "accept_rate" : 83,
        "profile_image" : "https://i.sstatic.net/FXaAg.jpg?s=256",
        "display_name" : "Mark Adler",
        "link" : "https://stackoverflow.com/users/1180620/mark-adler"
      },
      "creation_date" : 1759428250,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140769759,
      "post_id" : 79778405,
      "body" : "There are two places where, in theory, the code could need Java arrays with more than 2^31-1 elements. It seems implausible that either of those would be encounted in a real zip file. E.g. a central directory with over ten million entries. In any case, I updated the code in the answer to check for those, and exit with a failure if it runs into such a zip file.",
      "score" : 0,
      "owner" : {
        "account_id" : 1136690,
        "reputation" : 115257,
        "user_id" : 1180620,
        "user_type" : "registered",
        "accept_rate" : 83,
        "profile_image" : "https://i.sstatic.net/FXaAg.jpg?s=256",
        "display_name" : "Mark Adler",
        "link" : "https://stackoverflow.com/users/1180620/mark-adler"
      },
      "creation_date" : 1759264132,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140768437,
      "post_id" : 79778405,
      "body" : "You could write yourself a LongList class which offers an interface for long indexed lists, internally using a more complicated data structure. Generally, standard arrays in Java feel a bit strange and are only used if performance is critical.",
      "score" : 0,
      "owner" : {
        "account_id" : 888714,
        "reputation" : 36697,
        "user_id" : 927493,
        "user_type" : "registered",
        "accept_rate" : 61,
        "profile_image" : "https://i.sstatic.net/sxsnm.png?s=256",
        "display_name" : "JF Meier",
        "link" : "https://stackoverflow.com/users/927493/jf-meier"
      },
      "creation_date" : 1759225586,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140768426,
      "post_id" : 79778405,
      "body" : "Thank you, I&#39;ll give it a try. I really appreciate how much effort you have put into this. But give me some time to understand it, this is completely unidiomatic Java ...",
      "score" : 0,
      "owner" : {
        "account_id" : 888714,
        "reputation" : 36697,
        "user_id" : 927493,
        "user_type" : "registered",
        "accept_rate" : 61,
        "profile_image" : "https://i.sstatic.net/sxsnm.png?s=256",
        "display_name" : "JF Meier",
        "link" : "https://stackoverflow.com/users/927493/jf-meier"
      },
      "creation_date" : 1759225188,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140768370,
      "post_id" : 79778405,
      "body" : "I went to go fix something else that I noticed, but found that I could not. Java arrays cannot have 2^31 or more elements! Is that really true? That means there there are things that simply cannot be done in Java. At least not without a lot of shenanigans involving multiple arrays.",
      "score" : 0,
      "owner" : {
        "account_id" : 1136690,
        "reputation" : 115257,
        "user_id" : 1180620,
        "user_type" : "registered",
        "accept_rate" : 83,
        "profile_image" : "https://i.sstatic.net/FXaAg.jpg?s=256",
        "display_name" : "Mark Adler",
        "link" : "https://stackoverflow.com/users/1180620/mark-adler"
      },
      "creation_date" : 1759223943,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79775084" : [ {
      "comment_id" : 140765347,
      "post_id" : 79775084,
      "body" : "I was thinking of a case where STORE was used for speed (with ZIP just used like TAR for collecting files, not necessarily compressing) and/or because the data wasn&#39;t very compressible, like JPEG which even if optimized (but still using Huffman) can still shrink by a couple percent, or MP4 / h264+aac which can sometimes shrink by fractions of a percent.  But yes, good point about another common reason for STORE over DEFLATE; could well be nothing to gain.  Still could be worth attempting if you want to write high-effort code to try to do an optimal job at the OP&#39;s task.",
      "score" : 0,
      "owner" : {
        "account_id" : 78868,
        "reputation" : 376987,
        "user_id" : 224132,
        "user_type" : "registered",
        "accept_rate" : 83,
        "profile_image" : "https://i.sstatic.net/N4ivW.png?s=256",
        "display_name" : "Peter Cordes",
        "link" : "https://stackoverflow.com/users/224132/peter-cordes"
      },
      "creation_date" : 1759088462,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140765324,
      "post_id" : 79775084,
      "body" : "@PeterCordes Changing from stored to deflated won&#39;t work in general. The reason an entry is stored in the first place is usually because it is not compressible. Converting it to deflate will expand it. As an example, if we have an incompressible stored entry followed by a zero-length entry that I want to delete, I only have 30 bytes of headroom for the expansion. Deflate&#39;s stored blocks add five bytes for every 65535 data bytes, so if the stored entry is more than about 384K, this won&#39;t work.",
      "score" : 0,
      "owner" : {
        "account_id" : 1136690,
        "reputation" : 115257,
        "user_id" : 1180620,
        "user_type" : "registered",
        "accept_rate" : 83,
        "profile_image" : "https://i.sstatic.net/FXaAg.jpg?s=256",
        "display_name" : "Mark Adler",
        "link" : "https://stackoverflow.com/users/1180620/mark-adler"
      },
      "creation_date" : 1759087005,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140765317,
      "post_id" : 79775084,
      "body" : "Cool! You could potentially change the previous entry from STORE to DEFLATE so its length becomes elastic, if it&#39;s not huge so can be done quickly.  (Or if you need to find a few more bytes to put in a slightly longer <code>a.txt</code> in-place instead of at the end.  Or even try recompressing the previous entry with <code>-9</code> compression if it was already compressed and you need to find just a few more bytes.)",
      "score" : 0,
      "owner" : {
        "account_id" : 78868,
        "reputation" : 376987,
        "user_id" : 224132,
        "user_type" : "registered",
        "accept_rate" : 83,
        "profile_image" : "https://i.sstatic.net/N4ivW.png?s=256",
        "display_name" : "Peter Cordes",
        "link" : "https://stackoverflow.com/users/224132/peter-cordes"
      },
      "creation_date" : 1759086626,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140765268,
      "post_id" : 79775084,
      "body" : "I had to click on the username to check, &quot;wait, is that <i>the</i> Mark Adler?&quot;",
      "score" : 0,
      "owner" : {
        "account_id" : 7306058,
        "reputation" : 720,
        "user_id" : 5725780,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/FKaUq.png?s=256",
        "display_name" : "pipe",
        "link" : "https://stackoverflow.com/users/5725780/pipe"
      },
      "creation_date" : 1759084065,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140765267,
      "post_id" : 79775084,
      "body" : "There is an added constraint on prepending, where it has to end on a byte boundary. As a result, not only can I not prepend one byte, but I also cannot prepend 1..4 or, interestingly, 8 bytes. Again, not a problem for this application, where there is always at least 30 bytes of prepend.",
      "score" : 1,
      "owner" : {
        "account_id" : 1136690,
        "reputation" : 115257,
        "user_id" : 1180620,
        "user_type" : "registered",
        "accept_rate" : 83,
        "profile_image" : "https://i.sstatic.net/FXaAg.jpg?s=256",
        "display_name" : "Mark Adler",
        "link" : "https://stackoverflow.com/users/1180620/mark-adler"
      },
      "creation_date" : 1759084028,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140765092,
      "post_id" : 79775084,
      "body" : "@PeterCordes As I consider the implementation, it would be easier to prepend empty blocks than append. The reason is that you need to decode the entire deflate stream in order to find the last-block bit to reset it and enable appending. You can prepend empty blocks without having to look at the deflate stream at all. So you would write over the entry to be deleted with the local header from the next entry followed by as many empty deflate blocks as needed to get to the start of the deflate stream in the next entry. Which works only if there is a next entry, and it&#39;s deflated.",
      "score" : 1,
      "owner" : {
        "account_id" : 1136690,
        "reputation" : 115257,
        "user_id" : 1180620,
        "user_type" : "registered",
        "accept_rate" : 83,
        "profile_image" : "https://i.sstatic.net/FXaAg.jpg?s=256",
        "display_name" : "Mark Adler",
        "link" : "https://stackoverflow.com/users/1180620/mark-adler"
      },
      "creation_date" : 1759077325,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140765040,
      "post_id" : 79775084,
      "body" : "@PeterCordes Yes. Though the previous entry might not be deflated. Or this might be the first entry. (Maybe extend on the front side?) The way to increase the size of a deflate stream is to add empty fixed blocks (10 bits) and empty stored blocks (3 bits + fill bits to next byte + four bytes). You can add as many of those as you like, where you can reliably get to any number of bytes added greater than one. Reliably adding just one byte to a deflate stream is more problematic, but that is not needed in this application where you&#39;d be covering over at least a 30-byte local header.",
      "score" : 1,
      "owner" : {
        "account_id" : 1136690,
        "reputation" : 115257,
        "user_id" : 1180620,
        "user_type" : "registered",
        "accept_rate" : 83,
        "profile_image" : "https://i.sstatic.net/FXaAg.jpg?s=256",
        "display_name" : "Mark Adler",
        "link" : "https://stackoverflow.com/users/1180620/mark-adler"
      },
      "creation_date" : 1759075048,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140764519,
      "post_id" : 79775084,
      "body" : "Is it possible to make a DEFLATE stream longer without changing the &quot;plaintext&quot; (is there a better term for that)?  i.e. intentionally compress worse.  Well obviously yes, but I mean in some easily controllable way to hit a certain target compressed size.  If so, we could expand the previous file&#39;s compressed data to fill up the hole that previously contained <code>a.txt</code>, especially if it was already compressed and there was a way to just expand the tail of its DEFLATE stream.",
      "score" : 0,
      "owner" : {
        "account_id" : 78868,
        "reputation" : 376987,
        "user_id" : 224132,
        "user_type" : "registered",
        "accept_rate" : 83,
        "profile_image" : "https://i.sstatic.net/N4ivW.png?s=256",
        "display_name" : "Peter Cordes",
        "link" : "https://stackoverflow.com/users/224132/peter-cordes"
      },
      "creation_date" : 1759041478,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79776590" : [ {
      "comment_id" : 140767279,
      "post_id" : 79776590,
      "body" : "@TobySpeight I added a Java translation in another answer here.",
      "score" : 0,
      "owner" : {
        "account_id" : 1136690,
        "reputation" : 115257,
        "user_id" : 1180620,
        "user_type" : "registered",
        "accept_rate" : 83,
        "profile_image" : "https://i.sstatic.net/FXaAg.jpg?s=256",
        "display_name" : "Mark Adler",
        "link" : "https://stackoverflow.com/users/1180620/mark-adler"
      },
      "creation_date" : 1759171686,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140765873,
      "post_id" : 79776590,
      "body" : "Probably not the best approach in Java.",
      "score" : 0,
      "owner" : {
        "account_id" : 6229027,
        "reputation" : 32365,
        "user_id" : 4850040,
        "user_type" : "registered",
        "accept_rate" : 62,
        "profile_image" : "https://i.sstatic.net/acYd0.png?s=256",
        "display_name" : "Toby Speight",
        "link" : "https://stackoverflow.com/users/4850040/toby-speight"
      },
      "creation_date" : 1759130150,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}