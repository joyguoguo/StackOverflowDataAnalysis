{
  "question" : {
    "question_id" : 79751930,
    "title" : "What way is more efficient for narrowing down the type of a parameter?",
    "body" : "<p>I'm trying to create a class called <em>Complex</em> to do complex number arithmetic. It's abstract and has two subclasses <em>Cartesian</em> and <em>Polar</em> for different representations of complex numbers, and each of them has another two subclasses <em>Float</em> and <em>Double</em> to store values with different precision.</p>\n<p>Currently I'm trying to make a function <em>set</em> to set the value of a complex number to another of unknown type (it could be Cartesian or Polar, Float or Double).\nFor this I need to change the type of the parameter to Cartesian (<em>this</em> is type Cartesian.Float). I already have a function that does this:</p>\n<pre><code>public static Cartesian.Double toCartesian(Complex z) {\n    return (z instanceof Polar) ? (new Cartesian.Double(\n        Math.cos(z.getAngle()) * z.getModule(),\n        Math.sin(z.getAngle()) * z.getModule())) : ((Cartesian.Double) z);\n}\n</code></pre>\n<p>I have two versions but I don't know which is better/which I should use:</p>\n<pre><code>public void set(Complex z) {\n    Cartesian.Double z2 = toCartesian(z);\n    re = (float) z2.re;\n    im = (float) z2.im;\n}\n</code></pre>\n<p>and</p>\n<pre><code>public void set(Complex z) {\n    z = toCartesian(z);\n    re = (float) ((Cartesian.Double) z).re;\n    im = (float) ((Cartesian.Double) z).im;\n}\n</code></pre>\n",
    "tags" : [ "java", "performance" ],
    "owner" : {
      "account_id" : 32754010,
      "reputation" : 23,
      "user_id" : 25457439,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/f5PJndn6.jpg?s=256",
      "display_name" : "RedstoneGG4",
      "link" : "https://stackoverflow.com/users/25457439/redstonegg4"
    },
    "is_answered" : true,
    "view_count" : 130,
    "answer_count" : 1,
    "score" : 1,
    "last_activity_date" : 1756822053,
    "creation_date" : 1756662841,
    "link" : "https://stackoverflow.com/questions/79751930/what-way-is-more-efficient-for-narrowing-down-the-type-of-a-parameter",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79753585,
    "question_id" : 79751930,
    "body" : "<p>Let's focus on these two methods:</p>\n<pre><code>public void set(Complex z) {\n    Cartesian.Double z2 = toCartesian(z);\n    re = (float) z2.re;\n    im = (float) z2.im;\n}\n</code></pre>\n<pre><code>public void set(Complex z) {\n    z = toCartesian(z);\n    re = (float) ((Cartesian.Double) z).re;\n    im = (float) ((Cartesian.Double) z).im;\n}\n</code></pre>\n<p>The only difference between them is the introduction of a local variable vs. reusing the existing variable. There is no relevant difference between them in terms of either speed of memory, and that's a fully general point: you'll never ruin any performance metric of your code by introducing local variables. These are just names for some values, and the JVM optimizer completely rearranges that before it gets to machine code.</p>\n<p>You should instead focus on code readability, preferring the first version.</p>\n<p>To put any concerns to rest, here's the benchmarking code I used. I have both versions of your code, one is commented out. Note that I'm only exercising the case where the object supplied to <code>set</code> is <code>Cartesian.Double</code>, because that's the only path where the performance of <code>set</code> itself would matter. Otherwise the floating-point operations in <code>toCartesian</code> would dominate.</p>\n<p>Both versions give me around 13.9 milliseconds runtime.</p>\n<pre><code>public class Test {\n\n    public static void main(String[] args) {\n\n        long start = System.nanoTime();\n        benchmarkRun();\n        long elapsed = System.nanoTime() - start;\n        System.out.println(elapsed / 1e6 + &quot; ms&quot;);\n    }\n\n    private static void benchmarkRun() {\n        Cartesian.Double cd = new Cartesian.Double(1, 2);\n        Cartesian.Float cf = new Cartesian.Float(0, 0);\n        for (int i = 0; i &lt; 10_000_000; i++) {\n            cf.set(cd);\n            cd.re += 1.0;\n            cd.im += 0.1;\n        }\n    }\n\n    static abstract class Complex {\n        public static Cartesian.Double toCartesian(Complex z) {\n            return (z instanceof Polar) ? (new Cartesian.Double(\n                    Math.cos(z.getAngle()) * z.getModule(),\n                    Math.sin(z.getAngle()) * z.getModule())) : ((Cartesian.Double) z);\n        }\n\n        public double getModule() {\n            return 0;\n        }\n\n        public double getAngle() {\n            return 0;\n        }\n    }\n\n    static class Cartesian extends Complex {\n        static class Double extends Cartesian {\n            public double re;\n            public double im;\n\n            public Double(double re, double im) {\n                this.re = re;\n                this.im = im;\n            }\n        }\n        static class Float extends Cartesian {\n            public float re;\n            public float im;\n\n            public Float(float re, float im) {\n                this.re = re;\n                this.im = im;\n            }\n\n            public void set(Complex z) {\n//                Cartesian.Double z2 = toCartesian(z);\n//                re = (float) z2.re;\n//                im = (float) z2.im;\n                z = toCartesian(z);\n                re = (float) ((Cartesian.Double) z).re;\n                im = (float) ((Cartesian.Double) z).im;\n            }\n        }\n    }\n\n    static class Polar extends Complex {\n        static class Double extends Polar {\n            public double angle;\n            public double module;\n\n            public Double(double angle, double module) {\n                this.angle = angle;\n                this.module = module;\n            }\n        }\n        static class Float extends Polar {\n            public float angle;\n            public float module;\n\n            public Float(float angle, float module) {\n                this.angle = angle;\n                this.module = module;\n            }\n        }\n    }\n}\n</code></pre>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 4760688,
      "reputation" : 1921,
      "user_id" : 3848148,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/CTCkZ.png?s=256",
      "display_name" : "William F. Jameson",
      "link" : "https://stackoverflow.com/users/3848148/william-f-jameson"
    },
    "creation_date" : 1756822053,
    "last_activity_date" : 1756822053,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140705816,
    "post_id" : 79751930,
    "body" : "So you <i>do</i> want the <code>float</code> version even if only &#39;because Point2D&#39; has it, but if you actually use them, basic use of your API causes undocumented and unexpected <code>ClassCastException</code> errors. I&#39;m not sure you quite thought this one through. If you have no personal interest in it, ditch it. Point2D&#39;s excuse is that in the distant past there was some slight utility to floats (&#39;distant past&#39; = 32 bit chips, though I&#39;m oversimplifying a bit).",
    "score" : 0,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107206,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1756683724,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140705630,
    "post_id" : 79751930,
    "body" : "@rzwitserloot I understand, I knew that adding a float version might be pointless and indeed I don&#39;t see myself using it. The reason I added it is in part because I didn&#39;t have a reason not to, but mostly because <i>Point2D</i> has a float and double version and 2D points are isomorphic to complex numbers. Also, the reason why <i>toCartesian()</i> returns <i>Cartesian.Double</i> is because of what you said, no one is going to use the float version (ignoring the fact that this is a hobby and I&#39;m the only one working on it) and even if it&#39;s used, you can use the set function to turn it to <i>Cartesian.Float</i>.",
    "score" : 0,
    "owner" : {
      "account_id" : 32754010,
      "reputation" : 23,
      "user_id" : 25457439,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/f5PJndn6.jpg?s=256",
      "display_name" : "RedstoneGG4",
      "link" : "https://stackoverflow.com/users/25457439/redstonegg4"
    },
    "creation_date" : 1756673169,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140705544,
    "post_id" : 79751930,
    "body" : "Your first snippet (<code>toCartesian</code>) says: &quot;If I am polar, then, I am a Caretesian.Double&quot;. This does not match your preamble which says you have a float version of this too. Given that your hierarchy is unclear, I don&#39;t think your question is currently meaningfully answerable. For what its worth, <code>float</code> is pointless and you should not have these. They are <i>slower</i> and <i>worse</i> than double in every way. The only reason to have them is if you are going to have massive amounts of these coordinates and you want to save on RAM, or you need exact IEEE float behaviour.",
    "score" : 0,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107206,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1756667717,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140705525,
    "post_id" : 79751930,
    "body" : "@XavierPedraza Thank you, it was mostly curiosity and wanting to know what others think of it. I&#39;m aware of the dangers, still apreciated.",
    "score" : 0,
    "owner" : {
      "account_id" : 32754010,
      "reputation" : 23,
      "user_id" : 25457439,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/f5PJndn6.jpg?s=256",
      "display_name" : "RedstoneGG4",
      "link" : "https://stackoverflow.com/users/25457439/redstonegg4"
    },
    "creation_date" : 1756666496,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140705460,
    "post_id" : 79751930,
    "body" : "The only meaningful difference is the 1st line as those casts don&#39;t produce any new bytecode. So the 1st approach pushes a variable to a JVM register while the other does not. I&#39;m not sure if such a tiny difference can even be measured. That being said, most would find the 1st approach to be better as it is easier to read and does not obscure intent. Be wary of <a href=\"https://en.wikipedia.org/wiki/Program_optimization#When_to_optimize\" rel=\"nofollow noreferrer\">premature optimization</a>.",
    "score" : 2,
    "owner" : {
      "account_id" : 14914414,
      "reputation" : 1185,
      "user_id" : 10808904,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/Ts8fIsJj.png?s=256",
      "display_name" : "Xavier Pedraza",
      "link" : "https://stackoverflow.com/users/10808904/xavier-pedraza"
    },
    "creation_date" : 1756663388,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140705458,
    "post_id" : 79751930,
    "body" : "More efficient in what sense? Speed? Then benchmark it. I would use the first version for clarity but that&#39;s an opinion.",
    "score" : 3,
    "owner" : {
      "account_id" : 372682,
      "reputation" : 26512,
      "user_id" : 721855,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/vZiox.png?s=256",
      "display_name" : "aled",
      "link" : "https://stackoverflow.com/users/721855/aled"
    },
    "creation_date" : 1756663287,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}