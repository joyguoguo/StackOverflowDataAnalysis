{
  "question" : {
    "question_id" : 79597746,
    "title" : "How to improve architecture of a Transfer Monitoring Service using Observer pattern in Spring Boot?",
    "body" : "<p>I'm developing a system for monitoring money transfers.</p>\n<p>The idea is to dynamically build SQL queries based on different criteria using the <code>Observer</code> pattern.</p>\n<p>Once the matching transfers are found, they are sent asynchronously to an external service (<code>Markaz</code>).</p>\n<p>In the future, more and more criteria will be added, and for each new criteria,\na new <code>Observer</code> class will be created to encapsulate its logic independently.</p>\n<p>This is intended to make the system easily extensible without modifying the core monitoring service.</p>\n<p><strong>Architecture overview:</strong></p>\n<ul>\n<li><code>TransferMonitoringService</code>: main service that builds WHERE conditions from observers and monitors transfers.</li>\n<li><code>TransferObserver</code>: interface for defining dynamic conditions.</li>\n<li><code>FatfCountryObserver</code>: an example implementation (monitoring transfers to FATF-listed countries).</li>\n<li><code>MarkService</code>: sends selected transfers asynchronously using <code>@Async</code>.</li>\n<li><code>TdiController</code>: allows manual sending of a single transfer by its ID.</li>\n</ul>\n<p><strong>The system uses:</strong></p>\n<ul>\n<li>Spring Boot 3</li>\n<li>Spring Scheduling (<code>@Scheduled</code>)</li>\n<li>Spring Async (@Async +\n<code>ThreadPoolTaskExecutor</code>)</li>\n<li>Oracle Database (<code>JdbcTemplate</code>)</li>\n<li>DTOs\n(<code>TransferDto</code>, <code>ClientDto</code>, <code>MarkRequestDto</code>)</li>\n<li>Repositories\n(<code>TransferRepository</code>, <code>ClientRepository</code>) are implemented via standard\n<code>JdbcTemplate</code>, but I did not include them here to keep the example\nshort.</li>\n</ul>\n<p>If needed, I can share the full code via GitHub Gist or\nsimilar.</p>\n<p><strong>Key code snippets:</strong></p>\n<pre class=\"lang-java prettyprint-override\"><code>@Data\npublic class TransferDto {...}\n@Data\npublic class ClientDto{...}\n\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\n@JsonPropertyOrder({...})\npulic class MarkRequestDto{...}\n//------------------------------------\npublic interface TransferObserver {\n    String getSqlCondition();\n    List&lt;Object&gt; getSqlParameters();\n}\n\n//------------------------------------\n@Component\npublic class FatfCountryObserver implements TransferObserver {\n\n    private final JdbcTemplate jdbcTemplate;\n\n    @Autowired\n    public FatfCountryObserver(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    @Override\n    public String getSqlCondition() {\n        List&lt;String&gt; fatfCountries = getFatfCountries();\n        if (fatfCountries.isEmpty()) {\n            return null;\n        }\n        return &quot;destination_country IN (&quot; + fatfCountries.stream().map(c -&gt; &quot;?&quot;).collect(Collectors.joining(&quot;, &quot;)) + &quot;)&quot;;\n    }\n\n    @Override\n    public List&lt;Object&gt; getSqlParameters() {\n        return new ArrayList&lt;&gt;(getFatfCountries());\n    }\n\n    private List&lt;String&gt; getFatfCountries() {\n        String sql = &quot;SELECT kod FROM fatf_strn_list WHERE status = 1&quot;;\n        return jdbcTemplate.queryForList(sql, String.class);\n    }\n}\n//------------------------------------\n@Slf4j\n@Service\n@RequiredArgsConstructor\npublic class TransferMonitoringService {\n\n    private final List&lt;TransferObserver&gt; observers;\n    private final TransferRepository transferRepository;\n    private final ClientRepository clientRepository;\n    private final MarkService markazService;\n    private final MarkRequestBuilderService markRequestBuilderService;\n\n    public void monitorNewTransfers() {\n        List&lt;String&gt; whereParts = new ArrayList&lt;&gt;();\n        List&lt;Object&gt; allParams = new ArrayList&lt;&gt;();\n\n        for (TransferObserver observer : observers) {\n            String condition = observer.getSqlCondition();\n            if (condition != null) {\n                whereParts.add(&quot;(&quot; + condition + &quot;)&quot;);\n                allParams.addAll(observer.getSqlParameters());\n            }\n        }\n\n        if (whereParts.isEmpty()) {\n            log.warn(&quot;No monitoring conditions found.&quot;);\n            return;\n        }\n\n        String whereClause = String.join(&quot; OR &quot;, whereParts);\n        List&lt;TransferDto&gt; newTransfers = transferRepository.findNewTransfers(whereClause, allParams);\n\n        for (TransferDto transfer : newTransfers) {\n            ClientDto client = clientRepository.findById(transfer.getClientId());\n            MarkRequestDto request = markRequestBuilderService.build(transfer, client);\n            markService.sendSpo(request);\n        }\n    }\n}\n//------------------------------------\n@Slf4j\n@Service\n@RequiredArgsConstructor\npublic class MarkService {\n\n    private final Send2Mark send2Mark;\n    private final ObjectMapper objectMapper;\n    private static final String TDI_CREATE_PATH = &quot;/tdi/create&quot;;\n\n    @Async(&quot;asyncExecutor&quot;)\n    public void sendSpo(MarkRequestDto requestDto) {\n        try {\n            String requestJson = objectMapper.writeValueAsString(requestDto);\n            String response = send2Mark.send(SPO_CREATE_PATH, requestJson);\n\n            JsonObject jsonObject = JsonParser.parseString(response).getAsJsonObject();\n\n            if (jsonObject.get(&quot;success&quot;).getAsBoolean()) {\n                log.info(&quot;TDI successfully sent. Mark ID = {}&quot;, jsonObject.get(&quot;id&quot;).getAsString());\n            } else {\n                log.warn(&quot;Failed to send TDI: {}&quot;, jsonObject);\n            }\n        } catch (Exception e) {\n            log.error(&quot;Error sending TDI: {}&quot;, e.getMessage(), e);\n        }\n    }\n} \n//------------------------\n@Slf4j\n@Service\n@RequiredArgsConstructor\npublic class TransferMonitoringService {\n\n    private final List&lt;TransferObserver&gt; observers;\n    private final TransferRepository transferRepository;\n    private final ClientRepository clientRepository;\n    private final MarkService markService;\n    private final TdiBuilderService tdiBuilderService;\n\n    public void monitorNewTransfers() {\n        List&lt;String&gt; whereParts = new ArrayList&lt;&gt;();\n        List&lt;Object&gt; allParams = new ArrayList&lt;&gt;();\n\n        for (TransferObserver observer : observers) {\n            String condition = observer.getSqlCondition();\n            if (condition != null) {\n                whereParts.add(&quot;(&quot; + condition + &quot;)&quot;);\n                allParams.addAll(observer.getSqlParameters());\n            }\n        }\n\n        if (whereParts.isEmpty()) {\n            log.warn(&quot;There are no conditions for monitoring transfers (the observers returned it empty).&quot;);\n            return;\n        }\n\n        String whereClause = String.join(&quot; OR &quot;, whereParts);\n\n        List&lt;TransferDto&gt; newTransfers = transferRepository.findNewTransfers(whereClause, allParams);\n\n        for (TransferDto transfer : newTransfers) {\n            ClientDto client = clientRepository.findById(transfer.getClientId());           \n\n            TdiRequestDto request = tdiBuilderService.build(transfer, client);\n            markService.sendTdi(request);\n        }\n    }\n}\n//---------------------------------\n@Slf4j\n@Component\n@RequiredArgsConstructor\npublic class TransferScheduler {\n\n    private final TransferMonitoringService transferMonitoringService;\n\n    @Value(&quot;${monitoring.transfer.enabled}&quot;)\n    private boolean monitoringEnabled;\n\n    @Scheduled(cron = &quot;${monitoring.transfer.cron}&quot;) // default every 5 minut\n    public void monitorTransfers() {\n    log.info(&quot;Start monitoring new transfers...&quot;);\n\n    if (!monitoringEnabled) {\n        log.info(&quot;Transfer monitoring is disabled via the configuration.&quot;);\n        return;\n    }\n\n       transferMonitoringService.monitorNewTransfers();\n    }\n}\n \n</code></pre>\n",
    "tags" : [ "java", "spring-boot", "architecture", "observer-pattern" ],
    "owner" : {
      "account_id" : 15040147,
      "reputation" : 11,
      "user_id" : 10855078,
      "user_type" : "registered",
      "profile_image" : "https://graph.facebook.com/1900628616717937/picture?type=large",
      "display_name" : "John Williams",
      "link" : "https://stackoverflow.com/users/10855078/john-williams"
    },
    "is_answered" : false,
    "view_count" : 54,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1745925147,
    "creation_date" : 1745908769,
    "link" : "https://stackoverflow.com/questions/79597746/how-to-improve-architecture-of-a-transfer-monitoring-service-using-observer-patt",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140388814,
    "post_id" : 79597746,
    "body" : "I strongly suggest you use <a href=\"https://www.baeldung.com/spring-events\" rel=\"nofollow noreferrer\">Spring Event</a> to implement this functionality. Spring Event already use observer pattern to handle.",
    "score" : 0,
    "owner" : {
      "account_id" : 14893327,
      "reputation" : 57,
      "user_id" : 10754370,
      "user_type" : "registered",
      "profile_image" : "https://lh4.googleusercontent.com/-449rLP9zMT4/AAAAAAAAAAI/AAAAAAAAAqg/r-Rr--HRzBc/s256-rj/photo.jpg",
      "display_name" : "Anh Tuấn Nguyễn",
      "link" : "https://stackoverflow.com/users/10754370/anh-tu%e1%ba%a5n-nguy%e1%bb%85n"
    },
    "creation_date" : 1746154671,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}