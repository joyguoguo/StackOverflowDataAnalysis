{
  "question" : {
    "question_id" : 79841757,
    "title" : "Scrolling to JTree node vertically only",
    "body" : "<p>Our <code>JTree</code> subtype automatically scrolls to its selected node. It's implemented essentially as follows:</p>\n<pre class=\"lang-java prettyprint-override\"><code>            @Override\n            public void setSelectionPath(TreePath path) {\n                super.setSelectionPath(path);\n                scrollPathToVisible(path);\n            }\n</code></pre>\n<p>Some nodes have long names. When such a node is selected, its <code>JScrollPane</code> performs both vertical and horizontal scrolling.</p>\n<p><a href=\"https://i.sstatic.net/vf9Hiho7.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/vf9Hiho7.png\" alt=\"enter image description here\" /></a></p>\n<p><a href=\"https://i.sstatic.net/A4Hlm8JT.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/A4Hlm8JT.png\" alt=\"enter image description here\" /></a></p>\n<p>I was tasked with disabling the horizontal scrolling.</p>\n<p>In my attempted solution (see the snippet below), I trick Swing into believing it has to show a different <code>Rectangle</code> than the one that actually corresponds to the selected node. However, the challenging part is to retrieve the &quot;current&quot; X and width. If you hardcode them as zeroes, as I did, the horizontal scroll bar is going to be reset to the beginning each time selection occurs, even if the bar is in the middle.</p>\n<p>I guess there may be other pathways as well.</p>\n<p>How do can achieve my goal?</p>\n<p>Java 8.</p>\n<pre class=\"lang-java prettyprint-override\"><code>import javax.swing.JFrame;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTree;\nimport javax.swing.WindowConstants;\nimport javax.swing.tree.DefaultMutableTreeNode;\nimport javax.swing.tree.TreeNode;\nimport javax.swing.tree.TreePath;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.Dimension;\nimport java.awt.Rectangle;\n\npublic class SimpleTreeDemo {\n\n    public static void main(String[] args) {\n        Container mainPanel = createMainPanel();\n        JFrame frame = new JFrame(&quot;Tree Demo&quot;);\n        frame.setContentPane(mainPanel);\n        frame.setLocationRelativeTo(null);\n        frame.pack();\n        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        frame.setVisible(true);\n    }\n\n    private static Container createMainPanel() {\n        JScrollPane panel = new JScrollPane();\n        panel.setViewportView(createTree());\n        Dimension smallDimension = new Dimension(200, 100);\n        panel.setPreferredSize(smallDimension);\n        return panel;\n    }\n\n    private static Component createTree() {\n        JTree tree = new TreeEx(createRoot());\n        tree.setShowsRootHandles(true);\n        return tree;\n    }\n\n    private static TreeNode createRoot() {\n        DefaultMutableTreeNode root = new DefaultMutableTreeNode(&quot;Root&quot;);\n        root.add(new DefaultMutableTreeNode(&quot;Short child&quot;));\n        root.add(new DefaultMutableTreeNode(&quot;Loooooooooooooooooooooooooooooooooooong child&quot;));\n        return root;\n    }\n\n    private static class TreeEx extends JTree {\n\n        public TreeEx(TreeNode root) {\n            super(root);\n        }\n\n        @Override\n        public void setSelectionPath(TreePath path) {\n            super.setSelectionPath(path);\n            scrollPathToVisible(path);\n        }\n\n        @Override\n        public void scrollPathToVisible(TreePath path) {\n            // mostly a copy-pasted super-method\n            if (path == null) return;\n            makeVisible(path);\n            Rectangle bounds = buildVerticalBounds(path);\n            if (bounds == null) return;\n            scrollRectToVisible(bounds);\n            if (accessibleContext == null) return;\n            ((AccessibleJTree) accessibleContext).fireVisibleDataPropertyChange();\n        }\n\n        private Rectangle buildVerticalBounds(TreePath path) {\n            Rectangle requestedPath = getPathBounds(path);\n            if (requestedPath == null) return null;\n            requestedPath.setLocation(getCurrentX(), (int) requestedPath.getLocation().getY());\n            requestedPath.setSize(getCurrentWidth(), (int) requestedPath.getSize().getHeight());\n            return requestedPath;\n        }\n\n        // in theory, by correctly implementing the following two methods, one can achieve the desired functionality\n        private int getCurrentX() {\n            return 0;\n        }\n\n        private int getCurrentWidth() {\n            return 0;\n        }\n    }\n}\n</code></pre>\n",
    "tags" : [ "java", "swing" ],
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2683,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "is_answered" : false,
    "view_count" : 92,
    "answer_count" : 1,
    "score" : 1,
    "last_activity_date" : 1765387568,
    "creation_date" : 1765273438,
    "link" : "https://stackoverflow.com/questions/79841757/scrolling-to-jtree-node-vertically-only",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79841800,
    "question_id" : 79841757,
    "body" : "<p>You can retrieve the current X and width by querying the parent <code>JViewport</code>.</p>\n<pre class=\"lang-java prettyprint-override\"><code>        private Rectangle buildVerticalBounds(TreePath path) {\n            Rectangle bounds = getPathBounds(path);\n            if (bounds == null) return null;\n            Container parent = SwingUtilities.getAncestorOfClass(JViewport.class, this);\n            if (parent == null) return bounds;\n            JViewport parentViewport = (JViewport) parent;\n            bounds.setLocation(parentViewport.getViewPosition().x, (int) bounds.getLocation().getY());\n            bounds.setSize(parentViewport.getExtentSize().width, (int) bounds.getSize().getHeight());\n            return bounds;\n        }\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2683,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "creation_date" : 1765275814,
    "last_activity_date" : 1765289891,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140894415,
    "post_id" : 79841757,
    "body" : "@life888888 except I <i>need</i> a horizontal scroll bar. It just shouldn&#39;t automatically scroll on node selection",
    "score" : 0,
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2683,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "creation_date" : 1765289837,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140894348,
    "post_id" : 79841757,
    "body" : "at <code>private static Container createMainPanel() {</code> , add <code>panel.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZ&zwnj;&#8203;ONTAL_SCROLLBAR_NEVE&zwnj;&#8203;R);</code>  before <code>return panel;</code>",
    "score" : 0,
    "owner" : {
      "account_id" : 26698569,
      "reputation" : 4090,
      "user_id" : 20306007,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/98bbc403493aee3681b71dae7abef66e?s=256&d=identicon&r=PG",
      "display_name" : "life888888",
      "link" : "https://stackoverflow.com/users/20306007/life888888"
    },
    "creation_date" : 1765287735,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140894047,
    "post_id" : 79841757,
    "body" : "@JustanotherJavaprogrammer &quot;one&quot; refers to <i>scrolling</i> (in the context of <code>scrollPathToVisible()</code>), not the bar itself",
    "score" : 0,
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2683,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "creation_date" : 1765275889,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140894018,
    "post_id" : 79841757,
    "body" : "I&#39;m not sure what you want to achieve. You wrote &quot; I was tasked with disabling the horizontal one&quot;. What do you want it to look like?",
    "score" : 0,
    "owner" : {
      "account_id" : 8362430,
      "reputation" : 856,
      "user_id" : 6280255,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/579e86ed5089abcb535b4e05ead3f6f6?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Just another Java programmer",
      "link" : "https://stackoverflow.com/users/6280255/just-another-java-programmer"
    },
    "creation_date" : 1765274971,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140894015,
    "post_id" : 79841757,
    "body" : "@JustanotherJavaprogrammer the fact that it removes the horizontal scroll bar altogether",
    "score" : 0,
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2683,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "creation_date" : 1765274675,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140894007,
    "post_id" : 79841757,
    "body" : "What&#39;s wrong with JScrollPane panel = new JScrollPane(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER); ?",
    "score" : 0,
    "owner" : {
      "account_id" : 8362430,
      "reputation" : 856,
      "user_id" : 6280255,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/579e86ed5089abcb535b4e05ead3f6f6?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Just another Java programmer",
      "link" : "https://stackoverflow.com/users/6280255/just-another-java-programmer"
    },
    "creation_date" : 1765274226,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79841800" : [ {
      "comment_id" : 140897476,
      "post_id" : 79841800,
      "body" : "@Holger I encourage you to post it as an answer",
      "score" : 0,
      "owner" : {
        "account_id" : 10187542,
        "reputation" : 2683,
        "user_id" : 20692967,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
        "display_name" : "Sergey Zolotarev",
        "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
      },
      "creation_date" : 1765434198,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140895947,
      "post_id" : 79841800,
      "body" : "It’s the way, <code>JViewport</code> works. The view is moved into the opposite direction, so that the visible rect matches the area of the <code>JViewport</code>. The viewport doesn’t even maintain the view position; the <code>getViewPosition()</code> method also reads the location of the view component and flips the signs, like I did.",
      "score" : 1,
      "owner" : {
        "account_id" : 3211603,
        "reputation" : 301001,
        "user_id" : 2711488,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
        "display_name" : "Holger",
        "link" : "https://stackoverflow.com/users/2711488/holger"
      },
      "creation_date" : 1765363917,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140895534,
      "post_id" : 79841800,
      "body" : "@Holger Thank you for the feedback. How does <code>-getX()</code> work?",
      "score" : 0,
      "owner" : {
        "account_id" : 10187542,
        "reputation" : 2683,
        "user_id" : 20692967,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
        "display_name" : "Sergey Zolotarev",
        "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
      },
      "creation_date" : 1765347248,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140894743,
      "post_id" : 79841800,
      "body" : "A bit overengineered. You get the same result with <code>private Rectangle buildVerticalBounds(TreePath path) { Rectangle bounds = getPathBounds(path); if(bounds == null) return null; Container parent = getParent(); if(parent == null) return bounds; bounds.x = -getX(); bounds.width = parent.getWidth(); return bounds; }</code> In fact, for the desired scrolling behavior, the width doesn’t have to match the actual width, so you can even use <code>Rectangle bounds = getPathBounds(path); if(bounds == null) return null; bounds.x = -getX(); bounds.width = 0; return bounds;</code>",
      "score" : 1,
      "owner" : {
        "account_id" : 3211603,
        "reputation" : 301001,
        "user_id" : 2711488,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
        "display_name" : "Holger",
        "link" : "https://stackoverflow.com/users/2711488/holger"
      },
      "creation_date" : 1765300142,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}