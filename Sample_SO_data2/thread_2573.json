{
  "question" : {
    "question_id" : 79613879,
    "title" : "SQLiteOpenHelper database approach with manually copying suitable for Android deployment?",
    "body" : "<p>I have an android java app that uses a SQLite internal database with a database that is located in the asset folder. So I &quot;manually&quot; copy the database in the constructor. My question is, if this is a valid approach for Android deployment considering the possibility of updates or might this lead to inconsistant data when updating the database as my approach might interfere with the built-in logic of the SQLiteOpenHelper class. My onCreate method is empty because I am doing everything in the constructor</p>\n<pre><code>public class DB_SQLite_Helper extends SQLiteOpenHelper {\n\n    public static final String DATABASE_NAME = &quot;internal_database.db&quot;;\n    public static final int DBVERSION = 1;\n\n\n\n    public DB_SQLite_Helper(Context context) {\n        super(context,DATABASE_NAME,null,DBVERSION);\n        if (!ifDBExists(context)) {\n            if (!copyDBFromAssets(context)) {\n                throw new RuntimeException(&quot;Failed to Copy Database From Assets Folder&quot;);\n            }\n        }\n        mDB = this.getWritableDatabase();\n    }\n\n    SQLiteDatabase mDB;\n\n    @Override\n    public void onCreate(SQLiteDatabase sqLiteDatabase) {\n\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {\n        //Update for the 2nd version\n        if (oldVersion &lt; 2) {\n\n        }\n    }\n\n    \n\n\n    ////////////////////////////////////////////////////////////////////////////\n\n    /*\n     Copies the database from the assets folder to the apps database folder (with logging)\n     note databases folder is typically data/data/the_package_name/database\n          however using getDatabasePath method gets the actual path (should it not be as above)\n     This method can be significantly reduced one happy that it works.\n  */\n    @SuppressWarnings(&quot;IOStreamConstructor&quot;)\n    private boolean copyDBFromAssets(Context context) {\n        Log.d(&quot;CPYDBINFO&quot;,&quot;Starting attempt to cop database from the assets file.&quot;);\n        String DBPATH = context.getDatabasePath(DATABASE_NAME).getPath();\n        InputStream is;\n        OutputStream os;\n        int buffer_size = 8192;\n        int length = buffer_size;\n        long bytes_read = 0;\n        long bytes_written = 0;\n        byte[] buffer = new byte[length];\n\n        try {\n\n            is = context.getAssets().open(DATABASE_NAME);\n        } catch (IOException e) {\n            Log.e(&quot;CPYDB FAIL - NO ASSET&quot;,&quot;Failed to open the Asset file &quot; + DATABASE_NAME);\n            return false;\n        }\n\n        try {\n            os = new FileOutputStream(DBPATH);\n        } catch (IOException e) {\n            Log.e(&quot;CPYDB FAIL - OPENDB&quot;,&quot;Failed to open the Database File at &quot; + DBPATH);\n            return false;\n        }\n        Log.d(&quot;CPYDBINFO&quot;,&quot;Initiating copy from asset file&quot; + DATABASE_NAME + &quot; to &quot; + DBPATH);\n        while (length &gt;= buffer_size) {\n            try {\n                length = is.read(buffer,0,buffer_size);\n            } catch (IOException e) {\n                Log.e(&quot;CPYDB FAIL - RD ASSET&quot;,\n                        &quot;Failed while reading in data from the Asset. &quot; +\n                                bytes_read +\n                                &quot; bytes read successfully.&quot;\n                );\n                return false;\n            }\n            bytes_read = bytes_read + length;\n            try {\n                os.write(buffer,0,buffer_size);\n            } catch (IOException e) {\n                Log.e(&quot;CPYDB FAIL - WR ASSET&quot;,&quot;failed while writing Database File &quot; +\n                        DBPATH +\n                        &quot;. &quot; +\n                        bytes_written +\n                        &quot; bytes written successfully.&quot;);\n                return false;\n\n            }\n            bytes_written = bytes_written + length;\n        }\n        Log.d(&quot;CPYDBINFO&quot;,\n                &quot;Read &quot; + bytes_read + &quot; bytes. &quot; +\n                        &quot;Wrote &quot; + bytes_written + &quot; bytes.&quot;\n        );\n        try {\n            os.flush();\n            is.close();\n            os.close();\n        } catch (IOException e ) {\n            Log.e(&quot;CPYDB FAIL - FINALISING&quot;,&quot;Failed Finalising Database Copy. &quot; +\n                    bytes_read +\n                    &quot; bytes read.&quot; +\n                    bytes_written +\n                    &quot; bytes written.&quot;\n            );\n            return false;\n        }\n        return true;\n    }\n    /*\n    Checks to see if the database exists if not will create the respective directory (database)\n    Creating the directory overcomes the NOT FOUND error\n */\n    private boolean ifDBExists(Context context) {\n        String dbparent = context.getDatabasePath(DATABASE_NAME).getParent();\n        File f = context.getDatabasePath(DATABASE_NAME);\n        if (!f.exists()) {\n            Log.d(&quot;NODB MKDIRS&quot;, &quot;Database file not found, making directories.&quot;); //&lt;&lt;&lt;&lt; remove before the App goes live.\n            if (dbparent != null) {\n                File d = new File(dbparent);\n                if (!d.mkdirs() &amp;&amp; !d.isDirectory()) { // Check if mkdirs() failed and directory wasn't created\n                    Log.e(&quot;NODB MKDIRS&quot;, &quot;Failed to create directories for the database.&quot;);\n                    return false;\n                }\n            }\n        }\n        return f.exists();\n    }\n\n\n}//Class\n</code></pre>\n<p>And in the main activity I use</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n\n    public static DB_SQLite_Helper sqLite_DB;\n\n    protected void onCreate(Bundle savedInstanceState) {\n\n        super.onCreate(savedInstanceState);\n        com.example.game.databinding.ActivityMainBinding binding = ActivityMainBinding.inflate(getLayoutInflater());\n        View view = binding.getRoot();\n        Objects.requireNonNull(getSupportActionBar()).hide();\n        setContentView(view);\n\n        sqLite_DB = new DB_SQLite_Helper(this);\n    }\n</code></pre>\n<p>Update: Here is a screenshot of the database schema:\n<a href=\"https://i.sstatic.net/wiw3BjhY.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/wiw3BjhY.png\" alt=\"Screenshot of db\" /></a></p>\n",
    "tags" : [ "java", "android-sqlite" ],
    "owner" : {
      "account_id" : 13060317,
      "reputation" : 717,
      "user_id" : 9437740,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/6yvEH.png?s=256",
      "display_name" : "VanessaF",
      "link" : "https://stackoverflow.com/users/9437740/vanessaf"
    },
    "is_answered" : false,
    "view_count" : 104,
    "answer_count" : 2,
    "score" : 2,
    "last_activity_date" : 1747128938,
    "creation_date" : 1746784560,
    "link" : "https://stackoverflow.com/questions/79613879/sqliteopenhelper-database-approach-with-manually-copying-suitable-for-android-de",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79615046,
    "question_id" : 79613879,
    "body" : "<blockquote>\n<p>My question is, if this is a valid approach for Android deployment considering the possibility of updates or might this lead to inconsistant data when updating the database as my approach might interfere with the built-in logic of the SQLiteOpenHelper class.</p>\n</blockquote>\n<p>It is valid as for the lifetime of the App the database is created once (copied from the asset) updates will then be applied as and when. Subsequent opening of the database will, as the database exists, just open the existing database, bypassing the code undertaken if the database does not exist which would have had any updates applied.</p>\n<p>THE ABOVE IS ASSUMING you are not talking about updates as being applied to the underlying asset. If this is the case then you would need to detect a change to the asset (which would likely mean copying the asset and opening it, typically by checking the user_version in the header at offset 60 which is 4 bytes). If the asset has been detected as having changed then you would typically delete the existing database and then copy the new asset. However, matters are complicated if you want to keep updates applied to the original database (roughly it would be along the lines of rename the original, copy the new database, extract the respective data from the original and apply to the new, delete the original, close the new and pass control back to the openhelper).</p>\n<ul>\n<li><p>You may find <a href=\"https://stackoverflow.com/questions/67803713/how-to-update-database-from-assets-folder-in-app/67812561#67812561\">How to Update Database from Assets Folder in App</a> of use/interest.</p>\n<ul>\n<li>This example includes maintaining some original data <a href=\"https://stackoverflow.com/questions/54822935/which-methods-can-be-used-to-manage-differing-versions-of-pre-existing-databases/54822936#54822936\">Which methods can be used to manage differing versions of pre-existing databases?</a></li>\n</ul>\n</li>\n<li><p>using the SQLite <code>user_version</code> is one way that the asset can be checked, it does require management of the asset to ensure that the <code>user_version</code> is changed (typically by whatever SQLite tool is being used to provide the database).</p>\n</li>\n</ul>\n<p>In ALL cases above the <code>onCreate</code> method will not be called/invoke as the database exists when the time comes for it to be opened by the helper.</p>\n<p><strong>Additional re comment</strong></p>\n<blockquote>\n<p>The SQlite db also contains internal progress information of the player in a separate table (like unlocked levels, highscores etc). In case of a db update, this information should be tranferred to the new database. I'm sceptical that with my current code this will work properly</p>\n</blockquote>\n<p>The basic principles of the greater complexity i.e. comparing the asset version to the original version  is explained and demonstrated in the links (2nd).</p>\n<p>Perhaps consider this version of your helper:-</p>\n<pre><code>class DB_SQLite_Helper extends SQLiteOpenHelper {\n\n   public static final String DATABASE_NAME = &quot;internal_database.db&quot;;\n   public static final int DBVERSION = 2;\n   public static final  int OUCH = -666666666; /*********** ADDED **********/\n   private String OLD_DB_SUFFIX = &quot;_renamed&quot;;\n\n   public DB_SQLite_Helper(Context context) {\n      super(context,DATABASE_NAME,null,DBVERSION);\n      boolean dbExists = ifDBExists(context);\n      int assetVersion = getVersionFromDBInAssetFolder(context,DATABASE_NAME);\n      int originalDBVersion=0;\n      if (dbExists) {\n         originalDBVersion = getVersionFromDBFile(context,DATABASE_NAME);\n      }\n      Log.e(&quot;CPYDB_CHECK&quot;,&quot;DB exists &quot; + dbExists + &quot; DBVersion is &quot; + originalDBVersion + &quot; AVersion is &quot; + assetVersion);\n      if (!ifDBExists(context) || assetVersion &gt; originalDBVersion) {\n         if (dbExists &amp;&amp; assetVersion &gt; originalDBVersion) {\n            /* RENAME original DB so it can be used */\n            context.getDatabasePath(DATABASE_NAME).renameTo(context.getDatabasePath(DATABASE_NAME+OLD_DB_SUFFIX));\n         }\n         if (!copyDBFromAssets(context)) {\n            throw new RuntimeException(&quot;Failed to Copy Database From Assets Folder&quot;);\n         }\n         if (assetVersion &gt; originalDBVersion &amp;&amp; dbExists) {\n            SQLiteDatabase newdb = SQLiteDatabase.openDatabase(context.getDatabasePath(DATABASE_NAME).getPath(),null,0);\n            newdb.execSQL(&quot;ATTACH '&quot; + context.getDatabasePath(DATABASE_NAME + OLD_DB_SUFFIX) + &quot;' AS &quot; + OLD_DB_SUFFIX);\n            newdb.execSQL(&quot;INSERT OR IGNORE INTO user_data SELECT * FROM &quot; + OLD_DB_SUFFIX + &quot;.user_data;&quot;);\n            newdb.execSQL(&quot;DETACH &quot; + OLD_DB_SUFFIX);\n            newdb.close();\n            /* either extract user data into a Cursor\n            OR\n               ATTACH renamed original to new db copied from asset,\n               then use query to INSERT into user table SELECTing from attached user table\n               DETACH renamed original\n            */\n            /* REMEMBER TO CLOSE DB's */\n         }\n         /* Now delete the original db */\n         context.getDatabasePath(DATABASE_NAME+OLD_DB_SUFFIX).delete();\n      }\n      mDB = this.getWritableDatabase();\n   }\n\n   SQLiteDatabase mDB;\n\n   @Override\n   public void onCreate(SQLiteDatabase sqLiteDatabase) {\n\n   }\n\n   @Override\n   public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {\n      //Update for the 2nd version\n      /*\n      if (oldVersion &lt; 2) {\n\n      }\n\n       */\n   }\n\n\n\n\n   ////////////////////////////////////////////////////////////////////////////\n\n   /*\n    Copies the database from the assets folder to the apps database folder (with logging)\n    note databases folder is typically data/data/the_package_name/database\n         however using getDatabasePath method gets the actual path (should it not be as above)\n    This method can be significantly reduced one happy that it works.\n */\n   @SuppressWarnings(&quot;IOStreamConstructor&quot;)\n   private boolean copyDBFromAssets(Context context) {\n      Log.d(&quot;CPYDBINFO&quot;,&quot;Starting attempt to cop database from the assets file.&quot;);\n      String DBPATH = context.getDatabasePath(DATABASE_NAME).getPath();\n      InputStream is;\n      OutputStream os;\n      int buffer_size = 8192;\n      int length = buffer_size;\n      long bytes_read = 0;\n      long bytes_written = 0;\n      byte[] buffer = new byte[length];\n\n      try {\n\n         is = context.getAssets().open(DATABASE_NAME);\n      } catch (IOException e) {\n         Log.e(&quot;CPYDB FAIL - NO ASSET&quot;,&quot;Failed to open the Asset file &quot; + DATABASE_NAME);\n         return false;\n      }\n\n      try {\n         os = new FileOutputStream(DBPATH);\n      } catch (IOException e) {\n         Log.e(&quot;CPYDB FAIL - OPENDB&quot;,&quot;Failed to open the Database File at &quot; + DBPATH);\n         return false;\n      }\n      Log.d(&quot;CPYDBINFO&quot;,&quot;Initiating copy from asset file&quot; + DATABASE_NAME + &quot; to &quot; + DBPATH);\n      while (length &gt;= buffer_size) {\n         try {\n            length = is.read(buffer,0,buffer_size);\n         } catch (IOException e) {\n            Log.e(&quot;CPYDB FAIL - RD ASSET&quot;,\n                    &quot;Failed while reading in data from the Asset. &quot; +\n                            bytes_read +\n                            &quot; bytes read successfully.&quot;\n            );\n            return false;\n         }\n         bytes_read = bytes_read + length;\n         try {\n            os.write(buffer,0,buffer_size);\n         } catch (IOException e) {\n            Log.e(&quot;CPYDB FAIL - WR ASSET&quot;,&quot;failed while writing Database File &quot; +\n                    DBPATH +\n                    &quot;. &quot; +\n                    bytes_written +\n                    &quot; bytes written successfully.&quot;);\n            return false;\n\n         }\n         bytes_written = bytes_written + length;\n      }\n      Log.d(&quot;CPYDBINFO&quot;,\n              &quot;Read &quot; + bytes_read + &quot; bytes. &quot; +\n                      &quot;Wrote &quot; + bytes_written + &quot; bytes.&quot;\n      );\n      try {\n         os.flush();\n         is.close();\n         os.close();\n      } catch (IOException e ) {\n         Log.e(&quot;CPYDB FAIL - FINALISING&quot;,&quot;Failed Finalising Database Copy. &quot; +\n                 bytes_read +\n                 &quot; bytes read.&quot; +\n                 bytes_written +\n                 &quot; bytes written.&quot;\n         );\n         return false;\n      }\n      return true;\n   }\n   /*\n   Checks to see if the database exists if not will create the respective directory (database)\n   Creating the directory overcomes the NOT FOUND error\n*/\n   private boolean ifDBExists(Context context) {\n      String dbparent = context.getDatabasePath(DATABASE_NAME).getParent();\n      File f = context.getDatabasePath(DATABASE_NAME);\n      if (!f.exists()) {\n         Log.d(&quot;NODB MKDIRS&quot;, &quot;Database file not found, making directories.&quot;); //&lt;&lt;&lt;&lt; remove before the App goes live.\n         if (dbparent != null) {\n            File d = new File(dbparent);\n            if (!d.mkdirs() &amp;&amp; !d.isDirectory()) { // Check if mkdirs() failed and directory wasn't created\n               Log.e(&quot;NODB MKDIRS&quot;, &quot;Failed to create directories for the database.&quot;);\n               return false;\n            }\n         }\n      }\n      return f.exists();\n   }\n   /***********************************************************************************************/\n   /* ADDITIONAL                                                                                   */\n   /***********************************************************************************************/\n   /**\n    * Get the SQLite_user_vesrion from the DB in the asset folder\n    *\n    * @param context           needed to get the appropriate package assets\n    * @param assetfilename     the name of the asset file (assumes/requires name matches database)\n    * @return                  the version number as stored in the asset DB\n    */\n   public static int getVersionFromDBInAssetFolder(Context context, String assetfilename) {\n      InputStream is;\n      try {\n         is = context.getAssets().open(assetfilename);\n      } catch (IOException e) {\n         return OUCH;\n      }\n      return getDBVersionFromInputStream(is);\n   }\n\n   /**\n    * Get the version from the database itself without opening the database as an SQliteDatabase\n    * @param context   Needed to ascertain package\n    * @param dbname    the name of the dataabase\n    * @return          the version number extracted\n    */\n   public static int getVersionFromDBFile(Context context, String dbname) {\n      InputStream is;\n      try {\n         is = new FileInputStream(new File(context.getDatabasePath(dbname).toString()));\n      } catch (IOException e) {\n         return OUCH;\n      }\n      return getDBVersionFromInputStream(is);\n   }\n\n   /**\n    * Get the Database Version (user_version) from an input stream\n    *  Note the input stream is closed\n    * @param is    The Inputstream\n    * @return      The extracted version number\n    */\n   private static int getDBVersionFromInputStream(InputStream is) {\n      int rv = -1, dbversion_offset = 60, dbversion_length = 4 ;\n      byte[] dbfileheader = new byte[64];\n      byte[] dbversion = new byte[4];\n      try {\n         is.read(dbfileheader);\n         is.close();\n      } catch (IOException e) {\n         e.printStackTrace();\n         return rv;\n      }\n\n      for (int i = 0; i &lt; dbversion_length; i++ ) {\n         dbversion[i] = dbfileheader[dbversion_offset + i];\n      }\n      return ByteBuffer.wrap(dbversion).getInt();\n   }\n\n   /**\n    * Check to see if the asset file exists\n    *\n    * @param context           needed to get the appropriate package\n    * @param assetfilename     the name of the asset file to check\n    * @return                  true if the asset file exists, else false\n    */\n   public static boolean ifAssetFileExists(Context context, String assetfilename) {\n      try {\n         context.getAssets().open(assetfilename);\n      } catch (IOException e) {\n         return false;\n      }\n      return true;\n   }\n}\n</code></pre>\n<ul>\n<li>In short the 3 methods:- <code>getVersionFromDBInAssetFolder</code>,<code>getVersionFromDBFile</code> and <code>getDBVersionFromInputStream</code> have been added, allowing the SQLite <code>user_version</code> to be extracted (without accessing the database via the relatively resource intensive SQLite API).</li>\n<li>The version as well as the existence of the database file is then used to drive what then happens.\n<ul>\n<li>If the original database does not exist OR the asset version is greater than the existing database then the asset is needed.\n<ul>\n<li>If the db was found to exist then it is renamed</li>\n<li>the asset is copied</li>\n<li>if the asset version is greater than the original db version then the user data needs to be obtained from the original (renamed) db and copied to the new db copied from the asset, when done the original (renamed) db is deleted.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><em><strong>Note</strong></em> code is included to handle the copying of the user data from the original to the  new database by <code>ATACH</code>ing the renamed original to the newly copied asset.</li>\n</ul>\n<p>AND activity code as per:-</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n\n    public static DB_SQLite_Helper sqLite_DB;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        sqLite_DB = new DB_SQLite_Helper(this);\n        dumpTableData();\n        addUserData();\n        dumpTableData();\n    }\n\n    private void addUserData() {\n        if (DB_SQLite_Helper.DBVERSION == 1) {\n            SQLiteDatabase db = sqLite_DB.getWritableDatabase();\n            ContentValues cv = new ContentValues();\n            cv.put(&quot;highscore&quot;,1000);\n            cv.put(&quot;unlocked_up_to&quot;,3);\n            cv.put(&quot;and_so_on&quot;,&quot;blah&quot;);\n            db.insert(&quot;user_data&quot;,null,cv);\n        }\n    }\n\n    private void dumpTableData() {\n        SQLiteDatabase db = sqLite_DB.getWritableDatabase();\n        Cursor csr = db.query(&quot;game_data_level&quot;,null,null,null,null,null,null);\n        DatabaseUtils.dumpCursor(csr);\n        csr = db.query(&quot;user_data&quot;,null,null,null,null,null,null);\n        DatabaseUtils.dumpCursor(csr);\n        csr.close();\n    }\n}\n</code></pre>\n<ul>\n<li>so and attempt is made, irrespective of the database version, to dump extracted data (of both tables) and to insert user data (into the user_data table); noting that the INSERT will only happen if DBVERSION is 1.</li>\n</ul>\n<p>Also consider 2 database asset files identical accept that the game data has some additional levels and that the user_version is increased from 1 to 2 for the new game data (table is game_data_level). Both versions have no data in the user_data table.</p>\n<p>For testing purposes there are 3 assets two base files for each version and then the actual internal_database.db file, which will be replaced by the respective version:-</p>\n<p><a href=\"https://i.sstatic.net/EvHgM7ZP.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/EvHgM7ZP.png\" alt=\"assets\" /></a></p>\n<p><code>DBVERSION</code> should be kept up to date otherwise <code>onUpdate</code> may be called or and exception as there is no <code>onDowngrade</code> method. Otherwise DBVERSION does not play a part (it could do if wanted as an extra check).</p>\n<p>The runs, First run, replicating an install and the asset is at version 1. So version1.db is copied and pasted as internal_database.db (and replaces it) and <code>DBVERSION</code> is set to 1.</p>\n<p>The the log, when the App is run, includes:-</p>\n<pre><code>2025-05-12 13:41:57.074 D/NODB MKDIRS: Database file not found, making directories.\n2025-05-12 13:41:57.075 E/CPYDB_CHECK: DB exists false DBVersion is 0 AVersion is 1\n2025-05-12 13:41:57.076 D/NODB MKDIRS: Database file not found, making directories.\n2025-05-12 13:41:57.076 D/CPYDBINFO: Starting attempt to cop database from the assets file.\n2025-05-12 13:41:57.077 D/CPYDBINFO: Initiating copy from asset fileinternal_database.db to /data/user/0/a.a.so79613879prepoluateddbretaininguseedata/databases/internal_database.db\n2025-05-12 13:41:57.077 D/CPYDBINFO: Read 20480 bytes. Wrote 20480 bytes.\n2025-05-12 13:41:57.125 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@25e7ab8\n2025-05-12 13:41:57.125 I/System.out: 0 {\n2025-05-12 13:41:57.126 I/System.out:    level=1\n2025-05-12 13:41:57.126 I/System.out:    level_name=L1\n2025-05-12 13:41:57.126 I/System.out:    etc=blah\n2025-05-12 13:41:57.127 I/System.out: }\n2025-05-12 13:41:57.127 I/System.out: 1 {\n2025-05-12 13:41:57.128 I/System.out:    level=2\n2025-05-12 13:41:57.128 I/System.out:    level_name=L2\n2025-05-12 13:41:57.128 I/System.out:    etc=blah\n2025-05-12 13:41:57.128 I/System.out: }\n2025-05-12 13:41:57.129 I/System.out: 2 {\n2025-05-12 13:41:57.129 I/System.out:    level=3\n2025-05-12 13:41:57.129 I/System.out:    level_name=L3\n2025-05-12 13:41:57.129 I/System.out:    etc=blah\n2025-05-12 13:41:57.130 I/System.out: }\n2025-05-12 13:41:57.130 I/System.out: &lt;&lt;&lt;&lt;&lt;\n2025-05-12 13:41:57.131 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@dee8091\n2025-05-12 13:41:57.132 I/System.out: &lt;&lt;&lt;&lt;&lt;\n2025-05-12 13:41:57.143 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@adf1bf6\n2025-05-12 13:41:57.143 I/System.out: 0 {\n2025-05-12 13:41:57.144 I/System.out:    level=1\n2025-05-12 13:41:57.144 I/System.out:    level_name=L1\n2025-05-12 13:41:57.144 I/System.out:    etc=blah\n2025-05-12 13:41:57.144 I/System.out: }\n2025-05-12 13:41:57.145 I/System.out: 1 {\n2025-05-12 13:41:57.145 I/System.out:    level=2\n2025-05-12 13:41:57.146 I/System.out:    level_name=L2\n2025-05-12 13:41:57.146 I/System.out:    etc=blah\n2025-05-12 13:41:57.146 I/System.out: }\n2025-05-12 13:41:57.146 I/System.out: 2 {\n2025-05-12 13:41:57.147 I/System.out:    level=3\n2025-05-12 13:41:57.147 I/System.out:    level_name=L3\n2025-05-12 13:41:57.147 I/System.out:    etc=blah\n2025-05-12 13:41:57.148 I/System.out: }\n2025-05-12 13:41:57.148 I/System.out: &lt;&lt;&lt;&lt;&lt;\n2025-05-12 13:41:57.149 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@1c80bf7\n2025-05-12 13:41:57.150 I/System.out: 0 {\n2025-05-12 13:41:57.150 I/System.out:    id=1\n2025-05-12 13:41:57.150 I/System.out:    highscore=1000\n2025-05-12 13:41:57.150 I/System.out:    unlocked_up_to=3\n2025-05-12 13:41:57.151 I/System.out:    and_so_on=blah\n2025-05-12 13:41:57.151 I/System.out: }\n2025-05-12 13:41:57.152 I/System.out: &lt;&lt;&lt;&lt;&lt;\n</code></pre>\n<p>If run again, then no asset copy and the log includes:-</p>\n<pre><code>2025-05-12 13:44:22.938 E/CPYDB_CHECK: DB exists true DBVersion is 1 AVersion is 1\n2025-05-12 13:44:22.945 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@adf1bf6\n2025-05-12 13:44:22.947 I/System.out: 0 {\n2025-05-12 13:44:22.947 I/System.out:    level=1\n2025-05-12 13:44:22.947 I/System.out:    level_name=L1\n2025-05-12 13:44:22.947 I/System.out:    etc=blah\n2025-05-12 13:44:22.947 I/System.out: }\n....\n</code></pre>\n<ul>\n<li>truncated as it just repeats. But note that CPYDB_CHECK info.</li>\n</ul>\n<p>Now if DBVERSION is changed to 2 and internal_database.db is replaced by a copy of version2.db and the App is run (without uninstalling), then the log includes:-</p>\n<pre><code>2025-05-12 13:49:27.550 E/CPYDB_CHECK: DB exists true DBVersion is 1 AVersion is 2\n2025-05-12 13:49:27.550 D/CPYDBINFO: Starting attempt to cop database from the assets file.\n2025-05-12 13:49:27.552 D/CPYDBINFO: Initiating copy from asset fileinternal_database.db to /data/user/0/a.a.so79613879prepoluateddbretaininguseedata/databases/internal_database.db\n2025-05-12 13:49:27.553 D/CPYDBINFO: Read 20480 bytes. Wrote 20480 bytes.\n2025-05-12 13:49:27.607 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@1c80bf7\n2025-05-12 13:49:27.607 I/System.out: 0 {\n2025-05-12 13:49:27.607 I/System.out:    level=1\n2025-05-12 13:49:27.608 I/System.out:    level_name=L1\n2025-05-12 13:49:27.608 I/System.out:    etc=blah\n2025-05-12 13:49:27.608 I/System.out: }\n2025-05-12 13:49:27.609 I/System.out: 1 {\n2025-05-12 13:49:27.609 I/System.out:    level=2\n2025-05-12 13:49:27.609 I/System.out:    level_name=L2\n2025-05-12 13:49:27.609 I/System.out:    etc=blah\n2025-05-12 13:49:27.609 I/System.out: }\n2025-05-12 13:49:27.610 I/System.out: 2 {\n2025-05-12 13:49:27.610 I/System.out:    level=3\n2025-05-12 13:49:27.610 I/System.out:    level_name=L3\n2025-05-12 13:49:27.611 I/System.out:    etc=blah\n2025-05-12 13:49:27.611 I/System.out: }\n2025-05-12 13:49:27.611 I/System.out: 3 {\n2025-05-12 13:49:27.611 I/System.out:    level=4\n2025-05-12 13:49:27.611 I/System.out:    level_name=L4\n2025-05-12 13:49:27.612 I/System.out:    etc=blah\n2025-05-12 13:49:27.612 I/System.out: }\n2025-05-12 13:49:27.612 I/System.out: 4 {\n2025-05-12 13:49:27.613 I/System.out:    level=5\n2025-05-12 13:49:27.613 I/System.out:    level_name=L5\n2025-05-12 13:49:27.613 I/System.out:    etc=blah\n2025-05-12 13:49:27.613 I/System.out: }\n2025-05-12 13:49:27.613 I/System.out: &lt;&lt;&lt;&lt;&lt;\n2025-05-12 13:49:27.614 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@ddc8a64\n2025-05-12 13:49:27.615 I/System.out: 0 {\n2025-05-12 13:49:27.615 I/System.out:    id=1\n2025-05-12 13:49:27.615 I/System.out:    highscore=1000\n2025-05-12 13:49:27.615 I/System.out:    unlocked_up_to=3\n2025-05-12 13:49:27.616 I/System.out:    and_so_on=blah\n2025-05-12 13:49:27.616 I/System.out: }\n2025-05-12 13:49:27.616 I/System.out: 1 {\n2025-05-12 13:49:27.616 I/System.out:    id=2\n2025-05-12 13:49:27.617 I/System.out:    highscore=1000\n2025-05-12 13:49:27.617 I/System.out:    unlocked_up_to=3\n2025-05-12 13:49:27.617 I/System.out:    and_so_on=blah\n2025-05-12 13:49:27.617 I/System.out: }\n2025-05-12 13:49:27.618 I/System.out: &lt;&lt;&lt;&lt;&lt;\n2025-05-12 13:49:27.619 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@66994cd\n2025-05-12 13:49:27.619 I/System.out: 0 {\n2025-05-12 13:49:27.620 I/System.out:    level=1\n2025-05-12 13:49:27.620 I/System.out:    level_name=L1\n2025-05-12 13:49:27.620 I/System.out:    etc=blah\n2025-05-12 13:49:27.620 I/System.out: }\n2025-05-12 13:49:27.621 I/System.out: 1 {\n2025-05-12 13:49:27.621 I/System.out:    level=2\n2025-05-12 13:49:27.621 I/System.out:    level_name=L2\n2025-05-12 13:49:27.621 I/System.out:    etc=blah\n2025-05-12 13:49:27.622 I/System.out: }\n2025-05-12 13:49:27.622 I/System.out: 2 {\n2025-05-12 13:49:27.622 I/System.out:    level=3\n2025-05-12 13:49:27.623 I/System.out:    level_name=L3\n2025-05-12 13:49:27.623 I/System.out:    etc=blah\n2025-05-12 13:49:27.623 I/System.out: }\n2025-05-12 13:49:27.623 I/System.out: 3 {\n2025-05-12 13:49:27.624 I/System.out:    level=4\n2025-05-12 13:49:27.624 I/System.out:    level_name=L4\n2025-05-12 13:49:27.624 I/System.out:    etc=blah\n2025-05-12 13:49:27.624 I/System.out: }\n2025-05-12 13:49:27.625 I/System.out: 4 {\n2025-05-12 13:49:27.625 I/System.out:    level=5\n2025-05-12 13:49:27.625 I/System.out:    level_name=L5\n2025-05-12 13:49:27.625 I/System.out:    etc=blah\n2025-05-12 13:49:27.625 I/System.out: }\n2025-05-12 13:49:27.626 I/System.out: &lt;&lt;&lt;&lt;&lt;\n2025-05-12 13:49:27.626 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@9d90182\n2025-05-12 13:49:27.628 I/System.out: 0 {\n2025-05-12 13:49:27.628 I/System.out:    id=1\n2025-05-12 13:49:27.628 I/System.out:    highscore=1000\n2025-05-12 13:49:27.628 I/System.out:    unlocked_up_to=3\n2025-05-12 13:49:27.628 I/System.out:    and_so_on=blah\n2025-05-12 13:49:27.629 I/System.out: }\n2025-05-12 13:49:27.629 I/System.out: 1 {\n2025-05-12 13:49:27.629 I/System.out:    id=2\n2025-05-12 13:49:27.630 I/System.out:    highscore=1000\n2025-05-12 13:49:27.630 I/System.out:    unlocked_up_to=3\n2025-05-12 13:49:27.630 I/System.out:    and_so_on=blah\n2025-05-12 13:49:27.630 I/System.out: }\n2025-05-12 13:49:27.630 I/System.out: &lt;&lt;&lt;&lt;&lt;\n</code></pre>\n<p>As can be seen, levels 4 and 5 have been added AND the user_data has been retained.</p>\n<ul>\n<li>my bad that a second user_data row was added by the 2nd run</li>\n</ul>\n<p>Finally no changes are made and the App is run again and:-</p>\n<pre><code>2025-05-12 13:53:32.236 E/CPYDB_CHECK: DB exists true DBVersion is 2 AVersion is 2\n2025-05-12 13:53:32.244 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@adf1bf6\n2025-05-12 13:53:32.245 I/System.out: 0 {\n2025-05-12 13:53:32.245 I/System.out:    level=1\n2025-05-12 13:53:32.246 I/System.out:    level_name=L1\n2025-05-12 13:53:32.248 I/System.out:    etc=blah\n2025-05-12 13:53:32.250 I/System.out: }\n....\n</code></pre>\n<ul>\n<li>i.e. no asset copy and so on.</li>\n</ul>\n<p>The last test a new install of the App (at V2), the log includes:-</p>\n<pre><code>2025-05-12 13:58:17.427 D/NODB MKDIRS: Database file not found, making directories.\n2025-05-12 13:58:17.428 E/CPYDB_CHECK: DB exists false DBVersion is 0 AVersion is 2\n2025-05-12 13:58:17.429 D/NODB MKDIRS: Database file not found, making directories.\n2025-05-12 13:58:17.431 D/CPYDBINFO: Starting attempt to cop database from the assets file.\n2025-05-12 13:58:17.431 D/CPYDBINFO: Initiating copy from asset fileinternal_database.db to /data/user/0/a.a.so79613879prepoluateddbretaininguseedata/databases/internal_database.db\n2025-05-12 13:58:17.432 D/CPYDBINFO: Read 20480 bytes. Wrote 20480 bytes.\n2025-05-12 13:58:17.478 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@25e7ab8\n2025-05-12 13:58:17.478 I/System.out: 0 {\n2025-05-12 13:58:17.479 I/System.out:    level=1\n2025-05-12 13:58:17.479 I/System.out:    level_name=L1\n2025-05-12 13:58:17.479 I/System.out:    etc=blah\n2025-05-12 13:58:17.479 I/System.out: }\n2025-05-12 13:58:17.479 I/System.out: 1 {\n2025-05-12 13:58:17.479 I/System.out:    level=2\n2025-05-12 13:58:17.479 I/System.out:    level_name=L2\n2025-05-12 13:58:17.480 I/System.out:    etc=blah\n2025-05-12 13:58:17.480 I/System.out: }\n2025-05-12 13:58:17.480 I/System.out: 2 {\n2025-05-12 13:58:17.480 I/System.out:    level=3\n2025-05-12 13:58:17.480 I/System.out:    level_name=L3\n2025-05-12 13:58:17.480 I/System.out:    etc=blah\n2025-05-12 13:58:17.480 I/System.out: }\n2025-05-12 13:58:17.480 I/System.out: 3 {\n2025-05-12 13:58:17.480 I/System.out:    level=4\n2025-05-12 13:58:17.481 I/System.out:    level_name=L4\n2025-05-12 13:58:17.481 I/System.out:    etc=blah\n2025-05-12 13:58:17.481 I/System.out: }\n2025-05-12 13:58:17.481 I/System.out: 4 {\n2025-05-12 13:58:17.481 I/System.out:    level=5\n2025-05-12 13:58:17.481 I/System.out:    level_name=L5\n2025-05-12 13:58:17.481 I/System.out:    etc=blah\n2025-05-12 13:58:17.481 I/System.out: }\n2025-05-12 13:58:17.481 I/System.out: &lt;&lt;&lt;&lt;&lt;\n2025-05-12 13:58:17.482 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@dee8091\n2025-05-12 13:58:17.482 I/System.out: &lt;&lt;&lt;&lt;&lt;\n</code></pre>\n<ul>\n<li>i.e. version with the 5 game levels is installed and there is no user data.</li>\n</ul>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 6077735,
      "reputation" : 57861,
      "user_id" : 4744514,
      "user_type" : "registered",
      "accept_rate" : 96,
      "profile_image" : "https://i.sstatic.net/RQ2Np.jpg?s=256",
      "display_name" : "MikeT",
      "link" : "https://stackoverflow.com/users/4744514/miket"
    },
    "creation_date" : 1746839772,
    "last_activity_date" : 1747022491,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79618864,
    "question_id" : 79613879,
    "body" : "<blockquote>\n<p>I have to admit that your solutions seems extremely complex and I neither understand your explanations nor the code. Is there really no easier way to just use an internal sqlite database in an android app? My previous code works just fine and is not complex at all. Can I not just use my previous code and just implement the onUpdate method when the db changes? Are there not built-in mechanismns to handle this scenarios which I think should be a common one</p>\n</blockquote>\n<p>First, there are no inbuilt solutions to handle updating via the asset.</p>\n<p>A relatively simple solution, using the <code>onUpdate</code> method would be to apply changes directly. This, at it's simplest, could be do this whenever <code>onUpdate</code> is called and to apply ALL new level rows irrespective of wheteher or not they have previously been applied by IGNOREing UNIQUE conflicts (duplicates).</p>\n<p>Consider the scenario (using exactly the same data as in the previous answer)</p>\n<ul>\n<li>That is two tables\n<ul>\n<li>a) game_data_level (with 3 columns; level, level_name and etc, importantly level is the primary key and is therefore UNIQUE so cannot be duplicated), and</li>\n<li>b) user_data (with 4 columns; id, highscore, unlocked_up_to and and_so_on)</li>\n</ul>\n</li>\n<li>The game_data_level, as implied by it's name, is what you want rolled out for new versions.</li>\n<li>The user_data table is the table you want retained from version to version.</li>\n<li>The original version (DBVERSION 1), the asset, has 3 levels and no user_data.</li>\n<li>When the next version is published, then 3 new levels are to be introduced.</li>\n</ul>\n<p>So consider:-</p>\n<pre><code>class DB_SQLite_Helper extends SQLiteOpenHelper {\n\n   public static final String DATABASE_NAME = &quot;internal_database.db&quot;;\n   public static final int DBVERSION = 1;\n   public static final  int OUCH = -666666666; /*********** ADDED **********/\n   private String OLD_DB_SUFFIX = &quot;_renamed&quot;;\n\n   public DB_SQLite_Helper(Context context) {\n      super(context,DATABASE_NAME,null,DBVERSION);\n      if (!ifDBExists(context)) {\n         if (!copyDBFromAssets(context)) {\n            throw new RuntimeException(&quot;Failed to Copy Database From Assets Folder&quot;);\n         }\n      }\n      mDB = this.getWritableDatabase();\n   }\n\n   SQLiteDatabase mDB;\n\n   @Override\n   public void onCreate(SQLiteDatabase sqLiteDatabase) {\n\n   }\n\n   @Override\n   public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {\n      Log.d(&quot;DBONUPGRD&quot;,&quot;On Upgrade has been invoked. Old version (the actual database) is &quot; +oldVersion +\n              &quot;. New version (as per the compiled APK) is &quot; + newVersion);\n      /* WHENEVER ONUPGRADE IS CALLED JUST CALL easyAsUpgrade */\n      easyAsUpgrade(sqLiteDatabase);\n   }\n\n   private void easyAsUpgrade(SQLiteDatabase db) {\n      /* ALWAYS try to apply new levels */\n      db.beginTransaction(); /* only do in a single transaction */\n      addNewLevel(db,4,&quot;NEW LEVEL 4 &quot;,&quot;Instroduced for V2&quot;);\n      addNewLevel(db,5,&quot;L5&quot;,&quot;blah&quot;);\n      addNewLevel(db,5,&quot;L5&quot;,&quot;blah&quot;); /* OOOPS but ignored so no issue */\n      addNewLevel(db,6,&quot;L6&quot;,&quot;blah&quot;); /* OOOPS but ignored so no issue */\n      db.setTransactionSuccessful(); /* prepare to end the transaction */\n      db.endTransaction(); /* end the transaction */\n   }\n\n   private void addNewLevel(SQLiteDatabase db, int column_Level, String column_level_name, String column_etc) {\n      ContentValues cv = new ContentValues();\n      cv.put(&quot;level&quot;,column_Level);\n      cv.put(&quot;level_name&quot;,column_level_name);\n      cv.put(&quot;etc&quot;,column_etc);\n      db.insert(&quot;game_data_level&quot;,null,cv);\n   }\n\n\n   ////////////////////////////////////////////////////////////////////////////\n   ....\n</code></pre>\n<p>i.e. you original code (cut off for brevity) PLUS changes to the <code>onUpgrade</code> method and 2 new methods <code>easyAsUpgrade</code> and <code>addNewLevel</code>.</p>\n<p>The <code>addNewLevel</code> method is what actually adds the new level to the actual database, it simplifies the code per level.\nThe <code>easyAsUpgrade</code> invokes the <code>addNewLevel</code> invocations, doing so within a single transaction (thus minimising the io overheads).</p>\n<ul>\n<li><p>It should be noted that the code purposely attempts to introduce a duplicate level 5, to show that it is ignored. This caters for the simplicity of always applying the new levels whether they already exist or not.\nThe <code>onUpgrade</code> simply invokes the <code>easyAsUpgrade</code>.</p>\n</li>\n<li><p><em><strong>Of course the code in both <code>easyAsUpgrade</code> and <code>addNewLevel</code> is specific to the database and would have to be changed to suit.</strong></em></p>\n</li>\n</ul>\n<p>So whenever <code>DBVERSION</code> is increased <code>onUpgrade</code> etc will be invoked.</p>\n<p>Using:-</p>\n<pre><code>public class MainActivity extends AppCompatActivity {\n\n    public static DB_SQLite_Helper sqLite_DB ;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        sqLite_DB = new DB_SQLite_Helper(this);\n        dumpTableData(); /* extract all of the data in the database to the log*/\n        addUserData(); /* Add some user data */\n        dumpTableData(); /* again, extract all of the data in the database to the log */\n    }\n\n    private void addUserData() {\n        if (DB_SQLite_Helper.DBVERSION == 1) {\n            SQLiteDatabase db = sqLite_DB.getWritableDatabase();\n            ContentValues cv = new ContentValues();\n            cv.put(&quot;highscore&quot;,1000);\n            cv.put(&quot;unlocked_up_to&quot;,3);\n            cv.put(&quot;and_so_on&quot;,&quot;blah&quot;);\n            db.insert(&quot;user_data&quot;,null,cv);\n        }\n    }\n\n    private void dumpTableData() {\n        SQLiteDatabase db = sqLite_DB.getWritableDatabase();\n        Cursor csr = db.query(&quot;game_data_level&quot;,null,null,null,null,null,null);\n        DatabaseUtils.dumpCursor(csr);\n        csr = db.query(&quot;user_data&quot;,null,null,null,null,null,null);\n        DatabaseUtils.dumpCursor(csr);\n        csr.close();\n    }\n}\n</code></pre>\n<p>The the log includes:-</p>\n<pre><code>2025-05-13 12:20:46.227 D/NODB MKDIRS: Database file not found, making directories.\n2025-05-13 12:20:46.228 D/CPYDBINFO: Starting attempt to cop database from the assets file.\n2025-05-13 12:20:46.228 D/CPYDBINFO: Initiating copy from asset fileinternal_database.db to /data/user/0/a.a.so79613879prepoluateddbretaininguseedata/databases/internal_database.db\n2025-05-13 12:20:46.229 D/CPYDBINFO: Read 20480 bytes. Wrote 20480 bytes.\n2025-05-13 12:20:46.267 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@55cf91b\n2025-05-13 12:20:46.268 I/System.out: 0 {\n2025-05-13 12:20:46.268 I/System.out:    level=1\n2025-05-13 12:20:46.268 I/System.out:    level_name=L1\n2025-05-13 12:20:46.268 I/System.out:    etc=blah\n2025-05-13 12:20:46.269 I/System.out: }\n2025-05-13 12:20:46.269 I/System.out: 1 {\n2025-05-13 12:20:46.269 I/System.out:    level=2\n2025-05-13 12:20:46.270 I/System.out:    level_name=L2\n2025-05-13 12:20:46.270 I/System.out:    etc=blah\n2025-05-13 12:20:46.270 I/System.out: }\n2025-05-13 12:20:46.271 I/System.out: 2 {\n2025-05-13 12:20:46.271 I/System.out:    level=3\n2025-05-13 12:20:46.271 I/System.out:    level_name=L3\n2025-05-13 12:20:46.271 I/System.out:    etc=blah\n2025-05-13 12:20:46.271 I/System.out: }\n2025-05-13 12:20:46.272 I/System.out: &lt;&lt;&lt;&lt;&lt;\n2025-05-13 12:20:46.272 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@25e7ab8\n2025-05-13 12:20:46.273 I/System.out: &lt;&lt;&lt;&lt;&lt;\n2025-05-13 12:20:46.286 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@dee8091\n2025-05-13 12:20:46.287 I/System.out: 0 {\n2025-05-13 12:20:46.287 I/System.out:    level=1\n2025-05-13 12:20:46.287 I/System.out:    level_name=L1\n2025-05-13 12:20:46.288 I/System.out:    etc=blah\n2025-05-13 12:20:46.288 I/System.out: }\n2025-05-13 12:20:46.288 I/System.out: 1 {\n2025-05-13 12:20:46.289 I/System.out:    level=2\n2025-05-13 12:20:46.290 I/System.out:    level_name=L2\n2025-05-13 12:20:46.290 I/System.out:    etc=blah\n2025-05-13 12:20:46.290 I/System.out: }\n2025-05-13 12:20:46.290 I/System.out: 2 {\n2025-05-13 12:20:46.290 I/System.out:    level=3\n2025-05-13 12:20:46.290 I/System.out:    level_name=L3\n2025-05-13 12:20:46.290 I/System.out:    etc=blah\n2025-05-13 12:20:46.291 I/System.out: }\n2025-05-13 12:20:46.291 I/System.out: &lt;&lt;&lt;&lt;&lt;\n2025-05-13 12:20:46.292 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@adf1bf6\n2025-05-13 12:20:46.293 I/System.out: 0 {\n2025-05-13 12:20:46.293 I/System.out:    id=1\n2025-05-13 12:20:46.294 I/System.out:    highscore=1000\n2025-05-13 12:20:46.295 I/System.out:    unlocked_up_to=3\n2025-05-13 12:20:46.295 I/System.out:    and_so_on=blah\n2025-05-13 12:20:46.295 I/System.out: }\n2025-05-13 12:20:46.295 I/System.out: &lt;&lt;&lt;&lt;&lt;\n</code></pre>\n<ul>\n<li>noting that <code>onUpgrade</code> etc were not invoked</li>\n<li>also that a single user_data row has been added mimicking the use adding data.</li>\n</ul>\n<p>changing <code>DBVERSION</code> to 2 and then running (equivalent to publishing the app) then the log includes:-</p>\n<pre><code>2025-05-13 12:25:32.225 D/DBONUPGRD: On Upgrade has been invoked. Old version (the actual database) is 1. New version (as per the compiled APK) is 2\n2025-05-13 12:25:32.236 E/SQLiteDatabase: Error inserting etc=blah level=5 level_name=L5\n    android.database.sqlite.SQLiteConstraintException: UNIQUE constraint failed: game_data_level.level (code 1555 SQLITE_CONSTRAINT_PRIMARYKEY)\n        at android.database.sqlite.SQLiteConnection.nativeExecuteForLastInsertedRowId(Native Method)\n        at android.database.sqlite.SQLiteConnection.executeForLastInsertedRowId(SQLiteConnection.java:961)\n        at android.database.sqlite.SQLiteSession.executeForLastInsertedRowId(SQLiteSession.java:790)\n        at android.database.sqlite.SQLiteStatement.executeInsert(SQLiteStatement.java:89)\n        at android.database.sqlite.SQLiteDatabase.insertWithOnConflict(SQLiteDatabase.java:1870)\n        at android.database.sqlite.SQLiteDatabase.insert(SQLiteDatabase.java:1739)\n        at a.a.so79613879prepoluateddbretaininguseedata.DB_SQLite_Helper.addNewLevel(DB_SQLite_Helper.java:67)\n        at a.a.so79613879prepoluateddbretaininguseedata.DB_SQLite_Helper.easyAsUpgrade(DB_SQLite_Helper.java:56)\n        at a.a.so79613879prepoluateddbretaininguseedata.DB_SQLite_Helper.onUpgrade(DB_SQLite_Helper.java:48)\n        at android.database.sqlite.SQLiteOpenHelper.getDatabaseLocked(SQLiteOpenHelper.java:416)\n        at android.database.sqlite.SQLiteOpenHelper.getWritableDatabase(SQLiteOpenHelper.java:316)\n        at a.a.so79613879prepoluateddbretaininguseedata.DB_SQLite_Helper.&lt;init&gt;(DB_SQLite_Helper.java:33)\n        at a.a.so79613879prepoluateddbretaininguseedata.MainActivity.onCreate(MainActivity.java:19)\n        at android.app.Activity.performCreate(Activity.java:8595)\n        at android.app.Activity.performCreate(Activity.java:8573)\n        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1456)\n        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3764)\n        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3922)\n        at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:103)\n        at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:139)\n        at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:96)\n        at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2443)\n        at android.os.Handler.dispatchMessage(Handler.java:106)\n        at android.os.Looper.loopOnce(Looper.java:205)\n        at android.os.Looper.loop(Looper.java:294)\n        at android.app.ActivityThread.main(ActivityThread.java:8177)\n        at java.lang.reflect.Method.invoke(Native Method)\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:552)\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:971)\n2025-05-13 12:25:32.249 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@dee8091\n2025-05-13 12:25:32.250 I/System.out: 0 {\n2025-05-13 12:25:32.250 I/System.out:    level=1\n2025-05-13 12:25:32.250 I/System.out:    level_name=L1\n2025-05-13 12:25:32.250 I/System.out:    etc=blah\n2025-05-13 12:25:32.250 I/System.out: }\n2025-05-13 12:25:32.251 I/System.out: 1 {\n2025-05-13 12:25:32.251 I/System.out:    level=2\n2025-05-13 12:25:32.252 I/System.out:    level_name=L2\n2025-05-13 12:25:32.252 I/System.out:    etc=blah\n2025-05-13 12:25:32.252 I/System.out: }\n2025-05-13 12:25:32.252 I/System.out: 2 {\n2025-05-13 12:25:32.253 I/System.out:    level=3\n2025-05-13 12:25:32.253 I/System.out:    level_name=L3\n2025-05-13 12:25:32.254 I/System.out:    etc=blah\n2025-05-13 12:25:32.254 I/System.out: }\n2025-05-13 12:25:32.254 I/System.out: 3 {\n2025-05-13 12:25:32.255 I/System.out:    level=4\n2025-05-13 12:25:32.255 I/System.out:    level_name=NEW LEVEL 4 \n2025-05-13 12:25:32.255 I/System.out:    etc=Instroduced for V2\n2025-05-13 12:25:32.255 I/System.out: }\n2025-05-13 12:25:32.256 I/System.out: 4 {\n2025-05-13 12:25:32.256 I/System.out:    level=5\n2025-05-13 12:25:32.257 I/System.out:    level_name=L5\n2025-05-13 12:25:32.257 I/System.out:    etc=blah\n2025-05-13 12:25:32.257 I/System.out: }\n2025-05-13 12:25:32.257 I/System.out: 5 {\n2025-05-13 12:25:32.258 I/System.out:    level=6\n2025-05-13 12:25:32.258 I/System.out:    level_name=L6\n2025-05-13 12:25:32.259 I/System.out:    etc=blah\n2025-05-13 12:25:32.259 I/System.out: }\n2025-05-13 12:25:32.260 I/System.out: &lt;&lt;&lt;&lt;&lt;\n2025-05-13 12:25:32.261 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@adf1bf6\n2025-05-13 12:25:32.262 I/System.out: 0 {\n2025-05-13 12:25:32.262 I/System.out:    id=1\n2025-05-13 12:25:32.262 I/System.out:    highscore=1000\n2025-05-13 12:25:32.263 I/System.out:    unlocked_up_to=3\n2025-05-13 12:25:32.263 I/System.out:    and_so_on=blah\n2025-05-13 12:25:32.264 I/System.out: }\n2025-05-13 12:25:32.264 I/System.out: &lt;&lt;&lt;&lt;&lt;\n2025-05-13 12:25:32.266 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@1c80bf7\n2025-05-13 12:25:32.267 I/System.out: 0 {\n2025-05-13 12:25:32.267 I/System.out:    level=1\n2025-05-13 12:25:32.267 I/System.out:    level_name=L1\n2025-05-13 12:25:32.268 I/System.out:    etc=blah\n2025-05-13 12:25:32.268 I/System.out: }\n2025-05-13 12:25:32.269 I/System.out: 1 {\n2025-05-13 12:25:32.269 I/System.out:    level=2\n2025-05-13 12:25:32.270 I/System.out:    level_name=L2\n2025-05-13 12:25:32.270 I/System.out:    etc=blah\n2025-05-13 12:25:32.270 I/System.out: }\n2025-05-13 12:25:32.270 I/System.out: 2 {\n2025-05-13 12:25:32.270 I/System.out:    level=3\n2025-05-13 12:25:32.271 I/System.out:    level_name=L3\n2025-05-13 12:25:32.271 I/System.out:    etc=blah\n2025-05-13 12:25:32.271 I/System.out: }\n2025-05-13 12:25:32.271 I/System.out: 3 {\n2025-05-13 12:25:32.272 I/System.out:    level=4\n2025-05-13 12:25:32.272 I/System.out:    level_name=NEW LEVEL 4 \n2025-05-13 12:25:32.273 I/System.out:    etc=Instroduced for V2\n2025-05-13 12:25:32.273 I/System.out: }\n2025-05-13 12:25:32.274 I/System.out: 4 {\n2025-05-13 12:25:32.274 I/System.out:    level=5\n2025-05-13 12:25:32.274 I/System.out:    level_name=L5\n2025-05-13 12:25:32.275 I/System.out:    etc=blah\n2025-05-13 12:25:32.275 I/System.out: }\n2025-05-13 12:25:32.276 I/System.out: 5 {\n2025-05-13 12:25:32.276 I/System.out:    level=6\n2025-05-13 12:25:32.277 I/System.out:    level_name=L6\n2025-05-13 12:25:32.277 I/System.out:    etc=blah\n2025-05-13 12:25:32.277 I/System.out: }\n2025-05-13 12:25:32.277 I/System.out: &lt;&lt;&lt;&lt;&lt;\n2025-05-13 12:25:32.279 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@ddc8a64\n2025-05-13 12:25:32.279 I/System.out: 0 {\n2025-05-13 12:25:32.280 I/System.out:    id=1\n2025-05-13 12:25:32.280 I/System.out:    highscore=1000\n2025-05-13 12:25:32.281 I/System.out:    unlocked_up_to=3\n2025-05-13 12:25:32.281 I/System.out:    and_so_on=blah\n2025-05-13 12:25:32.281 I/System.out: }\n2025-05-13 12:25:32.282 I/System.out: &lt;&lt;&lt;&lt;&lt;\n</code></pre>\n<ul>\n<li><p>As can be seen, the asset has not been copied/used as there is no need.</p>\n</li>\n<li><p>Likewise, <code>onUpgrade</code> has been called as the new version is 2 but the old version is 2</p>\n</li>\n<li><p>The dump of the data (both) show that the new levels have been added and importantly that the user_data row has been retained.</p>\n</li>\n<li><p>The error, which has been trapped, due to the UNIQUE conflict (duplicate level 5 row) has not affected the processing which has continued and added the level 6 row.</p>\n</li>\n<li><p>The asset file, is then only pertinent to new installs. It does not matter, in this scenario of just adding new levels, whether or not the asset file is changed accordingly.</p>\n</li>\n</ul>\n<p>If the DBVERSION is left at 2 and the App is uninstalled, and then run (i.e. a new installation of the App), then the log includes:-</p>\n<pre><code>2025-05-13 12:36:21.731 D/NODB MKDIRS: Database file not found, making directories.\n2025-05-13 12:36:21.731 D/CPYDBINFO: Starting attempt to cop database from the assets file.\n2025-05-13 12:36:21.732 D/CPYDBINFO: Initiating copy from asset fileinternal_database.db to /data/user/0/a.a.so79613879prepoluateddbretaininguseedata/databases/internal_database.db\n2025-05-13 12:36:21.733 D/CPYDBINFO: Read 20480 bytes. Wrote 20480 bytes.\n2025-05-13 12:36:21.780 D/DBONUPGRD: On Upgrade has been invoked. Old version (the actual database) is 1. New version (as per the compiled APK) is 2\n2025-05-13 12:36:21.785 E/SQLiteDatabase: Error inserting etc=blah level=5 level_name=L5\n.... \n2025-05-13 12:36:21.799 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@25e7ab8\n2025-05-13 12:36:21.800 I/System.out: 0 {\n2025-05-13 12:36:21.800 I/System.out:    level=1\n2025-05-13 12:36:21.800 I/System.out:    level_name=L1\n2025-05-13 12:36:21.800 I/System.out:    etc=blah\n2025-05-13 12:36:21.801 I/System.out: }\n2025-05-13 12:36:21.801 I/System.out: 1 {\n2025-05-13 12:36:21.801 I/System.out:    level=2\n2025-05-13 12:36:21.802 I/System.out:    level_name=L2\n2025-05-13 12:36:21.802 I/System.out:    etc=blah\n2025-05-13 12:36:21.802 I/System.out: }\n2025-05-13 12:36:21.803 I/System.out: 2 {\n2025-05-13 12:36:21.803 I/System.out:    level=3\n2025-05-13 12:36:21.803 I/System.out:    level_name=L3\n2025-05-13 12:36:21.803 I/System.out:    etc=blah\n2025-05-13 12:36:21.803 I/System.out: }\n2025-05-13 12:36:21.804 I/System.out: 3 {\n2025-05-13 12:36:21.804 I/System.out:    level=4\n2025-05-13 12:36:21.804 I/System.out:    level_name=NEW LEVEL 4 \n2025-05-13 12:36:21.804 I/System.out:    etc=Instroduced for V2\n2025-05-13 12:36:21.805 I/System.out: }\n2025-05-13 12:36:21.805 I/System.out: 4 {\n2025-05-13 12:36:21.805 I/System.out:    level=5\n2025-05-13 12:36:21.805 I/System.out:    level_name=L5\n2025-05-13 12:36:21.805 I/System.out:    etc=blah\n2025-05-13 12:36:21.806 I/System.out: }\n2025-05-13 12:36:21.806 I/System.out: 5 {\n2025-05-13 12:36:21.806 I/System.out:    level=6\n2025-05-13 12:36:21.806 I/System.out:    level_name=L6\n2025-05-13 12:36:21.806 I/System.out:    etc=blah\n2025-05-13 12:36:21.807 I/System.out: }\n2025-05-13 12:36:21.807 I/System.out: &lt;&lt;&lt;&lt;&lt;\n2025-05-13 12:36:21.807 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@dee8091\n2025-05-13 12:36:21.808 I/System.out: &lt;&lt;&lt;&lt;&lt;\n2025-05-13 12:36:21.808 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@adf1bf6\n2025-05-13 12:36:21.809 I/System.out: 0 {\n2025-05-13 12:36:21.810 I/System.out:    level=1\n2025-05-13 12:36:21.810 I/System.out:    level_name=L1\n2025-05-13 12:36:21.810 I/System.out:    etc=blah\n2025-05-13 12:36:21.810 I/System.out: }\n2025-05-13 12:36:21.810 I/System.out: 1 {\n2025-05-13 12:36:21.810 I/System.out:    level=2\n2025-05-13 12:36:21.810 I/System.out:    level_name=L2\n2025-05-13 12:36:21.811 I/System.out:    etc=blah\n2025-05-13 12:36:21.811 I/System.out: }\n2025-05-13 12:36:21.811 I/System.out: 2 {\n2025-05-13 12:36:21.812 I/System.out:    level=3\n2025-05-13 12:36:21.812 I/System.out:    level_name=L3\n2025-05-13 12:36:21.812 I/System.out:    etc=blah\n2025-05-13 12:36:21.812 I/System.out: }\n2025-05-13 12:36:21.812 I/System.out: 3 {\n2025-05-13 12:36:21.813 I/System.out:    level=4\n2025-05-13 12:36:21.814 I/System.out:    level_name=NEW LEVEL 4 \n2025-05-13 12:36:21.814 I/System.out:    etc=Instroduced for V2\n2025-05-13 12:36:21.815 I/System.out: }\n2025-05-13 12:36:21.815 I/System.out: 4 {\n2025-05-13 12:36:21.815 I/System.out:    level=5\n2025-05-13 12:36:21.815 I/System.out:    level_name=L5\n2025-05-13 12:36:21.816 I/System.out:    etc=blah\n2025-05-13 12:36:21.816 I/System.out: }\n2025-05-13 12:36:21.816 I/System.out: 5 {\n2025-05-13 12:36:21.816 I/System.out:    level=6\n2025-05-13 12:36:21.816 I/System.out:    level_name=L6\n2025-05-13 12:36:21.817 I/System.out:    etc=blah\n2025-05-13 12:36:21.817 I/System.out: }\n2025-05-13 12:36:21.817 I/System.out: &lt;&lt;&lt;&lt;&lt;\n2025-05-13 12:36:21.818 I/System.out: &gt;&gt;&gt;&gt;&gt; Dumping cursor android.database.sqlite.SQLiteCursor@1c80bf7\n2025-05-13 12:36:21.818 I/System.out: &lt;&lt;&lt;&lt;&lt;\n</code></pre>\n<ul>\n<li>In short a combination in that the asset has been copied and (as the asset has a database at version 1) <code>onUpgrade</code> has been called.</li>\n<li><em>The error dump lines have been removed for brevity</em></li>\n</ul>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 6077735,
      "reputation" : 57861,
      "user_id" : 4744514,
      "user_type" : "registered",
      "accept_rate" : 96,
      "profile_image" : "https://i.sstatic.net/RQ2Np.jpg?s=256",
      "display_name" : "MikeT",
      "link" : "https://stackoverflow.com/users/4744514/miket"
    },
    "creation_date" : 1747104100,
    "last_activity_date" : 1747104100,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79615046" : [ {
      "comment_id" : 140419918,
      "post_id" : 79615046,
      "body" : "@VanessaF see 2nd answer for answer to the latest comment. i.e. Perhaps the simplest way.",
      "score" : 0,
      "owner" : {
        "account_id" : 6077735,
        "reputation" : 57861,
        "user_id" : 4744514,
        "user_type" : "registered",
        "accept_rate" : 96,
        "profile_image" : "https://i.sstatic.net/RQ2Np.jpg?s=256",
        "display_name" : "MikeT",
        "link" : "https://stackoverflow.com/users/4744514/miket"
      },
      "creation_date" : 1747104278,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140417375,
      "post_id" : 79615046,
      "body" : "Thanks a lot for your answer and great effort. I really appreciate it. I have to admit that your solutions seems extremely complex and I neither understand your explanations nor the code. Is there really no easier way to just use an internal sqlite database in an android app? My previous code works just fine and is not complex at all. Can I not just use my previous code and just implement the onUpdate method when the db changes? Are there not built-in mechanismns to handle this scenarios which I think should be a common one.",
      "score" : 0,
      "owner" : {
        "account_id" : 13060317,
        "reputation" : 717,
        "user_id" : 9437740,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/6yvEH.png?s=256",
        "display_name" : "VanessaF",
        "link" : "https://stackoverflow.com/users/9437740/vanessaf"
      },
      "creation_date" : 1747043386,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140416550,
      "post_id" : 79615046,
      "body" : "@VanessaF answer updated. In short simple enough to adapt your helper, as is demonstrated.",
      "score" : 0,
      "owner" : {
        "account_id" : 6077735,
        "reputation" : 57861,
        "user_id" : 4744514,
        "user_type" : "registered",
        "accept_rate" : 96,
        "profile_image" : "https://i.sstatic.net/RQ2Np.jpg?s=256",
        "display_name" : "MikeT",
        "link" : "https://stackoverflow.com/users/4744514/miket"
      },
      "creation_date" : 1747022244,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140413190,
      "post_id" : 79615046,
      "body" : "Thanks Mike for your answer. It might be possible that I update the db itself in future. It is for a game app and the sqlite db contains the level designs. So it might be possible that I will change some levels or add a further level. The SQlite db also contains internal progress information of the player in a separate table (like unlocked levels, highscores etc). In case of a db update, this information should be tranferred to the new database. I&#39;m sceptical that with my current code this will work properly (at least 2 LLM tell me that the design is bad but don&#39;t offer good solutions)",
      "score" : 0,
      "owner" : {
        "account_id" : 13060317,
        "reputation" : 717,
        "user_id" : 9437740,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/6yvEH.png?s=256",
        "display_name" : "VanessaF",
        "link" : "https://stackoverflow.com/users/9437740/vanessaf"
      },
      "creation_date" : 1746867906,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79618864" : [ {
      "comment_id" : 140623362,
      "post_id" : 79618864,
      "body" : "Thanks Mike for your comment. So when using my current approach, changes by the user will be stored in the database and the user sees those changes. But when I as the maintainer of the app introduce an altered database in an update, the user will not see his/her locally made changes in the database?",
      "score" : 0,
      "owner" : {
        "account_id" : 13060317,
        "reputation" : 717,
        "user_id" : 9437740,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/6yvEH.png?s=256",
        "display_name" : "VanessaF",
        "link" : "https://stackoverflow.com/users/9437740/vanessaf"
      },
      "creation_date" : 1753696131,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140620807,
      "post_id" : 79618864,
      "body" : "@VanessaF Changes made to the database will persist but only as per the current database. If you need changes to be kept when introducing changes via an asset then you have to merge the new asset with the existing to keep both sets of changes and thus introduce complexity.",
      "score" : 0,
      "owner" : {
        "account_id" : 6077735,
        "reputation" : 57861,
        "user_id" : 4744514,
        "user_type" : "registered",
        "accept_rate" : 96,
        "profile_image" : "https://i.sstatic.net/RQ2Np.jpg?s=256",
        "display_name" : "MikeT",
        "link" : "https://stackoverflow.com/users/4744514/miket"
      },
      "creation_date" : 1753560454,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140619878,
      "post_id" : 79618864,
      "body" : "Thanks Mike for your comments. Any comment to my last comment? I&#39;ll highly appreciate any further comment from you.",
      "score" : 0,
      "owner" : {
        "account_id" : 13060317,
        "reputation" : 717,
        "user_id" : 9437740,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/6yvEH.png?s=256",
        "display_name" : "VanessaF",
        "link" : "https://stackoverflow.com/users/9437740/vanessaf"
      },
      "creation_date" : 1753519814,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140611013,
      "post_id" : 79618864,
      "body" : "Thanks Mike for your comments and effort. I really appreciate it. So if I understand you correclty, my current approach is not suitable when I alter something on the db file because the user does not see this version. What if the users alters something via the java code on the database internally? Will this be persistent? So the app contains a predefined database file with some rows. When the user changes something via the app (which triggers java code to alter or insert rows), will this be persistent even when using my current approach?",
      "score" : 0,
      "owner" : {
        "account_id" : 13060317,
        "reputation" : 717,
        "user_id" : 9437740,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/6yvEH.png?s=256",
        "display_name" : "VanessaF",
        "link" : "https://stackoverflow.com/users/9437740/vanessaf"
      },
      "creation_date" : 1753254666,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140610117,
      "post_id" : 79618864,
      "body" : "@VanessaF You are basically back to the original answers i.e. you have to manage conversion to maintain the users changes.",
      "score" : 0,
      "owner" : {
        "account_id" : 6077735,
        "reputation" : 57861,
        "user_id" : 4744514,
        "user_type" : "registered",
        "accept_rate" : 96,
        "profile_image" : "https://i.sstatic.net/RQ2Np.jpg?s=256",
        "display_name" : "MikeT",
        "link" : "https://stackoverflow.com/users/4744514/miket"
      },
      "creation_date" : 1753213685,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140608216,
      "post_id" : 79618864,
      "body" : "Thanks Mike for your comment. What if something is altered or inserted in the sqlite database by the user while using the app. Will the user see the new version of the database or just the old one? When I alter something in the database by adjusting the file, the user does not see the new version until I change the name of the db file and the corresponding reference string name in the java code",
      "score" : 0,
      "owner" : {
        "account_id" : 13060317,
        "reputation" : 717,
        "user_id" : 9437740,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/6yvEH.png?s=256",
        "display_name" : "VanessaF",
        "link" : "https://stackoverflow.com/users/9437740/vanessaf"
      },
      "creation_date" : 1753172440,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140607383,
      "post_id" : 79618864,
      "body" : "@VanessaF Uninstalling the App would delete the App&#39;s files which includes the database files.",
      "score" : 0,
      "owner" : {
        "account_id" : 6077735,
        "reputation" : 57861,
        "user_id" : 4744514,
        "user_type" : "registered",
        "accept_rate" : 96,
        "profile_image" : "https://i.sstatic.net/RQ2Np.jpg?s=256",
        "display_name" : "MikeT",
        "link" : "https://stackoverflow.com/users/4744514/miket"
      },
      "creation_date" : 1753138434,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140605586,
      "post_id" : 79618864,
      "body" : "Thanks a lot for your comment and effort. I really appreciate it. Maybe one way is to tell the user (e.g. in an info section of the app or on google play) to uninstall the app before a possible update. Will this delete all former database files? Or you could ask the user to delte the cache of the app via the android setting menu. What would be your recommendation?",
      "score" : 0,
      "owner" : {
        "account_id" : 13060317,
        "reputation" : 717,
        "user_id" : 9437740,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/6yvEH.png?s=256",
        "display_name" : "VanessaF",
        "link" : "https://stackoverflow.com/users/9437740/vanessaf"
      },
      "creation_date" : 1753091689,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140603098,
      "post_id" : 79618864,
      "body" : "@VanessaF 50 versions would have something 50 times the use of storage, but would not really affect performance. Ideally you would delete the redundant files but that would likely fall into the realms of being too complex but could simply be a routine/function invoked when checking for the existence of the database.",
      "score" : 0,
      "owner" : {
        "account_id" : 6077735,
        "reputation" : 57861,
        "user_id" : 4744514,
        "user_type" : "registered",
        "accept_rate" : 96,
        "profile_image" : "https://i.sstatic.net/RQ2Np.jpg?s=256",
        "display_name" : "MikeT",
        "link" : "https://stackoverflow.com/users/4744514/miket"
      },
      "creation_date" : 1752972104,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140601967,
      "post_id" : 79618864,
      "body" : "Thanks Mike for your comment. Is there an easy way to replace the old db? And do older db files only affect the memory requiremenets of the app or does it have other (maybe performance) effects when doing this multiple times e.g. having 50 versions of a database due to frequent updates of the db",
      "score" : 0,
      "owner" : {
        "account_id" : 13060317,
        "reputation" : 717,
        "user_id" : 9437740,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/6yvEH.png?s=256",
        "display_name" : "VanessaF",
        "link" : "https://stackoverflow.com/users/9437740/vanessaf"
      },
      "creation_date" : 1752919091,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140601229,
      "post_id" : 79618864,
      "body" : "@VanessaF Yes, BUT, the old file(s) will remain, they will not be replaced.",
      "score" : 0,
      "owner" : {
        "account_id" : 6077735,
        "reputation" : 57861,
        "user_id" : 4744514,
        "user_type" : "registered",
        "accept_rate" : 96,
        "profile_image" : "https://i.sstatic.net/RQ2Np.jpg?s=256",
        "display_name" : "MikeT",
        "link" : "https://stackoverflow.com/users/4744514/miket"
      },
      "creation_date" : 1752874646,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140599273,
      "post_id" : 79618864,
      "body" : "Hi Mike, it&#39;s me again. I have a follow-up question: When using my inital approach (posted in the question) with the manual copying from the asset folder and if I want to update the database such that the old one is completely replaced by the new one, will it be sufficient just to rename the database in the asset folder (e.g.  &quot;internal_database_v2.db&quot;) and adjust the name in the SQLite Helper class (e.g.     <code>public static final String DATABASE_NAME = &quot;internal_database_v2.db&quot;;</code>)",
      "score" : 0,
      "owner" : {
        "account_id" : 13060317,
        "reputation" : 717,
        "user_id" : 9437740,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/6yvEH.png?s=256",
        "display_name" : "VanessaF",
        "link" : "https://stackoverflow.com/users/9437740/vanessaf"
      },
      "creation_date" : 1752826853,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140433049,
      "post_id" : 79618864,
      "body" : "Thanks a lot for your answers and effort.  Do you have experience with the android-sqlite-asset-helper framework (<a href=\"https://github.com/jgilfelt/android-sqlite-asset-helper\" rel=\"nofollow noreferrer\">github.com/jgilfelt/android-sqlite-asset-helper</a>). I think it might be helpful for my purposes. What do you think? Or is it possible to just change the onUpgrade method in my code? Overall your suggested approach makes use of many additional methods that introduce some complexity and as I don&#39;t fully understand what they are doing and how, i will have struggels adjusting them to my db. So maybe a simplified adjustment of your approach or the framework might work.",
      "score" : 0,
      "owner" : {
        "account_id" : 13060317,
        "reputation" : 717,
        "user_id" : 9437740,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/6yvEH.png?s=256",
        "display_name" : "VanessaF",
        "link" : "https://stackoverflow.com/users/9437740/vanessaf"
      },
      "creation_date" : 1747410656,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140426612,
      "post_id" : 79618864,
      "body" : "<b>3)</b> this just inserts a row whenever DBVERSION is 1. Solely to mimic the addition of some initial user data, to show for subsequent versions that it is kept.",
      "score" : 0,
      "owner" : {
        "account_id" : 6077735,
        "reputation" : 57861,
        "user_id" : 4744514,
        "user_type" : "registered",
        "accept_rate" : 96,
        "profile_image" : "https://i.sstatic.net/RQ2Np.jpg?s=256",
        "display_name" : "MikeT",
        "link" : "https://stackoverflow.com/users/4744514/miket"
      },
      "creation_date" : 1747255944,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140426610,
      "post_id" : 79618864,
      "body" : "<b>1)</b> Not a need but imo tidier (perhaps not the best name), <b>2)</b> as per in <code>easyAsUpgrade</code> which calls <code>addNewLevel</code> (3 columns) i.e. 1 put per column in the ContentValues. <b>4)</b> you don&#39;t need it, used to show what the tables contain by extracting data into a Cursor and using the <code>dumpCursor</code> method i.e. easy way to show the data (see the logs for results).",
      "score" : 0,
      "owner" : {
        "account_id" : 6077735,
        "reputation" : 57861,
        "user_id" : 4744514,
        "user_type" : "registered",
        "accept_rate" : 96,
        "profile_image" : "https://i.sstatic.net/RQ2Np.jpg?s=256",
        "display_name" : "MikeT",
        "link" : "https://stackoverflow.com/users/4744514/miket"
      },
      "creation_date" : 1747255788,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140420786,
      "post_id" : 79618864,
      "body" : "By the way: I have added a screenshot of the database schema. Maybe this helps a little to see how the db is structured and what values might change in case of an update",
      "score" : 0,
      "owner" : {
        "account_id" : 13060317,
        "reputation" : 717,
        "user_id" : 9437740,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/6yvEH.png?s=256",
        "display_name" : "VanessaF",
        "link" : "https://stackoverflow.com/users/9437740/vanessaf"
      },
      "creation_date" : 1747128995,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140420772,
      "post_id" : 79618864,
      "body" : "Thanks a lot Mike for your great effort. I really appreciate it. I still have to admit that I am struggeling to understand your approach. 1)Why do I need the method <code>easyAsUpgrade</code>? 2)If a new level is added, there are several columns in the talbe. How can I add them in the <code>onUpgrade</code> method? 3)In you <code>addUserData</code> method you use the hardcoded <code>if (DB_SQLite_Helper.DBVERSION == 1)</code> version number 1. But this might change from update to update. Further you use specific values for highscore but I don&#39;t know them in advance 4) Why do I need <code>dumpTableData</code> and where is it called",
      "score" : 0,
      "owner" : {
        "account_id" : 13060317,
        "reputation" : 717,
        "user_id" : 9437740,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/6yvEH.png?s=256",
        "display_name" : "VanessaF",
        "link" : "https://stackoverflow.com/users/9437740/vanessaf"
      },
      "creation_date" : 1747128771,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}