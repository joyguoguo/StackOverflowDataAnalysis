{
  "question" : {
    "question_id" : 79847295,
    "title" : "Stuck on Recursive State Design for a Zigzag Alternating-Sum Path in a Binary Tree",
    "body" : "<p>I’m trying to reason about a recursive algorithm on trees and I feel like I’m missing something subtle.</p>\n<p>I have an immutable binary tree (not a BST) where each node has an <code>int value</code>. I want to compute the maximum alternating-sum zigzag path anywhere in the tree. A path is any downward path (start at any node, go only to children). The path must strictly alternate left/right at each step. The sum alternates signs starting with <code>+</code> at the starting node: <code>+v0 − v1 + v2 − v3 …</code>. Single-node paths are allowed.</p>\n<p>Here’s the code I <em>thought</em> should work, but it fails on some cases with negative values and when the best path doesn’t start at the root.</p>\n<pre><code>int maxZigZagSum(Node root) {\n    return helper(root, true, 0);\n}\n\nint helper(Node node, boolean goLeft, int sign) {\n    if (node == null) return 0;\n\n    int cur = (sign == 0 ? node.val : -node.val);\n\n    int next;\n    if (goLeft) {\n        next = helper(node.left, false, 1 - sign);\n    } else {\n        next = helper(node.right, true, 1 - sign);\n    }\n\n    return Math.max(cur, cur + next);\n}\n</code></pre>\n<p>I tried calling <code>helper</code> twice at the root (once starting left, once right), but that still doesn’t fix all cases. Intuitively, I feel like I need to track <em>both</em> “last direction” and “parity of the sum”, but whenever I add more parameters the recursion explodes and I can’t keep it O(n). I also don’t see how to handle paths that start in the middle of the tree without restarting recursion from every node, which would be O(n²).</p>\n<p>What minimal information needs to be returned from each recursive call so that the parent can combine results correctly? How do you structure the recursion so that paths can start at any node, but you still only traverse the tree once? Why doesn’t the “return the best path starting here” approach work without additional state?</p>\n",
    "tags" : [ "java", "recursion", "binary-tree" ],
    "owner" : {
      "account_id" : 45012655,
      "reputation" : 51,
      "user_id" : 32053083,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/299ec5f93e1efb0942f01a942b020612?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "sunmicrosystemsfan101",
      "link" : "https://stackoverflow.com/users/32053083/sunmicrosystemsfan101"
    },
    "is_answered" : false,
    "view_count" : 33,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1765815019,
    "creation_date" : 1765754354,
    "link" : "https://stackoverflow.com/questions/79847295/stuck-on-recursive-state-design-for-a-zigzag-alternating-sum-path-in-a-binary-tr",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79847826,
    "question_id" : 79847295,
    "body" : "<p>I've spent some time trying to fix the logic of your code, but I haven't been able to (that's how incapable I am), so I can only show you a different way to achieve the result.</p>\n<pre><code>int max = 0;\n\nvoid maxZigZagSum( Node root, int value, boolean sum ) {\n   if( root != null ) {\n      if( sum ) {\n          value += root.value;\n      }\n      else  {\n         value -= root.value;\n      }\n      maxZigZagSum( root.left, value, ! sum );\n      maxZigZagSum( root.right, value, ! sum );\n   }\n   else {\n      if( value &gt; max ) {\n         max = value;\n      }\n   }\n}\n</code></pre>\n<p>I think the code is self-explanatory. If the node turns out to be null, we update (if applicable) the value of <strong>max</strong>. If it is not null, we update the value of <strong>value</strong> based on the state of <strong>sum</strong>, and we recursively apply this to both children, inverting the value of <strong>sum</strong>.</p>\n<p>This is the code I implemented for testing purposes:</p>\n<pre><code>class Node {\n\n   Node( int val, Node lef, Node rig ) {\n      value = val;\n      left = lef;\n      right = rig;\n   }\n   int value;\n   Node left, right;\n}\n\nvoid init() {\n   Node root = new Node( 0,\n           new Node( 1, new Node( 3, null, null ), new Node( 2, null, null ) ),\n           new Node( 4, new Node( 5, null, null ), new Node( 6, null, null ) )\n   );\n   maxZigZagSum( root, 0, true );\n   System.out.println( max );\n}\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 10843443,
      "reputation" : 924,
      "user_id" : 20882864,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/CCQCy.jpg?s=256",
      "display_name" : "Marce Puente",
      "link" : "https://stackoverflow.com/users/20882864/marce-puente"
    },
    "creation_date" : 1765815019,
    "last_activity_date" : 1765815019,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140903765,
    "post_id" : 79847295,
    "body" : "this question lacks a better explanation: what should be calculated, including an example of a tree and respective paths that must be considered -- posted code seems incomplete: starts from only one node, and only starts to the left",
    "score" : 0,
    "owner" : {
      "account_id" : 31180,
      "reputation" : 29752,
      "user_id" : 85421,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/kKvXH.gif?s=256",
      "display_name" : "user85421",
      "link" : "https://stackoverflow.com/users/85421/user85421"
    },
    "creation_date" : 1765786554,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}