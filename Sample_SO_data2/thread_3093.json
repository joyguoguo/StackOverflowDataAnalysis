{
  "question" : {
    "question_id" : 79574498,
    "title" : "Regular expression groups are not capturing properly",
    "body" : "<p>I have following expression:</p>\n<pre><code>String formula7 = &quot;(^TBC10.Actual.Value_&lt;&lt;Year&gt;&gt; == \\&quot;Final\\&quot; ? ^FN10101.Actual.Value_&lt;&lt;Year&gt;&gt; : ^INT805.Consensus.Value_&lt;&lt;Year&gt;&gt;) - (^PH2003 + ^PH2005 + ^PH2011 + ^PH2010 + ^PH2837 + ^PH2838 + ^PH2839 + ^PH2006 + ^PH2089)&quot;;\n</code></pre>\n<p>Now I want to extract groups from this string like the following:</p>\n<pre><code>// First bracket\n1.( ^ TBC10.Actual.Value_ &lt;&lt; Year &gt;&gt; == &quot;Final&quot; ? ^ FN10101.Actual.Value_ &lt;&lt; Year &gt;&gt; : ^ INT805.Consensus.Value_ &lt;&lt; Year &gt;&gt; )\n\n// Condition\n2. TBC10.Actual.Value_ &lt;&lt; Year &gt;&gt; == &quot;Final&quot;\n\n// Condition left side\n3. TBC10.Actual.Value_ &lt;&lt; Year &gt;&gt;\n\n// Condition right side\n4. Final\n\n// Trure condition value\n5. FN10101.Actual.Value_ &lt;&lt; Year &gt;&gt;\n\n// False condition value\n6. INT805.Consensus.Value_ &lt;&lt; Year &gt;&gt;\n\n// Other part\n7. - ( ^ PH2003 + ^ PH2005 + ^ PH2011 + ^ PH2010 + ^ PH2837 + ^ PH2838 + ^ PH2839 + ^ PH2006 + ^ PH2089)\n</code></pre>\n<p>To achieve this, I made the following regular expression</p>\n<pre><code>// Start with any characters. Then space. But it is optional. Then == sign. Then space. But it is optional.\n// Then contain any characters. Then space. But it is optional. Then contains ?. Then space. But it is\n// optional. Then contain any characters. Then space. But it is optional. Then contains : Then space. But it\n// Is optional. Then contain any characters. Then any characters. But it is optional\npublic static final String CONDITION_REGEX = &quot;((((.*)\\\\s?==\\\\s?(.*))\\\\s?\\\\?\\\\s?(.*)\\\\s?:\\\\s?(.*))(.*)?)&quot;;\npublic static final Pattern CONDITION_PATTERN = Pattern.compile(CONDITION_REGEX);\n</code></pre>\n<p>But when I run it, I am getting the following output</p>\n<pre><code>// replace caret(^), double comma(&quot;) and any white space from the string\nString formula = formula7.replaceAll(&quot;[\\\\^\\&quot;\\\\s]&quot;, &quot;&quot;);\n\nMatcher matcher = CONDITION_PATTERN.matcher(formula);\nif (matcher.matches()) {\n\n  // (TBC10.Actual.Value_&lt;&lt;Year&gt;&gt;==Final?FN10101.Actual.Value_&lt;&lt;Year&gt;&gt;:INT805.Consensus.Value_&lt;&lt;Year&gt;&gt;)-(PH2003+PH2005+PH2011+PH2010+PH2837+PH2838+PH2839+PH2006+PH2089)\n  String group1 = matcher.group(1);\n\n  // (TBC10.Actual.Value_&lt;&lt;Year&gt;&gt;==Final?FN10101.Actual.Value_&lt;&lt;Year&gt;&gt;:INT805.Consensus.Value_&lt;&lt;Year&gt;&gt;)-(PH2003+PH2005+PH2011+PH2010+PH2837+PH2838+PH2839+PH2006+PH2089)\n  String condition = matcher.group(2);\n\n  // (TBC10.Actual.Value_&lt;&lt;Year&gt;&gt;==Final\n  String conditionLeftSide = matcher.group(3);\n\n  // (TBC10.Actual.Value_&lt;&lt;Year&gt;&gt;\n  String conditionRightSide = matcher.group(4);\n\n  // Final\n  String trueCondition = matcher.group(5);\n\n  // FN10101.Actual.Value_&lt;&lt;Year&gt;&gt;\n  String condition6 = matcher.group(6);\n\n  // INT805.Consensus.Value_&lt;&lt;Year&gt;&gt;)-(PH2003+PH2005+PH2011+PH2010+PH2837+PH2838+PH2839+PH2006+PH2089)\n  String condition7 = matcher.group(7);\n\n  // &quot;&quot;\n  String condition8 = matcher.group(8);\n}\n</code></pre>\n<p>What I am doing wrong and how can I correct the <code>Regex</code> to achieve the result? I think <code>()</code> represent groups in <code>Regex</code>. And for each group I used <code>()</code>.</p>\n",
    "tags" : [ "java", "regex", "regex-group" ],
    "owner" : {
      "account_id" : 980746,
      "reputation" : 8770,
      "user_id" : 1000510,
      "user_type" : "registered",
      "accept_rate" : 76,
      "profile_image" : "https://i.sstatic.net/Bhpgn.png?s=256",
      "display_name" : "Basit",
      "link" : "https://stackoverflow.com/users/1000510/basit"
    },
    "is_answered" : true,
    "view_count" : 237,
    "answer_count" : 2,
    "score" : 5,
    "last_activity_date" : 1754999976,
    "creation_date" : 1744698810,
    "link" : "https://stackoverflow.com/questions/79574498/regular-expression-groups-are-not-capturing-properly",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79576190,
    "question_id" : 79574498,
    "body" : "<p>APPROACH:</p>\n<ul>\n<li>I matched the contents in the two parenthesis and capture the desired strings into <em>named capture groups</em>, <code>(?&lt;name&gt;...)</code> to help bring clarity.</li>\n<li>I used the <em>negated character classes</em>, <code>[^...]+</code>, between the anchors instead of <code>.*</code> to be more specific and to have more control over the matching between the anchors.</li>\n<li>I used the following strings/characters as anchors:\n<ul>\n<li>Beginning of string <code>^</code>.</li>\n<li><code>(^</code> Begin matching the first bracket from.</li>\n<li><code>==</code> Separates conditions on left and right sides.</li>\n<li><code>?</code> Separates conditions from values</li>\n<li><code>:</code> Separates True and False value</li>\n<li><code>)</code>  End first bracket.</li>\n<li><code>- (</code>  Begin Other Parts, second bracket.</li>\n<li><code>)</code>  End match.</li>\n</ul>\n</li>\n</ul>\n<p>REGEX PATTERN (Java 8 Flavor):</p>\n<pre><code>(?&lt;firstBracket&gt;^\\(\\^(?&lt;condition&gt;(?&lt;conditionLeftSide&gt;[^=\\n]+[^= ])[ ]*?==[ ]*(?&lt;conditionRightSide&gt;[^? ][^?]+[^? ]))[ ]*[?][ ]*(?&lt;TrueConditionValue&gt;[^:]+[^: ])[ ]*:[ ]*(?&lt;falseConditionValue&gt;[^)]+)\\))[ ]*(?&lt;otherPart&gt;-[ ]*\\([^)]+\\))\n\n</code></pre>\n<p><em>Regex Demo:</em> <a href=\"https://regex101.com/r/yFC663/3\" rel=\"nofollow noreferrer\">https://regex101.com/r/yFC663/3</a></p>\n<p>TEST STRING:</p>\n<pre><code>(^TBC10.Actual.Value_&lt;&lt;Year&gt;&gt; == \\&quot;Final\\&quot; ? ^FN10101.Actual.Value_&lt;&lt;Year&gt;&gt; : ^INT805.Consensus.Value_&lt;&lt;Year&gt;&gt;) - (^PH2003 + ^PH2005 + ^PH2011 + ^PH2010 + ^PH2837 + ^PH2838 + ^PH2839 + ^PH2006 + ^PH2089)\n\n</code></pre>\n<p>MATCH AND GROUPS:</p>\n<pre><code>MATCH    0-203  \n(^TBC10.Actual.Value_&lt;&lt;Year&gt;&gt; == \\&quot;Final\\&quot; ? ^FN10101.Actual.Value_&lt;&lt;Year&gt;&gt; : ^INT805.Consensus.Value_&lt;&lt;Year&gt;&gt;) - (^PH2003 + ^PH2005 + ^PH2011 + ^PH2010 + ^PH2837 + ^PH2838 + ^PH2839 + ^PH2006 + ^PH2089)\n\nfirstBracket    0-111   \n(^TBC10.Actual.Value_&lt;&lt;Year&gt;&gt; == \\&quot;Final\\&quot; ? ^FN10101.Actual.Value_&lt;&lt;Year&gt;&gt; : ^INT805.Consensus.Value_&lt;&lt;Year&gt;&gt;)\n\ncondition    2-42   \nTBC10.Actual.Value_&lt;&lt;Year&gt;&gt; == \\&quot;Final\\&quot;\n\nconditionLeftSide    2-29   \nTBC10.Actual.Value_&lt;&lt;Year&gt;&gt;\n\nconditionRightSide    33-42 \n\\&quot;Final\\&quot;\n\ntrueConditionValue    45-75 \n^FN10101.Actual.Value_&lt;&lt;Year&gt;&gt;\n\nfalseConditionValue    78-110   \n^INT805.Consensus.Value_&lt;&lt;Year&gt;&gt;\n\notherPart     112-203   \n- (^PH2003 + ^PH2005 + ^PH2011 + ^PH2010 + ^PH2837 + ^PH2838 + ^PH2839 + ^PH2006 + ^PH2089)\n</code></pre>\n<p>REGEX PATTERN NOTES:</p>\n<ul>\n<li><code>(?&lt;firstBracket&gt;</code> Begin <em>named capturing group</em> ```(?...)````\n<ul>\n<li>````^``` Match beginning of string.</li>\n<li><code>\\(</code> Match literal <code>(</code>.\n*<code>\\^</code> Match literal <code>^</code>.</li>\n<li><code>(?&lt;condition&gt;</code> Begin <em>named capture group</em>.\n<ul>\n<li><code>(?&lt;conditionLeftSide&gt;</code> Begin <em>named capture group</em>.\n<ul>\n<li><code>[^=\\n]+</code> <em>Negated character class</em> <code>[^...]</code>. Match any character that is not literal <code>=</code> or newline character <code>\\n</code> 1 or more times (<code>+</code>).</li>\n<li><code>[^= ]</code> <em>Negated character class</em> <code>[^...]</code>. Match any character that is not literal <code>=</code> or literal space character <code> </code> 1 or more times (<code>+</code>).</li>\n</ul>\n</li>\n<li><code>)</code></li>\n<li><code>[ ]*</code> Match literal space character <code> </code> 0 or more times (<code>*</code>).</li>\n<li><code>==</code> Match literal <code>==</code>.</li>\n<li><code>[ ]*</code> Match literal space character <code> </code> 0 or more times (<code>*</code>).</li>\n<li><code>(?&lt;conditionRightSide&gt;</code> Begin <em>named capture group</em>.\n<ul>\n<li><code>[^? ]</code> <em>Negated character class</em> <code>[^...]</code>. Match any character that is not literal <code>?</code> or literal space character <code> </code> to make sure the capture does not end in a space.</li>\n<li><code>[^?]+</code> <em>Negated character class</em> <code>[^...]</code>. Match any character that is not literal <code>?</code> 1 or more times (<code>+</code>).</li>\n<li><code>[^? ]</code> <em>Negated character class</em> <code>[^...]</code>. Match any character that is not literal <code>?</code> or literal space character <code> </code> to make sure the capture does not end in a space.</li>\n</ul>\n</li>\n<li><code>)</code></li>\n</ul>\n</li>\n<li><code>)</code></li>\n<li><code>[ ]*</code> Match literal space character <code> </code> 0 or more times (<code>*</code>).</li>\n<li><code>[?]</code> Match literal <code>?</code>.</li>\n<li><code>[ ]*</code> Match literal space character <code> </code> 0 or more times (<code>*</code>).</li>\n<li><code>(?&lt;trueConditionValue&gt;</code> Begin <em>named capture group</em>.\n<ul>\n<li><code>[^:]+</code> <em>Negated character class</em> <code>[^...]</code>. Match any character that is not literal <code>:</code> 1 or more times (<code>+</code>).</li>\n<li><code>[^: ]</code> <em>Negated character class</em> <code>[^...]</code>. Match any character that is not literal <code>:</code> or or literal space character <code> </code> to make sure the capture does not end in a space.</li>\n</ul>\n</li>\n<li><code>)</code></li>\n<li><code>[ ]*</code> Match literal space character <code> </code> 0 or more times (<code>*</code>).</li>\n<li><code>:</code> Match literal <code>:</code>.</li>\n<li><code>[ ]*</code> Match literal space character <code> </code> 0 or more times (<code>*</code>).</li>\n<li><code>(?&lt;falseConditionValue&gt;</code> Begin <em>named capture group</em>.\n<ul>\n<li><code>[^)]+</code> <em>Negated character class</em> <code>[^...]</code>. Match any character that is not literal <code>)</code> 1 or more times (<code>+</code>).</li>\n</ul>\n</li>\n<li><code>)</code></li>\n<li><code>\\)</code> Match literal <code>)</code>.</li>\n</ul>\n</li>\n<li><code>)</code></li>\n<li><code>[ ]*</code> Match literal space character <code> </code> 0 or more times (<code>*</code>).</li>\n<li><code>(?&lt;otherPart&gt;</code> Begin <em>named capture group</em>.\n<ul>\n<li><code>-</code> Match literal <code>-</code>.</li>\n<li><code>[ ]*</code> Match literal space character <code> </code> 0 or more times (<code>*</code>).</li>\n<li><code>\\(</code> Match literal <code>)</code>.</li>\n<li><code>[^)]+</code> <em>Negated character class</em> <code>[^...]</code>. Match anything that is not literal <code>)</code> 1 or more times (<code>+</code>).</li>\n<li><code>\\)</code> Match literal <code>)</code>.</li>\n</ul>\n</li>\n<li><code>)</code></li>\n</ul>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 25794356,
      "reputation" : 793,
      "user_id" : 19537838,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/e2aecbb99a302f70f711caf20ba0e1fd?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "rich neadle",
      "link" : "https://stackoverflow.com/users/19537838/rich-neadle"
    },
    "creation_date" : 1744760834,
    "last_activity_date" : 1744763121,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79733141,
    "question_id" : 79574498,
    "body" : "<p>I am posting my answer since it was my suggesting that turned out the solution.</p>\n<pre class=\"lang-none prettyprint-override\"><code>(\\(\\^(([^()]*)\\s(?:[&gt;&lt;]=?|==)\\s*\\&quot;([^\\&quot;]*)\\&quot;)\\s*\\?\\s*\\^(\\S+)\\s+:\\s+\\^([^()]*)\\))(\\s+-\\s+\\([^()]*\\))\n</code></pre>\n<p>See the <a href=\"https://regex101.com/r/0ZFrLl/1\" rel=\"nofollow noreferrer\">regex demo</a>.</p>\n<p><em>Details</em>:</p>\n<ul>\n<li><code>(\\(\\^(([^()]*)\\s(?:[&gt;&lt;]=?|==)\\s*\\&quot;([^\\&quot;]*)\\&quot;)\\s*\\?\\s*\\^(\\S+)\\s+:\\s+\\^([^()]*)\\))</code> - Group 1 matching</li>\n<li><code>\\(\\^</code> - a <code>(^</code> string</li>\n<li><code>(([^()]*)\\s(?:[&gt;&lt;]=?|==)\\s*\\&quot;([^\\&quot;]*)\\&quot;)</code> - Group 2 matching\n<ul>\n<li><code>([^()]*)</code> - Group 3: any zero or more chars other than <code>(</code> and <code>)</code></li>\n<li><code>\\s</code> - a whitespace</li>\n<li><code>(?:[&gt;&lt;]=?|==)</code> - <code>&lt;</code> or <code>&gt;</code> followed with an optional <code>=</code> or a <code>==</code> string</li>\n<li><code>\\s*</code> - zero or more whitespaces</li>\n<li><code>\\&quot;</code> - a <code>&quot;</code> char</li>\n<li><code>([^\\&quot;]*)</code> - Group 4: zero or more chars other than <code>&quot;</code></li>\n<li><code>\\&quot;</code> - a <code>&quot;</code> char</li>\n</ul>\n</li>\n<li><code>\\s*\\?\\s*</code> - an optional <code>?</code> char enclosed with zero or more whitespaces</li>\n<li><code>\\^</code> - a literal <code>^</code> char</li>\n<li><code>(\\S+)</code> - Group 5: one or more non-whitespace chars</li>\n<li><code>\\s+:\\s+</code> - a <code>:</code> char enclosed with one or more whitespaces</li>\n<li><code>\\^</code> - a literal <code>^</code> char</li>\n<li><code>([^()]*)</code> - Group 6: any zero or more chars other than <code>(</code> and <code>)</code></li>\n<li><code>\\)</code> - a literal <code>)</code> char</li>\n<li><code>(\\s+-\\s+\\([^()]*\\))</code> - Group 7:\n<ul>\n<li><code>\\s+-\\s+</code> - a <code>-</code> char enclosed with one or more whitespaces</li>\n<li><code>\\(</code> - a <code>(</code> char</li>\n<li><code>[^()]*</code> - any zero or more chars other than <code>(</code> and <code>)</code></li>\n<li><code>\\)</code> - a <code>)</code> char</li>\n</ul>\n</li>\n</ul>\n",
    "score" : 0,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 4739783,
      "reputation" : 631012,
      "user_id" : 3832970,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/IFOp5.jpg?s=256",
      "display_name" : "Wiktor Stribiżew",
      "link" : "https://stackoverflow.com/users/3832970/wiktor-stribi%c5%bcew"
    },
    "creation_date" : 1754999976,
    "last_activity_date" : 1754999976,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140343496,
    "post_id" : 79574498,
    "body" : "@sln Extremely Sorry. I wrote @sin instead of <code>@sln</code>. I tried to edit it, but 5 mins had been passed. I cannot edit the comment after 5 mins. Note that first I am removing all the <code>^</code>, <code>&quot;</code> and <code>space</code> using rejex. Then I am applying this rejex. But we can simply tweak this rejex to match with the original string also. We just need to make <code>^</code> optional. Just like we made the spaces optional <code>s*</code>. Thanks",
    "score" : 0,
    "owner" : {
      "account_id" : 980746,
      "reputation" : 8770,
      "user_id" : 1000510,
      "user_type" : "registered",
      "accept_rate" : 76,
      "profile_image" : "https://i.sstatic.net/Bhpgn.png?s=256",
      "display_name" : "Basit",
      "link" : "https://stackoverflow.com/users/1000510/basit"
    },
    "creation_date" : 1744875125,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140343478,
    "post_id" : 79574498,
    "body" : "@sin I asked @WiktorStribiżew to provide his comment as an answer.  I made that rejex after what he replied. But any ways here is the rejex <code>(\\(((\\S+)\\s*(?:[&gt;&lt;]=?|==)\\s*(\\S+))\\s*\\?\\s*(\\S+)\\s*:\\s*(\\S+)\\&zwnj;&#8203;))(\\s*.\\s*\\(\\S+\\))</code>. If he provides his answer, then I can reply with the java version as well. In Java we have to use double slash instead of single. Although I pasted the java rejex but I think here double slash replaces with single automatically. Thanks",
    "score" : 0,
    "owner" : {
      "account_id" : 980746,
      "reputation" : 8770,
      "user_id" : 1000510,
      "user_type" : "registered",
      "accept_rate" : 76,
      "profile_image" : "https://i.sstatic.net/Bhpgn.png?s=256",
      "display_name" : "Basit",
      "link" : "https://stackoverflow.com/users/1000510/basit"
    },
    "creation_date" : 1744874640,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140342428,
    "post_id" : 79574498,
    "body" : "Your example parts that you would like to match can&#39;t really be quantified. Can you add distinctive framework that generalizes what it is you expect to match.",
    "score" : 0,
    "owner" : {
      "account_id" : 268704,
      "reputation" : 3643,
      "user_id" : 15577665,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/22b015407c4f216f37fb10bccb8debaf?s=256&d=identicon&r=PG",
      "display_name" : "sln",
      "link" : "https://stackoverflow.com/users/15577665/sln"
    },
    "creation_date" : 1744837867,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140336481,
    "post_id" : 79574498,
    "body" : "@WiktorStribiżew Basically, it&#39;s not just this string. Infact, I don&#39;t know what the string would be. Here I just provide an example so you can understand. There are already rejex patterns. If string matches with this pattern, then I need to take some action. You are right. It is brittle. But for now, I need it. It is brittle, but I learned from it :) Thanks",
    "score" : 0,
    "owner" : {
      "account_id" : 980746,
      "reputation" : 8770,
      "user_id" : 1000510,
      "user_type" : "registered",
      "accept_rate" : 76,
      "profile_image" : "https://i.sstatic.net/Bhpgn.png?s=256",
      "display_name" : "Basit",
      "link" : "https://stackoverflow.com/users/1000510/basit"
    },
    "creation_date" : 1744716435,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140336130,
    "post_id" : 79574498,
    "body" : "You know, this expression is too brittle, and there will surely be strings that won&#39;t match it. I just used my best guess for the provided example, and I only provided it for you to see how impractical it is to follow the regex approach here.",
    "score" : 0,
    "owner" : {
      "account_id" : 4739783,
      "reputation" : 631012,
      "user_id" : 3832970,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/IFOp5.jpg?s=256",
      "display_name" : "Wiktor Stribiżew",
      "link" : "https://stackoverflow.com/users/3832970/wiktor-stribi%c5%bcew"
    },
    "creation_date" : 1744710760,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140336010,
    "post_id" : 79574498,
    "body" : "@WiktorStribiżew please provide the answer. I will mark as accepted. Thanks",
    "score" : 0,
    "owner" : {
      "account_id" : 980746,
      "reputation" : 8770,
      "user_id" : 1000510,
      "user_type" : "registered",
      "accept_rate" : 76,
      "profile_image" : "https://i.sstatic.net/Bhpgn.png?s=256",
      "display_name" : "Basit",
      "link" : "https://stackoverflow.com/users/1000510/basit"
    },
    "creation_date" : 1744708546,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140335588,
    "post_id" : 79574498,
    "body" : "This is not a regex task, you&#39;d better create a dedicated parser or use existing if any. However, if you want to struggle a bit more, <a href=\"https://regex101.com/r/0ZFrLl/1\" rel=\"nofollow noreferrer\">here</a> is a suggestion.",
    "score" : 4,
    "owner" : {
      "account_id" : 4739783,
      "reputation" : 631012,
      "user_id" : 3832970,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/IFOp5.jpg?s=256",
      "display_name" : "Wiktor Stribiżew",
      "link" : "https://stackoverflow.com/users/3832970/wiktor-stribi%c5%bcew"
    },
    "creation_date" : 1744700458,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}