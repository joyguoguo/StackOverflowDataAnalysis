{
  "question" : {
    "question_id" : 79843270,
    "title" : "Best method to loop a list while removing items",
    "body" : "<p>I have a list of ranges that consist of a start and end value. I need to optimise the list by identifying any overlapping ranges and merging them so that there is no duplication on the list.</p>\n<p>I have the following code which works</p>\n<pre><code>    private void reconcile() {\n        for (int i = 0; i &lt; list.size(); i++) {\n            for (int j = 0; j &lt; i; j++) {\n                if (list.get(j).overlaps(list.get(i))) {\n                    list.get(j).merge(list.get(i));\n                    list.remove(i);\n                    i--;\n                }\n            }\n        }\n    }\n</code></pre>\n<p>The list contains custom objects with overlap and merge methods.</p>\n<p>As I am removing objects while iterating, I need to include the <code>i--</code> to ensure I don't skip on object on the list when the indexing changes.</p>\n<p>Just wondering if there's a more elegant way of doing this?</p>\n",
    "tags" : [ "java", "loops", "arraylist" ],
    "owner" : {
      "account_id" : 1731743,
      "reputation" : 507,
      "user_id" : 1585219,
      "user_type" : "registered",
      "accept_rate" : 78,
      "profile_image" : "https://www.gravatar.com/avatar/77481f48f504096e66aade6f3c93494d?s=256&d=identicon&r=PG",
      "display_name" : "Michael",
      "link" : "https://stackoverflow.com/users/1585219/michael"
    },
    "is_answered" : true,
    "view_count" : 104,
    "answer_count" : 4,
    "score" : 0,
    "last_activity_date" : 1765552968,
    "creation_date" : 1765387801,
    "link" : "https://stackoverflow.com/questions/79843270/best-method-to-loop-a-list-while-removing-items",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79843473,
    "question_id" : 79843270,
    "body" : "<p>Ordinarily, the task &quot;I need to iterate a list from to back and possibly remove an item from it while doing it&quot; is best answered by: &quot;... then use the iterator&quot;:</p>\n<pre class=\"lang-java prettyprint-override\"><code>var it = list.iterator();\nwhile (it.hasNext()) {\n  Foo element = it.next();\n  if (element.someOperationThatRequiresRemovingIt()) {\n    it.remove();\n  }\n}\n</code></pre>\n<p>If that question involves iteration backwards and forward, and also adding things in between, the answer is &quot;... then use the <code>listIterator()</code>&quot;.</p>\n<p>But in your case you also need the index of the element, which, unfortunately, you don't have here, and trying to adopt &quot;use <code>it.remove()</code> somehow&quot; in your code principle results in considerably more finicky code rather than less.</p>\n<p>Note that guava has <a href=\"https://guava.dev/releases/18.0/api/docs/com/google/common/collect/RangeSet.html\" rel=\"nofollow noreferrer\"><code>RangeSet</code></a> which precisely represents what you want and is vastly more efficient than a list. All its operations are <code>O(log n)</code> more or less, instead of what you have which is at best <code>O(n)</code>. Also, the method names are better because the list fundamentally represents a disjointed set of ranges. For example, RangeSets <em>automatically</em> merge as you add:</p>\n<pre class=\"lang-java prettyprint-override\"><code>RangeSet&lt;Integer&gt; set = TreeRangeSet.create();\nset.add(Range.lessThan(5)); // [-∞, 5)\nset.add(Range.moreThan(4)); // (4, ∞]\n\nSet&lt;Range&lt;Integer&gt;&gt; ranges = set.asRanges();\nassertEquals(1, ranges.size());\n// The only range is 'all'...\n// because the 2 ranges above merge into 'all'.\n// This merging occurs automatically.\nassertEquals(Range.&lt;Integer&gt;all(), ranges.iterator().next9));\n</code></pre>\n<p>This does, of course, requiring adding a third party dep.</p>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107206,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1765406577,
    "last_activity_date" : 1765406577,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79844024,
    "question_id" : 79843270,
    "body" : "<p>You probably want to sort the list (e.g. by interval start) first, so you only have to check adjacent entries instead of comparing every element with every element. Then, going backwards, from the end to the start of the list, would imply that only indices of already processed elements change.</p>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 3211603,
      "reputation" : 301001,
      "user_id" : 2711488,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
      "display_name" : "Holger",
      "link" : "https://stackoverflow.com/users/2711488/holger"
    },
    "creation_date" : 1765461052,
    "last_activity_date" : 1765461052,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79843380,
    "question_id" : 79843270,
    "body" : "<p>The truth is that your code is fine, but yes, it can be improved (although the difference is negligible).</p>\n<pre><code>void reconcile() {\n\n     // since we compare each item with the previous one, we start\n     // at the last one and iterate until the second one.\n   for( int i = list.size() - 1; i &gt; 0; i -- ) {\n      if( list.get( i ).overlaps( list.get( i - 1 ) ) ) {\n         list.get( i - 1 ).merge( list.get( i ) );\n         list.remove( i );\n      }\n   }\n}\n</code></pre>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 10843443,
      "reputation" : 924,
      "user_id" : 20882864,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/CCQCy.jpg?s=256",
      "display_name" : "Marce Puente",
      "link" : "https://stackoverflow.com/users/20882864/marce-puente"
    },
    "creation_date" : 1765395328,
    "last_activity_date" : 1765429959,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79843282,
    "question_id" : 79843270,
    "body" : "<p>Why not using another list?</p>\n<pre><code>private List&lt;Foo&gt; reconcile() {\n    List&lt;Foo&gt; newList = new ArrayList&lt;&gt;();\n    \n\n    for (Foo cur : list) {\n        boolean notOverlapping = true;\n\n        for (Foo toCheck : newList) {\n            if (toCheck.overlaps(foo)) {\n                toCheck.merge(foo);\n                overlaps = false;\n                break;\n            }\n        }\n\n        if (notOverlapping) newList.add(cur);\n    }\n\n    return newList;\n}\n</code></pre>\n<p>Looping and removing on a list does not really seem a good idea to start with</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 21837180,
      "reputation" : 308,
      "user_id" : 16131265,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/QuW5K.jpg?s=256",
      "display_name" : "Achille004",
      "link" : "https://stackoverflow.com/users/16131265/achille004"
    },
    "creation_date" : 1765388386,
    "last_activity_date" : 1765388386,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}