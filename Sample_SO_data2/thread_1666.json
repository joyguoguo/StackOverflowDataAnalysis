{
  "question" : {
    "question_id" : 79689375,
    "title" : "Count maximum stable segments",
    "body" : "<p><strong>Problem Statement:</strong></p>\n<p>A warehouse manages a line of containers prepared for shipment. Each container has a specified mass, provided in the list massList, where massList[i] represents the mass of the \uD835\uDC56th container in the lineup.</p>\n<p>Containers are grouped into segments, where each segment consists of one or more consecutive containers. For example, given masses [3, 6, 3], valid segments include [3], [6], [3, 6], [6, 3], and [3, 6, 3]—but not [3, 3], since the containers are not adjacent.</p>\n<p>A segment is considered stable if the final container does not have the maximum mass among all containers in that segment. For instance:</p>\n<p>[3, 9, 4, 7] is stable (last mass is 7, but the maximum is 9).</p>\n<p>[4, 7, 2, 7] is not stable (last mass is 7, which equals the max).</p>\n<p>Divide the sequence into the maximum number of stable segments such that:</p>\n<p>Every container is part of exactly one segment.</p>\n<p>Each segment uses a contiguous part of the list.</p>\n<p>Every segment must be stable.</p>\n<p>If it's impossible to create a stable segment, return 0.</p>\n<p><strong>Example:</strong></p>\n<p>massList = [1, 2, 3, 2, 6, 3]\nOne valid partitioning: [1, 2, 3, 2] and [6, 3]</p>\n<p>Both are stable segments.</p>\n<p>No other partition yields more than 2 stable segments.</p>\n<p>Answer: 2</p>\n<p><strong>Constraints:</strong></p>\n<pre><code>2≤n≤10^5\n1≤massList[i]≤10^9\n</code></pre>\n<p>I have used greedy approach to solve this:</p>\n<p>We make one pass through the list and maintain:</p>\n<p>max: the maximum mass seen so far in the current segment.</p>\n<p>stableCount: how many stable segments we’ve found.</p>\n<pre><code>import java.util.*;\n\nclass ContainerPlanner {\n    public static int getMaxStableSegments(List&lt;Integer&gt; massList) {\n        int n = massList.size();    \n        int max = 0;\n        int stableCount = 0;\n\n        for (int i = 0; i &lt; n; i++) {\n            int m = massList.get(i);\n            max = Math.max(m, max);\n            if (m &lt; max &amp;&amp; max &gt; 0) {\n                stableCount++;\n                max = 0;\n            }\n        }\n\n        return stableCount;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(getMaxStableSegments(Arrays.asList(1, 2, 3, 2, 6, 3))); // Output: 2\n        System.out.println(getMaxStableSegments(Arrays.asList(8, 5, 4, 7, 2)));    // Output: 2\n        System.out.println(getMaxStableSegments(Arrays.asList(4, 3, 6, 5, 3, 4, 7, 1))); // Output: 3\n        System.out.println(getMaxStableSegments(Arrays.asList(\n            10, 5, 6, 4, 7, 6, 4, 2, 7, 1, 4, 6, 3, 4, 5, 1, 7, 5, 4, 6, 7, 8, 4, 6, 1, 9, 9\n        ))); // Output: 1\n    }\n}\n</code></pre>\n<p>I have added some test cases in main method, out of 4 test cases 1 test case fails</p>\n<p>Expected output is 1 but my solution is returning 10 for test case</p>\n<pre><code>getMaxStableSegments(Arrays.asList(\n            10, 5, 6, 4, 7, 6, 4, 2, 7, 1, 4, 6, 3, 4, 5, 1, 7, 5, 4, 6, 7, 8, 4, 6, 1, 9, 9\n        )); // Output: 1\n</code></pre>\n<p>My current greedy approach is incorrect because it fails to handle edge cases where it's impossible to divide all masses into valid stable segments. As a result, it's returning values like 10 instead of the correct answer, such as 1.</p>\n<p>What would be the correct and efficient approach to solve this problem, ensuring all masses are included in valid stable segments while maintaining optimal time complexity, that is less than O(n^2)?</p>\n",
    "tags" : [ "java", "algorithm" ],
    "owner" : {
      "account_id" : 31187804,
      "reputation" : 794,
      "user_id" : 23993901,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/7417aaad0c8ece3fac44f06d05a8ba8b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "CodeCrusader",
      "link" : "https://stackoverflow.com/users/23993901/codecrusader"
    },
    "is_answered" : true,
    "view_count" : 430,
    "answer_count" : 6,
    "score" : 6,
    "last_activity_date" : 1756516588,
    "creation_date" : 1751570807,
    "link" : "https://stackoverflow.com/questions/79689375/count-maximum-stable-segments",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79691038,
    "question_id" : 79689375,
    "body" : "<p>Since each segment requires an element that is higher than its last element, each segment must include a &quot;downward step&quot; from a higher element to a smaller element that immediately follows it.</p>\n<p>Start by finding the shortest possible end segment, by searching from the end for any element that is higher than the last one.</p>\n<p>Then find the maximum number of disjoint downward steps before this last segment.  Add 1 for the last segment, and <strong>this is the answer</strong>.</p>\n<h3>Proof</h3>\n<p>Since every segment requires a downward step, and we've consumed as few elements as possible for the end segment, there cannot possibly be more additional segments than there can be disjoint downward steps in the remaining elements.</p>\n<p>Furthermore, given some disjoint downward steps before the last segment, we can easily make a segment out of each and every one of them, because any left over elements in the array can be added to the following segment.</p>\n<h3>Maximum Disjoint Downward Steps</h3>\n<p>To count the maximum number of disjoint downward steps, just find every strictly decreasing subarray.  If it has length m, then it can be divided into <code>floor(m/2)</code> downward steps.  <code>[4,3,2,1]</code>, for example, can be divided into 2 steps, <code>[4,3]</code> and <code>[2,1]</code>, but given just <code>[3,2,1]</code>, you can only choose one downward step.  You'll get the same count if you just greedily consume downward steps as you find them.</p>\n<p>Adding up all these counts is easy to do in linear time, and that's how long the whole algorithm takes.</p>\n<p>Here is your Java implementation fixed:</p>\n<pre><code>import java.util.*;\n\npublic class ContainerPlanner {\n    public static int getMaxStableSegments(List&lt;Integer&gt; massList) {\n        int len = massList.size();\n        if (len &lt; 2) {\n            return 0;\n        }\n        int endSegStart = len-1;\n        int lastVal = massList.get(endSegStart);\n        while(endSegStart &gt;= 0 &amp;&amp; massList.get(endSegStart) &lt;= lastVal) {\n            --endSegStart;\n        }\n        if (endSegStart &lt; 0) {\n            return 0;\n        }\n        int count = 0;\n        for (int pos=0; pos&lt;endSegStart-1; ++pos) {\n            if (massList.get(pos) &gt; massList.get(pos+1)) {\n                ++pos; // consume adjacent element\n                ++count;\n            }\n        }\n        return count+1;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(getMaxStableSegments(Arrays.asList(1, 2, 3, 2, 6, 3))); // Output: 2\n        System.out.println(getMaxStableSegments(Arrays.asList(8, 5, 4, 7, 2)));    // Output: 2\n        System.out.println(getMaxStableSegments(Arrays.asList(4, 3, 6, 5, 3, 4, 7, 1))); // Output: 3\n        System.out.println(getMaxStableSegments(Arrays.asList(\n            10, 5, 6, 4, 7, 6, 4, 2, 7, 1, 4, 6, 3, 4, 5, 1, 7, 5, 4, 6, 7, 8, 4, 6, 1, 9, 9\n        ))); // Output: 1\n    }\n}```\n</code></pre>\n",
    "score" : 9,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 7178634,
      "reputation" : 60923,
      "user_id" : 5483526,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/780a651189f64a2cbf4b7f62cf852005?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Matt Timmermans",
      "link" : "https://stackoverflow.com/users/5483526/matt-timmermans"
    },
    "creation_date" : 1751718249,
    "last_activity_date" : 1751753410,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79689432,
    "question_id" : 79689375,
    "body" : "<p>Try it from the last one to the first one, like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>import java.util.Arrays;\nimport java.util.List;\n\npublic class ContainerPlanner {\n    public static int getMaxStableSegments(List&lt;Integer&gt; massList) {\n\n        int stableCount = 0;\n        int ref = 0;\n        int lastStableIndex = massList.size() - 1;\n\n        while (lastStableIndex &gt; 0) {\n            for (int i = lastStableIndex; i &gt;=0 ; i--) {\n                if(ref == 0) {\n                    ref = massList.get(i);\n                    lastStableIndex = i;\n                } else if(massList.get(i) &gt; ref) {\n                    stableCount++;\n                    ref = 0;\n                    lastStableIndex = i-1;\n                }\n            }\n            if(stableCount == 0) {\n                break;\n            }\n            lastStableIndex--;\n            ref = 0;\n        }\n\n        return stableCount;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(getMaxStableSegments(Arrays.asList(1, 2, 3, 2, 6, 3))); // Output: 2\n        System.out.println(getMaxStableSegments(Arrays.asList(8, 5, 4, 7, 2)));    // Output: 2\n        System.out.println(getMaxStableSegments(Arrays.asList(4, 3, 6, 5, 3, 4, 7, 1))); // Output: 3\n        System.out.println(getMaxStableSegments(Arrays.asList(1, 2, 3, 4, 5, 6, 7))); // Output: 0\n        System.out.println(getMaxStableSegments(Arrays.asList(\n                10, 5, 6, 4, 7, 6, 4, 2, 7, 1, 4, 6, 3, 4, 5, 1, 7, 5, 4, 6, 7, 8, 4, 6, 1, 9, 9\n        ))); // Output: 1\n    }\n}\n</code></pre>\n<h1>Later edit:</h1>\n<p>after @maraca comment, I came back at the code and not only fixed the issue, but simplified it a lot.</p>\n<pre class=\"lang-java prettyprint-override\"><code>\npublic static int getMaxStableSegments2(int... a) {\n    if (a.length &lt; 2) return 0;\n\n    int i = a.length - 2;\n\n    while (i &gt;= 0 &amp;&amp; a[i] &lt;= a[a.length - 1]) i--;\n    if (i &lt; 0) return 0;\n    int count = 1;\n\n    while (i &gt;= 2) {\n        if(a[i-1] &lt; a[i-2] ) {\n            count++;\n            i -= 2;\n        } else {\n            i--;\n        }\n    }\n    return count;\n}\n</code></pre>\n<p>Tested it with different other cases and works fine.</p>\n<pre class=\"lang-java prettyprint-override\"><code>public static void main(String[] args) {\n    System.out.println(getMaxStableSegments2() + &quot; = 0&quot;);// Output: 2\n    System.out.println(getMaxStableSegments2(1) + &quot; = 0&quot;);// Output: 2\n    System.out.println(getMaxStableSegments2(10, 9, 8, 9, 8, 9, 8, 7) + &quot; = 3&quot;);// Output: 2\n    System.out.println(getMaxStableSegments2(10, 9, 8, 7, 9, 8, 7, 9, 8, 7) + &quot; = 4&quot;);// Output: 2\n    System.out.println(getMaxStableSegments2(1, 2, 3, 4) + &quot; = 0&quot;);\n    System.out.println(getMaxStableSegments2(3,2,2,1) + &quot; = 2&quot;);\n    System.out.println(getMaxStableSegments2(2,2,2,2) + &quot; = 0&quot;);\n    System.out.println(getMaxStableSegments2(10, 5, 5, 5, 6, 4, 3) + &quot; = 2&quot;);// Output: 2\n    System.out.println(getMaxStableSegments2(1, 2, 3, 2, 6, 3) + &quot; = 2&quot;);\n    System.out.println(getMaxStableSegments2(8, 5, 4, 7, 2) + &quot; = 2&quot;);    // Output: 2\n    System.out.println(getMaxStableSegments2(4, 3, 6, 5, 3, 4, 7, 1) + &quot; = 3&quot;); // Output: 3\n    System.out.println(getMaxStableSegments2(1, 2, 3, 4, 5, 6, 7) + &quot; = 0&quot;); // Output: 0\n    System.out.println(getMaxStableSegments2(\n            10, 5, 6, 4, 7, 6, 4, 2, 7, 1, 4, 6, 3, 4, 5, 1, 7, 5, 4, 6, 7, 8, 4, 6, 1, 9, 9\n    ) + &quot; = 1&quot;); // Output: 1\n}\n</code></pre>\n<p>My strategy was to get the most optimistic scenario, where all segments were made of 2 weights. Loop it in reverse, and if one group is not stable, add the right one to the last group and decrease the index by one.</p>\n",
    "score" : 3,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1601399,
      "reputation" : 638,
      "user_id" : 1482356,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d6160b6e40d230fa92c6da8072b2f7e5?s=256&d=identicon&r=PG",
      "display_name" : "Peter Adrian",
      "link" : "https://stackoverflow.com/users/1482356/peter-adrian"
    },
    "creation_date" : 1751574196,
    "last_activity_date" : 1751720871,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79690722,
    "question_id" : 79689375,
    "body" : "<p>By starting at the <code>last</code> index going left you can look for the first number at index <code>i</code> which is greater than the last number in the list. There is no way around that, the segment has to be at least that long. The interesting part is how to continue:</p>\n<ol>\n<li><p>if i &lt; 0 return count</p>\n</li>\n<li><p>if i &lt; 2 return count + 1</p>\n</li>\n<li><p>Look at arr[i - 1] and find the first index j to the left of i - 1 where arr[i - 1] != arr[j] (if you can't find any return count + 1):</p>\n<ol>\n<li>arr[j] &gt; arr[i - 1]: count++, last = i - 1, i = j. The section from j to i - 1 is already valid by itself, so it is safe to make a cut between i and i - 1. Continue at the outer 1.</li>\n<li>else (arr[j] &lt; arr[i - 1] garanteed): i = j-- + 1. It is best to expand the current section at least to j + 1 because the section before needs at least a number more anyway and a higher number at the end of the section worsens our chances to find one soon. Continue at 3.</li>\n</ol>\n</li>\n</ol>\n<p>E.g. (with improvements, tested)</p>\n<pre><code>public int solve(int... arr) {\n    int last = arr[arr.length - 1];\n    int i = arr.length - 2;\n    while (i &gt;= 0 &amp;&amp; arr[i] &lt;= last) i--;\n    if (i &lt; 0) return 0;\n    int count = 1;\n    for (;;) {\n        if (i &lt; 2) return count;\n        int j = i - 2;\n        for (;;) {\n            while (j &gt;= 0)\n                if (arr[j] != arr[i - 1]) break;\n                else j--;\n            if (j &lt; 0) return count;\n            if (arr[j] &gt; arr[i - 1]) {\n                count++;\n                i = j;\n                break;\n            } else {\n                i = j-- + 1;\n            }\n        }\n    }\n}\n</code></pre>\n<p>Time complexity is still O(n) despite all the loops. The lookahead only leads to looking at the same index a constant number of times (2 times at most if I'm counting right).</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 6136413,
      "reputation" : 9587,
      "user_id" : 4785110,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/71b70abe72497023835a6dd8961b7c89?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "maraca",
      "link" : "https://stackoverflow.com/users/4785110/maraca"
    },
    "creation_date" : 1751672224,
    "last_activity_date" : 1751677018,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79690736,
    "question_id" : 79689375,
    "body" : "<p>Here is my attempt at linear time dynamic programming. The idea is if an element is chosen as (a valid) last of a segment, we add the count of this one segment to the best solution up to the element <code>e</code> just before the preceding greater element <code>p</code>, which is the minimum size for such a stable segment. “Best solution” in this case means <code>e</code> can either be last of another segment or part of the current segment. Otherwise, if an element is not last of a segment, we assign its state the best solution associated with the previous element since the current element must be part of a segment further ahead.</p>\n<p>Python code:</p>\n<pre class=\"lang-py prettyprint-override\"><code>def preceding_larger(A: list[int]) -&gt; list[int]:\n  &quot;&quot;&quot;Next preceding larger element for each element.&quot;&quot;&quot;\n\n  result = [-1] * len(A)\n  stack = []  \n\n  for i in range(len(A)):\n    while stack and A[stack[-1]] &lt;= A[i]:\n      stack.pop()\n    if stack:\n      result[i] = stack[-1]\n    stack.append(i)\n\n  return result\n\n\ndef f(A: list[int]) -&gt; int:\n  &quot;&quot;&quot;Maximum number of stable segments.&quot;&quot;&quot;\n\n  greaters = preceding_larger(A)\n\n  # First in the pair is if A_i is last in a segment,\n  # second is if A_i is not last in a segment\n  dp = [[0, 0] for _ in A] + [(0, 0)]\n\n  for i in range(len(A)):\n    dp[i][0] = -float('inf') if greaters[i] &lt; 0 else 1 + max(dp[greaters[i] - 1])\n\n    if i &lt; len(A) - 1:\n      dp[i][1] = max(dp[i - 1])\n\n  return max(dp[-2])\n\n\nexamples = [\n  [1, 2, 3, 2, 6, 3],  # 2\n  [8, 5, 4, 7, 2],  # 2\n  [4, 3, 6, 5, 3, 4, 7, 1],  # 3\n  [10, 5, 6, 4, 7, 6, 4, 2, 7, 1, 4, 6, 3, 4, 5, 1, 7, 5, 4, 6, 7, 8, 4, 6, 1, 9, 9],  # 1\n  [1, 2, 3, 4, 5, 6, 7],  # 0\n  [10, 2, 1, 2, 1, 2, 1, 9, 8, 7] # 4\n]\n\nfor A in examples:\n  print((A, f(A)))\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2318302,
      "reputation" : 24008,
      "user_id" : 2034787,
      "user_type" : "registered",
      "accept_rate" : 53,
      "profile_image" : "https://www.gravatar.com/avatar/78471a5b1bfa8b48d2056ff99a875f50?s=256&d=identicon&r=PG",
      "display_name" : "גלעד ברקן",
      "link" : "https://stackoverflow.com/users/2034787/%d7%92%d7%9c%d7%a2%d7%93-%d7%91%d7%a8%d7%a7%d7%9f"
    },
    "creation_date" : 1751676551,
    "last_activity_date" : 1751935970,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79750876,
    "question_id" : 79689375,
    "body" : "<p>The approach I use is as follows: I iterate through the list, counting the valid segments I find. If, when I reach the end of the list, all the segments found are valid, I return their number. If I haven't found any, I return “0.” The “worst” scenario is when I have found valid segments, but the last one is not valid.</p>\n<p>In the first two cases, the list is only iterated over once. In the third case, considering the worst-case scenario, which occurs when the last item does not allow the creation of a valid segment, so “0” must be returned, the original list is iterated over twice, and the list of segment endings is iterated over once.</p>\n<pre><code>public int getMaxStableSegments( List&lt;Integer&gt; massList ) {\n\n     // assigning the value “Integer.MIN_VALUE” to “max” is probably unnecessary\n     // in this case; it is only necessary if negative values need to be handled\n   int max = Integer.MIN_VALUE, found = 0;\n\n     // In this list, we will store the position of the last item in each segment,\n     // which we will use only if the last segment obtained by this method is invalid.\n   List&lt;Integer&gt; endOfSegments = new ArrayList&lt;&gt;();\n   for( int i = 0; i &lt; massList.size(); i ++ ) {\n      int value = massList.get( i );\n\n        // If “value” is less than “max,” it is a valid segment, so we increase\n        // “found” and assign the value “Integer.MIN_VALUE” to “max” to prevent\n        // the next value (which would be the first item in the new segment)\n        // from being considered a valid segment, we also add the value of “i”\n        // to the list of endings.\n      if( value &lt; max ) {\n         found ++;\n         max = Integer.MIN_VALUE;\n         endOfSegments.add( i );\n      }\n      \n        // If the following conditions are met, we have reached the end of the\n        // list, and the last segment is invalid, so we check if the \n        // “endOfSegments” list is empty (we haven't found any), in which case\n        // we return “0.” If it is not empty, we return what “rebuildSegments” \n        // returns.\n      if( value &gt;= max &amp;&amp; i == massList.size() - 1 ) {\n         if( endOfSegments.size() == 0 ) return 0;\n         \n           // The “found” parameter is increased by “1,” since the last segment\n           // has not been counted.\n         return rebuildSegments( massList, found + 1, endOfSegments );\n      }\n      \n        // if it is not the last item but &quot;max&quot; is less than &quot;value&quot;, we assign\n        // the value of ‘value’ to &quot;max&quot;\n      else if( max &lt; value ) {\n         max = value;\n      }\n   }\n   return found;\n}\n\n\nint rebuildSegments( List&lt;Integer&gt; data, int found, List&lt;Integer&gt; endOfSegments ) {\n\n     // we obtain the value of the last item in the list\n   int last = data.getLast();\n   \n     // we added the missing index\n   endOfSegments.add( data.size() - 1 );\n   \n     // here we iterate backwards, searching for the shortest sublist that is \n     // a valid segment.\n   for( int i = data.size() - 2, k = endOfSegments.size() - 1; i &gt;= 0; i -- ) {\n   \n        // if the value contained in the current index is greater than the \n        // content of “last,” we return “found.”\n      if( last &lt; data.get( i ) ) {\n         return found;\n      }\n      \n        // We check if the current index is less than the current item in the\n        // list of segment endings, in which case we decrease the number of\n        // segments found, along with “k.”\n      if( endOfSegments.get( k ) &gt; i ) {\n         found --;\n         k--;\n      }\n   }\n   return found;\n}\n</code></pre>\n<p>I have added a new test, which is the “worst” case scenario.</p>\n<pre><code>System.out.println( getMaxStableSegments( Arrays.asList( 1, 2, 3, 2, 6, 3 ) ) ); // Output: 2\nSystem.out.println( getMaxStableSegments( Arrays.asList( 8, 5, 4, 7, 2 ) ) );    // Output: 2\nSystem.out.println( getMaxStableSegments( Arrays.asList( 4, 3, 6, 5, 3, 4, 7, 1 ) ) ); // Output: 3\nSystem.out.println( getMaxStableSegments( Arrays.asList( 1, 2, 3, 4, 5, 6, 7 ) ) ); // Output: 0\nSystem.out.println( getMaxStableSegments( Arrays.asList(\n        10, 5, 6, 4, 7, 6, 4, 2, 7, 1, 4, 6, 3, 4, 5, 1, 7, 5, 4, 6, 7, 8, 4, 6, 1, 9, 9\n) ) ); // Output: 1    \nSystem.out.println( getMaxStableSegments( Arrays.asList(\n        10, 5, 6, 4, 7, 6, 4, 2, 7, 1, 4, 6, 3, 4, 5, 1, 7, 5, 4, 6, 7, 8, 4, 6, 1, 9, 11\n) ) ); // Output: 0   \n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 10843443,
      "reputation" : 924,
      "user_id" : 20882864,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/CCQCy.jpg?s=256",
      "display_name" : "Marce Puente",
      "link" : "https://stackoverflow.com/users/20882864/marce-puente"
    },
    "creation_date" : 1756516588,
    "last_activity_date" : 1756516588,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79689388,
    "question_id" : 79689375,
    "body" : "<pre><code>reverse order in masslist\nset count = 0;\nset start = 0;\nLOOP k\nLOOP X over masslist, starting at start\n  LOOP Y over masslist, from start to (index of X)-1\n     IF X &lt; Y\n        count++\n        start = (index of X) + 1\n        break from loop Y\n  END LOOP Y\nEND LOOP X\nEND LOOP k\nOUTPUT count\n\n  \n</code></pre>\n",
    "score" : -1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 9061,
      "reputation" : 21190,
      "user_id" : 16582,
      "user_type" : "registered",
      "accept_rate" : 67,
      "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
      "display_name" : "ravenspoint",
      "link" : "https://stackoverflow.com/users/16582/ravenspoint"
    },
    "creation_date" : 1751571451,
    "last_activity_date" : 1751572495,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140577093,
    "post_id" : 79689375,
    "body" : "@ChristophRackwitz Is this not a valid question?",
    "score" : 0,
    "owner" : {
      "account_id" : 13170666,
      "reputation" : 91477,
      "user_id" : 9513184,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/176386ce0b94057e55352484e69707f9?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Unmitigated",
      "link" : "https://stackoverflow.com/users/9513184/unmitigated"
    },
    "creation_date" : 1752071094,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140570559,
    "post_id" : 79689375,
    "body" : "I was mistaken. Not &quot;codeforces&quot;, but &quot;leetcode&quot;.",
    "score" : 0,
    "owner" : {
      "account_id" : 3072614,
      "reputation" : 16444,
      "user_id" : 2602877,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/c76ea7b35660e77624550130276c61d3?s=256&d=identicon&r=PG",
      "display_name" : "Christoph Rackwitz",
      "link" : "https://stackoverflow.com/users/2602877/christoph-rackwitz"
    },
    "creation_date" : 1751890963,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140566593,
    "post_id" : 79689375,
    "body" : "@ChristophRackwitz And?",
    "score" : 2,
    "owner" : {
      "account_id" : 17476274,
      "reputation" : 27971,
      "user_id" : 12671057,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/90d2e6942c69df199a95d06e0c8e9a10?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Kelly Bundy",
      "link" : "https://stackoverflow.com/users/12671057/kelly-bundy"
    },
    "creation_date" : 1751705816,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140566555,
    "post_id" : 79689375,
    "body" : "all of you realize that you&#39;re just solving Codeforces-type questions for the asker? these types of questions are from CS theory (efficient algorithms), sometimes used to gauge job candidates. applicants present their &quot;profile&quot; which has completion rates for different areas.&quot;solving&quot; a question (having it solved for you) gains you points that will impress the interviewer.",
    "score" : 1,
    "owner" : {
      "account_id" : 3072614,
      "reputation" : 16444,
      "user_id" : 2602877,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/c76ea7b35660e77624550130276c61d3?s=256&d=identicon&r=PG",
      "display_name" : "Christoph Rackwitz",
      "link" : "https://stackoverflow.com/users/2602877/christoph-rackwitz"
    },
    "creation_date" : 1751703800,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140566063,
    "post_id" : 79689375,
    "body" : "Btw unless you know the list type because you create it yourself it is safer to convert the list to an array to garantee O(1) access by index (list doesn&#39;t garantee that), or you need to use an iterator / for each / stream and not access by index.",
    "score" : 0,
    "owner" : {
      "account_id" : 6136413,
      "reputation" : 9587,
      "user_id" : 4785110,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/71b70abe72497023835a6dd8961b7c89?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "maraca",
      "link" : "https://stackoverflow.com/users/4785110/maraca"
    },
    "creation_date" : 1751666091,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140563335,
    "post_id" : 79689375,
    "body" : "Got it. I posted the answer, i think it works for all edge case scenarios, and time complexity is linear.",
    "score" : 0,
    "owner" : {
      "account_id" : 1601399,
      "reputation" : 638,
      "user_id" : 1482356,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d6160b6e40d230fa92c6da8072b2f7e5?s=256&d=identicon&r=PG",
      "display_name" : "Peter Adrian",
      "link" : "https://stackoverflow.com/users/1482356/peter-adrian"
    },
    "creation_date" : 1751574578,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140563235,
    "post_id" : 79689375,
    "body" : "A segment is not stable if the last mass is the maximum weight in that segment. so [3] is not stable because the last element is 3 and max element in segment is also 3.",
    "score" : 0,
    "owner" : {
      "account_id" : 31187804,
      "reputation" : 794,
      "user_id" : 23993901,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/7417aaad0c8ece3fac44f06d05a8ba8b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "CodeCrusader",
      "link" : "https://stackoverflow.com/users/23993901/codecrusader"
    },
    "creation_date" : 1751571894,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140563224,
    "post_id" : 79689375,
    "body" : "Am I missing something? If the segment contains ONE or more consecutive containers, and you want to retrieve the maximum segments, then just put one container into one segment and that&#39;s the max.",
    "score" : 1,
    "owner" : {
      "account_id" : 1601399,
      "reputation" : 638,
      "user_id" : 1482356,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d6160b6e40d230fa92c6da8072b2f7e5?s=256&d=identicon&r=PG",
      "display_name" : "Peter Adrian",
      "link" : "https://stackoverflow.com/users/1482356/peter-adrian"
    },
    "creation_date" : 1751571546,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79689388" : [ {
      "comment_id" : 140563264,
      "post_id" : 79689388,
      "body" : "Fixed by reversing the mass list order.",
      "score" : 0,
      "owner" : {
        "account_id" : 9061,
        "reputation" : 21190,
        "user_id" : 16582,
        "user_type" : "registered",
        "accept_rate" : 67,
        "profile_image" : "https://www.gravatar.com/avatar/febff21383acf755f8b375c322e36f2b?s=256&d=identicon&r=PG",
        "display_name" : "ravenspoint",
        "link" : "https://stackoverflow.com/users/16582/ravenspoint"
      },
      "creation_date" : 1751572568,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140563240,
      "post_id" : 79689388,
      "body" : "This code has 3 nested loops, which is not optimal time complexity. Also when I tried to convert this to java and run this solution, I observed that the issue still present, getting 10 as output instead of 1 for test case <code>[10, 5, 6, 4, 7, 6, 4, 2, 7, 1, 4, 6, 3, 4, 5, 1, 7, 5, 4, 6, 7, 8, 4, 6, 1, 9, 9]</code>",
      "score" : 3,
      "owner" : {
        "account_id" : 31187804,
        "reputation" : 794,
        "user_id" : 23993901,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/7417aaad0c8ece3fac44f06d05a8ba8b?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "CodeCrusader",
        "link" : "https://stackoverflow.com/users/23993901/codecrusader"
      },
      "creation_date" : 1751572006,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79689432" : [ {
      "comment_id" : 140566887,
      "post_id" : 79689432,
      "body" : "Thanks for noticing @maraca, i edited the post, and the result looks much better.",
      "score" : 0,
      "owner" : {
        "account_id" : 1601399,
        "reputation" : 638,
        "user_id" : 1482356,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/d6160b6e40d230fa92c6da8072b2f7e5?s=256&d=identicon&r=PG",
        "display_name" : "Peter Adrian",
        "link" : "https://stackoverflow.com/users/1482356/peter-adrian"
      },
      "creation_date" : 1751720933,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140566040,
      "post_id" : 79689432,
      "body" : "I don&#39;t think this works, e.g. [10,2,1,2,1,2,1,9,8,7] if I understood correctly, your algorithm consumes [8,7] then looks at the 9 and consumes the rest [10 .... 9], giving a count of 2. But it would be better to have [10,2,1], [2,1], [2,1], [9,8,7].",
      "score" : 1,
      "owner" : {
        "account_id" : 6136413,
        "reputation" : 9587,
        "user_id" : 4785110,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/71b70abe72497023835a6dd8961b7c89?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "maraca",
        "link" : "https://stackoverflow.com/users/4785110/maraca"
      },
      "creation_date" : 1751665188,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79750876" : [ {
      "comment_id" : 140702998,
      "post_id" : 79750876,
      "body" : "Thanks to user85421 for help me understand where my mistake was. I&#39;m not sure if I did the right thing. I posted an incorrect answer, which I then deleted, and created this new one so that it wouldn&#39;t be “rated” based on the previous incorrect answer. So, should I leave the other one visible, or should I edit it and let it carry the rating of the incorrect one? Is there another option?",
      "score" : 0,
      "owner" : {
        "account_id" : 10843443,
        "reputation" : 924,
        "user_id" : 20882864,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/CCQCy.jpg?s=256",
        "display_name" : "Marce Puente",
        "link" : "https://stackoverflow.com/users/20882864/marce-puente"
      },
      "creation_date" : 1756516982,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79690722" : [ {
      "comment_id" : 140572235,
      "post_id" : 79690722,
      "body" : "@גלעדברקן That&#39;s a good solution as well.",
      "score" : 0,
      "owner" : {
        "account_id" : 13170666,
        "reputation" : 91477,
        "user_id" : 9513184,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/176386ce0b94057e55352484e69707f9?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Unmitigated",
        "link" : "https://stackoverflow.com/users/9513184/unmitigated"
      },
      "creation_date" : 1751936505,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140566258,
      "post_id" : 79690722,
      "body" : "@גלעדברקן I&#39;m not entirely sure whether I understand the algorithm correctly, so it&#39;s hard to come up with a counter example, if there is any at all.",
      "score" : 0,
      "owner" : {
        "account_id" : 6136413,
        "reputation" : 9587,
        "user_id" : 4785110,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/71b70abe72497023835a6dd8961b7c89?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "maraca",
        "link" : "https://stackoverflow.com/users/4785110/maraca"
      },
      "creation_date" : 1751678075,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140566245,
      "post_id" : 79690722,
      "body" : "I added <a href=\"https://stackoverflow.com/a/79690736/2034787\">an attempt at dynamic programming</a>. If you have time to find a counter example, I’d appreciate it!",
      "score" : 0,
      "owner" : {
        "account_id" : 2318302,
        "reputation" : 24008,
        "user_id" : 2034787,
        "user_type" : "registered",
        "accept_rate" : 53,
        "profile_image" : "https://www.gravatar.com/avatar/78471a5b1bfa8b48d2056ff99a875f50?s=256&d=identicon&r=PG",
        "display_name" : "גלעד ברקן",
        "link" : "https://stackoverflow.com/users/2034787/%d7%92%d7%9c%d7%a2%d7%93-%d7%91%d7%a8%d7%a7%d7%9f"
      },
      "creation_date" : 1751676626,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}