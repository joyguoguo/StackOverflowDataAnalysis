{
  "question" : {
    "question_id" : 79597128,
    "title" : "Java how does searching for a key in a HashMap bucket work?",
    "body" : "<p>EDIT: As one of the people commenting mentioned, this question only concerns this specific implementation: <a href=\"https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/HashMap.java#L574\" rel=\"nofollow noreferrer\">https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/HashMap.java#L574</a>.</p>\n<p>When running <strong>get(Object key)</strong> on an instance of a HashMap in Java, as far as I understand these things are happening:</p>\n<ul>\n<li>using hash code of key, compute the index of the internal array in which the bucket resides,</li>\n<li>iterate over linked-list / red-black tree (in case of bucket having more than 8 entries) to search for the key</li>\n<li>when iterating over said linked-list / red-black tree, FIRST compare the hash codes (because if they are different, there's no point performing <strong>equals()</strong> method which is more expensive), if the hash codes are the same, then and only then run <strong>equals()</strong> to make sure the key is the same as we requested</li>\n</ul>\n<p>Do I understand it correctly? Especially, I mean the part of using the hash code twice -&gt; first to find the bucket, then INSIDE the bucket, to FIRST compare the hash codes of an entry in a linked-list/red-black tree, then and only then run &quot;equals()&quot;.</p>\n<p>I apologize, if the question seems trivial. My confusion arises from many explanations of the process as &quot;finding the bucket and immediately running equals() method on all entries&quot;, which in my opinion seems weird - why would you run <strong>equals()</strong> if you don't even know if the hashes are the same?</p>\n",
    "tags" : [ "java", "dictionary", "java-8", "hashmap", "hashtable" ],
    "owner" : {
      "account_id" : 34944043,
      "reputation" : 77,
      "user_id" : 26873512,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/FyIB0pKV.jpg?s=256",
      "display_name" : "Sebastian",
      "link" : "https://stackoverflow.com/users/26873512/sebastian"
    },
    "is_answered" : true,
    "view_count" : 124,
    "answer_count" : 1,
    "score" : 2,
    "last_activity_date" : 1745922557,
    "creation_date" : 1745866451,
    "link" : "https://stackoverflow.com/questions/79597128/java-how-does-searching-for-a-key-in-a-hashmap-bucket-work",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79597196,
    "question_id" : 79597128,
    "body" : "<p>EDIT: Turned out I was too lazy to read the source code. Of course, looking at the implementation code, we can find the <strong>getNode(Object o)</strong> method which is called by <strong>get(Object o)</strong> method. Inside of it, indeed, the correct bucket is first accessed by calculating the following formula: <strong>(n-1) &amp; hash</strong>, where n is the length of the internal array. Then for the first node (and each of the rest if there are more) we are comparing the hash of the <strong>Object o</strong> passed into the method with the hash of the Node/entry. If the hashes are equal, then the <strong>equals()</strong> method runs to make sure it's the same. If the hashes are not equal, well, then it skips to the next node (if the <strong>.next</strong> property is not null).</p>\n",
    "score" : 4,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 34944043,
      "reputation" : 77,
      "user_id" : 26873512,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/FyIB0pKV.jpg?s=256",
      "display_name" : "Sebastian",
      "link" : "https://stackoverflow.com/users/26873512/sebastian"
    },
    "creation_date" : 1745869963,
    "last_activity_date" : 1745869963,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140377881,
    "post_id" : 79597128,
    "body" : "Of course, let me quickly fix it. Thank you for the link to the article explaining it!",
    "score" : 0,
    "owner" : {
      "account_id" : 34944043,
      "reputation" : 77,
      "user_id" : 26873512,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/FyIB0pKV.jpg?s=256",
      "display_name" : "Sebastian",
      "link" : "https://stackoverflow.com/users/26873512/sebastian"
    },
    "creation_date" : 1745869930,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140377865,
    "post_id" : 79597128,
    "body" : "Your edit would probably be better as an answer. That way you can eventually accept it to mark your question solved. Plus, the question shouldn&#39;t contain the answer. See <a href=\"https://stackoverflow.com/help/self-answer\">stackoverflow.com/help/self-answer</a> for more information.",
    "score" : 1,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49904,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1745869622,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140377860,
    "post_id" : 79597128,
    "body" : "Thanks a lot @IłyaBursov (and luk2302 I mentioned earlier). Now I&#39;m 100% sure how it works. You guys are amazing.",
    "score" : 0,
    "owner" : {
      "account_id" : 34944043,
      "reputation" : 77,
      "user_id" : 26873512,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/FyIB0pKV.jpg?s=256",
      "display_name" : "Sebastian",
      "link" : "https://stackoverflow.com/users/26873512/sebastian"
    },
    "creation_date" : 1745869542,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140377844,
    "post_id" : 79597128,
    "body" : "your understanding is correct, multiple different hashcodes can be stored in single bucket, equals on some data types (like string) can be quite slow, this is why they&#39;re checking hashcodes first for every entity, then they&#39;re checking reference equality and only then call real equals",
    "score" : 0,
    "owner" : {
      "account_id" : 3415144,
      "reputation" : 24365,
      "user_id" : 2864275,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f1f73deb5983ac46af2a74732752292e?s=256&d=identicon&r=PG",
      "display_name" : "Iłya Bursov",
      "link" : "https://stackoverflow.com/users/2864275/i%c5%82ya-bursov"
    },
    "creation_date" : 1745869173,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140377802,
    "post_id" : 79597128,
    "body" : "@luk2302 Hmm, actually now that I look at this code, it seems like it works like that: 1. Check if the hash of the first entry of linked-list/red-black tree is equal to provided key&#39;s hash. If yes then perform equals(). If not -&gt; 2. Check if there are more entries in said list/tree. If there are, then again, compare the hashes and only then if they match, run the equals(). So, as far as I understand the &quot;getNode()&quot; method just simply iterates over one bucket, yes? (I mean unless the bucket is empty).",
    "score" : 0,
    "owner" : {
      "account_id" : 34944043,
      "reputation" : 77,
      "user_id" : 26873512,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/FyIB0pKV.jpg?s=256",
      "display_name" : "Sebastian",
      "link" : "https://stackoverflow.com/users/26873512/sebastian"
    },
    "creation_date" : 1745868325,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140377771,
    "post_id" : 79597128,
    "body" : "<a href=\"https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/HashMap.java#L574\" rel=\"nofollow noreferrer\">github.com/openjdk/jdk/blob/master/src/java.base/share/class&zwnj;&#8203;es/&hellip;</a> compares the hash for every element in the bucket before running equals (if I am reading it correctly)",
    "score" : 1,
    "owner" : {
      "account_id" : 2843847,
      "reputation" : 57516,
      "user_id" : 2442804,
      "user_type" : "registered",
      "accept_rate" : 80,
      "profile_image" : "https://i.sstatic.net/51a3aQOH.jpg?s=256",
      "display_name" : "luk2302",
      "link" : "https://stackoverflow.com/users/2442804/luk2302"
    },
    "creation_date" : 1745867583,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79597196" : [ {
      "comment_id" : 140379612,
      "post_id" : 79597196,
      "body" : "Of course, I understand that there is no specification about comparing keys in this way at all in hash tables, I was just curious about the specific implementation in current Java version. That&#39;s a good point, thank you for mentioning it!",
      "score" : 0,
      "owner" : {
        "account_id" : 34944043,
        "reputation" : 77,
        "user_id" : 26873512,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/FyIB0pKV.jpg?s=256",
        "display_name" : "Sebastian",
        "link" : "https://stackoverflow.com/users/26873512/sebastian"
      },
      "creation_date" : 1745922346,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140379365,
      "post_id" : 79597196,
      "body" : "You are just looking at one particular implementation version. Since there’s no specification about this behavior, an implementation is free to decide whether to check the hash code first or to call equals() unconditionally. In other words, never rely on the assumption that equals() will never be invoked for objects with different hash codes.",
      "score" : 3,
      "owner" : {
        "account_id" : 3211603,
        "reputation" : 301001,
        "user_id" : 2711488,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
        "display_name" : "Holger",
        "link" : "https://stackoverflow.com/users/2711488/holger"
      },
      "creation_date" : 1745917242,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}