{
  "question" : {
    "question_id" : 79675247,
    "title" : "How to pass data from an MCP client to an MCP server in Java with Spring AI?",
    "body" : "<p>How can I pass the API key from the MCP client to the MCP server in Spring AI without including it in the prompt? I tried using Tool Context, but it was not working. If this issue can be solved with Tool Context, can anyone share how to do that? Maybe my implementation was wrong.</p>\n<p>MCP Client code where I want to pass API Key from MCP Client to MCP Server:</p>\n<pre class=\"lang-java prettyprint-override\"><code>chatClient\n        .prompt()\n        .system(&quot;&quot;&quot;\n                System prompt.\n                &quot;&quot;&quot;)\n        .user(requestDto.prompt())\n        .toolCallbacks(toolCallbackProvider.getToolCallbacks())\n        .toolContext(Map.of(&quot;apiKey&quot;, &quot;test_key&quot;))\n        .call()\n        .content()\n</code></pre>\n<p>MCP Server where I want to read the API code sent from the client:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Tool(name = &quot;tool name&quot;, description = &quot;tool description&quot;)\npublic List&lt;Data&gt; getData(@ToolParam(description = &quot;des&quot;) TimeRange timeRange,\n                                            ToolContext toolContext) {\n\n}\n</code></pre>\n<p>In the above <code>toolContext</code> I am not able to get API key I send from client.</p>\n<p>There was only an &quot;exchange&quot; key in the <code>toolContext</code> Map context. This is why I reached the conclusion that tool context was not working as I was not able to see the key value in the map I passed from the client.</p>\n<p>This is the config I am using in the client:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Configuration\npublic class MCPConfig {\n    @Bean\n    public SyncMcpToolCallbackProvider toolCallbackProvider(List&lt;McpSyncClient&gt; clients) {\n        return new SyncMcpToolCallbackProvider(clients);\n    }\n}\n</code></pre>\n<p>In the MCP server code:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Tool(name = &quot;tool name&quot;, description = &quot;tool description&quot;)\npublic List&lt;Data&gt; getData(@ToolParam(description = &quot;des&quot;) PlayBackState playBackState,\n                                            ToolContext toolContext) {\nString apiKey = toolContext.getContext().get(&quot;apiKey&quot;).toString();\n}\n</code></pre>\n<p>Here I am getting <code>nullpointerexception</code> as <code>.get(&quot;apiKey&quot;)</code> is returning <code>null</code>. <br />\nIdeally it should have returned the value passed from the MCP Client; <code>&quot;test_key&quot;</code> is the value that should have been present.</p>\n<p>Below is the log I am getting on the above MCP server tool call:</p>\n<pre><code>2025-06-22T20:09:21.463+05:30 TRACE 17000 --- [app-mcp-server] [nio-8081-exec-3] o.s.w.s.f.support.RouterFunctionMapping  : Mapped to io.modelcontextprotocol.server.transport.WebMvcSseServerTransportProvider$$Lambda/0x000001ba36662f38@b76b7d8\n2025-06-22T20:09:21.463+05:30 DEBUG 17000 --- [app-mcp-server] [nio-8081-exec-3] io.modelcontextprotocol.spec.McpSchema   : Received JSON message: {&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;tools/call&quot;,&quot;id&quot;:&quot;355f2a07-8&quot;,&quot;params&quot;:{&quot;name&quot;:&quot;playback_controller&quot;,&quot;arguments&quot;:{&quot;playBackState&quot;:&quot;PAUSE&quot;}}}\n2025-06-22T20:09:21.463+05:30 DEBUG 17000 --- [app-mcp-server] [nio-8081-exec-3] i.m.spec.McpServerSession                : Received request: JSONRPCRequest[jsonrpc=2.0, method=tools/call, id=355f2a07-8, params={name=playback_controller, arguments={playBackState=PAUSE}}]\n2025-06-22T20:09:21.463+05:30 DEBUG 17000 --- [app-mcp-server] [oundedElastic-1] o.s.ai.tool.method.MethodToolCallback    : Starting execution of tool: playback_controller\n2025-06-22T20:09:59.228+05:30 DEBUG 17000 --- [app-mcp-server] [nio-8081-Poller] org.apache.tomcat.util.net.NioEndpoint   : timeout completed: keys processed=2; now=1750603199227; nextExpiration=1750603161517; keyCount=0; hasEvents=false; eval=false\n2025-06-22T20:09:59.231+05:30 DEBUG 17000 --- [app-mcp-server] [oundedElastic-1] i.m.s.t.WebMvcSseServerTransportProvider : Message sent to session a3545270-ab97-4ede-882f-2bdccb36097a\n2025-06-22T20:09:59.232+05:30 TRACE 17000 --- [app-mcp-server] [nio-8081-exec-3] o.s.web.servlet.DispatcherServlet        : No view rendering, null ModelAndView returned.\n2025-06-22T20:09:59.232+05:30 DEBUG 17000 --- [app-mcp-server] [nio-8081-exec-3] o.s.web.servlet.DispatcherServlet        : Completed 200 OK, headers={}\n2025-06-22T20:09:59.232+05:30 TRACE 17000 --- [app-mcp-server] [nio-8081-exec-3] o.s.b.w.s.f.OrderedRequestContextFilter  : Cleared thread-bound request context: org.apache.catalina.connector.RequestFacade@4cb31c2e\n2025-06-22T20:09:59.232+05:30 DEBUG 17000 --- [app-mcp-server] [nio-8081-exec-3] o.a.coyote.http11.Http11InputBuffer      : Before fill(): parsingHeader: [true], parsingRequestLine: [true], parsingRequestLinePhase: [0], parsingRequestLineStart: [0], byteBuffer.position(): [0], byteBuffer.limit(): [0], end: [351]\n</code></pre>\n<p>When I looked into <code>SyncMcpToolCallback</code> class in package <code>org.springframework.ai.mcp</code>:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public String call(String toolArguments, ToolContext toolContext) {\n    return this.call(toolArguments);\n}\n</code></pre>\n<p>ToolContext is not used. So, from my understanding, <code>toolContext</code> is not passed over the network in MCP Client.<br />\nCan this be the reason? If it is, why is that done like that?</p>\n<p>This is the response I get in the MCP client:</p>\n<pre class=\"lang-json prettyprint-override\"><code>{\n    &quot;type&quot;: &quot;about:blank&quot;,\n    &quot;title&quot;: &quot;Bad Request&quot;,\n    &quot;status&quot;: 400,\n    &quot;detail&quot;: &quot;java.util.concurrent.TimeoutException: Did not observe any item or terminal signal within 30000ms in 'Mono.deferContextual ⇢ at io.modelcontextprotocol.spec.McpClientSession.sendRequest(McpClientSession.java:233)' (and no fallback has been configured)&quot;,\n    &quot;instance&quot;: &quot;/chat&quot;\n}\n</code></pre>\n",
    "tags" : [ "java", "spring-boot", "spring-ai", "model-context-protocol" ],
    "owner" : {
      "account_id" : 29939318,
      "reputation" : 53,
      "user_id" : 22944268,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/ACg8ocJjrIqrZ7auuZ2Sz04GLhl1Ptr8qcEWyaRV-9lqO4egjvfb=k-s256",
      "display_name" : "Alanta335",
      "link" : "https://stackoverflow.com/users/22944268/alanta335"
    },
    "is_answered" : true,
    "view_count" : 1696,
    "answer_count" : 3,
    "score" : 5,
    "last_activity_date" : 1755934616,
    "creation_date" : 1750606142,
    "link" : "https://stackoverflow.com/questions/79675247/how-to-pass-data-from-an-mcp-client-to-an-mcp-server-in-java-with-spring-ai",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79700580,
    "question_id" : 79675247,
    "body" : "<p>I worked around this by providing a WebClient.Builder bean with an `ExchangeFilterFunction` that adds context-related headers to each request. On the server side, I intercept those requests and use `ThreadLocal` appropriately, ensuring it’s cleaned up at the end of processing.</p>\n<p>\\&gt; For the transport layer, you must use the **WebFlux-based client** (either SYNC or ASYNC mode) to ensure these headers propagate correctly.</p>\n<p>\\&gt; This approach is designed for a <strong>Spring MVC architecture</strong> (one thread per request). For <strong>non-blocking/reactive architectures,</strong> you should use Reactor’s `Context instead of `ThreadLocal`.</p>\n<p><strong>at MCP Server side</strong><br />\nA holder for the data (in my case, the <code>userId</code>). Use these static methods to access the context within your tool calls.</p>\n<pre><code>public class CustomVarHolder {\n    private static final ThreadLocal&lt;String&gt; userId=new ThreadLocal&lt;&gt;();\n\n    public static void setUserId(String uString){\n        userId.set(uString);\n    }\n    public static String getUserId(){\n        return userId.get();\n    }\n    public static void clear(){\n        userId.remove();\n    }\n}\n</code></pre>\n<p>Interceptor for the request:</p>\n<pre><code>@Component\npublic class CustomHandlerInterceptor implements HandlerInterceptor{\n\n    public static final String USER_HEADER_NAME = &quot;X-User-Header&quot;;\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n            throws Exception {\n        String userId=request.getHeader(USER_HEADER_NAME);\n        if(userId!=null){\n            CustomVarHolder.setUserId(userId);\n        }\n        else{\n            System.out.println(&quot;no header found&quot;);\n        }\n\n        return true;\n    }\n//Clear the value in the context holder\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception{\n        CustomVarHolder.clear();\n        System.out.println(&quot;thread local cleared&quot;);\n    }\n\n}\n</code></pre>\n<p>Configuring the interceptor</p>\n<pre><code>@Configuration\npublic class CustomWebMVCConfigurer implements WebMvcConfigurer{\n    private final CustomHandlerInterceptor interceptor;\n\n    CustomWebMVCConfigurer(CustomHandlerInterceptor interceptor){\n        this.interceptor=interceptor;\n    }\n\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(interceptor).addPathPatterns(&quot;/**&quot;);\n        System.out.println(&quot;interceptor is added&quot;);\n    }\n}\n</code></pre>\n<p><strong>at MCP Client side:</strong><br />\nConfiguring a Webclient builder bean to inject to WebFluxSseClientTransport</p>\n<pre><code>@Configuration\npublic class CustomUserHeader {\n    private static ThreadLocal&lt;String&gt; userHeader = new ThreadLocal&lt;&gt;();\n    public static final String USER_HEADER_NAME = &quot;X-User-Header&quot;;\n    public static void setUserHeader(String user) {\n        userHeader.set(user);\n    }\n    public static String getUserHeader() {\n        return userHeader.get();\n    }\n    public static void clear() {\n        userHeader.remove();\n    }\n    @Bean\n    @Primary\n    public WebClient.Builder webClientBuilder() {\n        System.out.println(&quot;Using WebClient from builder: &quot;);\n        return WebClient.builder().filter(filterFunction());\n    }\n    private ExchangeFilterFunction filterFunction(){\n        return ExchangeFilterFunction.ofRequestProcessor(req-&gt;{\n            String user = CustomUserHeader.getUserHeader();\n            System.out.println(&quot;from filter function &quot;+user);\n            if(user != null) {\n                ClientRequest modifiedClientRequest = ClientRequest.from(req).headers(\n                                        h-&gt;{\n                                            h.add(USER_HEADER_NAME, user);\n                                        }\n                                    ).build();\n                \n                return Mono.just(\n                    modifiedClientRequest\n                );\n            }\n            System.out.println(&quot;user id is null from filter function&quot;);\n            return Mono.just(req);\n\n        });\n    }\n\n}\n</code></pre>\n<p>creating and handling context</p>\n<pre><code>@GetMapping(&quot;chat&quot;)\n    public String getMethodName(@RequestParam(value = &quot;message&quot;,defaultValue = &quot;tell a joke&quot;) String param,@RequestParam(name = &quot;user&quot;,defaultValue = &quot;12323&quot;)String userId) {\n        try{\n        //setting the value to be send as context\n        CustomUserHeader.setUserHeader(userId);\n        \n        ToolCallingChatOptions options =ToolCallingChatOptions.builder().toolCallbacks(syncMcpToolCallbackProvider.getToolCallbacks()).internalToolExecutionEnabled(true).build();\n        Prompt prompt = Prompt.builder().chatOptions(options).messages(List.of(UserMessage.builder().text(param).build())).build();\n        return chatClient.prompt(prompt).system(&quot;give direct answers nothing more nothing less&quot;).call().content();\n        }\n        finally{\n//must clear the context value to prevent reusing the value in re use of thread\n            CustomUserHeader.clear();\n        }\n    \n    }\n</code></pre>\n<p>a</p>\n",
    "score" : 1,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 43014330,
      "reputation" : 34,
      "user_id" : 31031994,
      "user_type" : "unregistered",
      "profile_image" : "https://www.gravatar.com/avatar/b2449da002240fc05a04ddd8fdcb4b52?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "user31031994",
      "link" : "https://stackoverflow.com/users/31031994/user31031994"
    },
    "creation_date" : 1752480305,
    "last_activity_date" : 1752480305,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79738017,
    "question_id" : 79675247,
    "body" : "<p>I solved this problem using InheritedThreadLocal like the following. Just use this static class and add whatever context you want in the place of subject sum. For my case it holds the user auth info grabbed via the request headers in a custom sse transport provider implementation.</p>\n<pre class=\"lang-java prettyprint-override\"><code>public final class McpContextHolder {\n    private static final ThreadLocal&lt;SubjectSum&gt; subjectHolder =\n            new NamedInheritableThreadLocal&lt;&gt;(&quot;MCP Security and User Identification Context&quot;);\n\n    private McpContextHolder() {}\n\n    /**\n     * Attaches the user's context to the current thread.\n     */\n    public static void setSubject(SubjectSum subject) {\n        subjectHolder.set(subject);\n\n    }\n\n    /**\n     * Retrieves the context from the current thread.\n     */\n    public static SubjectSum getSubject() {\n        return subjectHolder.get();\n    }\n\n    /**\n     * Clears the context from the thread to prevent memory leaks.\n     */\n    public static void clear() {\n        subjectHolder.remove();\n    }\n}\n\n\n\n/**inside the post request handler\n* where subject can be the auth info you want to access inside the tool call\n*/\n\nMcpContextHolder.setSubject(subject);\n\n\n/** inside the tool call */\n\nSubject subject = McpContextHolder.getSubject();\nlog.debug(&quot;Current subject in the tool: {}&quot;, subjectSum);\n\n\n</code></pre>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 43543404,
      "reputation" : 11,
      "user_id" : 31292745,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/df42d9a50c94e998f3107215354dfb5a?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Sarthak Arora",
      "link" : "https://stackoverflow.com/users/31292745/sarthak-arora"
    },
    "creation_date" : 1755453839,
    "last_activity_date" : 1755453839,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79677611,
    "question_id" : 79675247,
    "body" : "<p>Have you tried to make <code>ToolContext</code> required and provide a description? It is better to set a short and clear description. It provides a main keys allowed AI to understand the context.</p>\n<p>Try to use simple objects, f.e. <code>String</code> apiKey and see if it works or not. Incorrect prompting in such cases is the most common mistake.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 42701960,
      "reputation" : 1,
      "user_id" : 30880754,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/584c21bf2a6bd5c2b215202a2defb350?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Valerii Fedorovych",
      "link" : "https://stackoverflow.com/users/30880754/valerii-fedorovych"
    },
    "creation_date" : 1750769773,
    "last_activity_date" : 1750769773,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79738017" : [ {
      "comment_id" : 140686434,
      "post_id" : 79738017,
      "body" : "This solution working the the implementation from user31031994 <a href=\"https://stackoverflow.com/a/79700580/22944268\">stackoverflow.com/a/79700580/22944268</a>",
      "score" : 1,
      "owner" : {
        "account_id" : 29939318,
        "reputation" : 53,
        "user_id" : 22944268,
        "user_type" : "registered",
        "profile_image" : "https://lh3.googleusercontent.com/a/ACg8ocJjrIqrZ7auuZ2Sz04GLhl1Ptr8qcEWyaRV-9lqO4egjvfb=k-s256",
        "display_name" : "Alanta335",
        "link" : "https://stackoverflow.com/users/22944268/alanta335"
      },
      "creation_date" : 1755934186,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79700580" : [ {
      "comment_id" : 140822863,
      "post_id" : 79700580,
      "body" : "Be careful: this does not seem to work if you expose your endpoint in HTTP streaming mode, for example using Flux&lt;String&gt; together with chatClient.prompt().user(...).stream().  The MCP client and its SDK do not appear to be thread-safe when used with Reactor for streaming chat clients.",
      "score" : 0,
      "owner" : {
        "account_id" : 4723263,
        "reputation" : 247,
        "user_id" : 3820633,
        "user_type" : "registered",
        "accept_rate" : 17,
        "profile_image" : "https://www.gravatar.com/avatar/102db1d429d12dc6e3fdf1f3d3ffbf5a?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "robynico",
        "link" : "https://stackoverflow.com/users/3820633/robynico"
      },
      "creation_date" : 1761662005,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140686440,
      "post_id" : 79700580,
      "body" : "The solution you gave work by replacing ThreadLocal with NamedInheritableThreadLocal  which was suggested by Sarthak Arora in <a href=\"https://stackoverflow.com/a/79738017/22944268\">stackoverflow.com/a/79738017/22944268</a>",
      "score" : 1,
      "owner" : {
        "account_id" : 29939318,
        "reputation" : 53,
        "user_id" : 22944268,
        "user_type" : "registered",
        "profile_image" : "https://lh3.googleusercontent.com/a/ACg8ocJjrIqrZ7auuZ2Sz04GLhl1Ptr8qcEWyaRV-9lqO4egjvfb=k-s256",
        "display_name" : "Alanta335",
        "link" : "https://stackoverflow.com/users/22944268/alanta335"
      },
      "creation_date" : 1755934305,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140644103,
      "post_id" : 79700580,
      "body" : "When I tried to access data from an @Tool method I created in my MCP server, I was getting null from the threadLocal.  The following log message confirms this:  2025-08-05T21:54:27.537+05:30  INFO 15560 --- [mcp-server] [boundedElastic-1] c.e.m.m.context.UserThreadLocalHolder   : Thread [boundedElastic-1] has user [null]  From this, I&#39;ve concluded that the tool is being called from a boundedElastic thread. Because of this, the threadLocal is null.",
      "score" : 2,
      "owner" : {
        "account_id" : 29939318,
        "reputation" : 53,
        "user_id" : 22944268,
        "user_type" : "registered",
        "profile_image" : "https://lh3.googleusercontent.com/a/ACg8ocJjrIqrZ7auuZ2Sz04GLhl1Ptr8qcEWyaRV-9lqO4egjvfb=k-s256",
        "display_name" : "Alanta335",
        "link" : "https://stackoverflow.com/users/22944268/alanta335"
      },
      "creation_date" : 1754411282,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79677611" : [ {
      "comment_id" : 140892166,
      "post_id" : 79677611,
      "body" : "Yes spring ai is still very buggy:  <a href=\"https://github.com/spring-projects/spring-ai/issues/4344\" rel=\"nofollow noreferrer\">github.com/spring-projects/spring-ai/issues/4344</a>    The issue, and it is still not resolved.. Interception is messy at best.",
      "score" : 0,
      "owner" : {
        "account_id" : 13875989,
        "reputation" : 1,
        "user_id" : 10017639,
        "user_type" : "registered",
        "profile_image" : "https://lh3.googleusercontent.com/-CR6b27yuDlE/AAAAAAAAAAI/AAAAAAAAAGA/ekr_uwevvpk/s256-rj/photo.jpg",
        "display_name" : "avi tiwari",
        "link" : "https://stackoverflow.com/users/10017639/avi-tiwari"
      },
      "creation_date" : 1765181782,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140550520,
      "post_id" : 79677611,
      "body" : "This method is based on passing the API key as context to LLM. This will be prone to prompt injection.  I have tried this method and it will work. I looking for a way that does not use LLM prompt context to pass data as it can be extracted using prompt injection.",
      "score" : 2,
      "owner" : {
        "account_id" : 29939318,
        "reputation" : 53,
        "user_id" : 22944268,
        "user_type" : "registered",
        "profile_image" : "https://lh3.googleusercontent.com/a/ACg8ocJjrIqrZ7auuZ2Sz04GLhl1Ptr8qcEWyaRV-9lqO4egjvfb=k-s256",
        "display_name" : "Alanta335",
        "link" : "https://stackoverflow.com/users/22944268/alanta335"
      },
      "creation_date" : 1751174537,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}