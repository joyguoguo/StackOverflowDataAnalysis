{
  "question" : {
    "question_id" : 79702785,
    "title" : "How to access authenticated user principal in SessionConnectedEvent when using a ChannelInterceptor for JWT authentication?",
    "body" : "<p>I’m using a custom WebSocketChannelInterceptor (implements ChannelInterceptor) to handle authentication during the CONNECT STOMP command. The interceptor extracts and validates a JWT token from the Authorization header like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Override\npublic Message&lt;?&gt; preSend(@NonNull Message&lt;?&gt; message, @NonNull MessageChannel channel) {\n    var accessor = StompHeaderAccessor.wrap(message);\n    StompCommand command = accessor.getCommand();\n    if (command == null) {\n        return null;\n    }\n\n    return switch (command) {\n        case CONNECT -&gt; handleConnect(message, accessor);\n        case SEND -&gt; handleSend(message, accessor);\n        default -&gt; message;\n    };\n}\n\nprivate Message&lt;?&gt; handleConnect(Message&lt;?&gt; message, StompHeaderAccessor accessor) {\n    String authorizationHeader = accessor.getFirstNativeHeader(HttpHeaders.AUTHORIZATION);\n    if (authorizationHeader == null || !authorizationHeader.startsWith(JwtService.BEARER_PREFIX)) {\n        throw new MessageHandlingException(message, &quot;Missing or invalid authorization header&quot;);\n    }\n\n    String token = authorizationHeader.substring(JwtService.BEARER_PREFIX.length()).trim();\n    try {\n        var jwtAuthToken = new JwtAuthenticationToken(token);\n        authManager.authenticate(jwtAuthToken);\n        return message;\n    } catch (BadCredentialsException e) {\n        throw new MessageHandlingException(message, e.getMessage());\n    } catch (RuntimeException e) {\n        throw new MessageHandlingException(message, &quot;Internal server error&quot;);\n    }\n}\n</code></pre>\n<p>My question is: How can I access the authenticated user's Principal inside the SessionConnectedEvent handler?</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Slf4j\n@Component\n@RequiredArgsConstructor\npublic class WebSocketEventListener {\n\n    @EventListener\n    public void sessionConnectedEvent(SessionConnectedEvent event) {\n        // How to get Principal here?\n    }\n}\n</code></pre>\n<p>I’m not interested in SessionConnectEvent — I specifically want to get the user from SessionConnectedEvent after the handshake and connection are completed.</p>\n<p>Thanks in advance!</p>\n<p>I've tried many different approaches, but none of them worked for my case. The token is sent during the initial WebSocket connection using STOMP headers like this:</p>\n<pre class=\"lang-js prettyprint-override\"><code>const client = new Client({\n    brokerURL: 'ws://localhost:8080/ws',\n    connectHeaders: {\n        &quot;Authorization&quot;: `Bearer ${accessToken}`,\n    },\n    onStompError: await onStompError,\n    onConnect: () =&gt; {\n        console.log(&quot;Successfully connected&quot;);\n    },\n    debug: console.debug\n});\n</code></pre>\n",
    "tags" : [ "java", "spring", "spring-websocket", "stomp" ],
    "owner" : {
      "account_id" : 42855635,
      "reputation" : 13,
      "user_id" : 30956973,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/pB1QZQjf.jpg?s=256",
      "display_name" : "Kvanzi",
      "link" : "https://stackoverflow.com/users/30956973/kvanzi"
    },
    "is_answered" : true,
    "view_count" : 87,
    "answer_count" : 1,
    "score" : 1,
    "last_activity_date" : 1752645612,
    "creation_date" : 1752624887,
    "link" : "https://stackoverflow.com/questions/79702785/how-to-access-authenticated-user-principal-in-sessionconnectedevent-when-using-a",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79702942,
    "question_id" : 79702785,
    "body" : "<p>The way I solved the authentication problem was that in my <code>preSend</code> I set the authentication token from the headers that contain it:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public final class WebsocketAuthenticationInterceptor implements ChannelInterceptor {\n\n    public static final String SIMP_USER_HEADER = &quot;simpUser&quot;;\n\n    @SneakyThrows\n    @Override\n    public Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) {\n        setAuthenticationIfPresent(message);\n        return message;\n    }\n\n    private void setAuthenticationIfPresent(Message&lt;?&gt; message) {\n        if (message instanceof GenericMessage&lt;?&gt; genericMessage &amp;&amp;\n                genericMessage.getHeaders().get(SIMP_USER_HEADER) instanceof PreAuthenticatedAuthenticationToken token) {\n            SecurityContextHolder.getContext().setAuthentication(token);\n        }\n    }\n}\n</code></pre>\n<p>and afterwards you can always access it anywhere (including the <code>sessionConnectedEvent</code> method) via <code>SecurityContextHolder.getContext().getAuthentication()</code></p>\n<hr />\n<p>Depending on where you are trying to access the Authenticated Principal, you might have to set <code>SecurityContextHolder.MODE_INHERITABLETHREADLOCAL</code> to allow child threads to access the Authentication Object that was set by the parent thread. For that just add this to any Configuration Bean:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@PostConstruct\nvoid setGlobalSecurityContext() {\n    SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL);\n}\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 16657879,
      "reputation" : 4350,
      "user_id" : 12038714,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a-/AAuE7mAgRe8u2G_kzJJ-KZ2yZwAD1E4kxs9eRlqnY45BUw=k-s256",
      "display_name" : "asgarov1",
      "link" : "https://stackoverflow.com/users/12038714/asgarov1"
    },
    "creation_date" : 1752643757,
    "last_activity_date" : 1752645612,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}