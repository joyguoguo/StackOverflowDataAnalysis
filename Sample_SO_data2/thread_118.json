{
  "question" : {
    "question_id" : 79838626,
    "title" : "Binding two JavaFX services&#39; running properties",
    "body" : "<p>How do I bind the <code>running</code> property of one <code>Service</code> to the same <code>property</code> of another <code>Service</code> that it (re)starts? The first service must be considered running as long as the &quot;nested&quot; service is. In my simple demo, there's only one nested service, yet there could be more.</p>\n<p>The problematic part is <code>service.runningProperty()</code> does not return a <code>javafx.beans.property.Property</code> with a <code>bind()</code> method. It instead returns a <code>ReadOnlyBooleanProperty</code> that does not expose such a method.</p>\n<p>I could override <code>javafx.concurrent.Service#runningProperty</code> in a subclass to return <code>super.runningProperty().or(nestedRunningProperty())</code>, but the method is <code>final</code>, could not be overridden.</p>\n<p>I am hesitant to declare a separate property in my <code>Service</code> subclass (say, <code>effectiveRunningProperty()</code>). I don't want the service's clients to even know whether it has nested services. I am fine with declaring <code>myService.addAndWire(anotherService)</code>, on the other hand, if necessary (may be called by another client beforehand, not the one requesting/ binding to the <code>running</code> property).</p>\n<p>What is the best way to achieve my goal?</p>\n<p>Here's a demo that does <strong>not</strong> achieve it. Its idea is to keep the &quot;Start&quot; button disabled as long as the service, in its entirety, is running.</p>\n<pre class=\"lang-java prettyprint-override\"><code>import javafx.application.Application;\nimport javafx.concurrent.Service;\nimport javafx.geometry.Insets;\nimport javafx.geometry.Pos;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Button;\nimport javafx.scene.layout.VBox;\nimport javafx.stage.Stage;\n\nimport java.time.Duration;\nimport java.util.function.Function;\n\n\npublic class FXServiceDemo extends Application {\n\n    @Override\n    public void start(Stage primaryStage) {\n        primaryStage.setScene(createScene());\n        primaryStage.setTitle(&quot;Service Demo&quot;);\n        primaryStage.show();\n    }\n\n    private Scene createScene() {\n        VBox root = createRoot();\n        Scene scene = new Scene(root);\n        return scene;\n    }\n\n    private VBox createRoot() {\n        VBox root = new VBox();\n        root.setAlignment(Pos.CENTER);\n        root.setPadding(new Insets(5));\n        root.getChildren().add(createStartButton());\n        return root;\n    }\n\n    private Button createStartButton() {\n        Service&lt;Void&gt; outerService = createOuterService(); // inner Service is not create in this scope\n        Button button = new Button();\n        button.textProperty().set(&quot;Start&quot;);\n        button.disableProperty().bind(outerService.runningProperty()); // button doesn't know there could be nested services\n        Function&lt;Boolean, String&gt; toWord = disable -&gt; disable ? &quot;DISABLED&quot; : &quot;ENABLED&quot;;\n        button.disableProperty().addListener((ob, ov, nv) -&gt; System.out.printf(&quot;Button was %s, but is now %s\\n&quot;, toWord.apply(ov), toWord.apply(nv)));\n        button.onActionProperty().setValue(e -&gt; outerService.restart());\n        return button;\n    }\n\n    private static Service&lt;Void&gt; createOuterService() {\n        Service&lt;Void&gt; service = Services.from(FXServiceDemo::perform);\n        return service;\n    }\n\n    private static void perform() {\n        System.out.println(&quot;Doing something before launching the nested Service...&quot;);\n        sleep(Duration.ofSeconds(1));\n        System.out.println(&quot;Launching the nested Service...&quot;);\n        startInnerService();\n    }\n\n    private static void startInnerService() {\n        Service&lt;Void&gt; service = createInnerService();\n        service.restart();\n    }\n\n    private static void sleep(Duration duration) {\n        try {\n            Thread.sleep(duration.toMillis());\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static Service&lt;Void&gt; createInnerService() {\n        Service&lt;Void&gt; service = Services.from(FXServiceDemo::performNested);\n        return service;\n    }\n\n    private static void performNested() {\n        System.out.println(&quot;Doing something in the nested Service...&quot;);\n        sleep(Duration.ofSeconds(2));\n        System.out.println(&quot;Nested completed&quot;);\n    }\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>import javafx.concurrent.Service;\nimport javafx.concurrent.Task;\n\npublic class Services {\n\n    public static Service&lt;Void&gt; from(Runnable task) {\n        return new Service&lt;Void&gt;() {\n            @Override\n            protected Task&lt;Void&gt; createTask() {\n                return new Task&lt;Void&gt;() {\n                    @Override\n                    protected Void call() {\n                        task.run();\n                        return null;\n                    }\n                };\n            }\n        };\n    }\n}\n</code></pre>\n<p>Once you run it and press the button, you get this console:</p>\n<pre><code>Button was ENABLED, but is now DISABLED \nDoing something before launching the nested Service...\nLaunching the nested Service...\nButton was DISABLED, but is now ENABLED \nDoing something in the nested Service...\nNested completed\n</code></pre>\n<p>Instead, it should be:</p>\n<pre><code>Button was ENABLED, but is now DISABLED \nDoing something before launching the nested Service...\nLaunching the nested Service...\nDoing something in the nested Service...\nNested completed\nButton was DISABLED, but is now ENABLED \n</code></pre>\n<p>Java 8.</p>\n",
    "tags" : [ "java", "concurrency", "javafx-8" ],
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2683,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "is_answered" : false,
    "view_count" : 30,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1764937440,
    "creation_date" : 1764919905,
    "link" : "https://stackoverflow.com/questions/79838626/binding-two-javafx-services-running-properties",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79838855,
    "question_id" : 79838626,
    "body" : "<p>Why have a nested service at all?  Why not have outerService call performedNested directly, as a regular method call?  That will allow outerService to keep running as long as the functions of the inner service are running.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2053598,
      "reputation" : 44991,
      "user_id" : 1831987,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/38b1c37530189ec4471a43a618e33f67?s=256&d=identicon&r=PG",
      "display_name" : "VGR",
      "link" : "https://stackoverflow.com/users/1831987/vgr"
    },
    "creation_date" : 1764936071,
    "last_activity_date" : 1764936071,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}