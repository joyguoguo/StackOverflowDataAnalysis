{
  "question" : {
    "question_id" : 79707291,
    "title" : "Is there _any_ way in Java (even if &quot;unsafe&quot;) to instantiate an uninitialized object directly at a specified address?",
    "body" : "<p>[Edit: This would not be done on (regular) heap memory; but direct ByteBuffer, or off-heap memory allocated through Unsafe, or MemorySegment (from FFM) are all possible candidates.]</p>\n<p>I'm aware that via Unsafe I can allocate a new uninitialised instance and, if I know the object size via e.g. jol or jamm, copy it to the desired location also via Unsafe. But this creates unnecessary garbage (though via escape analysis garbage creation might sometimes be avoided).</p>\n<p>For example are there any libraries with instrumentation that could do this?</p>\n<p>I'd rather avoid JNI because of the overhead. If the FFM enhancement enables this it would I expect be faster than JNI, but looking at a recent spec it looks as though it won't.</p>\n<p>Of course I'd rather avoid forking and then hacking the JVM if at all possible. May be there's some technique I haven't even thought of which would avoid that.</p>\n<p>And of course, I'm aware Unsafe is to be gradually excised from the JDK. But using Unsafe would prove a concept and have some limited life, before having to resort to hacking the JVM.</p>\n<p>My motivation is to enable really, really fast serialization and (often deep) copying, and to create collections of objects with much better memory locality than typical higgledy-piggledy heap-allocated objects, as part of prototyping a new (fast) JVM language.</p>\n<p>Please don't close the question because I'm &quot;asking for library recommendations&quot;, because I'm not. I simply want to know if it is possible at all (with or without 3rd party libraries) and not whether any such library is &quot;better than&quot; any other such library, if indeed any exists.</p>\n",
    "tags" : [ "java", "jvm", "unsafe", "low-level-code" ],
    "owner" : {
      "account_id" : 1845234,
      "reputation" : 1276,
      "user_id" : 1673705,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/abe6098dc122d57b2c7b1aa8f074723a?s=256&d=identicon&r=PG",
      "display_name" : "barneypitt",
      "link" : "https://stackoverflow.com/users/1673705/barneypitt"
    },
    "is_answered" : false,
    "view_count" : 177,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1752996933,
    "creation_date" : 1752932766,
    "link" : "https://stackoverflow.com/questions/79707291/is-there-any-way-in-java-even-if-unsafe-to-instantiate-an-uninitialized-ob",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79707341,
    "question_id" : 79707291,
    "body" : "<blockquote>\n<p>Is there <em>any</em> way in Java (even if &quot;unsafe&quot;) to instantiate an uninitialized object directly at a specified address?</p>\n</blockquote>\n<p>You can't do this in &quot;pure&quot; Java.</p>\n<p>You can't do that with <code>Unsafe</code>.  <code>Unsafe</code> does allow you to create a Java object without causing any constructor to run<sup>1</sup>, but you can't specify what address it would be allocated at.</p>\n<p>You could <strong>in theory</strong> do it with native code<sup>2</sup> called from JNI<sup>3</sup>, but it would be a difficult / risky thing to do.  If the object is in a heap managed by the Java GC, you would have to do everything in ways that wouldn't crash the GC and/or the allocator.  If it is not in the heap, then you have the problem of how to handle references; e.g. to avoid the GC or memory barriers from blowing up when they sees them.</p>\n<blockquote>\n<p>My motivation is to enable really, really fast serialization and (often deep) copying, and to create collections of objects with much better memory locality than typical higgledy-piggledy heap-allocated objects, as part of prototyping a new (fast) JVM language.</p>\n</blockquote>\n<p>OK ... so basically that entails modifying the JVM's memory management mechanisms.  It sounds like you need to design and implement a brand new JVM implementation that deals with allocation, etcetera in the way you want it to.  Of course, that makes your project larger than you probably envisaged.</p>\n<blockquote>\n<p>This would not be done on (regular) heap memory; but direct <code>ByteBuffer</code>, or off-heap memory allocated through Unsafe, or <code>MemorySegment</code> (from FFM) are all possible candidates</p>\n</blockquote>\n<p>I don't think this changes anything.  A Java object that is &quot;allocated&quot; inside <em>any</em> off-heap memory segment (be it a direct <code>ByteBuffer</code> or a <code>MemorySegment</code> or an <code>Unsafe</code> allocation) needs to have a reference; i.e. a memory address.  If  you assign the memory reference to a local variable or object fields (and possibly other things) then it may be visible to the GC and/or to memory barriers.  These will assume that the reference is a valid on-heap object reference, and will (most likely) crash the JVM immediately or lead to further heap corruption.  The JVM <em>assumes</em> that all Java object references are on-heap.</p>\n<hr />\n<p><sup>1 - This is used by the Java Object Serialization classes.<br>\n2 - Or any other supported mechanism for calling native code from Java. The performance of the mechanism is moot ... since at some level you will have to &quot;wear&quot; it if you use a conventional JVM.<br>\n3 - You can in theory do <em>anything</em> (permitted by the host OS) in native code.</sup></p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 47283,
      "reputation" : 723470,
      "user_id" : 139985,
      "user_type" : "registered",
      "accept_rate" : 69,
      "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
      "display_name" : "Stephen C",
      "link" : "https://stackoverflow.com/users/139985/stephen-c"
    },
    "creation_date" : 1752937091,
    "last_activity_date" : 1752996933,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140602524,
    "post_id" : 79707291,
    "body" : "@andrewJames Rolled back, as whether it is <i>possible</i> for an instrumented library to achieve this is fundamental to the question. I think closing the question on such a basis would be insanely over-zealous... but time will tell! Thanks for you input anyway.",
    "score" : 0,
    "owner" : {
      "account_id" : 1845234,
      "reputation" : 1276,
      "user_id" : 1673705,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/abe6098dc122d57b2c7b1aa8f074723a?s=256&d=identicon&r=PG",
      "display_name" : "barneypitt",
      "link" : "https://stackoverflow.com/users/1673705/barneypitt"
    },
    "creation_date" : 1752943134,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140602371,
    "post_id" : 79707291,
    "body" : "@andrewJames Feel free to recommend a change, but I can&#39;t see how to word &quot;are there any libraries that could do this&quot; any differently! It&#39;s an &quot;is it possible&quot; question, not a recommendation request.",
    "score" : 1,
    "owner" : {
      "account_id" : 1845234,
      "reputation" : 1276,
      "user_id" : 1673705,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/abe6098dc122d57b2c7b1aa8f074723a?s=256&d=identicon&r=PG",
      "display_name" : "barneypitt",
      "link" : "https://stackoverflow.com/users/1673705/barneypitt"
    },
    "creation_date" : 1752936838,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140602359,
    "post_id" : 79707291,
    "body" : "&quot;<i>Please don&#39;t close the question because I&#39;m &quot;asking for library recommendations&quot;, because I&#39;m not.</i>&quot; and &quot;<i>For example are there any libraries with instrumentation that could do this?</i>&quot; - Perhaps you can re-word those parts of your question which may attract close votes.",
    "score" : 2,
    "owner" : {
      "account_id" : 12743722,
      "reputation" : 22621,
      "user_id" : 12567365,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/zNR3x.png?s=256",
      "display_name" : "andrewJames",
      "link" : "https://stackoverflow.com/users/12567365/andrewjames"
    },
    "creation_date" : 1752936345,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79707341" : [ {
      "comment_id" : 140609470,
      "post_id" : 79707341,
      "body" : "@Holger Oops, I put my reply to your comments one level higher in the discussion tree!",
      "score" : 0,
      "owner" : {
        "account_id" : 1845234,
        "reputation" : 1276,
        "user_id" : 1673705,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/abe6098dc122d57b2c7b1aa8f074723a?s=256&d=identicon&r=PG",
        "display_name" : "barneypitt",
        "link" : "https://stackoverflow.com/users/1673705/barneypitt"
      },
      "creation_date" : 1753197717,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140609462,
      "post_id" : 79707341,
      "body" : "@barneypitt Now I need to check out jillegal, a very old, unmaintained and probably very un-production-ready library which actually <i>does</i> allocate objects in off-heap memory. I obviously wouldn&#39;t rely on this obscure unmaintained library to actually implement any part of the language, but I&#39;m keen to see what tricks it used. Even if I don&#39;t need them!",
      "score" : 0,
      "owner" : {
        "account_id" : 1845234,
        "reputation" : 1276,
        "user_id" : 1673705,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/abe6098dc122d57b2c7b1aa8f074723a?s=256&d=identicon&r=PG",
        "display_name" : "barneypitt",
        "link" : "https://stackoverflow.com/users/1673705/barneypitt"
      },
      "creation_date" : 1753197638,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140609441,
      "post_id" : 79707341,
      "body" : "I guess if I needed to be able to distinguish between heap and non-heap references I would just use one of the unused bits in object header to indicate what type of memory the object is allocated in. <i>But</i> I&#39;m thinking now that only creating heap-allocated objects, <i>which defer all field accesses to an off-heap memory area</i> would work just as efficiently as directly allocating objects in off-heap memory (because due to inlining and escape analysis, the transient &quot;wrapper&quot; object would usually be stack allocated in the scenarios I envisage).",
      "score" : 0,
      "owner" : {
        "account_id" : 1845234,
        "reputation" : 1276,
        "user_id" : 1673705,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/abe6098dc122d57b2c7b1aa8f074723a?s=256&d=identicon&r=PG",
        "display_name" : "barneypitt",
        "link" : "https://stackoverflow.com/users/1673705/barneypitt"
      },
      "creation_date" : 1753197359,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140609391,
      "post_id" : 79707341,
      "body" : "@barneypitt I was saying that <i>the ways in which the proposed language would navigate around the dangers</i> is not part of the question. I&#39;m not suggesting that people should not be pointing out dangers. But the question was not &quot;Hey, everybody, what do you think of this new language?&quot;. I have now discovered a library which does exactly what I was asking. It&#39;s called jillegal. Sadly it hasn&#39;t been touched in 11 years and I wouldn&#39;t for a moment trust it to work with java versions after 8 (the last version it supports). But I intend to mosey around the code and see if there are ideas I can use.",
      "score" : 0,
      "owner" : {
        "account_id" : 1845234,
        "reputation" : 1276,
        "user_id" : 1673705,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/abe6098dc122d57b2c7b1aa8f074723a?s=256&d=identicon&r=PG",
        "display_name" : "barneypitt",
        "link" : "https://stackoverflow.com/users/1673705/barneypitt"
      },
      "creation_date" : 1753196557,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140605898,
      "post_id" : 79707341,
      "body" : "@Holger  Ah ... I see. Yea, that works ... modulo the extra memory usage for these &quot;fat&quot; references. (I guess another alternative would be something like the PIDLAM approach used in PS-Algol.)",
      "score" : 0,
      "owner" : {
        "account_id" : 47283,
        "reputation" : 723470,
        "user_id" : 139985,
        "user_type" : "registered",
        "accept_rate" : 69,
        "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
        "display_name" : "Stephen C",
        "link" : "https://stackoverflow.com/users/139985/stephen-c"
      },
      "creation_date" : 1753099606,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140605551,
      "post_id" : 79707341,
      "body" : "@Holger I did not assume that the off-heap and on-heap pointers are coerced into one value. Since this only affects functions written in the OP’s language, the generated code can carry a pair or similar thing as long as needed, but, as said, you’d normally check and branch as early as possible; the optimized branches are generated for one of the scenarios then.",
      "score" : 1,
      "owner" : {
        "account_id" : 3211603,
        "reputation" : 301001,
        "user_id" : 2711488,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
        "display_name" : "Holger",
        "link" : "https://stackoverflow.com/users/2711488/holger"
      },
      "creation_date" : 1753090684,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140605515,
      "post_id" : 79707341,
      "body" : "@Holger That assumes that the bit patterns for on-heap and off-heap &quot;references&quot; can be distinguished at runtime.  And that the (JVM) GC will be happy with dealing with an object field or stack variable that contains one of these hybrid reference values.",
      "score" : 0,
      "owner" : {
        "account_id" : 47283,
        "reputation" : 723470,
        "user_id" : 139985,
        "user_type" : "registered",
        "accept_rate" : 69,
        "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
        "display_name" : "Stephen C",
        "link" : "https://stackoverflow.com/users/139985/stephen-c"
      },
      "creation_date" : 1753089938,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140605442,
      "post_id" : 79707341,
      "body" : "@Holger The generated code would have to distinguish between these cases but the usual optimization techniques apply, like having the conditionals as early as possible and branch to versions optimized to a particular case, etc.",
      "score" : 1,
      "owner" : {
        "account_id" : 3211603,
        "reputation" : 301001,
        "user_id" : 2711488,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
        "display_name" : "Holger",
        "link" : "https://stackoverflow.com/users/2711488/holger"
      },
      "creation_date" : 1753088420,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140605426,
      "post_id" : 79707341,
      "body" : "@Holger One snag.  This would require his language to distinguish between on-heap and off-heap objects ... at the class level.  (Or references represented as a pair consisting of a native reference and a integer.)",
      "score" : 1,
      "owner" : {
        "account_id" : 47283,
        "reputation" : 723470,
        "user_id" : 139985,
        "user_type" : "registered",
        "accept_rate" : 69,
        "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
        "display_name" : "Stephen C",
        "link" : "https://stackoverflow.com/users/139985/stephen-c"
      },
      "creation_date" : 1753088183,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140605387,
      "post_id" : 79707341,
      "body" : "@barneypitt So why do you need them to be ordinary JVM objects then? If they are only accessible by the functions of your language, whose code generation you control, just allocate some off-heap memory and let your functions access it. Case closed.",
      "score" : 2,
      "owner" : {
        "account_id" : 3211603,
        "reputation" : 301001,
        "user_id" : 2711488,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
        "display_name" : "Holger",
        "link" : "https://stackoverflow.com/users/2711488/holger"
      },
      "creation_date" : 1753087495,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140605379,
      "post_id" : 79707341,
      "body" : "@barneypitt How is this “unrelated to the question”? All built-in garbage collector algorithms assume the objects to be on the heap and relocatable. There is no way, your off-heap object could work without providing a new garbage collector implementation. It’s not even guaranteed that you can encode an off-heap pointer as an object reference, as the compressed pointers feature is specifically designed to encode addresses limited to the heap region.",
      "score" : 2,
      "owner" : {
        "account_id" : 3211603,
        "reputation" : 301001,
        "user_id" : 2711488,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
        "display_name" : "Holger",
        "link" : "https://stackoverflow.com/users/2711488/holger"
      },
      "creation_date" : 1753087316,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140604130,
      "post_id" : 79707341,
      "body" : "The proposed language supports (in fact absolutely requires the existence of, for many purposes) pure functions/methods. In fact all methods are pure by default... and nothing can escape the local method scope of pure methods, which is enforced at compile time. Only pure functions would be allowed to work with these specially allocated objects, which would always remain sandboxed in specialized collections (or exposed only as immutable heap-allocated copies).",
      "score" : 0,
      "owner" : {
        "account_id" : 1845234,
        "reputation" : 1276,
        "user_id" : 1673705,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/abe6098dc122d57b2c7b1aa8f074723a?s=256&d=identicon&r=PG",
        "display_name" : "barneypitt",
        "link" : "https://stackoverflow.com/users/1673705/barneypitt"
      },
      "creation_date" : 1753028708,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140603540,
      "post_id" : 79707341,
      "body" : "Would only be in exceptional circumstances. I&#39;ve thought about it all very long and very hard. For example, all Objects <i>can</i> be (but aren&#39;t generally) represented by alternative implementations, including ones which have only one actual field (a byte[]) or two fields (a byte[] and an offset) ... or ones which use a DirectByteBuffer or similar instead of a byte[]. Raw access to fields is prohibited (everything is a property) and properties can be implemented as unsafe reads/writes of primitives to the backing store. This is actually quite vanilla except the unsafe array reads/writes.",
      "score" : 0,
      "owner" : {
        "account_id" : 1845234,
        "reputation" : 1276,
        "user_id" : 1673705,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/abe6098dc122d57b2c7b1aa8f074723a?s=256&d=identicon&r=PG",
        "display_name" : "barneypitt",
        "link" : "https://stackoverflow.com/users/1673705/barneypitt"
      },
      "creation_date" : 1753002462,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140603430,
      "post_id" : 79707341,
      "body" : "@barneypitt Right.  But the problem is that you have a proverbial &quot;snowball&#39;s chance in hell&quot; of safely injecting off-heap Java objects into a JVM <i>without</i> modifying the JVM codebase.  (Which is apparently what you are trying to do: <i>&quot;Of course I&#39;d rather avoid forking and then hacking the JVM if at all possible.&quot;</i>.) That&#39;s what we are trying to tell you.  (But feel free to prove us wrong by actually doing it.)",
      "score" : 3,
      "owner" : {
        "account_id" : 47283,
        "reputation" : 723470,
        "user_id" : 139985,
        "user_type" : "registered",
        "accept_rate" : 69,
        "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
        "display_name" : "Stephen C",
        "link" : "https://stackoverflow.com/users/139985/stephen-c"
      },
      "creation_date" : 1752997125,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140603369,
      "post_id" : 79707341,
      "body" : "@LouisWasserman Quite. All of which the proposed language knows about and manages safely, though that fact is unrelated to the question. Or to put it another way, I&#39;m not some ham-fisted upstart who has no idea what he is doing!",
      "score" : 0,
      "owner" : {
        "account_id" : 1845234,
        "reputation" : 1276,
        "user_id" : 1673705,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/abe6098dc122d57b2c7b1aa8f074723a?s=256&d=identicon&r=PG",
        "display_name" : "barneypitt",
        "link" : "https://stackoverflow.com/users/1673705/barneypitt"
      },
      "creation_date" : 1752994372,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140603000,
      "post_id" : 79707341,
      "body" : "Objects of Java classes are expected to live on the heap, and that expectation is baked into the JVM at many, many levels.",
      "score" : 4,
      "owner" : {
        "account_id" : 465573,
        "reputation" : 200423,
        "user_id" : 869736,
        "user_type" : "registered",
        "accept_rate" : 82,
        "profile_image" : "https://www.gravatar.com/avatar/ae7bb06b9a23a4dd7eea69e853d47d12?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Louis Wasserman",
        "link" : "https://stackoverflow.com/users/869736/louis-wasserman"
      },
      "creation_date" : 1752965729,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140602912,
      "post_id" : 79707341,
      "body" : "Could you elaborate on why you think allocating objects in off-heap memory could be problematic? I would have thought that GC/memory barriers would ignore such off-heap objects entirely.",
      "score" : 0,
      "owner" : {
        "account_id" : 1845234,
        "reputation" : 1276,
        "user_id" : 1673705,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/abe6098dc122d57b2c7b1aa8f074723a?s=256&d=identicon&r=PG",
        "display_name" : "barneypitt",
        "link" : "https://stackoverflow.com/users/1673705/barneypitt"
      },
      "creation_date" : 1752958450,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140602897,
      "post_id" : 79707341,
      "body" : "@WasabiThumbs [continuation of the above] ... given that escape analysis would often eliminate the (uninitialised) object allocation, and in most other cases any garbage would be remain young-generation, and so be cheap to collect.",
      "score" : 0,
      "owner" : {
        "account_id" : 1845234,
        "reputation" : 1276,
        "user_id" : 1673705,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/abe6098dc122d57b2c7b1aa8f074723a?s=256&d=identicon&r=PG",
        "display_name" : "barneypitt",
        "link" : "https://stackoverflow.com/users/1673705/barneypitt"
      },
      "creation_date" : 1752957642,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140602895,
      "post_id" : 79707341,
      "body" : "@WasabiThumbs Why do you think direct memory serialization is a bad idea where portability is concerned? If you mean because of endian-ness, that doesn&#39;t concern me a bit, because big-endian architectures are about as rare as hen&#39;s teeth! And in any case, endian-ness can be corrected at the receiving end easily enough, right? A &quot;situational&quot; solution wouldn&#39;t work at all (as I said I&#39;m wanting to prototype a JVM language, the mechanism has to work on any old object). The more I think about it the better my rejected solution in the 4th paragraph looks viable for proof of concept... [continues]",
      "score" : 0,
      "owner" : {
        "account_id" : 1845234,
        "reputation" : 1276,
        "user_id" : 1673705,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/abe6098dc122d57b2c7b1aa8f074723a?s=256&d=identicon&r=PG",
        "display_name" : "barneypitt",
        "link" : "https://stackoverflow.com/users/1673705/barneypitt"
      },
      "creation_date" : 1752957472,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140602782,
      "post_id" : 79707341,
      "body" : "@barneypitt JNI seems to me the only sane way to make such an optimization, and in that case, it would be highly situational (assuming an unmodified JVM). You could simply implement your serializable struct in C and expose it to Java with native methods, then do whatever magic you&#39;d like with that struct pointer. I&#39;d also caution that direct memory serialization is a bad idea where portability is concerned.",
      "score" : 0,
      "owner" : {
        "account_id" : 14914414,
        "reputation" : 1185,
        "user_id" : 10808904,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/Ts8fIsJj.png?s=256",
        "display_name" : "Xavier Pedraza",
        "link" : "https://stackoverflow.com/users/10808904/xavier-pedraza"
      },
      "creation_date" : 1752951641,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140602592,
      "post_id" : 79707341,
      "body" : "It wouldn&#39;t be regular heap memory (I have added that!): for the reasons that you state I don&#39;t think that could be made to work safely. But direct ByteBuffer, or off-heap memory allocated through Unsafe, or MemorySegment are all possible candidates. I think you hugely overestimate the complexity of building an altered JVM. Why would a &quot;brand new&quot; JVM implementation be involved? It could just be a fork in which the Unsafe functionality was extended a little (at least to start with)... just a fork like any other fork. Though as I said, I&#39;d obviously prefer not to have to!",
      "score" : 0,
      "owner" : {
        "account_id" : 1845234,
        "reputation" : 1276,
        "user_id" : 1673705,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/abe6098dc122d57b2c7b1aa8f074723a?s=256&d=identicon&r=PG",
        "display_name" : "barneypitt",
        "link" : "https://stackoverflow.com/users/1673705/barneypitt"
      },
      "creation_date" : 1752944921,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}