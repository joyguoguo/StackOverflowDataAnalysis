{
  "question" : {
    "question_id" : 79826251,
    "title" : "Bruce Eckel : Constructor is a static method",
    "body" : "<p>Reading through the masterpiece <strong>Thinking in Java, Bruce Eckel</strong> in many location mentioned that the constructor is a static method. I can't find any article or reference supporting this idea, even I asked different AI,  all assured this idea is wrong.</p>\n<blockquote>\n<p><em>Here is one quote from the book chapter &quot;Type Information&quot; page 395</em><br />\nAll classes are loaded into the JVM dynamically, upon the first use of a class. This happens when the program makes the first reference to a static member of that class. <strong>It turns out that the constructor is also a static method of a class, even though the static keyword is not used for a constructor</strong>. Therefore, creating a new object of that class using the new operator also counts as a reference to a static member of the class.</p>\n</blockquote>\n<p>There are different location in the book where the author mentioned it clearly, Constructor is a static method.</p>\n<p><strong>Is Constructor a static method ?</strong></p>\n",
    "tags" : [ "java" ],
    "owner" : {
      "account_id" : 2238186,
      "reputation" : 4365,
      "user_id" : 1973933,
      "user_type" : "registered",
      "accept_rate" : 58,
      "profile_image" : "https://www.gravatar.com/avatar/45e1e6d2acd53544362e57016421d3bf?s=256&d=identicon&r=PG",
      "display_name" : "Melad Basilius",
      "link" : "https://stackoverflow.com/users/1973933/melad-basilius"
    },
    "is_answered" : true,
    "view_count" : 79,
    "answer_count" : 4,
    "score" : 0,
    "last_activity_date" : 1763737211,
    "creation_date" : 1763712444,
    "link" : "https://stackoverflow.com/questions/79826251/bruce-eckel-constructor-is-a-static-method",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79826312,
    "question_id" : 79826251,
    "body" : "<blockquote>\n<p>Is Constructor a static method?</p>\n</blockquote>\n<p>No.</p>\n<ol>\n<li><p>Constructors are not members of the class that declares them (JLS 8.2) and are therefore not inherited.  Static methods are class members and are inherited.</p>\n</li>\n<li><p>A constructor creates an object on every invocation, and static method doesn't.</p>\n</li>\n<li><p>Constructors explicitly or implicitly invoke a superclass constructor via <code>this</code> and <code>super</code> calls.</p>\n</li>\n<li><p>At the bytecode level, different bytecodes are used to invoke (call) constructors and static methods.</p>\n</li>\n<li><p>The reflection APIs handle constructors and static methods differently.</p>\n</li>\n</ol>\n<hr />\n<p>What Eckel should be saying is that there are <em>similarities</em> between constructors and static methods.  For example:</p>\n<ul>\n<li>Neither constructors or static methods can be overridden, though for different reasons.  (Unlike instance methods)</li>\n<li>Neither constructors or static methods are invoked with a target instance.  (Unlike instance methods.)</li>\n<li>Invocation of both constructors and static methods can trigger class initialization, as implied by the quoted text<sup>1</sup> in your question.  (Unlike instance methods.)</li>\n</ul>\n<hr />\n<p><sup>1 - The quoted text says <em>&quot;All classes are loaded into the JVM dynamically, upon the first use of a class.&quot;</em>.  In fact, the JLS says: <em>&quot;A class or interface T will be <strong>initialized</strong> immediately before [list of events]&quot;</em>.  (JLS 12.4.1)  This is a fine distinction, but class loading and class initialization are not the same thing.  The JLS doesn't say how and when class loading occurs, except that it needs to happen before class initialization.</sup></p>\n",
    "score" : 3,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 47283,
      "reputation" : 723399,
      "user_id" : 139985,
      "user_type" : "registered",
      "accept_rate" : 69,
      "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
      "display_name" : "Stephen C",
      "link" : "https://stackoverflow.com/users/139985/stephen-c"
    },
    "creation_date" : 1763716540,
    "last_activity_date" : 1763717966,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79826266,
    "question_id" : 79826251,
    "body" : "<p>Constructor, in Java, is its own class of methods, separate from static and instance methods.</p>\n<p>Traits shared with instance methods:</p>\n<ul>\n<li>access to a <em>this</em> pointer</li>\n</ul>\n<p>Traits shared with static methods:</p>\n<ul>\n<li>does not need an existing instance to call it</li>\n</ul>\n<p>Arguments for it being its own class of method separate from both:</p>\n<ul>\n<li>Reflection treats it as entirely separate thing <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html\" rel=\"nofollow noreferrer\">java.lang.reflect.Constructor</a>. Whereas instance and static methods are <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html\" rel=\"nofollow noreferrer\">java.lang.reflect.Method</a>. Constructor does not inherit from Method.</li>\n</ul>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1387645,
      "reputation" : 8268,
      "user_id" : 1319284,
      "user_type" : "registered",
      "accept_rate" : 69,
      "profile_image" : "https://www.gravatar.com/avatar/519eaa527537a16e0a4665432095c2e5?s=256&d=identicon&r=PG",
      "display_name" : "kutschkem",
      "link" : "https://stackoverflow.com/users/1319284/kutschkem"
    },
    "creation_date" : 1763713658,
    "last_activity_date" : 1763713658,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79826303,
    "question_id" : 79826251,
    "body" : "<p>It’s a dispute over words. No, by the official definitions a constructor is not a static method. I still see where he’s getting at.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 7612423,
      "reputation" : 87400,
      "user_id" : 5772882,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/8283c64511fa80afed5259d10850168f?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Anonymous",
      "link" : "https://stackoverflow.com/users/5772882/anonymous"
    },
    "creation_date" : 1763716024,
    "last_activity_date" : 1763716024,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79826653,
    "question_id" : 79826251,
    "body" : "<p>Bruce oversimplified. But then, the AI does as well. Oversimplifying is the point of a book, no? If oversimplification is not allowed, then the only book that you are allowed to read is the Java Lang Spec, but that'd be a terrible way to learn java.</p>\n<p>What Bruce means is not &quot;constructors <strong>are</strong> static methods&quot;. What Bruce means is: &quot;Constructors are.. constructors. They are their own thing. However, when thinking about what they are, they share much, <em>much</em> more with static methods, than with instance methods, so if you find it comfortable to think about them as if they were a method, then, think about them like funnily named static methods&quot;.</p>\n<p>And <strong>that</strong> is entirely correct. To wit:</p>\n<ul>\n<li><p>static methods simply do not do inheritance. You can't overwrite them. Yes, you can make a subclass and redefine your static method, but there's no way for that to make any difference: The author of any code that calls this method already knows exactly what method will be invoked as they write it, and any runtime behaviour cannot modify this. In contrast, when I write <code>foo.someInstanceMethod()</code> then exactly which method is invoked will depend on the type of the object the <code>foo</code> variable is pointing at (i.e., java does Dynamic Dispatch on instance methods but not on static methods). <strong>Constructors match this behaviour exactly</strong> - there simply <em>is no</em> dynamic dispatch for constructors at all. You write <code>new Foo()</code>, you know <em>exactly</em> which constructor you are invoking.</p>\n</li>\n<li><p>instance methods have a hidden parameter named the 'receiver'. It's the <code>x</code> in <code>x.foo(arg1, arg2)</code>. You can't invoke an instance method without a value for this receiver, and in addition, if the receiver is <code>null</code>, you get a <code>NullPointerException</code>, and the receiver, aside from being an argument the invoked method can use (it is exposed to them with the magic name <code>this</code>), also decides which actual method is invoked, as it controls the dynamic dispatch aspect. static methods don't have this. You don't need to supply this argument (and, in fact, you can't), static methods can't use <code>this</code> at all, and there is no dynamic dispatch. Constructors are ⅔ s like static methods and only ⅓ like instance methods: You don't have to (and can't) provide a receiver when invoking a constructor, and they don't do dynamic dispatch. They do __have__a <code>this</code> reference you can access from within one, which is like instance methods. But the source is: It was made, for you, by the system. Unlike with instance methods where it's a final parameter that is provided by the caller. In effect, the constructor 'made it', and they share that with all methods (static and instance alike): You can of course make your own stuff and access it. So they are very close to static methods in this regard and almost nothing like instance methods.</p>\n</li>\n<li><p>Whilst you do get a <code>this</code> in a constructor, confusing things happen and your code is hard to test and maintain if you treat this <code>this</code> as a full fledged variable. You should use that <code>this</code> to set up field values and nothing more; invoking methods on it gets very tricky (if your class is subclassed and one of the subclasses overrides this method, confusing things occur, and this is textbook hard to maintain code at that point), let alone if you pass your <code>this</code> ref to code written in other source files. In many ways, its best to think about constructors as <em>not having a <code>this</code> at all</em>. Instead think about it as: <code>this.field = foo</code> is a way to initialise this object, and <em>there is nothing else I am meant to do with <code>this</code></em>.</p>\n</li>\n</ul>\n<p>At the JVM level, constructors are declared as their own thing, but they look the most like a static method whose name is <code>&lt;init&gt;</code> (which is not a legal method name in java-the-language, but it is a method name in java-the-VM-spec).</p>\n<p>There are many, <em>many</em> ways to consider a method. In virtually all of them, constructors are exactly like, or almost exactly like, a static method.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107136,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1763737211,
    "last_activity_date" : 1763737211,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}