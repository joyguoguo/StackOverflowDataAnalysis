{
  "question" : {
    "question_id" : 79833456,
    "title" : "How to efficiently flush and write large amounts of data to a file using BufferedWriter in Java?",
    "body" : "<p>I'm working on a Java project where I need to write a large number of lines to a file. I know <code>BufferedWriter</code> can improve performance compared to writing character by character, but I am unsure about the best practices for <strong>flushing the buffer</strong> and <strong>ensuring all data is written correctly</strong>.</p>\n<p>Hereâ€™s my current code:</p>\n<pre><code>import java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class FileWriteExample {\n    public static void main(String[] args) {\n        try (BufferedWriter writer = new BufferedWriter(new FileWriter(&quot;output.txt&quot;))) {\n            for (int i = 0; i &lt; 100000; i++) {\n                writer.write(&quot;Line &quot; + i + &quot;\\n&quot;);\n            }\n            // Do I need to call writer.flush() here explicitly?\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<p><strong>Questions:</strong></p>\n<ol>\n<li><p>Is it necessary to call <code>writer.flush()</code> explicitly before closing the <code>BufferedWriter</code>?</p>\n</li>\n<li><p>Are there performance differences between calling <code>flush()</code> periodically inside the loop vs relying on <code>try-with-resources</code>?</p>\n</li>\n<li><p>What are the recommended best practices for writing large files efficiently in Java?</p>\n</li>\n</ol>\n",
    "tags" : [ "java", "performance", "file-io", "bufferedwriter" ],
    "owner" : {
      "account_id" : 39996495,
      "reputation" : 15,
      "user_id" : 29557900,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/OlU9KX91.jpg?s=256",
      "display_name" : "Ahamed Shahif",
      "link" : "https://stackoverflow.com/users/29557900/ahamed-shahif"
    },
    "is_answered" : true,
    "view_count" : 137,
    "closed_date" : 1764527529,
    "answer_count" : 2,
    "score" : -1,
    "last_activity_date" : 1764655746,
    "creation_date" : 1764442257,
    "link" : "https://stackoverflow.com/questions/79833456/how-to-efficiently-flush-and-write-large-amounts-of-data-to-a-file-using-buffere",
    "closed_reason" : "Needs more focus"
  },
  "answers" : [ {
    "answer_id" : 79833488,
    "question_id" : 79833456,
    "body" : "<h2>tl;dr</h2>\n<p><code>BufferedWriter</code> in your try-with-resources syntax handles all your concerns about efficiency and flushing. Nothing more for you to do.</p>\n<h2>Don't worry. Be happy.</h2>\n<p>It is the job of a <a href=\"https://BufferedWriter\" rel=\"nofollow noreferrer\"><code>BufferedWriter</code></a> implementation to efficiently handle writing data to a file. No need for you to worry. So your question is effectively moot; just let the buffered writer do its job.</p>\n<p>Notice that <code>BufferedWriter</code> is <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/AutoCloseable.html\" rel=\"nofollow noreferrer\"><code>AutoCloseable</code></a>. That means you can conveniently use it in try-with-resources syntax as shown in your example code. When the task has completed, and flow-of-control exits your <code>try</code> block, the JVM automatically calls the required <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/AutoCloseable.html#close()\" rel=\"nofollow noreferrer\"><code>close</code></a> method on the resource (your <code>BufferedWriter</code> object).</p>\n<p>If we examine the Javadoc for <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/BufferedWriter.html#close()\" rel=\"nofollow noreferrer\"><code>BufferedWriter#close</code></a>, we see:</p>\n<blockquote>\n<p>Closes the stream, flushing it first.</p>\n</blockquote>\n<p>So there is no need for you to do any calls to <code>flush</code>. The <code>BufferedWriter</code> class handles flushing as you submit data. And <code>BufferedWriter#close</code> handles the final flushing when you are done. Easy-peasy.</p>\n<h3>Java NIO.2</h3>\n<p>By the way, we can simplify your code using the NIO.2 features in modern Java. Learn about the <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/file/Path.html\" rel=\"nofollow noreferrer\"><code>Path</code></a> and <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/nio/file/Files.html\" rel=\"nofollow noreferrer\"><code>Files</code></a> (plural) classes.</p>\n<p>And we can make your limit number more readable with digit grouping.</p>\n<pre class=\"lang-java prettyprint-override\"><code>try (\n        final BufferedWriter writer = Files.newBufferedWriter( Path.of( &quot;output.txt&quot; ) )\n)\n{\n    for ( int index = 0 ; index &lt; 100_000 ; index++ )\n    {\n        writer.write( &quot;Line &quot; + index + &quot;\\n&quot; );\n    }\n}  // The `close` method gets called on each declared resource when exiting this block.\ncatch ( IOException e )\n{\n    e.printStackTrace();\n}\n</code></pre>\n<h3>Line separator</h3>\n<p>By the way, you may want to replace your hard-coded <code>&quot;\\n&quot;</code> with platform-sensitive code by either:</p>\n<ul>\n<li>Calling <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/BufferedWriter.html#newLine()\" rel=\"nofollow noreferrer\"><code>BufferedWriter#newLine</code></a>.</li>\n<li>Writing the result of <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/System.html#lineSeparator()\" rel=\"nofollow noreferrer\"><code>System.lineSeparator()</code></a>.</li>\n</ul>\n<pre class=\"lang-java prettyprint-override\"><code>{\n    writer.write( &quot;Line &quot; + index ) ;\n    writer.newLine() ;\n}\n</code></pre>\n<h3><code>Appendable</code> for method-chaining</h3>\n<p>Notice that <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/BufferedWriter.html\" rel=\"nofollow noreferrer\"><code>BufferedWriter</code></a> implements <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Appendable.html\" rel=\"nofollow noreferrer\"><code>Appendable</code></a>. This contract brings <code>append</code> methods. These contrast with the <code>write</code> methods in that they return a <code>Writer</code> object reference rather than <code>void</code>. So you can use <a href=\"https://en.wikipedia.org/wiki/Method_chaining\" rel=\"nofollow noreferrer\">method-chaining</a> rather than concatenation, if you so desire. Your IDE likely will offer to convert your code.</p>\n<pre class=\"lang-java prettyprint-override\"><code>{\n    writer.append( &quot;Line &quot; ).append( index ) ;\n    writer.newLine() ;\n}\n</code></pre>\n<h2>Threads</h2>\n<p>Writing to storage is very slow work for a computer. Your code blocks while waiting for the writes to complete.</p>\n<p>So one opportunity for optimizing performance, if you actually have a <em>proven</em> performance problem, is to use <a href=\"https://openjdk.org/jeps/444\" rel=\"nofollow noreferrer\">virtual threads</a> to prepare your data for export in advance rather than alternating between preparing and writing.</p>\n<p>That is much too big a topic to address here. You will find many existing Questions &amp; Answers on that.</p>\n",
    "score" : 2,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 322981,
      "reputation" : 347089,
      "user_id" : 642706,
      "user_type" : "registered",
      "accept_rate" : 58,
      "profile_image" : "https://i.sstatic.net/ZWEI3.jpg?s=256",
      "display_name" : "Basil Bourque",
      "link" : "https://stackoverflow.com/users/642706/basil-bourque"
    },
    "creation_date" : 1764445025,
    "last_activity_date" : 1764503752,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79833868,
    "question_id" : 79833456,
    "body" : "<p>My answer is going to focus (only) on the 3 questions that you asked:</p>\n<blockquote>\n<ol>\n<li>Is it necessary to call <code>writer.flush()</code> explicitly before closing the <code>BufferedWriter</code>?</li>\n</ol>\n</blockquote>\n<p>It is not necessary.  The javadoc states that <code>writer.close()</code> will flush the buffer.</p>\n<blockquote>\n<ol start=\"2\">\n<li>Are there performance differences between calling <code>flush()</code> periodically inside the loop vs relying on <em>try-with-resources</em>?</li>\n</ol>\n</blockquote>\n<p>Yes.</p>\n<p>Each time the buffer is flushed, a syscall is made to the operating system that will copy data from the buffer to kernel space buffers.  Depending on the OS, this may trigger I/O operations for the device where the file system resides.  These syscalls, the copying and the I/O operations are all overheads</p>\n<p>If you make explicit <code>flush()</code> calls, you incur these overheads each time you do it.  If you let <code>BufferedWriter</code> take care of it (i.e. let it flush automatically when the buffer is full and on <code>close()</code>) you will most likely have fewer flush events and better performance.</p>\n<blockquote>\n<ol start=\"3\">\n<li>What are the recommended best practices for writing large files efficiently in Java?</li>\n</ol>\n</blockquote>\n<p>I don't believe in so-called &quot;best practices&quot; because they are rarely best in all situations.  But here are some rules of thumb:</p>\n<ul>\n<li>Unless the files are really large and/or take a significant time to write, it is probably not worth spending your effort on optimizing this.</li>\n<li>Consider using a larger buffer (&gt;= 8192 bytes), but not too large.  Be prepared to tune the buffer size.  (There is some debate as to whether tuning buffer sizes is worthwhile.  But either way, the optimal buffer size will depend on the operating system, the file system, how much pressure there is on physical RAM (for OS buffer cache, etc) and the device you are ultimately writing to.)</li>\n<li>If you have to generate the data that you are writing, consider pipelining the generation and writing; i.e. use one thread to generate / format the output and another to write it.</li>\n<li>Don't attempt to write a single file in parallel using multiple threads.  It is complicated to implement and the speedup is likely to be disappointing; see <a href=\"https://stackoverflow.com/a/1993707/139985\">https://stackoverflow.com/a/1993707/139985</a></li>\n</ul>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 47283,
      "reputation" : 723469,
      "user_id" : 139985,
      "user_type" : "registered",
      "accept_rate" : 69,
      "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
      "display_name" : "Stephen C",
      "link" : "https://stackoverflow.com/users/139985/stephen-c"
    },
    "creation_date" : 1764504307,
    "last_activity_date" : 1764655746,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140879851,
    "post_id" : 79833456,
    "body" : "1. No! <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/io/BufferedWriter.html#close()\" rel=\"nofollow noreferrer\">javadoc</a>: &quot;<i>Closes the stream, flushing it first.</i>&quot; || 2. Yes, assuming you meant calling <code>flush()</code> or not calling it inside the loop. || 3. Opinion-based, depends on context, .... (e.g. flushing after every entry in a LOG-file)",
    "score" : 1,
    "owner" : {
      "account_id" : 31180,
      "reputation" : 29752,
      "user_id" : 85421,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/kKvXH.gif?s=256",
      "display_name" : "user85421",
      "link" : "https://stackoverflow.com/users/85421/user85421"
    },
    "creation_date" : 1764492089,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79833488" : [ {
      "comment_id" : 140879419,
      "post_id" : 79833488,
      "body" : "<i>By the way, you may want to replace your hard-coded &quot;/n&quot; with platform-sensitive code: System.lineSeparator().</i>  Or just do <code>writer.newLine();</code> (which will give you the correct separator for your platform)",
      "score" : 1,
      "owner" : {
        "account_id" : 22124137,
        "reputation" : 4244,
        "user_id" : 16376827,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/1ImPw.png?s=256",
        "display_name" : "g00se",
        "link" : "https://stackoverflow.com/users/16376827/g00se"
      },
      "creation_date" : 1764448621,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79833868" : [ {
      "comment_id" : 140882655,
      "post_id" : 79833868,
      "body" : "Well you certainly shouldn&#39;t be hard-wiring an OS specific buffer size into your code.  If that was worthwhile, then the Java runtime would make the default OS specific.",
      "score" : 0,
      "owner" : {
        "account_id" : 47283,
        "reputation" : 723469,
        "user_id" : 139985,
        "user_type" : "registered",
        "accept_rate" : 69,
        "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
        "display_name" : "Stephen C",
        "link" : "https://stackoverflow.com/users/139985/stephen-c"
      },
      "creation_date" : 1764656149,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140882542,
      "post_id" : 79833868,
      "body" : "things like &#39;os type&#39; is stuff the java class library <b>does</b> have, and is exactly what I was referring to. Handwriting something like <code>switch (osType) { case MACOS -&gt; 8192; case WINDOWS -&gt; 4096;}</code> is ridiculous. If that&#39;s a good idea in the first place, it&#39;s definitely the OpenJDK code that should be doing that. <i>If_</i> <code>Files.newBufferedReader</code> doesn&#39;t do that, then it isn&#39;t relevant, or, a bug should be filed.",
      "score" : 1,
      "owner" : {
        "account_id" : 401843,
        "reputation" : 107206,
        "user_id" : 768644,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
        "display_name" : "rzwitserloot",
        "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
      },
      "creation_date" : 1764647046,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140882465,
      "post_id" : 79833868,
      "body" : "I&#39;m guessing ... things like file size, fs block size, os type, buffer cache.  My point is that these values are difficult / impossible for the <i>Java runtime</i> to measure in order to calculate an optimal buffer size.  (The javadocs talk about a &quot;defaulf&quot; buffer size which implies to me that they don&#39;t attempt to do anything smart.  I haven&#39;t checked though.)",
      "score" : 0,
      "owner" : {
        "account_id" : 47283,
        "reputation" : 723469,
        "user_id" : 139985,
        "user_type" : "registered",
        "accept_rate" : 69,
        "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
        "display_name" : "Stephen C",
        "link" : "https://stackoverflow.com/users/139985/stephen-c"
      },
      "creation_date" : 1764640371,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140882442,
      "post_id" : 79833868,
      "body" : "What kind of information would be required to pick the optimal buffer size?",
      "score" : 1,
      "owner" : {
        "account_id" : 401843,
        "reputation" : 107206,
        "user_id" : 768644,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
        "display_name" : "rzwitserloot",
        "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
      },
      "creation_date" : 1764638389,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140880975,
      "post_id" : 79833868,
      "body" : "@rzwitserloot The Java class library can&#39;t help with picking an optimal buffer size.  It doesn&#39;t have enough information to decide.  If the OP is going to try tuning this, it needs to be done based on knowledge of the specific use-case.  (And hence, there are no &quot;best practices&quot;.)",
      "score" : 0,
      "owner" : {
        "account_id" : 47283,
        "reputation" : 723469,
        "user_id" : 139985,
        "user_type" : "registered",
        "accept_rate" : 69,
        "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
        "display_name" : "Stephen C",
        "link" : "https://stackoverflow.com/users/139985/stephen-c"
      },
      "creation_date" : 1764576800,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140880285,
      "post_id" : 79833868,
      "body" : "In regards to comment &#39;use a large buffer&#39;, I think that&#39;s actively detrimental here. You should definitely not be handtuning the buffer size! The &#39;best&#39; thing to do is to let NIO&#39;s <code>Files.newBufferedWriter</code> set things up, that way, if there&#39;s a &#39;smart&#39; way to pick &#39;the best&#39; buffer size, that&#39;s <i>the</i> place to write it. If there is such a thing and an OpenJDK impl fails to use that, then <b>file a bug</b> with the JDK team to add it. Definitely don&#39;t handroll it. Hence: That&#39;s detrimental advice.",
      "score" : 0,
      "owner" : {
        "account_id" : 401843,
        "reputation" : 107206,
        "user_id" : 768644,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
        "display_name" : "rzwitserloot",
        "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
      },
      "creation_date" : 1764521614,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}