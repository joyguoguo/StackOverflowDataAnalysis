{
  "question" : {
    "question_id" : 79822730,
    "title" : "Why do we need abstract methods in Enums",
    "body" : "<p>I've been studying Java for some time now to better understand what goes on inside some of the code parts.</p>\n<p>While studying <code>Enum</code>, which I am used to using exclusively for listing various fixed values (such as days of the week), I came across something that I didn't quite understand - the implementation of abstract methods within <code>Enum</code>.</p>\n<p>My question is as follows: first, is this mechanism even necessary today? It looks like code smell, although I can't explain why.</p>\n<p>Second, how often is Enum used in this way? I understand that there can always be exceptional cases, but it seems to make the code quite difficult to read.</p>\n<p>Here is an example:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public enum Operation {\n    ADD {\n        @Override\n        public int apply(int x, int y) {\n            return x + y;\n        }\n    },\n    SUBTRACT {\n        @Override\n        public int apply(int x, int y) {\n            return x  -  y;\n        }\n    };\n    public abstract int apply(int x, int y);\n}\n</code></pre>\n<p>I tried to find a practical use for it and found only one thing - development in Java for Android, and there I generally understand the meaning of the mechanism, but for web development it looks like an outdated mechanism that only spoils the code.</p>\n",
    "tags" : [ "java", "enums" ],
    "owner" : {
      "account_id" : 30066488,
      "reputation" : 37,
      "user_id" : 23041500,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/ACg8ocITbW0KY3qcGq8wAGrAYL1zq0pE_Wy_Ik1Q2RQvFWAJ=k-s256",
      "display_name" : "Ice K",
      "link" : "https://stackoverflow.com/users/23041500/ice-k"
    },
    "is_answered" : true,
    "view_count" : 268,
    "answer_count" : 6,
    "score" : 1,
    "last_activity_date" : 1763585533,
    "creation_date" : 1763409863,
    "link" : "https://stackoverflow.com/questions/79822730/why-do-we-need-abstract-methods-in-enums",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79822759,
    "question_id" : 79822730,
    "body" : "<p>This idiom is not outdated at all, and commonly used.  Nothing about this spoils anything.</p>\n<p>If you have a calculator app, you can reasonably expect to have a fixed set of functions, each of which has a hardcoded implementation, and structuring them in an enum is perfectly reasonable.  (Though in a more realistic calculator app, there may be some need for some different structure around unary versus binary operations, etc.)</p>\n<p>But when you have a known, fixed list of implementations for a certain type of operation, this is an extremely standard approach to the strategy pattern.</p>\n",
    "score" : 7,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 465573,
      "reputation" : 200423,
      "user_id" : 869736,
      "user_type" : "registered",
      "accept_rate" : 82,
      "profile_image" : "https://www.gravatar.com/avatar/ae7bb06b9a23a4dd7eea69e853d47d12?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Louis Wasserman",
      "link" : "https://stackoverflow.com/users/869736/louis-wasserman"
    },
    "creation_date" : 1763412021,
    "last_activity_date" : 1763412021,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79822760,
    "question_id" : 79822730,
    "body" : "<p>An <code>abstract</code> method is a guarantee that all implementations will have that method. The compiler will enforce this.  If you get an <code>Operation</code> from somewhere, how would you know you could call <code>apply</code> on it?</p>\n<p>If you comment out that function definition, the code doesn't compile anymore with this simple <code>main</code>:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public static void main(String args[]) {\n    Operation op = ADD;\n    System.out.println(op.apply(1, 2));\n}\n</code></pre>\n<p>This fails with:</p>\n<pre class=\"lang-none prettyprint-override\"><code>Operation.java:19: error: cannot find symbol\n        System.out.println(op.apply(1, 2));\n                             ^\n  symbol:   method apply(int,int)\n  location: variable op of type Operation\n</code></pre>\n<p>As you can see, the compiler knows that <code>op</code> is an <code>Operation</code>. It does not know which operation it is. If you were to add <code>public int foo() { return 0; }</code> to <code>ADD</code>, the compiler wouldn't see it:</p>\n<pre class=\"lang-none prettyprint-override\"><code>Operation.java:22: error: cannot find symbol\n        System.out.println(op.foo());\n                             ^\n  symbol:   method foo()\n  location: variable op of type Operation\n1 error\n</code></pre>\n<p>Looking at the <a href=\"https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.9\" rel=\"nofollow noreferrer\">language specification</a> you see that it talks about &quot;enum classes&quot;. The spec also says:</p>\n<blockquote>\n<p>The [...] class body of an enum constant implicitly declares an anonymous class [...] that [...] is a direct subclass of the immediately enclosing enum class</p>\n</blockquote>\n<p>With that you're back at regular class hierarchies: deriving classes (or here enum values) must implement <code>abstract</code> methods of their base classes, or be declared <code>abstract</code> themselves. Then you just need to know that you have an <code>Operation</code> (base class), but not which child class it is. You can call its <code>abstract</code> methods.</p>\n<p>As for whether this is outdated: No. &quot;Example 8.9.3-3. Enum Constants with Class Bodies&quot; in the Language Specification uses the same examples your code. If you want to call methods on <code>enum</code>s and have each <code>enum</code> value behave differently, this is the <em>only</em> way to go. If <code>apply</code> was not abstract, you'd have to define a body for it in <code>Operation</code> and that would always be called, independently of the actual operation, unless you override it. Which you may forget.</p>\n<p>As to &quot;why have functions on enums&quot; and &quot;where should this code live&quot; --- I think it fits perfectly on the <code>enum</code> values. Each operation knows how to apply itself to its operands. The alternative would be some big <code>switch</code> statement that tries to check what operation it has and then call some code to do the operation. This is a code smell: each time you add a new enum value, you must remember to update the <code>switch</code>. The suggested refactoring here is <a href=\"https://refactoring.guru/replace-conditional-with-polymorphism\" rel=\"nofollow noreferrer\">replace conditional with polymorphism</a>, which gets you to your initial <code>enum</code>.</p>\n",
    "score" : 5,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 1535561,
      "reputation" : 9056,
      "user_id" : 1431720,
      "user_type" : "registered",
      "accept_rate" : 89,
      "profile_image" : "https://www.gravatar.com/avatar/f5a1388d4d3b2bf03b11bb5658c68c29?s=256&d=identicon&r=PG",
      "display_name" : "Robert",
      "link" : "https://stackoverflow.com/users/1431720/robert"
    },
    "creation_date" : 1763412151,
    "last_activity_date" : 1763488255,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79822785,
    "question_id" : 79822730,
    "body" : "<p>You are achieving polymorphism by declaring an abstract operation in your Enum. Your client classes need to know only the operation and operands.</p>\n<p>Such is the beauty of Object Orientation. Highly object oriented language like java lets you abstract the things. Not like procedural languges where you can type randomly just to achieve your objective. While writing object oriented code, you always think like</p>\n<ul>\n<li><p>What could change tomorrow?</p>\n</li>\n<li><p>What other part of softer can use this operations?</p>\n</li>\n<li><p>What other classes/code going to affect because of this change?</p>\n</li>\n<li><p>What part of software need to be re-tested/ verified after the change?</p>\n</li>\n</ul>\n<p>Java lets you write the software such a way that in case of small change in your implementation you do not have to do many changes. You do not have to re-verify everything from beginning to end. Just verify/test the part that has changed.</p>\n<p>Abstraction is handy tool to decouple the software components and reduces the dependency of a client and implementation.</p>\n<p>Example use -</p>\n<pre><code>    public double operate(Operation operation, int first, int second){\n       return operation.apply(first,second);\n    }\n</code></pre>\n",
    "score" : 3,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1692303,
      "reputation" : 1009,
      "user_id" : 1554421,
      "user_type" : "registered",
      "accept_rate" : 100,
      "profile_image" : "https://www.gravatar.com/avatar/c54f7df56e954887ebc7b7c5c5e771d4?s=256&d=identicon&r=PG",
      "display_name" : "Gunwant",
      "link" : "https://stackoverflow.com/users/1554421/gunwant"
    },
    "creation_date" : 1763413962,
    "last_activity_date" : 1763413962,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79822854,
    "question_id" : 79822730,
    "body" : "<blockquote>\n<p>While studying <code>Enum</code>, which I am used to using exclusively for listing various fixed values (such as days of the week), I came across something that I didn't quite understand - the implementation of abstract methods within <code>Enum</code>.</p>\n</blockquote>\n<p>Quoth the Bard:</p>\n<blockquote>\n<p>There are more things in Heaven and Earth, Horatio, than are dreamt of in your philosophy.</p>\n</blockquote>\n<p>(Hamlet)</p>\n<hr />\n<p>You seem to understand the actual implementation just fine.  I take the question to be largely about <em>rationale</em>.</p>\n<p>Moreover, you seem to be conflating two different things.  Instances of an enum type having <em>polymorphic behavior</em> is a matter of virtual methods.  All abstract methods provide for polymorphic behavior, but polymorphic behavior does not necessarily rest on abstract methods.</p>\n<blockquote>\n<p>is this mechanism even necessary today?</p>\n</blockquote>\n<p>It was never necessary.  C has enums that are just integers, and from day one, Java provided for a stronger form of enum than C ever did, by way of <code>final static</code> fields of <code>final</code> classes, or, as was widely used at one time, fields of interfaces.  There's still plenty of that in the standard library, and it's all you really need for defining a closed set of namespaced symbols.</p>\n<p>However, enabling enum instances to have virtual methods was a key reason for implementing enum classes, which people were already doing before Java rolled it out as a language feature.  I've always taken this motivation to be second only to the desire improved type safety, as building enum values as class instances achieves.  Where the concepts represented by enum instances have characteristic behavior, it's perfectly natural to model that via methods.</p>\n<blockquote>\n<p>It looks like code smell, although I can't explain why.</p>\n</blockquote>\n<p>I attribute that to taking a narrow view of the nature and purpose of enums.  You have been using only basic enum features in your own work, and perhaps it's new to you that there even are other features.  It's understandable that you want to know what those additional features are good for.  And if they seem strange to you then it's understandable that you feel some aversion.</p>\n<p>It's a bit less understandable for you to take such a dismissive approach in your question, though.</p>\n<blockquote>\n<p>Second, how often is Enum used in this way?</p>\n</blockquote>\n<p>It's not uncommon.  I don't see a way to quantify it with any specificity.</p>\n<blockquote>\n<p>I understand that there can always be exceptional cases, but it seems to make the code quite difficult to read.</p>\n</blockquote>\n<p>Well, an enum class with extra methods, constructors, or fields is of course more complicated than one with only identifiers, but I don't agree with &quot;quite difficult to read&quot;.  Moreover, if the extra code were not in the enum class then it would need to be somewhere else, separated from the enum with which it was associated.  You don't reduce complexity that way, or make the overall code any easier to digest.</p>\n",
    "score" : 3,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1763420631,
    "last_activity_date" : 1763420631,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79823137,
    "question_id" : 79822730,
    "body" : "<p>There are two ways I know of to have enum constants behave differently. The first is to use abstract methods, like you've shown. The second is to delegate to a functional interface. For instance, I can rewrite your enum using <code>IntBinaryOperator</code>:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public enum Operation {\n    ADD(Integer::sum),\n    SUBTRACT((x, y) -&gt; x - y),\n    ;\n\n    private final IntBinaryOperator operator;\n\n    Operation(IntBinaryOperator operator) {\n        this.operator = operator;\n    }\n\n    public int apply(int x, int y) {\n        return operator.applyAsInt(x, y);\n    }\n}\n</code></pre>\n<p>This can lead to less code if you have a functional interface available. If you don't you can define a private functional interface inside your enum, but that could lead to more code if you need more than one custom functional interface.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1211967,
      "reputation" : 9964,
      "user_id" : 1180351,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
      "display_name" : "Rob Spoor",
      "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
    },
    "creation_date" : 1763454522,
    "last_activity_date" : 1763454522,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79822999,
    "question_id" : 79822730,
    "body" : "<p><strong>Is this mechanism even necessary today?</strong></p>\n<p>yes ofcourse.This ensure the compile time safety and keeps all behavior in one place.</p>\n<p><strong>When it is a code smell?</strong></p>\n<p>if enum is too large and  Overloading Enums with business logic</p>\n<p><strong>How often is Enum used in this way?</strong></p>\n<p>This is still used.This is useful when finite constants are there,cleaner than switch statements</p>\n<p>you can refer this</p>\n<p><a href=\"https://prgrmmng.com/enum-constant-specific-class-bodies-advanced-scenarios\" rel=\"nofollow noreferrer\">https://prgrmmng.com/enum-constant-specific-class-bodies-advanced-scenarios</a></p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 26137201,
      "reputation" : 333,
      "user_id" : 19827057,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/eAPUxDRv.jpg?s=256",
      "display_name" : "mariya cherian",
      "link" : "https://stackoverflow.com/users/19827057/mariya-cherian"
    },
    "creation_date" : 1763442970,
    "last_activity_date" : 1763442970,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140859406,
    "post_id" : 79822730,
    "body" : "In a service I recently needed to consume a response from another service containing a range of days of the week, e.g., Monday or Monday through Thursday. A fixed set of 10 possible such ranges. Of course an enum on my side. I needed to know whether a given day, e.g. Tuesday, was in the range. An abstract method was the only reasonable solution. And worked well.",
    "score" : 1,
    "owner" : {
      "account_id" : 7612423,
      "reputation" : 87409,
      "user_id" : 5772882,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/8283c64511fa80afed5259d10850168f?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Anonymous",
      "link" : "https://stackoverflow.com/users/5772882/anonymous"
    },
    "creation_date" : 1763431592,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140859284,
    "post_id" : 79822730,
    "body" : "that basically is part of OOP - enum constants are just instances of the enum class (or of an anonymous subclass of it) [big difference to <i>normal</i> classes: instances cannot be created at runtime, not even with reflection]",
    "score" : 3,
    "owner" : {
      "account_id" : 31180,
      "reputation" : 29752,
      "user_id" : 85421,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/kKvXH.gif?s=256",
      "display_name" : "user85421",
      "link" : "https://stackoverflow.com/users/85421/user85421"
    },
    "creation_date" : 1763422163,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140859219,
    "post_id" : 79822730,
    "body" : "Actually, I did not know about this technique of adding an <code>abstract</code> method to my <code>Enum</code> subclass, to be overridden by each enum object. That is a clever way to ensure each of my enum objects implements the method, enforced by the compiler. And I did not realize <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/lang/Enum.html\" rel=\"nofollow noreferrer\"><code>Enum</code></a> is itself <code>abstract</code>.",
    "score" : 0,
    "owner" : {
      "account_id" : 322981,
      "reputation" : 347089,
      "user_id" : 642706,
      "user_type" : "registered",
      "accept_rate" : 58,
      "profile_image" : "https://i.sstatic.net/ZWEI3.jpg?s=256",
      "display_name" : "Basil Bourque",
      "link" : "https://stackoverflow.com/users/642706/basil-bourque"
    },
    "creation_date" : 1763416678,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140859129,
    "post_id" : 79822730,
    "body" : "@IceK, where developers endow enum types with virtual methods, it is reasonable to suppose that they consider it useful, appropriate, and not outdated to do so. They do not believe that it spoils any code.  If anywhere there are other developers who think it is outdated to do so then it is reasonable to suppose that they do not engage that mechanism, and therefore no code is spoilt there, either.",
    "score" : 3,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1763412903,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140859110,
    "post_id" : 79822730,
    "body" : "@LouisWasserman I am writing that this is my point of view, and therefore I am asking for clarification. It turns out that this is a fairly common practice. Thank you for your answer, but I cannot fully understand one point: let&#39;s say I have a WEB MVC application. How can I understand that this part of the logic related to Enum should be processed in Service, and this part should be processed using abstract methods?",
    "score" : 0,
    "owner" : {
      "account_id" : 30066488,
      "reputation" : 37,
      "user_id" : 23041500,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/ACg8ocITbW0KY3qcGq8wAGrAYL1zq0pE_Wy_Ik1Q2RQvFWAJ=k-s256",
      "display_name" : "Ice K",
      "link" : "https://stackoverflow.com/users/23041500/ice-k"
    },
    "creation_date" : 1763412064,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140859102,
    "post_id" : 79822730,
    "body" : "@JohnBollinger I don&#39;t quite understand the point of your comment. Perhaps I didn&#39;t express myself clearly. What I mean is that it&#39;s not the possibility itself that spoils things, but its use that can spoil things, and that&#39;s why I asked whether this practice is outdated and how often it is used.",
    "score" : 1,
    "owner" : {
      "account_id" : 30066488,
      "reputation" : 37,
      "user_id" : 23041500,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/ACg8ocITbW0KY3qcGq8wAGrAYL1zq0pE_Wy_Ik1Q2RQvFWAJ=k-s256",
      "display_name" : "Ice K",
      "link" : "https://stackoverflow.com/users/23041500/ice-k"
    },
    "creation_date" : 1763411899,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140859097,
    "post_id" : 79822730,
    "body" : "&quot;where it shouldn&#39;t be&quot; Who said?  &quot;in theory, it should be processed somewhere at the business logic level&quot; Whose theory?  Nothing about this is unusual in any way.  This is a perfectly common way to structure business logic.",
    "score" : 5,
    "owner" : {
      "account_id" : 465573,
      "reputation" : 200423,
      "user_id" : 869736,
      "user_type" : "registered",
      "accept_rate" : 82,
      "profile_image" : "https://www.gravatar.com/avatar/ae7bb06b9a23a4dd7eea69e853d47d12?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Louis Wasserman",
      "link" : "https://stackoverflow.com/users/869736/louis-wasserman"
    },
    "creation_date" : 1763411731,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140859094,
    "post_id" : 79822730,
    "body" : "@LouisWasserman That&#39;s the point, I don&#39;t understand why anyone would want to create such a problem for themselves. I imagine this approach as taking business logic to a place where it shouldn&#39;t be, i.e., to Enum, to constants. That is the essence of my question: I cannot understand why this is moved to Enum, although, in theory, it should be processed somewhere at the business logic level, and this approach seems to scatter the code logic across its incomprehensible parts.",
    "score" : 0,
    "owner" : {
      "account_id" : 30066488,
      "reputation" : 37,
      "user_id" : 23041500,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/ACg8ocITbW0KY3qcGq8wAGrAYL1zq0pE_Wy_Ik1Q2RQvFWAJ=k-s256",
      "display_name" : "Ice K",
      "link" : "https://stackoverflow.com/users/23041500/ice-k"
    },
    "creation_date" : 1763411537,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140859091,
    "post_id" : 79822730,
    "body" : "If a given enum does not need -- and therefore does not use -- abstract methods, then how does the mere capability of it using them spoil any code?",
    "score" : 3,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1763411313,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140859073,
    "post_id" : 79822730,
    "body" : "How would you take a different approach to solve the problem your example is solving?  That looks perfectly normal, idiomatic, and effective to me, and it has nothing to do with Android.",
    "score" : 6,
    "owner" : {
      "account_id" : 465573,
      "reputation" : 200423,
      "user_id" : 869736,
      "user_type" : "registered",
      "accept_rate" : 82,
      "profile_image" : "https://www.gravatar.com/avatar/ae7bb06b9a23a4dd7eea69e853d47d12?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Louis Wasserman",
      "link" : "https://stackoverflow.com/users/869736/louis-wasserman"
    },
    "creation_date" : 1763410285,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79822999" : [ {
      "comment_id" : 140859827,
      "post_id" : 79822999,
      "body" : "@Stultuske Do not mean &quot;enum replace switch statement&quot;, means using enums we can encapsulate behaviour cleaner than a big switch statement.when using long switch statements behaviour is scattered",
      "score" : 2,
      "owner" : {
        "account_id" : 26137201,
        "reputation" : 333,
        "user_id" : 19827057,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/eAPUxDRv.jpg?s=256",
        "display_name" : "mariya cherian",
        "link" : "https://stackoverflow.com/users/19827057/mariya-cherian"
      },
      "creation_date" : 1763455617,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140859746,
      "post_id" : 79822999,
      "body" : "what do you mean, &quot;cleaner than switch statements&quot;? it can be a switch statement that decides the type (subclass) of the enum, it doesn&#39;t necessarily replaces it.",
      "score" : 0,
      "owner" : {
        "account_id" : 3116234,
        "reputation" : 9469,
        "user_id" : 2636929,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/85fa83a02c04af43fcd224821ca9b750?s=256&d=identicon&r=PG",
        "display_name" : "Stultuske",
        "link" : "https://stackoverflow.com/users/2636929/stultuske"
      },
      "creation_date" : 1763452862,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79822760" : [ {
      "comment_id" : 140860077,
      "post_id" : 79822760,
      "body" : "<i>&quot;you&#39;d have to define a body for it in Operation and that would always be called&quot;</i>, not if you <b>override</b> it in the specific enums that need to.",
      "score" : 0,
      "owner" : {
        "account_id" : 213468,
        "reputation" : 110280,
        "user_id" : 466862,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/d873f397779db38cd510d9ee5416fd43?s=256&d=identicon&r=PG",
        "display_name" : "Mark Rotteveel",
        "link" : "https://stackoverflow.com/users/466862/mark-rotteveel"
      },
      "creation_date" : 1763462445,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140859128,
      "post_id" : 79822760,
      "body" : "Looking at it from this perspective, many things become clearer. It looks better than, say, processing 50 enums using if-else.  Thank you for your reply.",
      "score" : 1,
      "owner" : {
        "account_id" : 30066488,
        "reputation" : 37,
        "user_id" : 23041500,
        "user_type" : "registered",
        "profile_image" : "https://lh3.googleusercontent.com/a/ACg8ocITbW0KY3qcGq8wAGrAYL1zq0pE_Wy_Ik1Q2RQvFWAJ=k-s256",
        "display_name" : "Ice K",
        "link" : "https://stackoverflow.com/users/23041500/ice-k"
      },
      "creation_date" : 1763412873,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}