{
  "question" : {
    "question_id" : 79590874,
    "title" : "Issue with orphanRemoval = true and FetchType.LAZY in Hibernate 6.6.X.Final",
    "body" : "<p>I’ve encountered an issue after upgrading to Hibernate 6.6.9.Final from 6.4.10.Final related to the behavior of orphanRemoval = true when combined with FetchType.LAZY.</p>\n<p>Issue Description</p>\n<p>In previous Hibernate versions, if I had a lazily-loaded collection with orphanRemoval = true and saved the parent entity without explicitly initializing the collection, Hibernate would not attempt to delete any orphans—unless the collection was explicitly modified.</p>\n<p>However, after updating to 6.6.9.Final, it seems that Hibernate attempts to remove orphans, even if the lazy collection was never loaded or accessed. This behavior is unexpected and leads to incorrect deletions.</p>\n<p>The last version where this behavior worked as expected (i.e., the test passes) is 6.5.3.Final. From version 6.6.0.Final onward, this issue starts to occur.</p>\n<p>Reproducer:</p>\n<pre class=\"lang-java prettyprint-override\"><code>package org.hibernate.bugs;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport jakarta.persistence.*;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.HashSet;\n\n/**\n * This test case reproduces the scenario where an exercise is updated via an API.\n * The exercise instance coming from the API is created outside a transaction (detached),\n * and it does not include its lazy-loaded student participations. The test then verifies\n * that the existing student participations remain intact after the update.\n * &lt;p&gt;\n * Participations are not needed for the update and are not sent in the exercise update request,\n * because they are large and not necessary for the update.\n * &lt;p&gt;\n * This test succeeds with Hibernate version 6.5.3.Final, but fails with version 6.6.X.Final.\n */\nclass JPAUnitTestCase {\n\n    private EntityManagerFactory entityManagerFactory;\n\n    @BeforeEach\n    void init() {\n        entityManagerFactory = Persistence.createEntityManagerFactory(&quot;templatePU&quot;);\n    }\n\n    @AfterEach\n    void destroy() {\n        entityManagerFactory.close();\n    }\n\n    @Test\n    void testUpdateExerciseDoesNotRemoveStudentParticipations() {\n        // Create and persist an exercise with two student participations.\n        EntityManager em = entityManagerFactory.createEntityManager();\n        em.getTransaction().begin();\n\n        Exercise exercise = new Exercise();\n        exercise.setName(&quot;Initial Exercise&quot;);\n\n        StudentParticipation participation1 = new StudentParticipation();\n        participation1.setName(&quot;Participation 1&quot;);\n        participation1.setExercise(exercise);\n\n        StudentParticipation participation2 = new StudentParticipation();\n        participation2.setName(&quot;Participation 2&quot;);\n        participation2.setExercise(exercise);\n\n        exercise.getStudentParticipations().add(participation1);\n        exercise.getStudentParticipations().add(participation2);\n\n        em.persist(exercise);\n        em.persist(participation1);\n        em.persist(participation2);\n\n        em.getTransaction().commit();\n        em.close();\n\n        // Simulate the API payload: a detached exercise instance is created outside any transaction.\n        Exercise apiExercise = new Exercise();\n        apiExercise.setId(exercise.getId());\n        apiExercise.setName(&quot;Updated Exercise&quot;);\n        // Note: The API payload does not include studentParticipations.\n\n        // Start a new transaction to update the managed entity using the API payload.\n        em = entityManagerFactory.createEntityManager();\n        em.getTransaction().begin();\n\n        em.merge(apiExercise);\n\n        em.getTransaction().commit();\n        em.close();\n\n        // Verify that the student participations are still present.\n        em = entityManagerFactory.createEntityManager();\n        Exercise verifiedExercise = em.find(Exercise.class, exercise.getId());\n        assertEquals(&quot;Updated Exercise&quot;, verifiedExercise.getName(), &quot;Exercise name should be updated&quot;);\n        assertEquals(2, verifiedExercise.getStudentParticipations().size(), &quot;Student participations should not be removed&quot;);\n        em.close();\n    }\n\n    // --- Entity definitions for the purpose of the test ---\n    @Entity(name = &quot;Exercise&quot;)\n    public static class Exercise {\n        @Id\n        @GeneratedValue(strategy = GenerationType.IDENTITY)\n        private Long id;\n\n        private String name;\n\n        @OneToMany(mappedBy = &quot;exercise&quot;, cascade = CascadeType.REMOVE, orphanRemoval = true, fetch = FetchType.LAZY)\n        private java.util.Set&lt;StudentParticipation&gt; studentParticipations = new HashSet&lt;&gt;();\n\n        public Long getId() { return id; }\n        public void setId(Long id) { this.id = id; }\n\n        public String getName() { return name; }\n        public void setName(String name) { this.name = name; }\n\n        public java.util.Set&lt;StudentParticipation&gt; getStudentParticipations() { return studentParticipations; }\n        public void setStudentParticipations(java.util.Set&lt;StudentParticipation&gt; studentParticipations) { this.studentParticipations = studentParticipations; }\n    }\n\n    @Entity(name = &quot;StudentParticipation&quot;)\n    public static class StudentParticipation {\n        @Id\n        @GeneratedValue(strategy = GenerationType.IDENTITY)\n        private Long id;\n\n        private String name;\n\n        @ManyToOne\n        private Exercise exercise;\n\n        public Long getId() { return id; }\n        public void setId(Long id) { this.id = id; }\n\n        public String getName() { return name; }\n        public void setName(String name) { this.name = name; }\n\n        public Exercise getExercise() { return exercise; }\n        public void setExercise(Exercise exercise) { this.exercise = exercise; }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            StudentParticipation that = (StudentParticipation) o;\n            if (id == null) return false;\n            return id.equals(that.id);\n        }\n\n        @Override\n        public int hashCode() {\n            return id != null ? id.hashCode() : 0;\n        }\n    }\n}\n</code></pre>\n",
    "tags" : [ "java", "hibernate" ],
    "owner" : {
      "account_id" : 41592687,
      "reputation" : 1,
      "user_id" : 30362255,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/9e430971bfd80480cefef7f66b71df64?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Michal Kawka",
      "link" : "https://stackoverflow.com/users/30362255/michal-kawka"
    },
    "is_answered" : false,
    "view_count" : 125,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1745770277,
    "creation_date" : 1745505254,
    "link" : "https://stackoverflow.com/questions/79590874/issue-with-orphanremoval-true-and-fetchtype-lazy-in-hibernate-6-6-x-final",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ ],
  "answer_comments" : { }
}