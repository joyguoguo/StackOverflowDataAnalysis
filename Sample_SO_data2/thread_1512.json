{
  "question" : {
    "question_id" : 79702285,
    "title" : "All MapStruct fields are encrypted with PasswordEncoder instead of only the password",
    "body" : "<p>I’m developing an application with <strong>Spring Boot</strong> and facing an issue using <strong>MapStruct</strong> to map a DTO (<code>RegisterRequest</code>) to an entity (<code>Usuario</code>) and save the data in a <strong>PostgreSQL</strong> database.</p>\n<p>My goal is for <strong>only</strong> the <code>password</code> field to be encrypted with <strong>PasswordEncoder</strong> (using BCrypt), while the other fields (<code>firstName</code>, <code>lastName</code>, <code>email</code>, <code>role</code>) should be mapped directly from the DTO.</p>\n<p>However, the implementation generated by <strong>MapStruct</strong> is encrypting <strong>all</strong> the fields, which causes a length error:<br />\n<code>value too long for type character varying(30)</code></p>\n<p>on the firstName column, which has a 30-character limit, while the generated hashes are approximately 60 characters long.</p>\n<p><strong>What I want to do</strong></p>\n<p>To avoid doing the mapping manually, I wanted to use <strong>MapStruct</strong> (as I had done before with other mappings) to delegate this work and reduce boilerplate code. The flow I needed was:</p>\n<ul>\n<li><p>Receive a POST request with a <code>RegisterRequest</code> containing <code>email</code>, <code>password</code>, <code>firstName</code>, and <code>lastName</code>.</p>\n</li>\n<li><p>Map these fields to a <code>Usuario</code> entity using <strong>MapStruct</strong>.</p>\n</li>\n<li><p>Encrypt only the <code>password</code> field using <strong>PasswordEncoder</strong>.</p>\n</li>\n<li><p>Assign a constant value <code>&quot;User&quot;</code> to the <code>role</code> field.</p>\n</li>\n<li><p>Save the <code>Usuario</code> in the database without any length errors.</p>\n</li>\n</ul>\n<hr />\n<p><strong>Relevant Code</strong></p>\n<pre><code>@Mapper(componentModel = MappingConstants.ComponentModel.SPRING)\npublic interface UsuarioRegisterMapper {\n\n    @Mapping(target = &quot;rol&quot;, constant = &quot;User&quot;)\n    @Mapping(target = &quot;id&quot;, ignore = true)\n    @Mapping(target = &quot;contrasena&quot;, expression = &quot;java(encodePassword(request.contrasena(), passwordEncoder))&quot;)\n    Usuario toEntity(RegisterRequest request, @Context PasswordEncoder passwordEncoder);\n\n    default String encodePassword(String rawPassword, @Context PasswordEncoder passwordEncoder) {\n        return passwordEncoder.encode(rawPassword);\n    }\n}\n</code></pre>\n<p>the implementation automatically generated by MapStruct:</p>\n<pre><code>@Generated(\n    value = &quot;org.mapstruct.ap.MappingProcessor&quot;,\n    date = &quot;2025-07-14T21:19:15-0600&quot;,\n    comments = &quot;version: 1.5.5.Final, compiler: javac, environment: Java 23.0.2 (Oracle Corporation)&quot;\n)\n@Component\npublic class UsuarioRegisterMapperImpl implements UsuarioRegisterMapper {\n\n    @Override\n    public Usuario toEntity(RegisterRequest request, PasswordEncoder passwordEncoder) {\n        if (request == null) {\n            return null;\n        }\n\n        Usuario usuario = new Usuario();\n\n        usuario.setNombre(encodePassword(request.nombre(), passwordEncoder));\n        usuario.setApellido(encodePassword(request.apellido(), passwordEncoder));\n        usuario.setEmail(encodePassword(request.email(), passwordEncoder));\n        usuario.setRol(encodePassword(&quot;User&quot;, passwordEncoder));\n        usuario.setContrasena(encodePassword(request.contrasena(), passwordEncoder));\n\n        return usuario;\n    }\n}\n</code></pre>\n<pre><code>package com.proyectoUno.security.dto;\n\npublic record RegisterRequest(\n        String email,\n        String contrasena,\n        String nombre,\n        String apellido\n) {}\n</code></pre>\n<pre><code>@Service\npublic class AuthService {\n    // ... (injections)\n\n    public AuthResponse register(RegisterRequest request) {\n        if (usuarioRepository.findByEmail(request.email()).isPresent()) {\n            throw new EntidadDuplicadaException(&quot;Email is already associated with an account&quot;, &quot;email&quot;, Collections.singletonList(request.email()));\n        }\n\n// This is where I use the mapper to skip the manual process of instantiating the class and calling .set for each value\n        Usuario usuario = usuarioRegisterMapper.toEntity(request, this.passwordEncoder);\n\n        System.out.println(&quot;Usuario before saving: &quot; + usuario);\n        usuarioRepository.save(usuario);\n\n        UserDetails userDetails = new CustomUserDetails(usuario);\n        String jwtToken = jwtService.generateAccessToken(userDetails);\n        String refreshToken = jwtService.generateRefreshToken(userDetails);\n        return new AuthResponse(jwtToken, refreshToken);\n    }\n    // ...\n}\n</code></pre>\n<p>Postman:</p>\n<pre><code>{\n  &quot;email&quot;: &quot;mario.rodriguez@gmail.com&quot;,\n  &quot;contrasena&quot;: &quot;soyMario1050&quot;,\n  &quot;nombre&quot;: &quot;Mario&quot;,\n  &quot;apellido&quot;: &quot;Rodriguez&quot;\n}\n</code></pre>\n<p>After sending the request from Postman, the bug appeared. To verify it was caused by the Mapper configuration, I did some quick debugging to check the mapper’s output.</p>\n<pre><code>Usuario before saving: Usuario{id=null, \n  nombre='$2a$10$SKiTvYYJK.vZPetwOtY1OOBMCz6m15.bSUCZzk67Q..Ybs0h0n6nu', \n  apellido='$2a$10$h/PjGAv8aF7sGdCMo7jK/.CaHfcS.e1bHGIM28bb/RIYd/t1CL0jy', \n  email='$2a$10$ookM1PA26edcSu0mt4FnZegsvg/Cm3S0zdp5aRmfY/e1pcJ7TqT8K', \n  contrasena='$2a$10$aMIQJAo/pX7TEWhbKwtj/O0x/yuy8eqkfMVBfY7..fmnnmcwLo1e.', \n  rol='$2a$10$WV1kZvIx.j/UZfCSmcPMoOvOMFXXUM.qDKIarD5rIOLAHThULlUKK', \n  fechaRegistro=null, activo=false, prestamo=[]}\n</code></pre>\n<p>And that’s when the issue became clear: the mapper wasn’t just handling the <code>password</code> field — it was applying the default method to <strong>all</strong> fields, even though it was only supposed to be used for the <code>password</code>.</p>\n<p><strong>What I’ve tried</strong></p>\n<ul>\n<li><p>I added explicit mappings in <code>UsuarioRegisterMapper</code> for <code>nombre</code>, <code>apellido</code>, and <code>email</code> (like <code>@Mapping(target = &quot;nombre&quot;, source = &quot;request.nombre&quot;)</code>), but the generated implementation still applies <code>encodePassword</code> to all fields.</p>\n</li>\n<li><p>I cleaned and recompiled the project with <code>mvn clean install</code>, but the problem persists.</p>\n</li>\n<li><p>I verified that the <code>usuario</code> table has the correct column lengths (e.g., <code>nombre</code> as <code>varchar(30)</code>), but the generated hashes exceed this limit.</p>\n</li>\n</ul>\n<p><strong>Question</strong></p>\n<ul>\n<li><p>Why is MapStruct encrypting all fields with <code>PasswordEncoder</code> instead of limiting it to the <code>password</code> field?</p>\n</li>\n<li><p>How can I fix the configuration or implementation so that only <code>password</code> is encrypted and the other fields are mapped directly?</p>\n</li>\n<li><p>Is there a bug in MapStruct version 1.5.5.Final with Java 23.0.2?</p>\n</li>\n</ul>\n<p>Any help or suggestions would be greatly appreciated. Thanks in advance.</p>\n",
    "tags" : [ "java", "postgresql", "spring-boot", "spring-security", "mapstruct" ],
    "owner" : {
      "account_id" : 43045854,
      "reputation" : 13,
      "user_id" : 31047070,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/ccad5dde42a1f2337836ce3e944e79d9?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Mario Rodriguez",
      "link" : "https://stackoverflow.com/users/31047070/mario-rodriguez"
    },
    "is_answered" : true,
    "view_count" : 193,
    "answer_count" : 2,
    "score" : 1,
    "last_activity_date" : 1752655505,
    "creation_date" : 1752592387,
    "link" : "https://stackoverflow.com/questions/79702285/all-mapstruct-fields-are-encrypted-with-passwordencoder-instead-of-only-the-pass",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79703049,
    "question_id" : 79702285,
    "body" : "<p>The reason why everything gets mapped is due to the fact that MapStruct sees <code>encodePassword</code> and thinks that it can be applied to all <code>String</code> -&gt; <code>String</code> mappings.</p>\n<p>The best way to avoid this is to use <code>@Named</code>, which would mark the method as a qualified method and you have to explicitly pick that in order to be used. That would look like:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Mapper(componentModel = MappingConstants.ComponentModel.SPRING)\npublic interface UsuarioRegisterMapper {\n\n    @Mapping(target = &quot;rol&quot;, constant = &quot;User&quot;)\n    @Mapping(target = &quot;id&quot;, ignore = true)\n    @Mapping(target = &quot;contrasena&quot;, qualifiedByName = &quot;encode&quot;)\n    Usuario toEntity(RegisterRequest request, @Context PasswordEncoder passwordEncoder);\n\n    @Named(&quot;encode&quot;)\n    default String encodePassword(String rawPassword, @Context PasswordEncoder passwordEncoder) {\n        return passwordEncoder.encode(rawPassword);\n    }\n}\n</code></pre>\n",
    "score" : 2,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 1128956,
      "reputation" : 21901,
      "user_id" : 1115491,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/c9531b4a4ce89f5e793bfb91916318bb?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Filip",
      "link" : "https://stackoverflow.com/users/1115491/filip"
    },
    "creation_date" : 1752650299,
    "last_activity_date" : 1752650299,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79703148,
    "question_id" : 79702285,
    "body" : "<p>The problem you are facing is caused by mapstruct's mapping method resolution. From the docs(<a href=\"https://mapstruct.org/documentation/stable/reference/html/#mapping-method-resolution\" rel=\"nofollow noreferrer\">https://mapstruct.org/documentation/stable/reference/html/#mapping-method-resolution</a>):</p>\n<blockquote>\n<p>When mapping a property from one type to another, MapStruct looks for the most specific method which maps the source type into the target type. The method may either be declared on the same mapper interface or on another mapper which is registered via <code>@Mapper#uses()</code></p>\n</blockquote>\n<p>Because you have declared a String -&gt; String mapping method inside the mapper interface, it is more specific than implicit String -&gt; String mapping(<a href=\"https://mapstruct.org/documentation/stable/reference/html/#implicit-type-conversions\" rel=\"nofollow noreferrer\">https://mapstruct.org/documentation/stable/reference/html/#implicit-type-conversions</a>).</p>\n<p>To fix this, you can encode and map password inside @afterMapping method:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Mapper(componentModel = MappingConstants.ComponentModel.SPRING)\npublic abstract class UsuarioRegisterMapper {\n\n    @Mapping(target = &quot;rol&quot;, constant = &quot;User&quot;)\n    @Mapping(target = &quot;id&quot;, ignore = true)\n    Usuario toEntity(RegisterRequest request, @Context PasswordEncoder passwordEncoder);\n    \n    @AfterMapping\n    protected void after(RegisterRequest request, @MappingTarget Usuario usuario, @Context PasswordEncoder passwordEncoder) {\n        usuario.setContrasena(encodePassword(request.getContrasena()));\n    }\n\n    private String encodePassword(String rawPassword, PasswordEncoder passwordEncoder) {\n        return passwordEncoder.encode(rawPassword);\n    }\n}\n</code></pre>\n<p>Note that the `encodePassword` method is private in mapper, so the implementation will not use it to map other fields.</p>\n<p>You could also implement string encoding outside the mapper, and use qualifiers to apply it.</p>\n<p>Also, refrain from using expression attribute in @Mapping, it is considered bad practice.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 28139807,
      "reputation" : 1,
      "user_id" : 21503044,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f712b62acf496fb3f4d4bacbbfe7db88?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Jan Borowy",
      "link" : "https://stackoverflow.com/users/21503044/jan-borowy"
    },
    "creation_date" : 1752655347,
    "last_activity_date" : 1752655505,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140638393,
    "post_id" : 79702285,
    "body" : "Can you accept one of the answers so that your question is marked as &quot;answered&quot; ?",
    "score" : 0,
    "owner" : {
      "account_id" : 16282653,
      "reputation" : 339,
      "user_id" : 11758130,
      "user_type" : "registered",
      "profile_image" : "https://lh4.googleusercontent.com/-lObbwv6E3_A/AAAAAAAAAAI/AAAAAAAAAAA/ACHi3reN5UeyNdB5WnwdOwwsRku2N590ZQ/s256-rj/photo.jpg",
      "display_name" : "Vincent Meunier",
      "link" : "https://stackoverflow.com/users/11758130/vincent-meunier"
    },
    "creation_date" : 1754204615,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140595634,
    "post_id" : 79702285,
    "body" : "Thanks a lot, I didn’t really know how helper methods worked. :D",
    "score" : 0,
    "owner" : {
      "account_id" : 43045854,
      "reputation" : 13,
      "user_id" : 31047070,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/ccad5dde42a1f2337836ce3e944e79d9?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Mario Rodriguez",
      "link" : "https://stackoverflow.com/users/31047070/mario-rodriguez"
    },
    "creation_date" : 1752720366,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140591444,
    "post_id" : 79702285,
    "body" : "MapStruct automatically detects a method taking a <code>String</code> that outputs a <code>String</code> and will use it (see the section in the manual about mapping methods and the detection thereof). I would suggest to ditch the method and to write an <code>@AfterMapping</code> which would do the encoding.",
    "score" : 0,
    "owner" : {
      "account_id" : 3192259,
      "reputation" : 126826,
      "user_id" : 2696260,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/qHEzx.png?s=256",
      "display_name" : "M. Deinum",
      "link" : "https://stackoverflow.com/users/2696260/m-deinum"
    },
    "creation_date" : 1752593465,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79703049" : [ {
      "comment_id" : 140595626,
      "post_id" : 79703049,
      "body" : "I really appreciate your approach, thank you so much. :D",
      "score" : 0,
      "owner" : {
        "account_id" : 43045854,
        "reputation" : 13,
        "user_id" : 31047070,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/ccad5dde42a1f2337836ce3e944e79d9?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Mario Rodriguez",
        "link" : "https://stackoverflow.com/users/31047070/mario-rodriguez"
      },
      "creation_date" : 1752720257,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79703148" : [ {
      "comment_id" : 140595628,
      "post_id" : 79703148,
      "body" : "Thanks a lot, I didn’t know you could do it this way. I learned something new about MapStruct. :D",
      "score" : 0,
      "owner" : {
        "account_id" : 43045854,
        "reputation" : 13,
        "user_id" : 31047070,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/ccad5dde42a1f2337836ce3e944e79d9?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Mario Rodriguez",
        "link" : "https://stackoverflow.com/users/31047070/mario-rodriguez"
      },
      "creation_date" : 1752720304,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}