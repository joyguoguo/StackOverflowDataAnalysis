{
  "question" : {
    "question_id" : 79619012,
    "title" : "Avoid multiple error responses due to retry logic in Spring RabbitMQ listener with transactional setup",
    "body" : "<p>I have a microservices architecture where services communicate via RabbitMQ. In one microservice (let’s call it EventService), I publish a message and wait for a synchronous response from another microservice (ProcessorService). This synchronous design means EventService waits until ProcessorService publishes a response back.</p>\n<p>In ProcessorService, I’m using a @RabbitListener annotated method to consume the message. My listener is transactional (@Transactional) because I need lazy-loaded Hibernate entities and use Hibernate.initialize(...).</p>\n<p>Now, the problem:</p>\n<p>If an exception occurs in the consumer, the retry interceptor is triggered.</p>\n<p>The retry configuration retries the failed message 4 times.</p>\n<p>For each retry attempt, an error response is sent to the response queue — so I end up with 4+ responses (one per attempt) in the response queue.</p>\n<p>After all retries are exhausted, another message is sent to the dead letter queue (DLQ).</p>\n<p>I only want one error response to go to the response queue, and that too only once, either after the final retry or right before the message is dead-lettered.</p>\n<p>I’m also handling specific exception types like NotFoundException, IllegalArgumentException, etc., to skip retry altogether. However, because the method is transactional, I get an UnexpectedRollbackException as the root cause and this results in a second error message going to the DLQ, even though I already handled the exception.</p>\n<p><strong>What I’ve tried:</strong>\nConfigured SimpleRetryPolicy with retryableExceptions.put(MyException.class, false) for specific cases.</p>\n<p>Custom FailedMessageRecoverer for DLQ.</p>\n<p>Used Spring’s RetryInterceptorBuilder.stateless() in the container factory.</p>\n<p><strong>What I want to achieve:</strong>\nPrevent sending multiple error responses to the response queue.</p>\n<p>Ensure that only the last retry attempt sends the error response.</p>\n<p>If retry is skipped (non-retryable exception), send only one error response and avoid DLQ duplication due to UnexpectedRollbackException.</p>\n<p>Ideally, keep @Transactional to allow lazy loading (unless there's a clean workaround).</p>\n<p><strong>Additional Context:</strong>\nUsing Spring Boot with Spring AMQP.</p>\n<p>Hibernate is used for ORM.</p>\n<p>RabbitMQ is used for messaging.</p>\n<p>AmqpTemplate is used to send responses.</p>\n<p><strong>Any suggestions on how to:</strong></p>\n<p>Suppress intermediate error responses during retries?</p>\n<p>Prevent DLQ duplication in transactional rollback scenarios?</p>\n<p>Make Spring’s retry logic and transactional behavior work together without redundant side effects?</p>\n<pre><code>  @Transactional\n  @RabbitListener(\n      queues = &quot;${spring.rabbitmq.queues[11].name}&quot;,\n      containerFactory = &quot;rabbitListenerContainerFactory&quot;)\n  public void processUniversityMessages(MessageWrapper&lt;?&gt; request) {\n    handleRequest(Module.UNIVERSITY, request);\n  }\n\n  public void handleRequest(Module module, MessageWrapper&lt;?&gt; request) {\n    String routingKey = routingResolver.getRoutingKey(module);\n    String exchange = routingResolver.getExchange();\n    SubModule subModule = SubModule.fromString(request.getSubModule().toString());\n\n    MessageWrapper&lt;Object&gt; responseWrapper = new MessageWrapper&lt;&gt;();\n    responseWrapper.setCorrelationId(request.getCorrelationId());\n    responseWrapper.setModule(module);\n    responseWrapper.setSubModule(subModule);\n    try {\n      Object payload = request.getPayload();\n      switch (module) {\n        case COACH:\n          responseWrapper.setPayload(handleCoachRelatedRequest(subModule, payload));\n          break;\n        case STUDENT_ATHLETE:\n          responseWrapper.setPayload(handleStudentAthleteRelatedRequest(subModule, payload));\n          break;\n        case UNIVERSITY:\n          responseWrapper.setPayload(handleUniversityRelatedRequest(subModule, payload));\n          break;\n        case USER:\n          responseWrapper.setPayload(handleUserRelatedRequest(subModule, payload));\n          break;\n        case COLLEGE_ADMIN:\n          responseWrapper.setPayload(handleCollegeAdminRelatedRequest(subModule, payload));\n          break;\n        case PSA:\n          responseWrapper.setPayload(handlePSARelatedRequest(subModule, payload));\n          break;\n        default:\n          throw new IllegalArgumentException(&quot;Unknown module&quot;);\n      }\n      responseWrapper.setStatus(ResponseStatus.SUCCESS);\n    } catch (Exception e) {\n      ErrorResponseDto error = getErrorResponseDto(e);\n      responseWrapper.setPayload(error);\n      responseWrapper.setStatus(ResponseStatus.ERROR);\n    }\n    rabbitTemplate.convertAndSend(exchange, routingKey, responseWrapper);\n  }\n\n@Bean\n  public RetryOperationsInterceptor retryInterceptor(\n      AmqpTemplate amqpTemplate, MessageConverter converter) {\n\n    // Define which exceptions should NOT trigger retries\n    Map&lt;Class&lt;? extends Throwable&gt;, Boolean&gt; retryableExceptions = new HashMap&lt;&gt;();\n    retryableExceptions.put(NotFoundException.class, false);\n    retryableExceptions.put(UnProcessableEntityException.class, false);\n    retryableExceptions.put(IllegalArgumentException.class, false);\n    retryableExceptions.put(ResourceMismatchException.class, false);\n\n    // All other exceptions will retry (default: true)\n    SimpleRetryPolicy retryPolicy =\n        new SimpleRetryPolicy(\n            rabbitContext.getMaxAttempts(),\n            retryableExceptions,\n            true // Default retry for unmapped exceptions\n            );\n    return RetryInterceptorBuilder.stateless()\n        .retryPolicy(retryPolicy)\n        .backOffOptions(\n            rabbitContext.getRetryInterceptorInitialIntervalMillis(),\n            rabbitContext.getRetryInterceptorMultiplier(),\n            rabbitContext.getRetryInterceptorMaxIntervalMillis())\n        .recoverer(\n            new FailedMessageRecoverer(\n                amqpTemplate,\n                rabbitContext.getDeadLetterExchangeName(),\n                (message) -&gt; {\n                  String originalQueue = message.getMessageProperties().getConsumerQueue();\n                  return rabbitContext.getQueues().stream()\n                      .filter(q -&gt; q.getName().equals(originalQueue))\n                      .findFirst()\n                      .map(RabbitQueueConfig::getDlqRoutingKey)\n                      .orElseThrow();\n                },\n                converter))\n        .build();\n  }\n</code></pre>\n",
    "tags" : [ "java", "spring-boot", "hibernate", "rabbitmq" ],
    "owner" : {
      "account_id" : 25746909,
      "reputation" : 122,
      "user_id" : 19499990,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/AItbvmlcpIvWLpEu_AmCcOc9JAtNCatx_XZfvzcFLmcI=k-s256",
      "display_name" : "yatin tripathi",
      "link" : "https://stackoverflow.com/users/19499990/yatin-tripathi"
    },
    "is_answered" : false,
    "view_count" : 29,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1747115123,
    "creation_date" : 1747115123,
    "link" : "https://stackoverflow.com/questions/79619012/avoid-multiple-error-responses-due-to-retry-logic-in-spring-rabbitmq-listener-wi",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ ],
  "answer_comments" : { }
}