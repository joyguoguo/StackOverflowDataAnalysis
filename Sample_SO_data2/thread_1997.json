{
  "question" : {
    "question_id" : 79660058,
    "title" : "Efficient non-locking mass remove+insert in spring boot",
    "body" : "<p>TLDR : How to efficiently delete/update/insert in a table and read concurrently, in spring boot.</p>\n<p>I have an entity (say MyRecord), with another having fetch parameters (MyRecordFetch)</p>\n<p>eg</p>\n<pre><code>@Entity\nclass MyRecord\n@ManyToOne private MyRecordFetch fetcher;\n\n// then usable data, fields, etc\n</code></pre>\n<p>Every minute I list the MyRecordFetch that are able to update their list of MyRecord, I fetch them in parallel, when all are fetched/errored I delete the MyRecord for the successful ones, and insert the new ones instead.</p>\n<p>This works. It does like 500 000 records every 5 minutes, in a short period. However there is a slight issue : when removing the old records and inserting the new ones, it locks the DB so a service that list those MyRecord is stalled for the update time. This can be an issue.</p>\n<p>What I already did :</p>\n<ul>\n<li>set the database options like reordering, multi insert, etc.</li>\n<li>the remove method is made as a @nativequery to avoid hibernate updating its cache (instead of JPQL).</li>\n<li>use the postgres' importcsv when DB is postgres (went from 40s to 30s !)</li>\n</ul>\n<p>I tried several other things among the years but nothing was as effective as those</p>\n<p>What I was thinking about :</p>\n<p>Use the table normally, but request spring to use a materialized view for RO calls, typically created as <code>select * from myrecord</code> with commit propagation, this way the view is only updated at the end of the remove+transmit and its lock time would be minimal.<br />\nHowever materialized view are not supported in spring boot it seems ? I know you can alias an entity from a selection but that's not materialized so it's still subject to lock.</p>\n<p>Use temporary table, to write new entries into, then delete the old entries and copy the temp table into the myrecord one. This is basically the same idea as with materialized view, except the constraints would be checked in the lock so it would be less efficient. And still, temp tables are not supported by spring ?</p>\n<p>A last idea would be to have the DB manage that &quot;caching&quot; , typically oracle DB has this snapshot capabilities. But I don't think it's present in other DB systems ?</p>\n<p>It seems I could use eg liquibase to make the materialized views but it seems like too big of a change. Especially since that means I need to have the CI update the SQL statements which is very likely to break a lot of things.</p>\n<p>Did I miss something ?\nTo be clear, I actually have a lib of many different MyRecord (with each their own table), with their own MyRecordFetcher classes, and a general updater that those fetcher service register into via spring dependency ( <code>@AutoWired Optional&lt;List&lt;RecordFetcher&gt;&gt; fetchers;</code> ) , so making all the changes by hand is not really acceptable.</p>\n",
    "tags" : [ "java", "spring", "database", "spring-boot" ],
    "owner" : {
      "account_id" : 4751899,
      "reputation" : 182,
      "user_id" : 3841737,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/ce20bf22d2c5b85420f935226bacf571?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "guigolum",
      "link" : "https://stackoverflow.com/users/3841737/guigolum"
    },
    "is_answered" : false,
    "view_count" : 42,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1749544995,
    "creation_date" : 1749543524,
    "link" : "https://stackoverflow.com/questions/79660058/efficient-non-locking-mass-removeinsert-in-spring-boot",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ ],
  "answer_comments" : { }
}