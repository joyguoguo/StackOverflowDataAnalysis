{
  "question" : {
    "question_id" : 79756745,
    "title" : "Connection handling problems when repeatedly starting server on ephemeral port",
    "body" : "<p>In the following scenario:</p>\n<p>In a loop:</p>\n<ul>\n<li>construct and launch server</li>\n<li>construct client and make a request</li>\n<li>print response code</li>\n<li>cleanup server and client</li>\n</ul>\n<p>I am seeing occasional timeouts and rarely other errors.\nUsually, the error appears after a few thousand iterations.</p>\n<p>The example may seem contrived, but is motivated by testing a large codebase with a lot of wiremock tests. I initially thought that it is a wiremock bug, but I observe the same behaviour on plain Jetty.</p>\n<p><strong>I suspect I am hitting some OS limit (or perhaps some options are missing). I need some insight on what is happening.</strong></p>\n<p>I am on MacOS 15.6.1, but same issue occured on our CI on Linux.</p>\n<p>I initially thought I may be running out of ephemeral ports:</p>\n<ul>\n<li>I checked number of ephemeral ports using <code>netstat -np tcp</code></li>\n<li>I added <code>connector.setReuseAddress(true);</code> - I intended to use <code>SO_REUSEADDR</code></li>\n<li>I also tried reducing Maximum Segment Lifetime to 1 via <code>sudo sysctl -w net.inet.tcp.msl=1</code> - this reduces the number of ports in <code>TIME_WAIT</code> state - but the problem persists.</li>\n</ul>\n<p>I also thought I might be producing a lot of garbage.\nI tried increasing the heap and observed the behaviour - but observed the same result (but maybe this can lead somewhere?)</p>\n<p><strong>Example error 1 - timeout:</strong></p>\n<pre class=\"lang-none prettyprint-override\"><code>Exception in thread &quot;main&quot; java.net.http.HttpConnectTimeoutException: HTTP connect timed out\n    at java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:949)\n    at java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)\n    at com.example.Main.main(Main.java:43)\nCaused by: java.net.http.HttpConnectTimeoutException: HTTP connect timed out\n    at java.net.http/jdk.internal.net.http.ResponseTimerEvent.handle(ResponseTimerEvent.java:68)\n    at java.net.http/jdk.internal.net.http.HttpClientImpl.purgeTimeoutsAndReturnNextDeadline(HttpClientImpl.java:1788)\n    at java.net.http/jdk.internal.net.http.HttpClientImpl$SelectorManager.run(HttpClientImpl.java:1386)\nCaused by: java.net.ConnectException: HTTP connect timed out\n    at java.net.http/jdk.internal.net.http.ResponseTimerEvent.handle(ResponseTimerEvent.java:69)\n    ... 2 more\n</code></pre>\n<p><strong>Example error 2 - EOF:</strong></p>\n<pre class=\"lang-none prettyprint-override\"><code>Exception in thread &quot;main&quot; java.io.IOException: HTTP/1.1 header parser received no bytes\n    at java.net.http/jdk.internal.net.http.HttpClientImpl.send(HttpClientImpl.java:970)\n    at java.net.http/jdk.internal.net.http.HttpClientFacade.send(HttpClientFacade.java:133)\n    at com.example.Main.main(Main.java:43)\nCaused by: java.io.IOException: HTTP/1.1 header parser received no bytes\n    at java.net.http/jdk.internal.net.http.common.Utils.wrapWithExtraDetail(Utils.java:412)\n    at java.net.http/jdk.internal.net.http.Http1Response$HeadersReader.onReadError(Http1Response.java:590)\n    at java.net.http/jdk.internal.net.http.Http1AsyncReceiver.checkForErrors(Http1AsyncReceiver.java:302)\n    at java.net.http/jdk.internal.net.http.Http1AsyncReceiver.flush(Http1AsyncReceiver.java:268)\n    at java.net.http/jdk.internal.net.http.common.SequentialScheduler$LockingRestartableTask.run(SequentialScheduler.java:182)\n    at java.net.http/jdk.internal.net.http.common.SequentialScheduler$CompleteRestartableTask.run(SequentialScheduler.java:149)\n    at java.net.http/jdk.internal.net.http.common.SequentialScheduler$SchedulableTask.run(SequentialScheduler.java:207)\n    at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1144)\n    at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:642)\n    at java.base/java.lang.Thread.run(Thread.java:1583)\nCaused by: java.io.EOFException: EOF reached while reading\n    at java.net.http/jdk.internal.net.http.Http1AsyncReceiver$Http1TubeSubscriber.onComplete(Http1AsyncReceiver.java:601)\n    at java.net.http/jdk.internal.net.http.SocketTube$InternalReadPublisher$ReadSubscription.signalCompletion(SocketTube.java:648)\n    at java.net.http/jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription.read(SocketTube.java:853)\n    at java.net.http/jdk.internal.net.http.SocketTube$SocketFlowTask.run(SocketTube.java:181)\n    at java.net.http/jdk.internal.net.http.common.SequentialScheduler$SchedulableTask.run(SequentialScheduler.java:207)\n    at java.net.http/jdk.internal.net.http.common.SequentialScheduler.runOrSchedule(SequentialScheduler.java:280)\n    at java.net.http/jdk.internal.net.http.common.SequentialScheduler.runOrSchedule(SequentialScheduler.java:233)\n    at java.net.http/jdk.internal.net.http.SocketTube$InternalReadPublisher$InternalReadSubscription.signalReadable(SocketTube.java:782)\n</code></pre>\n<p><strong>Code to reproduce the problem:</strong></p>\n<p>Server:</p>\n<pre class=\"lang-java prettyprint-override\"><code>package com.example;\n\nimport org.eclipse.jetty.http.HttpHeader;\nimport org.eclipse.jetty.server.Handler;\nimport org.eclipse.jetty.server.Request;\nimport org.eclipse.jetty.server.Response;\nimport org.eclipse.jetty.server.Server;\nimport org.eclipse.jetty.server.ServerConnector;\nimport org.eclipse.jetty.util.Callback;\n\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\n\npublic class SingleEndpointServer implements AutoCloseable {\n\n    private final Server server;\n\n    public SingleEndpointServer() {\n        this.server = new Server();\n\n        ServerConnector connector = new ServerConnector(this.server);\n        connector.setPort(0); // Use port 0 for an ephemeral port\n        connector.setReuseAddress(true); // Set SO_REUSEADDR\n\n        this.server.addConnector(connector);\n        this.server.setHandler(new FixedEndpointHandler());\n    }\n\n    public void start() throws Exception {\n        this.server.start();\n        //System.out.println(&quot;Server started on port: &quot; + getPort());\n    }\n\n    public void stop() throws Exception {\n        //System.out.println(&quot;Stopping server on port: &quot; + getPort());\n        this.server.stop();\n    }\n\n    public int getPort() {\n        return ((ServerConnector) this.server.getConnectors()[0]).getLocalPort();\n    }\n\n    public String getBaseUrl() {\n        return &quot;http://localhost:&quot; + getPort();\n    }\n\n    @Override\n    public void close() throws Exception {\n        stop();\n    }\n\n    private static class FixedEndpointHandler extends Handler.Abstract {\n        @Override\n        public boolean handle(Request request, Response response, Callback callback) {\n            // Check if the request matches our hardcoded endpoint\n            if (&quot;POST&quot;.equals(request.getMethod()) &amp;&amp; &quot;/test&quot;.equals(request.getHttpURI().getPath())) {\n                applyStubResponse(response, callback);\n            } else {\n                sendNotFoundResponse(response, callback, request);\n            }\n            return true; // Mark the request as handled\n        }\n\n        private void applyStubResponse(Response response, Callback callback) {\n            response.setStatus(400);\n            response.getHeaders().put(HttpHeader.CONTENT_TYPE, &quot;application/json&quot;);\n\n            String body = &quot;{\\&quot;error\\&quot;: \\&quot;Expected error returned from server.\\&quot;}&quot;;\n            byte[] responseBody = body.getBytes(StandardCharsets.UTF_8);\n            ByteBuffer bodyBuffer = ByteBuffer.wrap(responseBody);\n\n            response.write(true, bodyBuffer, callback);\n        }\n\n        private void sendNotFoundResponse(Response response, Callback callback, Request request) {\n            String errorMessage = &quot;Endpoint not found: &quot; + request.getMethod() + &quot; &quot; + request.getHttpURI().getPath();\n            byte[] responseBody = errorMessage.getBytes(StandardCharsets.UTF_8);\n            ByteBuffer bodyBuffer = ByteBuffer.wrap(responseBody);\n\n            response.setStatus(404);\n            response.getHeaders().put(HttpHeader.CONTENT_TYPE, &quot;text/plain; charset=utf-8&quot;);\n\n            response.write(true, bodyBuffer, callback);\n        }\n    }\n}\n</code></pre>\n<p>Main:</p>\n<pre class=\"lang-java prettyprint-override\"><code>package com.example;\n\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\n\npublic class Main {\n\n\n    public static void main(String[] args) throws Exception {\n        \n        for (int i = 0;; i++) {\n            System.out.println(&quot;=== Cycle &quot; + (i + 1) + &quot; ===&quot;);\n            SingleEndpointServer server = null;\n            try {\n                server = new SingleEndpointServer();\n                server.start();\n\n                HttpClient client = HttpClient.newBuilder()\n                        .version(HttpClient.Version.HTTP_1_1)\n                        .connectTimeout(Duration.ofSeconds(10))\n                        .build();\n\n                HttpRequest request = HttpRequest.newBuilder()\n                        .uri(URI.create(server.getBaseUrl() + &quot;/test&quot;))\n                        .POST(HttpRequest.BodyPublishers.ofString(&quot;{}&quot;))\n                        .header(&quot;Content-Type&quot;, &quot;application/json&quot;)\n                        .timeout(Duration.ofSeconds(5))\n                        .build();\n\n                HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());\n\n                System.out.println(&quot;Response Status Code: &quot; + response.statusCode());\n\n            } finally {\n                if (server != null) {\n                    server.stop();\n                }\n            }\n\n        }\n    }\n}\n\n</code></pre>\n<p><strong>Dependencies:</strong></p>\n<ul>\n<li>org.eclipse.jetty:jetty-server:12.0.25</li>\n</ul>\n",
    "tags" : [ "java", "http", "jetty", "wiremock" ],
    "owner" : {
      "account_id" : 1713236,
      "reputation" : 26559,
      "user_id" : 1570854,
      "user_type" : "registered",
      "accept_rate" : 71,
      "profile_image" : "https://i.sstatic.net/ef6Ng.jpg?s=256",
      "display_name" : "Lesiak",
      "link" : "https://stackoverflow.com/users/1570854/lesiak"
    },
    "is_answered" : true,
    "view_count" : 141,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1757076974,
    "creation_date" : 1757073670,
    "link" : "https://stackoverflow.com/questions/79756745/connection-handling-problems-when-repeatedly-starting-server-on-ephemeral-port",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79756803,
    "question_id" : 79756745,
    "body" : "<p>So the issue <strong>may</strong> be that calling <code>server.stop()</code> doesnâ€™t immediately free threads, sockets, and ports. Creating a new server immediately can race with cleanup causing EOFs, try to add <code>server.destroy()</code> after stopping it.</p>\n<p>Also you should put the <code>HttpClient</code> out of the loop because otherwise it forces new threads and selectors repeatedly, increasing resource churn.</p>\n<p>Try those fixes:</p>\n<pre><code>HttpClient client = HttpClient.newBuilder()\n        .version(HttpClient.Version.HTTP_1_1)\n        .connectTimeout(Duration.ofSeconds(10))\n        .build();\n\nfor (int i = 0;; i++) {\n    SingleEndpointServer server = null;\n    try {\n        server = new SingleEndpointServer();\n        server.start();\n\n        HttpRequest request = HttpRequest.newBuilder()\n                .uri(URI.create(server.getBaseUrl() + &quot;/test&quot;))\n                .POST(HttpRequest.BodyPublishers.ofString(&quot;{}&quot;))\n                .header(&quot;Content-Type&quot;, &quot;application/json&quot;)\n                .timeout(Duration.ofSeconds(5))\n                .build();\n\n        HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());\n        System.out.println(&quot;Response Status Code: &quot; + response.statusCode())\n\n    } finally {\n        if (server != null) {\n            server.stop();\n            server.destroy();\n        }\n\n    }\n}\n</code></pre>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "user_type" : "does_not_exist",
      "display_name" : "user17466897"
    },
    "creation_date" : 1757076974,
    "last_activity_date" : 1757076974,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79756803" : [ {
      "comment_id" : 140723067,
      "post_id" : 79756803,
      "body" : "Maybe socket buffer sizes / flush policy are the issue on MacOS ?",
      "score" : 0,
      "owner" : {
        "user_type" : "does_not_exist",
        "display_name" : "user17466897"
      },
      "creation_date" : 1757368067,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140722144,
      "post_id" : 79756803,
      "body" : "Same on Ubuntu / x86_64 - 100_000 runs without problem. Seems that MacOS OS defaults may be something to look at.",
      "score" : 1,
      "owner" : {
        "account_id" : 1713236,
        "reputation" : 26559,
        "user_id" : 1570854,
        "user_type" : "registered",
        "accept_rate" : 71,
        "profile_image" : "https://i.sstatic.net/ef6Ng.jpg?s=256",
        "display_name" : "Lesiak",
        "link" : "https://stackoverflow.com/users/1570854/lesiak"
      },
      "creation_date" : 1757340312,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140718711,
      "post_id" : 79756803,
      "body" : "Windows 10 / 24 GB RAM / x64 / Intel core I5 4 hearts.  OpenJDK 24 and I made sure to use the same version of Jetty as you.  Maybe the problem comes from your firewall on your OS ?",
      "score" : 0,
      "owner" : {
        "user_type" : "does_not_exist",
        "display_name" : "user17466897"
      },
      "creation_date" : 1757151511,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140718067,
      "post_id" : 79756803,
      "body" : "Ah, interesting. What OS / CPU Architecture / Javva version are you running on?",
      "score" : 0,
      "owner" : {
        "account_id" : 1713236,
        "reputation" : 26559,
        "user_id" : 1570854,
        "user_type" : "registered",
        "accept_rate" : 71,
        "profile_image" : "https://i.sstatic.net/ef6Ng.jpg?s=256",
        "display_name" : "Lesiak",
        "link" : "https://stackoverflow.com/users/1570854/lesiak"
      },
      "creation_date" : 1757107059,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140717933,
      "post_id" : 79756803,
      "body" : "@Lesiak Tried to reproduce the issue on VSCode inside a Maven project but it seems like the problem doesn&#39;t come from your code but indeed from your OS (went up to cycle 50000 without any noticeable problem)...",
      "score" : 1,
      "owner" : {
        "user_type" : "does_not_exist",
        "display_name" : "user17466897"
      },
      "creation_date" : 1757102096,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140717653,
      "post_id" : 79756803,
      "body" : "1. Unfortunately even Thread.sleep(200) does not help - same symptoms. 2. Even if it helped, I doubt if this is actionable - our test suite already takes a lot of time. 3. You say: &quot;I think it may be linked that the Jetty server still has sockets who aren&#39;t closed, so the client tries to read them but the server is already destroyed&quot;. Can you elaborate? I believe that this code opens new ephemeral port in each iteration - (I checked that no collisions occur - no ports were reused). Thus in new iteration the client does not connect to the old server instance.",
      "score" : 1,
      "owner" : {
        "account_id" : 1713236,
        "reputation" : 26559,
        "user_id" : 1570854,
        "user_type" : "registered",
        "accept_rate" : 71,
        "profile_image" : "https://i.sstatic.net/ef6Ng.jpg?s=256",
        "display_name" : "Lesiak",
        "link" : "https://stackoverflow.com/users/1570854/lesiak"
      },
      "creation_date" : 1757091640,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140717286,
      "post_id" : 79756803,
      "body" : "@Lesiak I think it may be linked that the Jetty server still has sockets who aren&#39;t closed, so the client tries to read them but the server is already destroyed. Maybe add a Thread.sleep(200) or 50ms after the server is destroyed ?",
      "score" : 0,
      "owner" : {
        "user_type" : "does_not_exist",
        "display_name" : "user17466897"
      },
      "creation_date" : 1757080180,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140717218,
      "post_id" : 79756803,
      "body" : "Applied the suggestions, but the issue persists. The distribution of errors seems to have changed a bit, I see <code>Exception in thread &quot;main&quot; java.io.IOException: parsing HTTP&#47;1.1 status line, receiving [], parser state [STATUS_LINE]</code> more frequently - it was very rare in the initial version.",
      "score" : 0,
      "owner" : {
        "account_id" : 1713236,
        "reputation" : 26559,
        "user_id" : 1570854,
        "user_type" : "registered",
        "accept_rate" : 71,
        "profile_image" : "https://i.sstatic.net/ef6Ng.jpg?s=256",
        "display_name" : "Lesiak",
        "link" : "https://stackoverflow.com/users/1570854/lesiak"
      },
      "creation_date" : 1757078096,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}