{
  "question" : {
    "question_id" : 79673381,
    "title" : "Time Based File Availability Check in Apache Camel - Spring boot",
    "body" : "<p>I am implementing a service where my source directory is continously monitored and files will be pulled and pushed to destination. I want to acheive one functionlaity where time based file availablity will come into picture.</p>\n<p>I may receive a file abc.txt everyday at 5:00pm,if the file didnt arrive at 5:00pm, need to wait for 30mins then check. If the file didn't arrive within the buffer window as well, trigger an email.</p>\n<p>I tried using &quot;seda&quot; of camel but didn't work. Whenever the time happens, it pauses the files to pull from source, ie if you copy any file to source it is not pulling and pushing to destination. It is a kind of freeze. No action performs. But after 5mins, everything is normal, ie. all the files will be pulled and pushed to destination.</p>\n<p>Please help, below is my code.</p>\n<pre><code>@Component\npublic class LocalToLocalRoute implements FileTransferRouteResolver {\n\n    private final FileTransferProperties properties;\n    private final LocalCacheService localCacheService;\n    private final List&lt;String&gt; filesToMonitor;\n\n    public LocalToLocalRoute(FileTransferProperties properties, LocalCacheService localCacheService) {\n        this.properties = properties;\n        this.localCacheService = localCacheService;\n        this.filesToMonitor = getFilesToMonitor(properties);\n    }\n\n    @Override\n    public void configureRoute(RouteBuilder routeBuilder) throws Exception {\n        LocalToLocal localtolocalProps = properties.getLocaltolocal();\n        List&lt;String&gt; allowedExtensions = localtolocalProps.getFilter();\n        Long retryDelay = properties.getRetryDelay();\n        Integer maxRetryLimit = properties.getMaxRetryLimit();\n        \n        AftUri fromUri = AftUri.builder(&quot;file&quot;)\n                .path(localtolocalProps.getSource())\n                .addParams(localtolocalProps.getFromCamelOptions())\n                .build();\n\n        AftUri toUri = AftUri.builder(&quot;file&quot;)\n                .path(localtolocalProps.getDestination())\n                .addParams(localtolocalProps.getToCamelOptions())\n                .build();\n\n        AftUri errorUri = AftUri.builder(&quot;file&quot;)\n                .path(localtolocalProps.getSource() + File.separator + &quot;.error&quot;)\n                .build();\n\n        transfer(routeBuilder, fromUri, toUri, errorUri, this.getClass().getSimpleName(), retryDelay, maxRetryLimit, allowedExtensions, localCacheService, filesToMonitor);\n\n        if (localtolocalProps.getFilechecks() == null) {\n            return;\n        }\n\n        for (LocalToLocal.FileCheck fileCheck : localtolocalProps.getFilechecks()) {\n            String fileName = fileCheck.getFilename();\n            String checkTime = fileCheck.getCheckTime();\n            int bufferMinutes = fileCheck.getBufferMinutes();\n            long fileExpectedTime = convertTimeToMilliseconds(checkTime);\n            String cron = toCron(checkTime);\n            String quartzId = &quot;quartz://fileCheckGroup/&quot; + fileName + &quot;?cron=&quot; + cron;\n            invokeFileCheck(routeBuilder, fileName, checkTime, fileExpectedTime, quartzId);\n            invokeBufferedCheck(routeBuilder, fileName, bufferMinutes, fileExpectedTime);\n        }\n\n    }\n\n\n    private void invokeFileCheck(RouteBuilder routeBuilder, String fileName, String checkTime, long fileExpectedTime, String quartzId) {\n        routeBuilder.from(quartzId)\n        .routeId(&quot;FileCheckRoute-&quot; + fileName + &quot;-&quot; + UUID.randomUUID())\n                .log(&quot;Checking for file: &quot; + fileName + &quot; at scheduled time: &quot; + checkTime)\n                .process(exchange -&gt; {\n                    boolean containsKey = localCacheService.containsKey(fileName);\n                    if (containsKey) {\n                        Long fileProcessedTime = localCacheService.get(fileName);\n                        if (fileProcessedTime &gt;= fileExpectedTime) {\n                            exchange.setProperty(&quot;fileName&quot;, fileName);\n                            exchange.setProperty(&quot;fileExists&quot;, true);\n                        }\n                    } else {\n                        exchange.setProperty(&quot;fileName&quot;, fileName);\n                        exchange.setProperty(&quot;fileExists&quot;, false);\n                    }\n                })\n                .choice()\n                    .when(routeBuilder.simple(&quot;${exchangeProperty.fileExists} == false&quot;))\n                    .log(&quot;File ${exchangeProperty.fileName} is missing. Waiting for buffer window...&quot;)\n                    .to(&quot;seda:bufferDelay-&quot; + fileName)\n                .otherwise()\n                    .log(&quot;File ${exchangeProperty.fileName} found. No need to wait.&quot;)\n                    .process(e -&gt; localCacheService.remove(fileName))\n                .end();\n    }\n    \n    private void invokeBufferedCheck(RouteBuilder routeBuilder, String fileName, int bufferMinutes, long fileExpectedTime) {\n        routeBuilder.from(&quot;seda:bufferDelay-&quot; + fileName)\n            .routeId(&quot;BufferedCheckRoute-&quot; + fileName + &quot;-&quot; + UUID.randomUUID())\n            .log(&quot;Buffer check started for file: &quot; + fileName + &quot;, waiting for {} minutes&quot;+ bufferMinutes)\n            .delayer(bufferMinutes * 60 * 1000L)\n            .log(&quot;Buffer delay expired for file: &quot; + fileName)\n            .process(exchange -&gt; {\n                Long fileProcessedTime = localCacheService.get(fileName);\n                boolean stillMissing = (fileProcessedTime == null) || (fileProcessedTime &lt; fileExpectedTime);\n                exchange.setProperty(&quot;stillMissing&quot;, stillMissing);\n                exchange.setProperty(&quot;fileName&quot;, fileName);\n            })\n            .choice()\n                .when(routeBuilder.simple(&quot;${exchangeProperty.stillMissing} == true&quot;))\n                    .log(&quot;ALERT: File ${exchangeProperty.fileName} still missing after buffer wait.&quot;)\n                .otherwise()\n                    .log(&quot;File ${exchangeProperty.fileName} arrived within buffer window.&quot;)\n                    .process(e -&gt; localCacheService.remove(fileName))\n            .end();\n    }\n\n    \n    public static long convertTimeToMilliseconds(String time) {\n        String[] parts = time.split(&quot;:&quot;);\n        int hours = Integer.parseInt(parts[0]);\n        int minutes = Integer.parseInt(parts[1]);\n        return (hours * 60L + minutes) * 60 * 1000;\n    }\n\n    \n     private String toCron(String time) {\n            String[] parts = time.split(&quot;:&quot;);\n            int hour = Integer.parseInt(parts[0]);\n            int minute = Integer.parseInt(parts[1]);\n            return String.format(&quot;0 %d %d * * ?&quot;, minute, hour); // Quartz cron format\n        }\n}\n</code></pre>\n<pre><code>\n\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.camel.Exchange;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic interface FileTransferRouteResolver {\n    \n    final Logger LOGGER = LoggerFactory.getLogger(FileTransferRouteResolver.class);\n    void configureRoute(RouteBuilder routeBuilder) throws Exception;\n\n    default void transfer(RouteBuilder routeBuilder, AftUri fromUri, AftUri toUri,AftUri errorUri, String routeName, int retryDelay, int maxDeliveries, List&lt;String&gt; allowedExtensions) {\n        String filterExpression = buildExtensionFilter(allowedExtensions);\n        routeBuilder.onException(Exception.class)\n                .redeliveryDelay(retryDelay)\n                .maximumRedeliveries(maxDeliveries)\n                .retryAttemptedLogLevel(org.apache.camel.LoggingLevel.INFO)\n                .handled(true)\n                .log(&quot;Exception occurred while moving file: ${file:name}&quot;)\n                .to(errorUri.build());\n\n        routeBuilder.from(fromUri.build())\n                .routeId(routeName + &quot;-&quot; + UUID.randomUUID())\n                .log(&quot;Detected new file: ${file:name}&quot;)\n                .filter().simple(filterExpression)\n                    .log(&quot;Accepted file: ${file:name}&quot;)\n                    .to(toUri.build())\n                    .log(&quot;File: ${file:name} moved to destination&quot;)\n                .end();\n    }\n    \n    \n    default void transfer(RouteBuilder routeBuilder, AftUri fromUri, AftUri toUri,AftUri errorUri, String routeName, Long retryDelay, Integer maxDeliveries, List&lt;String&gt; allowedExtensions, LocalCacheService localCacheService, List&lt;String&gt; filesToMonitor) {\n        String filterExpression = buildExtensionFilter(allowedExtensions);\n        \n        routeBuilder.onException(Exception.class)\n                .redeliveryDelay(retryDelay)\n                .maximumRedeliveries(maxDeliveries)\n                .retryAttemptedLogLevel(org.apache.camel.LoggingLevel.INFO)\n                .log(&quot;Exception occurred while moving file: ${file:name}&quot;)\n                .to(errorUri.build());\n\n        routeBuilder.from(fromUri.build())\n                .routeId(routeName + &quot;-&quot; + UUID.randomUUID())\n                .log(&quot;Detected new file: ${file:name}&quot;)\n                .filter().simple(filterExpression)\n                    .log(&quot;Accepted file: ${file:name}&quot;)\n                    .process(exchange -&gt; {\n                        String fileName = exchange.getIn().getHeader(Exchange.FILE_NAME, String.class);\n                        if(filesToMonitor.contains(fileName)) {\n                            localCacheService.put(fileName, System.currentTimeMillis());\n                            LOGGER.info(&quot;File '{}' detected and recorded in cache at {}.&quot;, fileName, System.currentTimeMillis());\n                        }\n                    })\n                    .to(toUri.build())\n                    .log(&quot;File: ${file:name} moved to destination&quot;)\n                .end();\n    }\n    \n    \n    default String buildExtensionFilter(List&lt;String&gt; extensions) {\n        if (extensions == null || extensions.isEmpty() || extensions.get(0).equals(&quot;*&quot;)) {\n            return &quot;true&quot;; // Allow all files if no filter is defined\n        }\n\n        return extensions.stream()\n            .filter(ext -&gt; ext != null &amp;&amp; !ext.isBlank())\n            .map(ext -&gt; ext.startsWith(&quot;.&quot;) ? ext.substring(1) : ext) // Remove leading dot\n            .&lt;String&gt;flatMap(ext -&gt; Stream.of(\n                &quot;${file:ext} == '&quot; + ext.toLowerCase() + &quot;'&quot;,\n                &quot;${file:ext} == '&quot; + ext.toUpperCase() + &quot;'&quot;\n            ))\n            .reduce((a, b) -&gt; a + &quot; || &quot; + b)\n            .orElse(&quot;true&quot;);\n    }\n\n    default List&lt;String&gt; getFilesToMonitor(FileTransferProperties properties) {\n        List&lt;FileCheck&gt; filechecks = properties.getLocaltolocal().getFilechecks();\n        if(filechecks.isEmpty()) {\n            return null;\n        } else {\n            return filechecks.stream().map(e -&gt; e.getFilename()).collect(Collectors.toList());\n        }\n    }\n\n}\n\n</code></pre>\n",
    "tags" : [ "java", "spring", "spring-boot", "apache-camel" ],
    "owner" : {
      "account_id" : 19688119,
      "reputation" : 144,
      "user_id" : 14413687,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/7a995ec3dbc88c638df09d3308238cff?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "spyder",
      "link" : "https://stackoverflow.com/users/14413687/spyder"
    },
    "is_answered" : true,
    "view_count" : 68,
    "answer_count" : 2,
    "score" : 0,
    "last_activity_date" : 1751016665,
    "creation_date" : 1750423056,
    "link" : "https://stackoverflow.com/questions/79673381/time-based-file-availability-check-in-apache-camel-spring-boot",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79677319,
    "question_id" : 79673381,
    "body" : "<p>seda appears to be a blocking behavior related to the delayer() in the invokeBufferedCheck() route.</p>\n<p>Use seda with concurrentConsumers set &gt; 1 or switch to direct with a ScheduledExecutorService-based delay using Camel's ScheduledPollConsumer or a custom processor with a non-blocking delay strategy.</p>\n<p>Then I guess you have 2 options :</p>\n<p>Option 1: Use seda with concurrentConsumers and asyncDelayed</p>\n<p>In this scenario, modify you involeBufferedCheck like below :</p>\n<pre><code>routeBuilder.from(&quot;seda:bufferDelay-&quot; + fileName + &quot;?concurrentConsumers=2&quot;)\n    .routeId(&quot;BufferedCheckRoute-&quot; + fileName + &quot;-&quot; + UUID.randomUUID())\n    .log(&quot;Buffer check started for file: &quot; + fileName + &quot;, waiting for &quot; + bufferMinutes + &quot; minutes&quot;)\n    .delayer(bufferMinutes * 60 * 1000L)\n        .asyncDelayed() // important to avoid blocking the thread\n    .log(&quot;Buffer delay expired for file: &quot; + fileName)\n    .process(exchange -&gt; {\n        Long fileProcessedTime = localCacheService.get(fileName);\n        boolean stillMissing = (fileProcessedTime == null) || (fileProcessedTime &lt; fileExpectedTime);\n        exchange.setProperty(&quot;stillMissing&quot;, stillMissing);\n        exchange.setProperty(&quot;fileName&quot;, fileName);\n    })\n    .choice()\n        .when(routeBuilder.simple(&quot;${exchangeProperty.stillMissing} == true&quot;))\n            .log(&quot;ALERT: File ${exchangeProperty.fileName} still missing after buffer wait.&quot;)\n            // Here you can invoke your email alert processor/service\n        .otherwise()\n            .log(&quot;File ${exchangeProperty.fileName} arrived within buffer window.&quot;)\n            .process(e -&gt; localCacheService.remove(fileName))\n    .end();\n</code></pre>\n<p>Option 2: Avoid delayer entirely â€“ Use Camel Timer with a dynamic delay.</p>\n<p>Instead of a delayed seda, schedule a separate quartz or timer route with a delay. This will completely avoid thread blocking. e.g:</p>\n<pre><code>String timerUri = String.format(&quot;quartz://delayedCheck/%s?trigger.repeatCount=0&amp;trigger.startDelay=%d&quot;, \n                                fileName, bufferMinutes * 60 * 1000L);\n\nrouteBuilder.from(&quot;seda:bufferDelay-&quot; + fileName)\n    .routeId(&quot;ScheduleBufferCheck-&quot; + fileName)\n    .to(timerUri);\n\nrouteBuilder.from(timerUri)\n    .routeId(&quot;ExecuteBufferCheck-&quot; + fileName + &quot;-&quot; + UUID.randomUUID())\n    .log(&quot;Executing buffered file check for file: &quot; + fileName)\n    .process(exchange -&gt; {\n        Long fileProcessedTime = localCacheService.get(fileName);\n        boolean stillMissing = (fileProcessedTime == null) || (fileProcessedTime &lt; fileExpectedTime);\n        exchange.setProperty(&quot;stillMissing&quot;, stillMissing);\n        exchange.setProperty(&quot;fileName&quot;, fileName);\n    })\n    .choice()\n        .when(routeBuilder.simple(&quot;${exchangeProperty.stillMissing} == true&quot;))\n            .log(&quot;ALERT: File ${exchangeProperty.fileName} still missing after buffer wait.&quot;)\n        .otherwise()\n            .log(&quot;File ${exchangeProperty.fileName} arrived within buffer window.&quot;)\n            .process(e -&gt; localCacheService.remove(fileName))\n    .end();\n</code></pre>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 38184131,
      "reputation" : 442,
      "user_id" : 28663047,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/tEoSnnyf.png?s=256",
      "display_name" : "RCDevs Security",
      "link" : "https://stackoverflow.com/users/28663047/rcdevs-security"
    },
    "creation_date" : 1750756384,
    "last_activity_date" : 1750756384,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79681714,
    "question_id" : 79673381,
    "body" : "<pre><code>public void createQuartzRoutes(RouteBuilder routeBuilder, String fileName, String checkTime, long fileExpectedTime, String quartzId, int bufferMinutes) {\n            routeBuilder.from(quartzId)\n                .routeId(&quot;QuartzFileCheckRoute-&quot; + fileName + UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;))\n                .log(&quot;Initial check started for file: &quot; + fileName + &quot; at scheduled time: &quot; + checkTime)\n                .process(exchange -&gt; {\n                    boolean containsKey = localCacheService.containsKey(fileName);\n                    if (containsKey) {\n                        Long fileProcessedTime = localCacheService.get(fileName);\n                        if (fileProcessedTime != null &amp;&amp; fileProcessedTime &gt;= fileExpectedTime) {\n                            exchange.setProperty(&quot;fileName&quot;, fileName);\n                            exchange.setProperty(&quot;fileExistsInitially&quot;, true);\n                        } else {\n                            exchange.setProperty(&quot;fileName&quot;, fileName);\n                            exchange.setProperty(&quot;fileExistsInitially&quot;, false);\n                        }\n                    } else {\n                        exchange.setProperty(&quot;fileName&quot;, fileName);\n                        exchange.setProperty(&quot;fileExistsInitially&quot;, false);\n                    }\n                })\n                .choice() // OUTER CHOICE STARTS HERE\n                    .when(routeBuilder.simple(&quot;${exchangeProperty.fileExistsInitially} == false&quot;))\n                        .log(&quot;File ${exchangeProperty.fileName} is missing initially. Waiting for buffer window of &quot; + bufferMinutes + &quot; minutes...&quot;)\n                        .delay(bufferMinutes * 60 * 1000L)\n                        .log(&quot;Buffer delay expired for file: ${exchangeProperty.fileName}&quot;)\n                        .process(exchange -&gt; {\n                            Long fileProcessedTime = localCacheService.get(fileName);\n                            boolean stillMissing = (fileProcessedTime == null) || (fileProcessedTime &lt; fileExpectedTime);\n                            exchange.setProperty(&quot;stillMissing&quot;, stillMissing);\n                        })\n                        .choice() // INNER CHOICE STARTS HERE\n                            .when(routeBuilder.simple(&quot;${exchangeProperty.stillMissing} == true&quot;))\n                                .log(&quot;********ALERT: File ${exchangeProperty.fileName} still missing after buffer wait.********&quot;)\n                            .otherwise()\n                                .log(&quot;File ${exchangeProperty.fileName} arrived within buffer window.&quot;)\n                                .process(e -&gt; localCacheService.remove(fileName))\n                        .endChoice() // &lt;-- IMPORTANT: Use endChoice() to close the inner choice\n                    .otherwise() // Now this otherwise() correctly applies to the OUTER choice\n                        .log(&quot;File ${exchangeProperty.fileName} found during initial check. No need for buffer wait.&quot;)\n                        .process(e -&gt; localCacheService.remove(fileName))\n                .end(); // End of outer choice\n     }\n</code></pre>\n<p>I solved it using above code. But appriciate your efforts. Thank you.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 19688119,
      "reputation" : 144,
      "user_id" : 14413687,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/7a995ec3dbc88c638df09d3308238cff?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "spyder",
      "link" : "https://stackoverflow.com/users/14413687/spyder"
    },
    "creation_date" : 1751016665,
    "last_activity_date" : 1751016665,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}