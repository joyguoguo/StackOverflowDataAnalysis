{
  "question" : {
    "question_id" : 79840796,
    "title" : "Wrong behavior of background thread execution in android",
    "body" : "<p>I have an app with a background thread which must send periodically a message to MQTT broker to keep the connection aliave. (see this post <a href=\"https://stackoverflow.com/questions/79835732/paho-android-mqtt-client-does-not-send-pingreq-to-broker-when-phone-screen-is-of\">paho Android MQTT client does not send PINGREQ to broker when phone screen is off</a>)  The periodicity of the messages is not critical and i use Thread.sleep() in a loop to send these messages.<br>\nHere is the java code of the thread</p>\n<pre><code>public class HeartBeat extends Thread {\n  private boolean bloop;\n  private Thread t_wait;\n  private long sleepTime;\n  private MQTTService mqtts;\n  private final String TAG = &quot;HB&quot;;\n  private final String topic_hb = &quot;wmon01/hb&quot;;\n  private long slt = 0, dt = 0;\n  private SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;);\n  public HeartBeat(MQTTService m, int st) {\n    bloop = false;\n    // sleepTime = st * 1000 / 10;\n    sleepTime = 20000;\n    mqtts = m;\n    slt = System.currentTimeMillis();\n    Log.d(TAG, sdf.format(slt) + &quot;new HeartBeat&quot;);\n  }\n  public void startLoop() {\n    if (bloop == false) {\n      bloop = true;\n      t_wait = new Thread((Runnable) this);\n      t_wait.setPriority(Thread.MAX_PRIORITY);\n      t_wait.start();\n      slt = System.currentTimeMillis();\n      mqtts.sendMessage(topic_hb, sdf.format(slt) + &quot; t_wait.start()&quot;);\n      Log.d(TAG, sdf.format(slt) + &quot; t_wait.start()&quot;);\n    }\n  }\n  public void stopLoop() {\n    bloop = false;\n  }\n  public void run() {\n    while (bloop) {\n      try {\n        Thread.sleep(sleepTime);\n      } catch (InterruptedException e) {\n        e.printStackTrace();\n        slt = System.currentTimeMillis();\n        mqtts.sendMessage(topic_hb, sdf.format(slt) + &quot; / t_wait thread exception: &quot; + e.getMessage());\n        Log.d(TAG, sdf.format(slt) + &quot; / t_wait thread exception: &quot; + e.getMessage());\n      }\n      if (!bloop)\n        break;\n      slt = System.currentTimeMillis();\n      dt = slt - dt;\n      mqtts.sendMessage(topic_hb, sdf.format(slt) + &quot; / &quot; + dt + &quot; / HB message&quot;);\n      dt = slt;\n      Log.d(TAG, sdf.format(slt) + &quot; / &quot; + dt + &quot; / HB message&quot;);\n    }\n    slt = System.currentTimeMillis();\n    mqtts.sendMessage(topic_hb, sdf.format(slt) + &quot; / &quot; + dt + &quot; / bloop = false&quot;);\n    Log.d(TAG, sdf.format(slt) + &quot; / &quot; + dt + &quot; / bloop = false&quot;);\n  }\n}\n</code></pre>\n<p>The messages are logged on server side so I can see the message timestamp and time difference between them.\nAfter few days of testing it shows complete random values of delta t between messages.<br>\nInitially, after first start after app installation, if the screen is on, or connected to a charger, with a sleep time of 20000 msec, the message frequency looks ok</p>\n<pre><code>…\n//---------TS---------- / --dt-- / \n2025-12-07 19:30:56.612 / 20033 / HB message\n2025-12-07 19:31:16.644 / 20032 / HB message\n2025-12-07 19:31:36.675 / 20031 / HB message\n2025-12-07 19:31:56.703 / 20028 / HB message\n2025-12-07 19:32:16.730 / 20027 / HB message\n2025-12-07 19:32:36.761 / 20031 / HB message\n…\n</code></pre>\n<p>When screen is off and no charger connected, then delta t gets random and much much higher than expected value.</p>\n<pre><code>…\n//-----------TS---------------- / --dt-- / \n2025-12-07 20:11:11.689 / 82275 / HB message\n2025-12-07 20:12:29.939 / 78250 / HB message\n2025-12-07 20:13:48.985 / 79046 / HB message\n2025-12-07 20:14:45.506 / 56521 / HB message\n2025-12-07 20:16:07.179 / 81673 / HB message\n…\n</code></pre>\n<p>And the value gets bigger and bigger until the MQTT broker disconnects the client because of inactivity..</p>\n<pre><code>...\n2025-12-08 01:31:59.101 t_wait.start()\n2025-12-08 01:34:16.088 / 2027783 / HB message\n2025-12-08 01:39:04.445 / 288357 / HB message\n2025-12-08 01:45:42.742 t_wait.start()\n2025-12-08 01:45:42.809 / 398364 / HB message\n2025-12-08 01:46:47.515 / 64706 / HB message\n...\n</code></pre>\n<p>More than that, it started to show values lower than 20000 msec sleep time!?!</p>\n<pre><code>...\n2025-12-08 11:04:52.943 / 18120 / HB message\n2025-12-08 11:04:57.501 / 4558 / HB message\n2025-12-08 11:05:13.009 / 15508 / HB message\n2025-12-08 11:05:24.100 / 11091 / HB message\n2025-12-08 11:05:25.411 / 1311 / HB message\n2025-12-08 11:05:40.675 / 15264 / HB message\n...\n</code></pre>\n<p>The application is set either to use battery in unrestricted mode or is set to “never sleep”, the behavior is the same.<br>\nI can understand that power management can have impact on execution, but I cannot understand how sleep(<strong>msec</strong>)  can return before <strong>msec</strong> to elapse!!!<br>\nIs there a way to make this thread to behave consistent?</p>\n",
    "tags" : [ "java", "android", "power-management", "background-thread" ],
    "owner" : {
      "account_id" : 10781545,
      "reputation" : 11,
      "user_id" : 9089026,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/bbc1ae9bf7e2909ee1f83e089b05ef12?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "ves",
      "link" : "https://stackoverflow.com/users/9089026/ves"
    },
    "is_answered" : false,
    "view_count" : 105,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1765291755,
    "creation_date" : 1765186511,
    "link" : "https://stackoverflow.com/questions/79840796/wrong-behavior-of-background-thread-execution-in-android",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79842075,
    "question_id" : 79840796,
    "body" : "<p>First here is the requirement which led to the investigation of background thread behavior:</p>\n<p><strong>The client app must send at least 1 message to server every 3 min interval, otherwise, the server will disconnect it.</strong></p>\n<p>I tested Thread.sleep() and Handler.postDelayed(). With none of these methods could get a reliable way to execute a piece of code at a predictable rate. When android power management comes into the picture the execution rate starts increasing, slow but steady, until gets to a value which is not acceptable for the requirement.</p>\n<p>Didn’t try AlarmManager or WorkManager because the documentation (<a href=\"https://developer.android.com/reference/android/app/AlarmManager\" rel=\"nofollow noreferrer\">https://developer.android.com/reference/android/app/AlarmManager</a> or <a href=\"https://developer.android.com/reference/androidx/work/PeriodicWorkRequest\" rel=\"nofollow noreferrer\">https://developer.android.com/reference/androidx/work/PeriodicWorkRequest</a>) clearly states an interval of up to 15 mins.</p>\n<p>After several days of research and testing, it looks this is not <strong>“wrong behavior”</strong> but <strong>“the behavior”</strong>. I would say Android is not meant for this requirement.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 10781545,
      "reputation" : 11,
      "user_id" : 9089026,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/bbc1ae9bf7e2909ee1f83e089b05ef12?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "ves",
      "link" : "https://stackoverflow.com/users/9089026/ves"
    },
    "creation_date" : 1765291755,
    "last_activity_date" : 1765291755,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140892800,
    "post_id" : 79840796,
    "body" : "<b>@CommonsWare</b>, “…perhaps there is more than one thread at that point...” Ahh good point. Yes, at that point in time there were a lot of t_wait threads. Stupid misunderstanding from myself ☹and perfect illustration of @Torben’s point.",
    "score" : 0,
    "owner" : {
      "account_id" : 10781545,
      "reputation" : 11,
      "user_id" : 9089026,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/bbc1ae9bf7e2909ee1f83e089b05ef12?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "ves",
      "link" : "https://stackoverflow.com/users/9089026/ves"
    },
    "creation_date" : 1765207229,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140892798,
    "post_id" : 79840796,
    "body" : "<b>@Torben</b>, “…  the problem is pretty much always in our own code...” I fully agree with that. But without being too defensive, sometimes it happens (to me for sure) to don’t see the forest for the trees.",
    "score" : 0,
    "owner" : {
      "account_id" : 10781545,
      "reputation" : 11,
      "user_id" : 9089026,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/bbc1ae9bf7e2909ee1f83e089b05ef12?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "ves",
      "link" : "https://stackoverflow.com/users/9089026/ves"
    },
    "creation_date" : 1765207154,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140892440,
    "post_id" : 79840796,
    "body" : "&quot;but I cannot understand how sleep(msec) can return before msec to elapse!!!&quot; -- perhaps there is more than one thread at that point. Since we do not know how you are creating and starting this thread, we cannot help with that. And, since your logging does not include the thread ID, we cannot rule out the possibility of more than one thread having been started.",
    "score" : 1,
    "owner" : {
      "account_id" : 39846,
      "reputation" : 1011235,
      "user_id" : 115145,
      "user_type" : "registered",
      "accept_rate" : 84,
      "profile_image" : "https://i.sstatic.net/wDnd8.png?s=256",
      "display_name" : "CommonsWare",
      "link" : "https://stackoverflow.com/users/115145/commonsware"
    },
    "creation_date" : 1765194334,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140892405,
    "post_id" : 79840796,
    "body" : "It is a good idea to accept the sad fact that the problem is pretty much always in our own code, not in the library we use. It helps us stay on the correct path and concentrate on relevant things (e.g. finding out what we are doing wrong). In this case the code works just as it is intended, you just think it should do something else. Please read this: <a href=\"https://developer.android.com/develop/background-work/background-tasks/persistent\" rel=\"nofollow noreferrer\">developer.android.com/develop/background-work/background-tas&zwnj;&#8203;ks/&hellip;</a>",
    "score" : 2,
    "owner" : {
      "account_id" : 1041463,
      "reputation" : 3917,
      "user_id" : 1047418,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/3deab5aa1be96fe145d3103251263523?s=256&d=identicon&r=PG",
      "display_name" : "Torben",
      "link" : "https://stackoverflow.com/users/1047418/torben"
    },
    "creation_date" : 1765192480,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140892389,
    "post_id" : 79840796,
    "body" : "Android hates neverending background tasks. Even if you&#39;ve granted unrestricted background battery it does not mean your process can last forever. You have to launch your apps activity daily (and iirc it has to be through user interaction so pop-up activity does not count) to keep your app in the active bucket. Also new android devices implement &quot;cached apps freezer&quot; which is probably the cause of oddities in your &quot;heartbeat&quot; timings.",
    "score" : 2,
    "owner" : {
      "account_id" : 12721843,
      "reputation" : 17453,
      "user_id" : 9241978,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/5TQ64.png?s=256",
      "display_name" : "Pawel",
      "link" : "https://stackoverflow.com/users/9241978/pawel"
    },
    "creation_date" : 1765191990,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}