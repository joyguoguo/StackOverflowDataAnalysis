{
  "question" : {
    "question_id" : 79704167,
    "title" : "Is there a way in *any* JVM language to implement two interfaces with some method(s) with the same signature but different return types",
    "body" : "<p>So, I need to have an object implement two interfaces that both require a method with the same signature as each other, but different return types. Something like these two:</p>\n<pre><code>interface FooPrinter {\n    void foo(String bar);\n}\n\ninterface FooGiver {\n    String foo(String bar);\n}\n</code></pre>\n<p>I don't control either of these interfaces, so I can't change the method names. This answer: <a href=\"https://stackoverflow.com/questions/32560313/implement-two-interfaces-with-the-same-method-signature-but-different-return-typ\">Implement two interfaces with the same method signature but different return type</a>\nsays that the JVM can run code that does this, but the Java language forbids it.</p>\n<p>Is there any JVM language that allows you to do this, and how? It needs to be callable when cast to one of the two interfaces, from any JVM language, and not just the one used to compile it. It doesn't need to be callable from the concrete class. If this is possible in Groovy, I would prefer this, since it's the language my project is using. However, I should be able to incorporate a different language into my project if I need to.</p>\n",
    "tags" : [ "java", "groovy", "jvm", "programming-languages" ],
    "owner" : {
      "account_id" : 28382762,
      "reputation" : 308,
      "user_id" : 21709774,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/VXMZB.png?s=256",
      "display_name" : "Choosechee",
      "link" : "https://stackoverflow.com/users/21709774/choosechee"
    },
    "is_answered" : false,
    "view_count" : 213,
    "answer_count" : 2,
    "score" : 3,
    "last_activity_date" : 1752775534,
    "creation_date" : 1752713557,
    "link" : "https://stackoverflow.com/questions/79704167/is-there-a-way-in-any-jvm-language-to-implement-two-interfaces-with-some-metho",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79705241,
    "question_id" : 79704167,
    "body" : "<blockquote>\n<p>Is there a way in <em>any</em> JVM language to implement two interfaces with some method(s) with the same signature but different return types</p>\n</blockquote>\n<p>Yes. <a href=\"https://stackoverflow.com/a/32560791/2402272\">The accepted answer to the question you linked</a> provides such an example, written in the Jasmin assembly language.</p>\n<p>Or close, anyway.  I have no personal experience with Jasmin, but I suspect that the example presented there errs by declaring the putative interface implementation methods as <code>static</code>, in exactly the same sense that it would be erroneous to do analogously in Java.  But it looks like that would be easily fixed.</p>\n<p>However, I think you should consider whether you really want (or need) to do this at all.  You have not provided any details on your real-world use case, but I'm inclined to think that there are better alternatives, such as ones based on composition instead of on inheritance, or based on adapter classes, or similar.  For instance:</p>\n<pre><code>class FooOwner {\n    private String foo;\n\n    private class Giver implements FooGiver {\n        public String foo(String bar) {\n            return bar + foo;\n        }\n    }\n\n    private class Printer implements FooPrinter {\n        public void foo(String bar) {\n            System.out.println(foo + bar);\n        }\n    }\n\n    public FooOwner(String foo) {\n        this.foo = foo;\n    }\n\n    public FooGiver getGiver() {\n        return new Giver();\n    }\n\n    public FooPrinter getPrinter() {\n        return new Printer();\n    }\n}\n\npublic class Example {\n    public static void main(String args[]) {\n        FooOwner owner = new FooOwner(&quot;foo!&quot;);\n        FooPrinter printer = owner.getPrinter();\n        FooGiver giver = owner.getGiver();\n        \n        for (String arg : args) {\n            System.out.print(&quot;printed: &quot;);\n            printer.foo(arg);\n\n            System.out.print(&quot;given:   &quot;);\n            System.out.println(giver.foo(arg));\n        }\n    }\n}\n</code></pre>\n<p>That would be one of the &quot;or similar&quot; cases.  Observe that an instance of class <code>FooOwner</code> can provide both for giving foo and for printing foo based on its own internal state, though it does not itself implement either interface.  Adapter classes could work similarly.  Straight up composition would replace <code>return new Printer()</code> with <code>return this.printer</code>, along with the requisite support for that, and similar for <code>getGiver()</code>.  If <code>FooGiver</code> and <code>FooPrinter</code> were functional interfaces then there would be lambda-based alternatives, too.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1752775233,
    "last_activity_date" : 1752775534,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79705245,
    "question_id" : 79704167,
    "body" : "<p>It is difficult to know what is the real need behind this question, but if we are looking for an implementation (a bit ugly for my taste), we can use an auxiliary class that modifies the signature of one of the methods, in our utility class we create an object <em>Aux</em>, and through it we invoke the interface method, something like the following:</p>\n<pre><code>interface FooPrinter {\n   void foo( String bar );\n}\n\ninterface FooGiver {\n   String foo( String bar );\n}\n\nclass Aux implements FooPrinter {\n   @Override\n   public void foo( String bar ) {\n      System.out.println( &quot;popo&quot; );\n   }\n}\n\nclass MyClass implements FooGiver {\n   Aux aux = new Aux();\n   String bar;\n\n   public String foo( String bar ) {\n      return &quot;foo&quot;;\n   }\n\n     // we obtain the utility of the interface method, through the object “Aux”.\n   public void maskedFoo( String bar ) {\n      aux.foo( bar );\n   }\n}\n\nvoid xx() {\n   MyClass myc = new MyClass();\n   myc.foo( &quot;r&quot; );\n   myc.maskedFoo( &quot;3&quot; );\n}\n</code></pre>\n<p>The usefulness of this approach is closely linked to the possibility of modifying the name of the methods involved in <em>MyClass</em> (although the signatures could also be modified), if this is not feasible because the rest of the code depends on them, I do not think there is any viable solution.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 10843443,
      "reputation" : 924,
      "user_id" : 20882864,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/CCQCy.jpg?s=256",
      "display_name" : "Marce Puente",
      "link" : "https://stackoverflow.com/users/20882864/marce-puente"
    },
    "creation_date" : 1752775508,
    "last_activity_date" : 1752775508,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140767181,
    "post_id" : 79704167,
    "body" : "I guess I might as well say now that the use case was that I needed to implement two interfaces where one had an <code>add</code> method that returned a <code>boolean</code>, and the other had one that returned <code>void</code>. Don&#39;t know why I didn&#39;t say it earlier.",
    "score" : 0,
    "owner" : {
      "account_id" : 28382762,
      "reputation" : 308,
      "user_id" : 21709774,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/VXMZB.png?s=256",
      "display_name" : "Choosechee",
      "link" : "https://stackoverflow.com/users/21709774/choosechee"
    },
    "creation_date" : 1759168494,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140766311,
    "post_id" : 79704167,
    "body" : "“<i>I also wanted to say that the <code>Proxy</code> solution doesn&#39;t even work in the case it was written for (same return type).</i>” Well, that’s an entirely different case, as when having the same return type, there is only one method in the proxy. But when having different return types, in a combination not rejected by the generator like <code>Object</code> and <code>String</code>, you’ll see that it actually works. However, the generator rejects your actual case of having <code>void</code> and <code>Object</code>, hence, you’d need your own proxy generator.",
    "score" : 1,
    "owner" : {
      "account_id" : 3211603,
      "reputation" : 301001,
      "user_id" : 2711488,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
      "display_name" : "Holger",
      "link" : "https://stackoverflow.com/users/2711488/holger"
    },
    "creation_date" : 1759144431,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140601246,
    "post_id" : 79704167,
    "body" : "I guess I&#39;ll just give this up and use an adapter. Thanks for the suggestions, though.",
    "score" : 0,
    "owner" : {
      "account_id" : 28382762,
      "reputation" : 308,
      "user_id" : 21709774,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/VXMZB.png?s=256",
      "display_name" : "Choosechee",
      "link" : "https://stackoverflow.com/users/21709774/choosechee"
    },
    "creation_date" : 1752875433,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140598291,
    "post_id" : 79704167,
    "body" : "you can also write or manipulate bytecode directly - there are some bytecode assemblers to help with that on the internet (example: <a href=\"https://i.sstatic.net/EDtmBkdZ.png\" rel=\"nofollow noreferrer\">dissabled code</a> using <code>javap -p -c A</code> after <i>adapting</i> <code>A.class</code> with an hex-editor; and the execution <a href=\"https://i.sstatic.net/DdhbNpF4.png\" rel=\"nofollow noreferrer\">output</a>)",
    "score" : 0,
    "owner" : {
      "account_id" : 31180,
      "reputation" : 29752,
      "user_id" : 85421,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/kKvXH.gif?s=256",
      "display_name" : "user85421",
      "link" : "https://stackoverflow.com/users/85421/user85421"
    },
    "creation_date" : 1752785138,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140597875,
    "post_id" : 79704167,
    "body" : "@Choosechee, could you show pseudo-code how you want to use it?",
    "score" : 1,
    "owner" : {
      "account_id" : 1333316,
      "reputation" : 29017,
      "user_id" : 1276664,
      "user_type" : "registered",
      "accept_rate" : 17,
      "profile_image" : "https://www.gravatar.com/avatar/873470471a482071b8e085095cf89221?s=256&d=identicon&r=PG",
      "display_name" : "daggett",
      "link" : "https://stackoverflow.com/users/1276664/daggett"
    },
    "creation_date" : 1752775158,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140597583,
    "post_id" : 79704167,
    "body" : "But perhaps this is an X-Y question.  Are you sure that you are not asking for an inheritance-based solution where one based on composition would be better?  There are all sorts of ways that you could combine <i>separate</i> <code>FooPrinter</code> and <code>FooGiver</code> objects in a shared host unit.",
    "score" : 3,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1752768198,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140597368,
    "post_id" : 79704167,
    "body" : "I&#39;m not sure how we could answer &quot;no&quot; to &quot;<i>Is there any JVM language that allows you to do this</i>&quot;.  That would require knowing <b>all</b> the JVM languages, and their semantics. Quite possibly one of the bytecode assemblers would do it, but I&#39;m not sure. Resolving methods that differ only by return type is not a common language feature, such that I would expect to find a high-level JVM language that does it, but who knows?",
    "score" : 0,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1752764440,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140595952,
    "post_id" : 79704167,
    "body" : "Are you forced to have a type implement those interfaces? Could you create some kind of adapter type that has <code>void printFoo(String)</code> and <code>String giveFoo(String)</code> methods that delegate to the real <code>FooPrinter</code> and <code>FooGiver</code> instances, respectively?",
    "score" : 6,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49904,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1752734714,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140595749,
    "post_id" : 79704167,
    "body" : "Forgot to ping @Sweeper (too late to edit), and I also wanted to say that the <code>Proxy</code> solution doesn&#39;t even work in the case it was written for (same return type). It even says in the Javadoc that <code>Proxy</code> has no way of telling what interface it&#39;s being used as.",
    "score" : 0,
    "owner" : {
      "account_id" : 28382762,
      "reputation" : 308,
      "user_id" : 21709774,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/VXMZB.png?s=256",
      "display_name" : "Choosechee",
      "link" : "https://stackoverflow.com/users/21709774/choosechee"
    },
    "creation_date" : 1752725636,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140595730,
    "post_id" : 79704167,
    "body" : "Just tried it, gave me an exception: Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: methods with same signature foo(java.lang.String) but incompatible return types: void and others",
    "score" : 0,
    "owner" : {
      "account_id" : 28382762,
      "reputation" : 308,
      "user_id" : 21709774,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/VXMZB.png?s=256",
      "display_name" : "Choosechee",
      "link" : "https://stackoverflow.com/users/21709774/choosechee"
    },
    "creation_date" : 1752724834,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140595567,
    "post_id" : 79704167,
    "body" : "Not really a JVM language, but have you considered using <code>Proxy</code> to forward the calls to differently-named methods <a href=\"https://stackoverflow.com/a/13731009/5133585\">like this</a>?",
    "score" : 1,
    "owner" : {
      "account_id" : 6651855,
      "reputation" : 292280,
      "user_id" : 5133585,
      "user_type" : "registered",
      "accept_rate" : 96,
      "profile_image" : "https://i.sstatic.net/dfqcw.png?s=256",
      "display_name" : "Sweeper",
      "link" : "https://stackoverflow.com/users/5133585/sweeper"
    },
    "creation_date" : 1752716821,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140595541,
    "post_id" : 79704167,
    "body" : "Okay, I&#39;ve loosened the requirement.",
    "score" : 0,
    "owner" : {
      "account_id" : 28382762,
      "reputation" : 308,
      "user_id" : 21709774,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/VXMZB.png?s=256",
      "display_name" : "Choosechee",
      "link" : "https://stackoverflow.com/users/21709774/choosechee"
    },
    "creation_date" : 1752715187,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140595534,
    "post_id" : 79704167,
    "body" : "The requirement of &quot;be callable from any JVM language&quot; makes this impossible. Suppose <code>Foo</code> implements both <code>FooPrinter</code> and <code>FooGiver</code>, and in Java you write <code>new Foo().foo()</code> - which <code>foo</code> would that call? If you weaken the requirement to say that both <code>foo</code>s must be callable on their corresponding interfaces , and not necessarily directly on a concrete class, that is still possible in theory.",
    "score" : 5,
    "owner" : {
      "account_id" : 6651855,
      "reputation" : 292280,
      "user_id" : 5133585,
      "user_type" : "registered",
      "accept_rate" : 96,
      "profile_image" : "https://i.sstatic.net/dfqcw.png?s=256",
      "display_name" : "Sweeper",
      "link" : "https://stackoverflow.com/users/5133585/sweeper"
    },
    "creation_date" : 1752714487,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}