{
  "question" : {
    "question_id" : 79561196,
    "title" : "Allow Commit/Rollback in PRAGMA AUTONOMOUS_TRANSACTION",
    "body" : "<p>At the application level, we enforce &quot;ALTER SESSION DISABLE COMMIT IN PROCEDURE&quot; to restrict commits/rollbacks inside procedures, but this also blocks Pragma Autonomous Transactions as well.</p>\n<p>Need a way (from the application side, no PL/SQL changes) to allow commits/rollbacks inside Pragma Autonomous Transactions while keeping other commits disabled.</p>\n<p>Question:\nHow can we achieve this restriction at the application level without affecting autonomous transactions?</p>\n",
    "tags" : [ "java", "sql", "plsql", "oracle19c" ],
    "owner" : {
      "account_id" : 35012453,
      "reputation" : 31,
      "user_id" : 26919252,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/4499ae39ab6065efce97aa0d6f76881b?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Movindu Thulmith",
      "link" : "https://stackoverflow.com/users/26919252/movindu-thulmith"
    },
    "is_answered" : true,
    "view_count" : 111,
    "answer_count" : 1,
    "score" : 3,
    "last_activity_date" : 1744093168,
    "creation_date" : 1744087592,
    "link" : "https://stackoverflow.com/questions/79561196/allow-commit-rollback-in-pragma-autonomous-transaction",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79561324,
    "question_id" : 79561196,
    "body" : "<p>I don't think you can do that.</p>\n<p>What problem are you trying to solve, actually?</p>\n<ul>\n<li><p>procedures shouldn't COMMIT at all; that should be left to the caller to decide anyway</p>\n<ul>\n<li><p>which means that you <em>could</em> disable commit/rollback to isolate/find procedures that ARE committing (they will fail) and fix them (i.e. remove COMMIT)</p>\n</li>\n<li><p>on the other hand, perhaps you'd rather <em>search</em> for commits in code, e.g.</p>\n<pre><code>select * from user_source where lower(text) like '%commit%';\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>where &amp; why do you use autonomous transaction? It should be used for logging purposes only, for situations where certain code fails, you call a logging procedure which <em>is</em> an autonomous transaction so that it could insert logging information - procedure that raised the error, position within that procedure, statement you ran, error you got - and commit that insert into the log table. Don't forget to RAISE afterwards, if necessary</p>\n<ul>\n<li>why would you NOT want to RAISE? In a case you're running some code in a loop and want to log errors you get, but also move on with the next loop iteration and later check what went wrong</li>\n</ul>\n</li>\n<li><p>if you're <strong>misusing</strong> autonomous transaction - maybe the most common situation is &quot;solving&quot; mutating table error - then give up on it, it is the wrong way to do it. There are techniques to overcome such an error (a compound trigger, or a package (in older Oracle database versions))</p>\n</li>\n<li><p>depending on what you're doing, perhaps you could call a procedure (which is committing) via DBMS_SCHEDULER. Although that is possible, I'm not sure it is the right way to do it; probably depends on what you do</p>\n</li>\n</ul>\n<p>Anyway: if you alter session and disable commits, that's how it is - commits are disabled. &quot;No PL/SQL changes&quot;? There's no such thing as a free lunch.</p>\n",
    "score" : 4,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 12498833,
      "reputation" : 144021,
      "user_id" : 9097906,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/RmIqt.jpg?s=256",
      "display_name" : "Littlefoot",
      "link" : "https://stackoverflow.com/users/9097906/littlefoot"
    },
    "creation_date" : 1744093168,
    "last_activity_date" : 1744093168,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140317624,
    "post_id" : 79561196,
    "body" : "believe me cleaning wrongly used commits in your code base and trying to compile all of them(with cost of invalidating dependencies), has lesser cost than your anti commit enforcement policy, commit and rollback in pl/sql sources are evil!",
    "score" : 0,
    "owner" : {
      "account_id" : 1633589,
      "reputation" : 1850,
      "user_id" : 1507669,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/pMaaM.jpg?s=256",
      "display_name" : "hmmftg",
      "link" : "https://stackoverflow.com/users/1507669/hmmftg"
    },
    "creation_date" : 1744225336,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140310241,
    "post_id" : 79561196,
    "body" : "Please edit the question to limit it to a specific problem with enough detail to identify an adequate answer.",
    "score" : 0,
    "owner" : {
      "account_id" : -1,
      "reputation" : 1,
      "user_id" : -1,
      "user_type" : "moderator",
      "profile_image" : "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=256&d=identicon&r=PG",
      "display_name" : "Community",
      "link" : "https://stackoverflow.com/users/-1/community"
    },
    "creation_date" : 1744088267,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79561324" : [ {
      "comment_id" : 140314485,
      "post_id" : 79561324,
      "body" : "Thank you for explanation. I don&#39;t know Java so I can&#39;t suggest anything about it. However, MAYBE you could - generally - disable COMMIT, but modify logging procedure which would enable it just before COMMIT using dynamic SQL, i.e. <code>EXECUTE IMMEDIATE(&#39;ALTER SESSION ENABLE COMMIT IN PROCEDURE&#39;)</code>, then COMMIT, and disable it (dynamic SQL) after commit. Is it safe enough? Can&#39;t tell ...",
      "score" : 1,
      "owner" : {
        "account_id" : 12498833,
        "reputation" : 144021,
        "user_id" : 9097906,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/RmIqt.jpg?s=256",
        "display_name" : "Littlefoot",
        "link" : "https://stackoverflow.com/users/9097906/littlefoot"
      },
      "creation_date" : 1744175554,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140314311,
      "post_id" : 79561324,
      "body" : "Would it be feasible to implement a parser in our Java code that reads procedure definitions before execution and selectively applies the commit restriction based on the presence of PRAGMA AUTONOMOUS_TRANSACTION? Or is there another approach you might suggest given our dynamic procedure execution environment?",
      "score" : 0,
      "owner" : {
        "account_id" : 35012453,
        "reputation" : 31,
        "user_id" : 26919252,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/4499ae39ab6065efce97aa0d6f76881b?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Movindu Thulmith",
        "link" : "https://stackoverflow.com/users/26919252/movindu-thulmith"
      },
      "creation_date" : 1744168279,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140314310,
      "post_id" : 79561324,
      "body" : "<b>DBMS_SCHEDULER approach</b>: This is an interesting suggestion, but would introduce additional complexity in our architecture. Since our workflows can execute hundreds of steps in sequence, scheduling separate jobs for each logging operation would create significant overhead.  <b>About &quot;No PL/SQL changes</b>&quot;: You&#39;re right that there&#39;s no free lunch. We were hoping for a solution at the Java/JDBC level because modifying thousands of PL/SQL procedures across our extensive codebase would be extremely time-consuming and risky.",
      "score" : 0,
      "owner" : {
        "account_id" : 35012453,
        "reputation" : 31,
        "user_id" : 26919252,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/4499ae39ab6065efce97aa0d6f76881b?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Movindu Thulmith",
        "link" : "https://stackoverflow.com/users/26919252/movindu-thulmith"
      },
      "creation_date" : 1744168269,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140314309,
      "post_id" : 79561324,
      "body" : "<b>Our use of autonomous transactions</b>: We use autonomous transactions precisely for the purpose you mentioned - logging operations that must persist regardless of whether the main transaction succeeds or fails. These are legitimate audit logging needs, not attempts to work around mutating table issues.  <b>Regarding RAISE</b>: We do follow the practice of raising exceptions after logging in most cases. There are specific scenarios where we catch, log, and continue, but those are carefully considered exceptions to the rule.",
      "score" : 0,
      "owner" : {
        "account_id" : 35012453,
        "reputation" : 31,
        "user_id" : 26919252,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/4499ae39ab6065efce97aa0d6f76881b?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Movindu Thulmith",
        "link" : "https://stackoverflow.com/users/26919252/movindu-thulmith"
      },
      "creation_date" : 1744168261,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140314308,
      "post_id" : 79561324,
      "body" : "<b>Using the search approach</b>: The query select * from user_source where lower(text) like &#39;%commit%&#39;; is helpful for code review, but we need a runtime solution because:  1. We&#39;re dealing with a massive enterprise-level codebase with thousands of procedures 2. We need to prevent commits at execution time, not just identify them 3. Our architecture dynamically calls procedures based on workflow configurations, so we don&#39;t always know at development time which procedures will execute",
      "score" : 0,
      "owner" : {
        "account_id" : 35012453,
        "reputation" : 31,
        "user_id" : 26919252,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/4499ae39ab6065efce97aa0d6f76881b?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Movindu Thulmith",
        "link" : "https://stackoverflow.com/users/26919252/movindu-thulmith"
      },
      "creation_date" : 1744168248,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140314307,
      "post_id" : 79561324,
      "body" : "<b>About procedures not committing</b>: I fully agree that procedures generally shouldn&#39;t commit - that responsibility belongs to the caller. Our restriction is specifically to enforce this design principle and prevent accidental commits that would break transaction atomicity.",
      "score" : 0,
      "owner" : {
        "account_id" : 35012453,
        "reputation" : 31,
        "user_id" : 26919252,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/4499ae39ab6065efce97aa0d6f76881b?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Movindu Thulmith",
        "link" : "https://stackoverflow.com/users/26919252/movindu-thulmith"
      },
      "creation_date" : 1744168239,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140314306,
      "post_id" : 79561324,
      "body" : "<b>The problem we&#39;re trying to solve</b>: We&#39;re using a workflow engine that requires strict transaction atomicity. We disable commits in procedures to ensure all operations within a workflow step either commit entirely or roll back entirely. However, we have legitimate audit logging needs that require autonomous transactions.",
      "score" : 0,
      "owner" : {
        "account_id" : 35012453,
        "reputation" : 31,
        "user_id" : 26919252,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/4499ae39ab6065efce97aa0d6f76881b?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Movindu Thulmith",
        "link" : "https://stackoverflow.com/users/26919252/movindu-thulmith"
      },
      "creation_date" : 1744168224,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}