{
  "question" : {
    "question_id" : 79754345,
    "title" : "Any way I can return 128 bit value out of the method without creating objects on heap in Java?",
    "body" : "<p>I've been working with quite a few languages in the past C++, C#, Rust. And everywhere I could return 128-bit value from a method. But Java seems to be hardcore.</p>\n<p>I'm trying to implement a decimal that is stored in 128 bits. I do not want to create a heap object for the decimal but pass around the value on the stack as 2 longs, hi and lo 64-bit values. However, it seems to be absolutely impossible to return 2 longs from a method without allocating on the heap.</p>\n<p>Is there anything possible here? I'm open to any hack, bytecode generation, unsafe instructions (but without allocating on unsafe heap).</p>\n",
    "tags" : [ "java" ],
    "owner" : {
      "account_id" : 20385534,
      "reputation" : 585,
      "user_id" : 14954633,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/8719807e8a5c2b945628417ca6255db4?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "djbobo",
      "link" : "https://stackoverflow.com/users/14954633/djbobo"
    },
    "is_answered" : true,
    "view_count" : 239,
    "answer_count" : 3,
    "score" : 3,
    "last_activity_date" : 1756908050,
    "creation_date" : 1756889043,
    "link" : "https://stackoverflow.com/questions/79754345/any-way-i-can-return-128-bit-value-out-of-the-method-without-creating-objects-on",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79754385,
    "question_id" : 79754345,
    "body" : "<p>No, you can't.</p>\n<p>You just return <code>record R(long hi, long lo){}</code> and hope JIT does its magic.</p>\n",
    "score" : 6,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 4497436,
      "reputation" : 20796,
      "user_id" : 3656904,
      "user_type" : "registered",
      "accept_rate" : 67,
      "profile_image" : "https://www.gravatar.com/avatar/8bdbd1f89f8907e8e8b15ab88c084c65?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "talex",
      "link" : "https://stackoverflow.com/users/3656904/talex"
    },
    "creation_date" : 1756891036,
    "last_activity_date" : 1756894230,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79754600,
    "question_id" : 79754345,
    "body" : "<p>Pre-allocate a bunch of objects to store 128-bit integers and put them in a stack.</p>\n<p>When you need one, take it from the stack, and when you're done with it, put it back.</p>\n<p>Think of this pre-allocated space like call stack space.  Assuming the the <em>call stacks</em> that the JVM allocates for each thread are about 1MB, then you already have a hard limit.  A  thread couldn't possibly use more than 64K 128-bit ints simultaneously allocated on the call stack, anyway.  If you pre-allocate something close to this amount, then the limited number of them available doesn't actually impose any new limit on what you can do.</p>\n",
    "score" : 3,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 7178634,
      "reputation" : 60923,
      "user_id" : 5483526,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/780a651189f64a2cbf4b7f62cf852005?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Matt Timmermans",
      "link" : "https://stackoverflow.com/users/5483526/matt-timmermans"
    },
    "creation_date" : 1756902945,
    "last_activity_date" : 1756903431,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79754691,
    "question_id" : 79754345,
    "body" : "<p>JDK27 (so.. about a year from now) might give you the  hope you are looking for. You're looking for <a href=\"https://openjdk.org/projects/valhalla/\" rel=\"nofollow noreferrer\">Project Valhalla</a> which essentially adds (and I'm oversimplifying here) the notion of structs that <strong>are</strong> just a sequence of bits (not a reference). Hence such a 'value object' cannot be <code>null</code>. This:</p>\n<pre><code>value class Point {\n  int x, y;\n}\n\nvoid foo(Point p) { .. }\n</code></pre>\n<p>operates at the runtime level identically to <code>void foo(int x, int y)</code>. Just like <code>x</code> and <code>y</code> cannot be <code>null</code>, <code>p</code> cannot be either. And, crucially, you can return these things.</p>\n<p>But, it's not part of the JDK yet. It's not even in preview yet. Being rather optimistic, I'd say JDK27 is the first possible chance this shows up in preview, but, I think it'll take longer than that.</p>\n<p>Until then you have no direct solution. At best you can return an object (i.e. involve the heap) and pray hotspot eliminates the cost (which is probably will!), or use some sort of cache scheme where you reuse the same object a lot.</p>\n<p>If performance is important to you, use <a href=\"https://www.baeldung.com/java-microbenchmark-harness\" rel=\"nofollow noreferrer\">JMH</a> to test your algorithm's performance.</p>\n",
    "score" : 3,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 401843,
      "reputation" : 107206,
      "user_id" : 768644,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/b13bedc5215730fbce5edff6c130988a?s=256&d=identicon&r=PG",
      "display_name" : "rzwitserloot",
      "link" : "https://stackoverflow.com/users/768644/rzwitserloot"
    },
    "creation_date" : 1756908050,
    "last_activity_date" : 1756908050,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140712240,
    "post_id" : 79754345,
    "body" : "@VGR I like it. Mutable Parameters by the backdoor.",
    "score" : 0,
    "owner" : {
      "account_id" : 5277236,
      "reputation" : 8627,
      "user_id" : 4213662,
      "user_type" : "registered",
      "accept_rate" : 80,
      "profile_image" : "https://graph.facebook.com/693430827/picture?type=large",
      "display_name" : "Persixty",
      "link" : "https://stackoverflow.com/users/4213662/persixty"
    },
    "creation_date" : 1756911939,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140712233,
    "post_id" : 79754345,
    "body" : "@RobSpoor, True. What would be needed is a <i>mutable</i> thread-local object holding primitive types. I&#39;m generally sceptical of any real performance gain. GC on modern JVMs are generally good at sparks Objects. Small Objects with a short lifespan that fly around and disappear.",
    "score" : 2,
    "owner" : {
      "account_id" : 5277236,
      "reputation" : 8627,
      "user_id" : 4213662,
      "user_type" : "registered",
      "accept_rate" : 80,
      "profile_image" : "https://graph.facebook.com/693430827/picture?type=large",
      "display_name" : "Persixty",
      "link" : "https://stackoverflow.com/users/4213662/persixty"
    },
    "creation_date" : 1756911870,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140712230,
    "post_id" : 79754345,
    "body" : "One option is the strategy methods in early versions of Java SE used:  write a method whose return type is void and which accepts an array of longs as an argument.  The method will fill in the first two elements of the array with the value it wants to &quot;return.&quot;  (Null arrays and arrays with a length less than 2 result in an exception being thrown.)",
    "score" : 2,
    "owner" : {
      "account_id" : 2053598,
      "reputation" : 44991,
      "user_id" : 1831987,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/38b1c37530189ec4471a43a618e33f67?s=256&d=identicon&r=PG",
      "display_name" : "VGR",
      "link" : "https://stackoverflow.com/users/1831987/vgr"
    },
    "creation_date" : 1756911839,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140711895,
    "post_id" : 79754345,
    "body" : "@Persixty two <code>ThreadLocal&lt;Long&gt;</code> instances will cause unnecessary boxing, thereby having two heap objects (unless the values are between -128 and 127 inclusive). A single <code>ThreadLocal&lt;Int128&gt;</code> would have a single heap object that contains two <code>long</code> fields. And if it&#39;s modifiable there&#39;s only one instance per thread (but keep the mutability as private as possible).",
    "score" : 3,
    "owner" : {
      "account_id" : 1211967,
      "reputation" : 9964,
      "user_id" : 1180351,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
      "display_name" : "Rob Spoor",
      "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
    },
    "creation_date" : 1756905317,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140711603,
    "post_id" : 79754345,
    "body" : "Can you pass a dummy class containing two longs which the method sets? 99.99% sure this is all premature optimisation",
    "score" : 0,
    "owner" : {
      "account_id" : 17972905,
      "reputation" : 10131,
      "user_id" : 13061224,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/GyOMS.jpg?s=256",
      "display_name" : "siggemannen",
      "link" : "https://stackoverflow.com/users/13061224/siggemannen"
    },
    "creation_date" : 1756898634,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140711302,
    "post_id" : 79754345,
    "body" : "I hesitate from providing this answer because it will be downvoted. You could consider one/two static <code>ThreadLocal&lt;Long&gt;</code> variables in the class containing the method and returning the part/all of the return value through there so long as the method doesn&#39;t need to stack them for recursion. It&#39;s a bit stinky and close to global variables. But if you manage instances with extreme care could be OK. It would only make sense if you really (really) have a performance bottleneck.",
    "score" : 0,
    "owner" : {
      "account_id" : 5277236,
      "reputation" : 8627,
      "user_id" : 4213662,
      "user_type" : "registered",
      "accept_rate" : 80,
      "profile_image" : "https://graph.facebook.com/693430827/picture?type=large",
      "display_name" : "Persixty",
      "link" : "https://stackoverflow.com/users/4213662/persixty"
    },
    "creation_date" : 1756891599,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140711230,
    "post_id" : 79754345,
    "body" : "As far as I know it&#39;s impossible until project Valhalla is finalized. Even with a MemorySegment you still need to allocate memory. A ThreadLocal could help with minimizing allocation but you&#39;d still need an instance per thread.",
    "score" : 2,
    "owner" : {
      "account_id" : 1211967,
      "reputation" : 9964,
      "user_id" : 1180351,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
      "display_name" : "Rob Spoor",
      "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
    },
    "creation_date" : 1756889692,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79754385" : [ {
      "comment_id" : 140714324,
      "post_id" : 79754385,
      "body" : "@djbobo you return <code>new R(hi, lo)</code>, then assign it in the caller (let&#39;s call the variable <code>r</code>) and immediately call <code>long hi = r.hi(); long lo = r.lo();</code>. If <code>r</code> is then no longer used, the JIT can get rid of the entire record instead and instead act like the method is returning 2 values. It&#39;s not the entire method that&#39;s inlined, only the record instance.",
      "score" : 2,
      "owner" : {
        "account_id" : 1211967,
        "reputation" : 9964,
        "user_id" : 1180351,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
        "display_name" : "Rob Spoor",
        "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
      },
      "creation_date" : 1756985426,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140712160,
      "post_id" : 79754385,
      "body" : "I don&#39;t see how, for example, I want the method     <code>mult(long lo1, long hi1, long lo2, long hi2)</code>    to return lo, hi. The mult method is chunky; JIT does not inline it, allocating on the heap.",
      "score" : 0,
      "owner" : {
        "account_id" : 20385534,
        "reputation" : 585,
        "user_id" : 14954633,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/8719807e8a5c2b945628417ca6255db4?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "djbobo",
        "link" : "https://stackoverflow.com/users/14954633/djbobo"
      },
      "creation_date" : 1756910570,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140712147,
      "post_id" : 79754385,
      "body" : "@StephenC yep, I can see that for small methods",
      "score" : 0,
      "owner" : {
        "account_id" : 20385534,
        "reputation" : 585,
        "user_id" : 14954633,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/8719807e8a5c2b945628417ca6255db4?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "djbobo",
        "link" : "https://stackoverflow.com/users/14954633/djbobo"
      },
      "creation_date" : 1756910315,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140711902,
      "post_id" : 79754385,
      "body" : "@djbobo But if you only use the result to extract the two values immediately after you get it, the JIT may see that the scope of the object itself is small enough to get rid of it.",
      "score" : 3,
      "owner" : {
        "account_id" : 1211967,
        "reputation" : 9964,
        "user_id" : 1180351,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/pKB8y.png?s=256",
        "display_name" : "Rob Spoor",
        "link" : "https://stackoverflow.com/users/1180351/rob-spoor"
      },
      "creation_date" : 1756905420,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140711449,
      "post_id" : 79754385,
      "body" : "Is there any evidence that the JIT compilers in the latest JDKs &gt;do&lt; implement such optimization; i.e. avoiding the allocation of a <code>record</code>?",
      "score" : 2,
      "owner" : {
        "account_id" : 47283,
        "reputation" : 723470,
        "user_id" : 139985,
        "user_type" : "registered",
        "accept_rate" : 69,
        "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
        "display_name" : "Stephen C",
        "link" : "https://stackoverflow.com/users/139985/stephen-c"
      },
      "creation_date" : 1756895110,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140711446,
      "post_id" : 79754385,
      "body" : "It worked for very small methods, probably because JIT inlined them. My methods are not that small, e.g. decimal rescale, division and multiplication are quite chunky, so JIT does not inline them, and returning records allocates on heap.",
      "score" : 0,
      "owner" : {
        "account_id" : 20385534,
        "reputation" : 585,
        "user_id" : 14954633,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/8719807e8a5c2b945628417ca6255db4?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "djbobo",
        "link" : "https://stackoverflow.com/users/14954633/djbobo"
      },
      "creation_date" : 1756895001,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79754691" : [ {
      "comment_id" : 140717355,
      "post_id" : 79754691,
      "body" : "It is unclear if this will help when the <code>value</code> object is returned.  The JVM bytecode instruction set (currently) supports returning of one value only.",
      "score" : 0,
      "owner" : {
        "account_id" : 47283,
        "reputation" : 723470,
        "user_id" : 139985,
        "user_type" : "registered",
        "accept_rate" : 69,
        "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
        "display_name" : "Stephen C",
        "link" : "https://stackoverflow.com/users/139985/stephen-c"
      },
      "creation_date" : 1757081738,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79754600" : [ {
      "comment_id" : 140712183,
      "post_id" : 79754600,
      "body" : "That&#39;s valuable work around, just cannot believe Java cannot do better than that in 2025!",
      "score" : 0,
      "owner" : {
        "account_id" : 20385534,
        "reputation" : 585,
        "user_id" : 14954633,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/8719807e8a5c2b945628417ca6255db4?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "djbobo",
        "link" : "https://stackoverflow.com/users/14954633/djbobo"
      },
      "creation_date" : 1756910873,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}