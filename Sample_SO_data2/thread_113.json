{
  "question" : {
    "question_id" : 79838766,
    "title" : "PKIX path building failed: unable to find valid certification path — How to load PEM certificate into truststore at runtime in Spring Boot?",
    "body" : "<p>I am getting the below SSL error when my Java (Java 21, Spring Boot 3/4) application makes a REST call to a gateway:</p>\n<pre><code>Internal server error: (certificate_unknown) PKIX path building failed: \nsun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target\n</code></pre>\n<p>I already have the server certificate in a <code>.pem</code> file (X.509 certificate).<br />\nExample format:</p>\n<pre class=\"lang-none prettyprint-override\"><code>-----BEGIN CERTIFICATE-----\nMIIGmjCCBYKgAwIBAgIT...\n-----END CERTIFICATE-----\n</code></pre>\n<p>My Java application needs to trust this certificate when calling the Gateway.<br />\nThe Gateway requires certificate pinning — if the cert is not trusted, the request fails immediately.</p>\n<p>When my Java/Spring application starts:</p>\n<ol>\n<li><p><strong>Load this PEM certificate</strong> from <code>resources/certs/certificate.pem</code></p>\n</li>\n<li><p><strong>Add it to an in-memory truststore (JKS or PKCS12)</strong> at runtime</p>\n</li>\n<li><p><strong>Use that truststore for all outbound REST calls</strong> (WebClient / RestTemplate)</p>\n</li>\n<li><p>I do <em>not</em> want to modify the JVM default <code>cacerts</code>.</p>\n</li>\n<li><p>I want the application itself to load &amp; trust only the pinned certificate.</p>\n</li>\n</ol>\n<h3>What I have tried</h3>\n<p>I tried manually loading the cert:</p>\n<pre class=\"lang-java prettyprint-override\"><code>CertificateFactory cf = CertificateFactory.getInstance(&quot;X.509&quot;);\nX509Certificate cert = (X509Certificate) cf.generateCertificate(new FileInputStream(&quot;uidai_public.pem&quot;));\n</code></pre>\n<p>This loads successfully, but configuring it into SSLContext is failing.</p>\n<p>My WebClient configuration attempts:</p>\n<pre class=\"lang-java prettyprint-override\"><code>TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\ntmf.init(myKeystore);\nSSLContext sslContext = SSLContext.getInstance(&quot;TLS&quot;);\nsslContext.init(null, tmf.getTrustManagers(), null);\n</code></pre>\n<p>But unless the certificate is in a real truststore file, Spring throws the same <code>PKIX path building failed</code>.</p>\n<h3>Question</h3>\n<p><strong>How do I correctly:</strong></p>\n<ul>\n<li><p>Load an X.509 PEM certificate inside <code>src/main/resources</code></p>\n</li>\n<li><p>Programmatically create an in-memory truststore</p>\n</li>\n<li><p>Register that truststore with <code>WebClient</code> (or <code>HttpClient</code>) so that only that certificate is trusted?</p>\n</li>\n<li><p>Ensure that calls to the Gateway no longer fail with PKIX errors?</p>\n</li>\n</ul>\n<h3>Constraints</h3>\n<ul>\n<li><p>Java 21</p>\n</li>\n<li><p>Spring Boot 3.4.x / 4.x</p>\n</li>\n<li><p>Certificate is a <code>.pem</code> file containing a full X.509 certificate (NOT a public key only)</p>\n</li>\n<li><p>Application runs inside a container, so I cannot manually modify <code>/etc/ssl/certs</code> or JVM <code>cacerts</code></p>\n</li>\n</ul>\n",
    "tags" : [ "java", "ssl", "ssl-certificate", "webclient", "x509" ],
    "owner" : {
      "account_id" : 17055723,
      "reputation" : 9,
      "user_id" : 12340316,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a-/AAuE7mBH-gYLjUbWYhJhZACOMh1Z2a76ie3ni_oEmERvGuk=k-s256",
      "display_name" : "Arpit Sharma",
      "link" : "https://stackoverflow.com/users/12340316/arpit-sharma"
    },
    "is_answered" : false,
    "view_count" : 71,
    "answer_count" : 2,
    "score" : 0,
    "last_activity_date" : 1765029362,
    "creation_date" : 1764930290,
    "link" : "https://stackoverflow.com/questions/79838766/pkix-path-building-failed-unable-to-find-valid-certification-path-how-to-load",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79838775,
    "question_id" : 79838766,
    "body" : "<blockquote>\n<p>Application runs inside a container, so I cannot manually modify /etc/ssl/certs or JVM cacerts</p>\n</blockquote>\n<p>Assuming this is a docker image, can you edit the dockerfile?</p>\n<pre><code>RUN keytool -cacerts -storepass changeit -noprompt -trustcacerts -importcert -alias my-cert -file /path/to/cert.pem\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1096470,
      "reputation" : 29424,
      "user_id" : 1089967,
      "user_type" : "registered",
      "accept_rate" : 59,
      "profile_image" : "https://www.gravatar.com/avatar/1f256b904ff621d678598d8fa49f86c5?s=256&d=identicon&r=PG",
      "display_name" : "lance-java",
      "link" : "https://stackoverflow.com/users/1089967/lance-java"
    },
    "creation_date" : 1764930920,
    "last_activity_date" : 1764930920,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79839131,
    "question_id" : 79838766,
    "body" : "<p>So you are in the right direction. It seems like you are missing the part where you put the certificate in the in memory truststore. Can you try with the following additional statement: <code>myKeystore.setCertificateEntry(&quot;my-trusted-cert&quot;, cert);</code></p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 9107988,
      "reputation" : 4087,
      "user_id" : 6777695,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/82120153a9fce415fd4983897d45d441?s=256&d=identicon&r=PG",
      "display_name" : "Hakan54",
      "link" : "https://stackoverflow.com/users/6777695/hakan54"
    },
    "creation_date" : 1764953119,
    "last_activity_date" : 1764953119,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}