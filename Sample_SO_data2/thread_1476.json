{
  "question" : {
    "question_id" : 79705823,
    "title" : "3D projection without matrices breaks on negative distance",
    "body" : "<p>I am drawing edges of triangles and quads with rotation and changing camera position, without projection matrices but multiplication and division, however I can not figure out what happens to the coordinates when the vertices go behind the camera.</p>\n<p>After I pass a vertex it breaks and changes its position (looks like it mirrors to the side). I assume due to the negative distance of being behind the camera. Although I ignore triangles behind the camera I must find their position so I can draw the edges.</p>\n<p><code>Main</code> class:</p>\n<pre><code>package def_pack;\nimport java.io.IOException;\nimport javax.swing.JFrame;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n            JFrame f = new JFrame(&quot;3D Test&quot;);\n            f.setSize(1920, 1080);\n            f.setResizable(false);\n            f.setLocationRelativeTo(null);\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            GamePanel gamePanel = new GamePanel();\n            f.add(gamePanel);\n            gamePanel.setSize(1920,1080);\n            gamePanel.startThread();\n            f.setVisible(true);\n    }\n}\n</code></pre>\n<p><code>GamePanel</code> class:</p>\n<pre><code>package def_pack;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.io.IOException;\nimport javax.swing.JPanel;\n\npublic class GamePanel extends JPanel implements Runnable{\n    public Thread thr;\n    public scene s;\n    GamePanel() throws IOException{\n            s = new scene();\n    }\n    @Override\n    public void run() {\n\n        while (true) {\n             try {\n                Thread.sleep(1);\n            } catch (InterruptedException e) {e.printStackTrace();}\n              try {\n                update();\n                repaint();\n              } catch (IOException e) {e.printStackTrace();}\n        }\n    }\n\n    public void update() throws IOException {\n        s.update();\n    }\n    public void paintComponent(Graphics g) {\n            Graphics2D g2d= (Graphics2D)g;\n            g2d.clearRect(0, 0, 1920, 1080);\n            try {\n                s.draw(g2d);\n            } catch (InterruptedException e) {e.printStackTrace();}\n    }\n    public void startThread() {\n            thr = new Thread(this);\n            thr.start();\n    }\n}\n</code></pre>\n<p><code>vertex3D</code> class:</p>\n<pre><code>package def_pack;\n\npublic class vertex3D {\n    public double x,y,z;\n    public double[] transformedCoords= {0,0,0};\n       vertex3D(double x, double y, double z){\n           this.x=x;\n           this.y=-y;\n           this.z=z;\n       }\n\n    public void update(double camX, double camY, double camZ) {\n// get relative coordinates\n            this.transformedCoords[0]=this.x-camX;\n            this.transformedCoords[1]=this.y-camY;\n            this.transformedCoords[2]=this.z-camZ;\n    }\n}\n</code></pre>\n<p><code>scene</code> class:</p>\n<pre><code>package def_pack;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Polygon;\nimport java.awt.Rectangle;\nimport java.awt.geom.Area;\nimport java.io.IOException;\nimport java.util.ArrayList;\n\npublic class scene {\n    public double camX=0;\n    public double camY=0;\n    public double camZ=0;\n    public vertex3D[] testQuad = {new vertex3D(-3,-2,2),new vertex3D(-3,-2,4),new vertex3D(-3,3,4),new vertex3D(-3,3,2)};\n    public int meshesAmount;\n    public ArrayList&lt;vertex3D[]&gt; meshes = new ArrayList&lt;&gt;();\n    public Rectangle screen = new Rectangle(0,0,1920,1080);\n    public int scrW=1920;\n    public int scrH=1080;\n    public int sizer=300;\n    scene() throws IOException {\n        meshes.add(testQuad);\n        meshesAmount=meshes.size();\n        }\n    public void update(){\n        camZ+=0.001;\n        for (int i=0;i&lt;meshesAmount;i++) {\n            for (int j=0;j&lt;meshes.get(i).length;j++) {\n                meshes.get(i)[j].update(camX,camY,camZ);\n            }\n        }\n    }\n    public void draw(Graphics2D g2d) throws InterruptedException {\n        for (int i=0;i&lt;meshesAmount;i++) {\n            boolean drawable=false;\n                for (int j=0;j&lt;meshes.get(i).length;j++) {\n                    if (meshes.get(i)[j].transformedCoords[2]&gt;0) {\n                    drawable=true;\n                }\n        }\n            if (drawable) {\n                int nPoints=meshes.get(i).length;\n                int xPoints[] = new int[nPoints];\n                int yPoints[]=new int[nPoints];\n                for (int j=0;j&lt;meshes.get(i).length;j++) {\n                    double newX=meshes.get(i)[j].transformedCoords[0]/(meshes.get(i)[j].transformedCoords[2]);\n                    double newY=meshes.get(i)[j].transformedCoords[1]/(meshes.get(i)[j].transformedCoords[2]);\n                    newX*=sizer;\n                    newX/=scrW/scrH;\n                    newY*=sizer;\n                    newX+=scrW/2;\n                    newY+=scrH/2;\n                    xPoints[j]=(int)(newX);\n                    yPoints[j]=(int)(newY);\n                }\n                g2d.setColor(Color.cyan);\n                Polygon p = new Polygon(xPoints, yPoints, xPoints.length);\n                Area polyArea = new Area(p);\n                Area screenArea = new Area(screen);\n                polyArea.intersect(screenArea);\n                g2d.fill(polyArea);\n            }\n        }\n   }\n}\n</code></pre>\n<p>I tried:</p>\n<pre><code>if (behindCam[j]) {\n    meshes.get(i)[j].transformedCoords[2]=-1/meshes.get(i)[j].transformedCoords[0];\n}\n</code></pre>\n<p>and:</p>\n<pre><code>newX*=-1;\nnewY*=-1;\n</code></pre>\n<p>and:</p>\n<pre><code>meshes.get(i)[j].transformedCoords[2]=-meshes.get(i)[j].transformedCoords[2];\n</code></pre>\n<p>However, I can not figure it out. It seems that when <code>meshes.get(i)[j].transformedCoords[2]</code> (z coordinate) makes distance blow up when using the first approach and it's between 0 and -1, however after that it seems to work. I tried limiting <code>transformedCoords[2]</code> to 0.0001 so that it never becomes negative, however the perspective looks fake after that.</p>\n<p>Image of quad from beginning:</p>\n<p><a href=\"https://i.sstatic.net/53YoUf1H.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/53YoUf1H.png\" alt=\"quad begin\" /></a></p>\n<p>Nearing distance 0 for vertices closest to cam:</p>\n<p><a href=\"https://i.sstatic.net/KPV2aZbG.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/KPV2aZbG.png\" alt=\"quad middle\" /></a></p>\n<p>Half of quad behind cam:</p>\n<p><a href=\"https://i.sstatic.net/fUpWRi6t.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/fUpWRi6t.png\" alt=\"quad half behind\" /></a></p>\n",
    "tags" : [ "java", "graphics", "3d", "geometry" ],
    "owner" : {
      "account_id" : 18244328,
      "reputation" : 1,
      "user_id" : 13917968,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/2e44c41bd67de198261eacaace91ab7e?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "randomuser12345",
      "link" : "https://stackoverflow.com/users/13917968/randomuser12345"
    },
    "is_answered" : false,
    "view_count" : 186,
    "answer_count" : 1,
    "score" : -1,
    "last_activity_date" : 1754524379,
    "creation_date" : 1752822862,
    "link" : "https://stackoverflow.com/questions/79705823/3d-projection-without-matrices-breaks-on-negative-distance",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79707529,
    "question_id" : 79705823,
    "body" : "<p>I believe you are doing the perspective projection matrix incorrectly (if that's what you were trying to do)</p>\n<p>this might be fixed if you implemented the perspective projection matrix properly (i dont see znear or zfar in your equations) but if the math seems daunting there is a library called <em><strong>joml</strong></em> (java open math library) that i have used before with jogl (java opengl).</p>\n<ul>\n<li><p>What is zNear and zFar you may be asking?</p>\n<p>znear and zfar are variables in the perspective projection matrix that dictate the</p>\n<p>closest and farthest something can be from the screen.</p>\n<p>--------------------think of it this way---------------------</p>\n<p>imagine instead of your screen being 2D, it was a 3D glass box.</p>\n<p>zNear would be the face of the box facing towards you,</p>\n<p>and zFar would be the other face opposite to that one,</p>\n<p>and 3D stuff that you view can only go as close as zNear or</p>\n<p>as far as zFar.</p>\n<p>-------------------------------------------------------------</p>\n<ul>\n<li><p>cool, how can i implement zNear and zFar?<br />\nyou could just look at a perspective projection matrix and do the math yourself,</p>\n<p>but it would be slower and more daunting (for some), so i reccomened using</p>\n<p><em><strong>joml</strong></em> as i previously stated, because it has a lot of methods and classes for 3d</p>\n<p>rendering (albeit mostly for jogl but would still work in your case).</p>\n<p>for example you could do:</p>\n<pre class=\"lang-java prettyprint-override\"><code>Matrix4f projMatrix = new Matrix4f().perspective(fov,aspectRatio,znear,zfar);\n</code></pre>\n<p>and then do this per frame:</p>\n<pre class=\"lang-java prettyprint-override\"><code>vertexes.forEach(vertex-&gt;{\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>   vertex = vertex * scaleMatrix * rotationMatrix  * projMatrix;\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>});\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>drawVertexes(); //assuming you have a method like this\n</code></pre>\n</li>\n</ul>\n</li>\n<li><p>And on a personal note i recommend that you look into jogl for 3D rendering in java, it has a slight learning curve but for me it was worth it. you will get more control via shaders and uniforms and way more performance because it is hardware accelerated.</p>\n</li>\n</ul>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 34932063,
      "reputation" : 10,
      "user_id" : 26867515,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/3dd216f1f1845b16bfd23e135447f25c?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "carlosreyna0",
      "link" : "https://stackoverflow.com/users/26867515/carlosreyna0"
    },
    "creation_date" : 1752953692,
    "last_activity_date" : 1752954343,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140679708,
    "post_id" : 79705823,
    "body" : "Helllo user, welcome, what you say and what your code does don&#39;t seem to match, so I ask, do you want the camera to “orbit” around the figure (rotating on itself to keep the figure centered), or do you want the figure to “orbit” the camera by rotating on itself, so that it always shows the same side to the camera, or some other possibility?.",
    "score" : 0,
    "owner" : {
      "account_id" : 10843443,
      "reputation" : 924,
      "user_id" : 20882864,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/CCQCy.jpg?s=256",
      "display_name" : "Marce Puente",
      "link" : "https://stackoverflow.com/users/20882864/marce-puente"
    },
    "creation_date" : 1755705884,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140602131,
    "post_id" : 79705823,
    "body" : "@markspace Hi, I do not know how much more I can reduce my code. This is the most reduced version I can make. the mouselisten and keylisten classes only serve to detect mouse movement and keystrokes to control the camera. What I mean is that when I use the fix for transformedCoords[2]=-1/transformedCoords[2] the coordinate becomes absurdly large, with my console having output numbers as big as 200, when in reality when the vertex is behind the cam so the coordinate should be much smaller. I do not exactly know what the right value should be, if I did, I would not be asking this question. Sorry",
    "score" : 0,
    "owner" : {
      "account_id" : 18244328,
      "reputation" : 1,
      "user_id" : 13917968,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/2e44c41bd67de198261eacaace91ab7e?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "randomuser12345",
      "link" : "https://stackoverflow.com/users/13917968/randomuser12345"
    },
    "creation_date" : 1752926645,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140602053,
    "post_id" : 79705823,
    "body" : "It&#39;s still kinda bad.  First, there&#39;s far to much code for us to look at.  Second descriptions like <i>&quot;makes distance blow up by a lot when using the first approach and it&#39;s between 0 and -1&quot;</i> are still pretty vague.  Please reduce the code to exactly what is not working (you will have to debug!), then show us what values (the numbers) are not right, and what the values should be (by giving us the correct answer).",
    "score" : 2,
    "owner" : {
      "account_id" : 2709823,
      "reputation" : 11069,
      "user_id" : 2338547,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/QT3fG.png?s=256",
      "display_name" : "markspace",
      "link" : "https://stackoverflow.com/users/2338547/markspace"
    },
    "creation_date" : 1752922711,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79707529" : [ {
      "comment_id" : 140602984,
      "post_id" : 79707529,
      "body" : "@randomuser12345 alright thank you for responding, I wouldn&#39;t recommend not using a projection matrix, best of luck with solving your problem!",
      "score" : 0,
      "owner" : {
        "account_id" : 34932063,
        "reputation" : 10,
        "user_id" : 26867515,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/3dd216f1f1845b16bfd23e135447f25c?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "carlosreyna0",
        "link" : "https://stackoverflow.com/users/26867515/carlosreyna0"
      },
      "creation_date" : 1752964694,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140602915,
      "post_id" : 79707529,
      "body" : "Hi, thank you for the answer! I am trying to do the projection without any matrices and I can draw the vertices from a top down view, kind of like a mini-map, and using this current method I have for side to side rotation they rotate around the camera correctly and the Z value seems to be right, however, even when I use a projection matrix with it, it does not seem to work properly. I will fiddle around with my code some more.",
      "score" : 0,
      "owner" : {
        "account_id" : 18244328,
        "reputation" : 1,
        "user_id" : 13917968,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/2e44c41bd67de198261eacaace91ab7e?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "randomuser12345",
        "link" : "https://stackoverflow.com/users/13917968/randomuser12345"
      },
      "creation_date" : 1752958630,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}