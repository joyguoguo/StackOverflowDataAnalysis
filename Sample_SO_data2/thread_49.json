{
  "question" : {
    "question_id" : 79842996,
    "title" : "Portaudio is recording a weird distorted waveform when recording jack devices and firefox",
    "body" : "<p>I am not sure why this is happening so I am coming here to look for any sort of help I can get. Basically when recording any jack device such as firefox in my app it comes out as distorted. But it works perfectly fine when recording it to a wav file in the demo code attached, or when recording my microphone. The full source of my application is at <a href=\"https://github.com/1vers1on/bolt\" rel=\"nofollow noreferrer\">https://github.com/1vers1on/bolt</a></p>\n<p>This image shows the impulses when recording firefox.</p>\n<p><a href=\"https://i.sstatic.net/3ornB3lD.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/3ornB3lD.png\" alt=\"Impulses in the waveform when recording firefox\" /></a></p>\n<p>This is the waveform when recording firefox when nothing is playing.</p>\n<p><a href=\"https://i.sstatic.net/M28efrpB.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/M28efrpB.png\" alt=\"Waveform when nothing is playing\" /></a></p>\n<p>This waveform is what is shown when recording my microphone. Completely normal as expected.</p>\n<p><a href=\"https://i.sstatic.net/wjZDmVFY.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.sstatic.net/wjZDmVFY.png\" alt=\"Expected waveform\" /></a></p>\n<p>The relevant files in my source code are &quot;Bolt.java&quot;, &quot;PortAudioInputStream.java&quot;, &quot;InputThread.java&quot;, and all of the jni folders and c source code.</p>\n<p>The following demo code works completely as expected with all input devices.</p>\n<pre class=\"lang-java prettyprint-override\"><code>package net.ellie.bolt;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.util.List;\nimport javax.sound.sampled.AudioFileFormat;\nimport javax.sound.sampled.AudioFormat;\nimport javax.sound.sampled.AudioSystem;\n\nimport net.ellie.bolt.jni.portaudio.AudioInputStream;\nimport net.ellie.bolt.jni.portaudio.PortAudioJNI;\n\npublic class Main {\n    public static void main(String[] args) {\n        // try {\n        // Bolt.run();\n        // } catch (Exception e) {\n        // e.printStackTrace();\n        // }\n\n        final int durationSeconds = 5;\n        final int channelsPreferred = 2;\n        final double sampleRatePreferred = 48000.0;\n\n        PortAudioJNI pa = new PortAudioJNI();\n        int init = pa.initialize();\n        if (init != 0) {\n            System.err.println(&quot;Failed to initialize PortAudio (code=&quot; + init + &quot;)&quot;);\n            return;\n        }\n\n        try {\n            List&lt;PortAudioJNI.DeviceInfo&gt; devices = pa.enumerateDevices();\n            if (devices == null || devices.isEmpty()) {\n                System.err.println(&quot;No audio devices found&quot;);\n                return;\n            }\n\n            for (PortAudioJNI.DeviceInfo d : devices) {\n                System.out.printf(&quot;Device %d: %s (in: %d ch, out: %d ch, default SR: %.1f)\\n&quot;,\n                        d.index(), d.name(), d.maxInputChannels(), d.maxOutputChannels(), d.defaultSampleRate());\n            }\n\n            PortAudioJNI.DeviceInfo device = devices.get(27);\n\n            int channels = Math.min(device.maxInputChannels(), channelsPreferred);\n            double sampleRate = sampleRatePreferred;\n\n            if (!pa.isFormatSupported(device.index(), channels, sampleRate)) {\n                channels = Math.max(1, Math.min(device.maxInputChannels(), 1));\n                sampleRate = device.defaultSampleRate() &gt; 0 ? device.defaultSampleRate() : sampleRatePreferred;\n            }\n\n            long framesPerBuffer = 256;\n            AudioInputStream inputStream = pa.openInputStream(device.index(), channels, sampleRate, framesPerBuffer);\n\n            try (inputStream) {\n                inputStream.start();\n\n                int totalFrames = (int) (sampleRate * durationSeconds);\n                int bytesPerSample = 2;\n                int bytesPerFrame = bytesPerSample * channels;\n                byte[] data = new byte[totalFrames * bytesPerFrame];\n\n                int bytesCaptured = 0;\n                while (bytesCaptured &lt; data.length) {\n                    int remaining = data.length - bytesCaptured;\n                    int toRead = Math.max(bytesPerFrame, Math.min(remaining, bytesPerFrame * 1024));\n                    int read = inputStream.read(data, bytesCaptured, toRead);\n                    if (read &lt;= 0)\n                        break;\n                    bytesCaptured += read;\n                }\n\n                int framesCaptured = bytesCaptured / bytesPerFrame;\n                float[] floatInterleaved = pcm16LeBytesToFloats(data, framesCaptured, channels);\n\n                float gain = 0.8f;\n                for (int i = 0; i &lt; floatInterleaved.length; i++) {\n                    floatInterleaved[i] *= gain;\n                }\n\n                byte[] outBytes = floatsToPcm16LeBytes(floatInterleaved, framesCaptured, channels);\n\n                AudioFormat format = new AudioFormat(\n                        (float) sampleRate,\n                        16,\n                        channels,\n                        true,\n                        false\n                );\n\n                ByteArrayInputStream bais = new ByteArrayInputStream(outBytes);\n                javax.sound.sampled.AudioInputStream ais = new javax.sound.sampled.AudioInputStream(bais, format,\n                        framesCaptured);\n\n                File out = new File(&quot;output.wav&quot;);\n                AudioSystem.write(ais, AudioFileFormat.Type.WAVE, out);\n                System.out.printf(&quot;Saved %d frames to %s at %.0f Hz, %d ch (processed)\\n&quot;, framesCaptured,\n                        out.getAbsolutePath(), sampleRate, channels);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            pa.terminate();\n        }\n    }\n\n    private static float[] pcm16LeBytesToFloats(byte[] bytes, int frames, int channels) {\n        int samples = frames * channels;\n        float[] out = new float[samples];\n        int bi = 0;\n        for (int i = 0; i &lt; samples; i++) {\n            int lo = bytes[bi++] &amp; 0xFF;\n            int hi = bytes[bi++];\n            int sample = (hi &lt;&lt; 8) | lo;\n            float f = sample &gt;= 0 ? (sample / 32767.0f) : (sample / 32768.0f);\n            out[i] = f;\n        }\n        return out;\n    }\n\n    private static byte[] floatsToPcm16LeBytes(float[] floats, int frames, int channels) {\n        int samples = frames * channels;\n        byte[] out = new byte[samples * 2];\n        int bi = 0;\n        for (int i = 0; i &lt; samples; i++) {\n            float f = floats[i];\n            if (f &gt; 1.0f)\n                f = 1.0f;\n            if (f &lt; -1.0f)\n                f = -1.0f;\n            int s;\n            if (f &gt;= 0) {\n                s = (int) Math.round(f * 32767.0);\n            } else {\n                s = (int) Math.round(f * 32768.0);\n            }\n            out[bi++] = (byte) (s &amp; 0xFF);\n            out[bi++] = (byte) ((s &gt;&gt;&gt; 8) &amp; 0xFF);\n        }\n        return out;\n    }\n}\n\n</code></pre>\n<p>Here is the PortAudioInputSource.java</p>\n<pre class=\"lang-java prettyprint-override\"><code>package net.ellie.bolt.input.sources.real;\n\nimport java.io.IOException;\nimport java.util.List;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport net.ellie.bolt.contexts.PortAudioContext;\nimport net.ellie.bolt.input.CloseableInputSource;\nimport net.ellie.bolt.jni.portaudio.AudioInputStream;\nimport net.ellie.bolt.jni.portaudio.PortAudioJNI;\n\npublic class PortAudioInputSource implements CloseableInputSource {\n    private final Logger logger = LoggerFactory.getLogger(PortAudioInputSource.class);\n    private volatile boolean running = true;\n    private AudioInputStream audioInputStream;\n    private final int sampleRate;\n    private final int channelCount;\n    private final int framesPerBuffer;\n    private byte[] byteBuffer; // re-used between reads to avoid allocations\n    \n    public PortAudioInputSource(int deviceIndex, int channels, double sampleRate, long framesPerBuffer) {\n        PortAudioJNI pa = PortAudioContext.getInstance().getPortAudioJNI();\n        \n        PortAudioJNI.DeviceInfo device = null;\n        List&lt;PortAudioJNI.DeviceInfo&gt; devices = pa.enumerateDevices();\n        for (PortAudioJNI.DeviceInfo d : devices) {\n            if (d.index() == deviceIndex) {\n                device = d;\n                break;\n            }\n        }\n        \n        if (device == null) {\n            throw new RuntimeException(&quot;Device not found: &quot; + deviceIndex);\n        }\n        \n        int maxInputChannels = device.maxInputChannels();\n        \n        int actualChannels = channels;\n        if (channels == 1 &amp;&amp; maxInputChannels &lt; 1) {\n            actualChannels = Math.max(1, maxInputChannels);\n            logger.warn(&quot;Device {} doesn't support {} channels, using {} channels instead&quot;, \n                    device.name(), channels, actualChannels);\n        }\n        \n        this.sampleRate = (int) sampleRate;\n        this.channelCount = Math.max(1, actualChannels);\n        this.framesPerBuffer = (int) Math.max(1, framesPerBuffer);\n        \n        logger.info(&quot;Opening PortAudio input stream with deviceIndex={}, channels={} (requested: {}), sampleRate={}, framesPerBuffer={}&quot;,\n                deviceIndex, this.channelCount, channels, sampleRate, framesPerBuffer);\n        \n        audioInputStream = PortAudioContext.getInstance().getPortAudioJNI()\n            .openInputStream(deviceIndex, this.channelCount, sampleRate, framesPerBuffer);\n\n        this.byteBuffer = new byte[this.framesPerBuffer * this.channelCount * 2];\n\n        audioInputStream.start();\n    }\n\n    @Override\n    public int read(float[] buffer, int offset, int length) throws InterruptedException, IOException {\n        if (!running || audioInputStream == null) {\n            return 0;\n        }\n\n        int bytesToRead = Math.min(byteBuffer.length, length * 2 * channelCount);\n        int bytesRead = audioInputStream.read(byteBuffer, 0, bytesToRead);\n        if (bytesRead &lt;= 0) {\n            return 0;\n        }\n\n        int framesCaptured = bytesRead / (2 * channelCount);\n        int framesToCopy = Math.min(framesCaptured, length);\n\n        int bi = 0;\n        for (int i = 0; i &lt; framesToCopy; i++) {\n            float sum = 0;\n            int channelsRead = 0;\n            for (int j = 0; j &lt; channelCount; j++) {\n                if (bi + 1 &gt;= byteBuffer.length) break;\n                \n                int lo = byteBuffer[bi++] &amp; 0xFF;\n                int hi = byteBuffer[bi++];\n                int sample = (hi &lt;&lt; 8) | lo;\n                float f = sample &gt;= 0 ? (sample / 32767.0f) : (sample / 32768.0f);\n                sum += f;\n                channelsRead++;\n            }\n\n            if (channelsRead &gt; 0) {\n                buffer[offset + i] = sum / channelsRead;\n            } else {\n                buffer[offset + i] = 0;\n            }\n        }\n\n        return framesToCopy;\n    }\n\n    @Override\n    public int getSampleRate() {\n        return sampleRate;\n    }\n\n    @Override\n    public void stop() {\n        running = false;\n        if (audioInputStream != null) {\n            audioInputStream.stop();\n            audioInputStream.close();\n            audioInputStream = null;\n        }\n    }\n\n    @Override\n    public String getName() {\n        return &quot;PortAudio Input Source&quot;;\n    }\n\n    @Override\n    public boolean isRunning() {\n        return running;\n    }\n\n    @Override\n    public boolean isComplex() {\n        return false;\n    }\n\n    @Override\n    public void close() {\n        stop();\n    }\n}\n</code></pre>\n<p>This is the InputThread.java file</p>\n<pre class=\"lang-java prettyprint-override\"><code>package net.ellie.bolt.input;\n\nimport java.io.IOException;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport net.ellie.bolt.config.Configuration;\nimport net.ellie.bolt.dsp.buffers.CircularFloatBuffer;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class InputThread implements Runnable {\n    private static final Logger logger = LoggerFactory.getLogger(InputThread.class);\n\n    private final CloseableInputSource inputSource;\n    private final AtomicBoolean running = new AtomicBoolean(false);\n    private final CircularFloatBuffer buffer;\n\n    // Throttling state\n    private final int complexFactor;\n    private final int sampleRate; // samples per second for one channel; effective rate accounts for complexFactor\n    private long nextReadDeadlineNanos = 0L;\n\n    private final float[] readBuffer;\n\n    private Thread localInputThread = null;\n\n    public InputThread(CloseableInputSource inputSource, int sampleRate) {\n        this.inputSource = inputSource;\n\n        this.complexFactor = inputSource.isComplex() ? 2 : 1;\n        this.sampleRate = sampleRate;\n\n        int bufferSize = Configuration.getFftSize() * 32 * complexFactor; // TODO: figure out the correct size\n        this.buffer = new CircularFloatBuffer(bufferSize);\n\n        this.readBuffer = new float[4 * 16384 * complexFactor]; // TODO: maybe increase the size\n    }\n\n    public void start() {\n        running.set(true);\n        localInputThread = new Thread(this, &quot;InputThread-&quot; + inputSource.getName());\n        localInputThread.start();\n    }\n\n    @Override\n    public void run() {\n        logger.info(&quot;InputThread for {} started&quot;, inputSource.getName());\n        try {\n            nextReadDeadlineNanos = System.nanoTime();\n            while (running.get()) {\n                long now = System.nanoTime();\n                long waitNanos = nextReadDeadlineNanos - now;\n                if (waitNanos &gt; 0) {\n                    long waitMillis = waitNanos / 1_000_000L;\n                    int waitExtraNanos = (int)(waitNanos % 1_000_000L);\n                    if (waitMillis &gt; 0 || waitExtraNanos &gt; 0) {\n                        try {\n                            Thread.sleep(waitMillis, waitExtraNanos);\n                        } catch (InterruptedException ie) {\n                            Thread.currentThread().interrupt();\n                            break;\n                        }\n                    }\n                }\n\n                int samplesRead = inputSource.read(readBuffer, 0, readBuffer.length);\n                if (samplesRead &gt; 0) {\n                    buffer.write(readBuffer, 0, samplesRead);\n\n                    double secondsForChunk = (double) samplesRead / (double) (sampleRate * complexFactor);\n                    long nanosForChunk = (long) (secondsForChunk * 1_000_000_000L);\n                    nextReadDeadlineNanos = System.nanoTime() + nanosForChunk;\n                } else {\n                    try {\n                        Thread.sleep(1);\n                    } catch (InterruptedException e) {\n                        Thread.currentThread().interrupt();\n                        break;\n                    }\n                    nextReadDeadlineNanos = System.nanoTime() + 1_000_000L;\n                }\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try { inputSource.close(); } catch (Exception ignored) {}\n        }\n    }\n\n    public void stop() {\n        running.set(false);\n        if (localInputThread != null) {\n            try {\n                localInputThread.join();\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n        inputSource.stop();\n        logger.info(&quot;InputThread for {} stopped&quot;, inputSource.getName());\n    }\n\n    public CircularFloatBuffer getBuffer() {\n        return buffer;\n    }\n}\n</code></pre>\n",
    "tags" : [ "java", "audio", "java-native-interface", "signal-processing", "portaudio" ],
    "owner" : {
      "account_id" : 23847095,
      "reputation" : 55,
      "user_id" : 17851476,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/MDyDg.jpg?s=256",
      "display_name" : "HoosierTransfer",
      "link" : "https://stackoverflow.com/users/17851476/hoosiertransfer"
    },
    "is_answered" : false,
    "view_count" : 47,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1765375933,
    "creation_date" : 1765372670,
    "link" : "https://stackoverflow.com/questions/79842996/portaudio-is-recording-a-weird-distorted-waveform-when-recording-jack-devices-an",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140896321,
    "post_id" : 79842996,
    "body" : "betting on stereo-mono issue being a <i>part</i> of it.",
    "score" : 0,
    "owner" : {
      "account_id" : 3072614,
      "reputation" : 16444,
      "user_id" : 2602877,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/c76ea7b35660e77624550130276c61d3?s=256&d=identicon&r=PG",
      "display_name" : "Christoph Rackwitz",
      "link" : "https://stackoverflow.com/users/2602877/christoph-rackwitz"
    },
    "creation_date" : 1765376036,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140896236,
    "post_id" : 79842996,
    "body" : "You should <a href=\"https://stackoverflow.com/posts/79842996/edit\">edit</a> your question and provide a <a href=\"https://stackoverflow.com/help/minimal-reproducible-example\">minimal reproducible example</a>.",
    "score" : 2,
    "owner" : {
      "account_id" : 14709065,
      "reputation" : 10004,
      "user_id" : 10622916,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/0022d8bc5b72b83b2ff1a2a54b571f03?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Bodo",
      "link" : "https://stackoverflow.com/users/10622916/bodo"
    },
    "creation_date" : 1765373481,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}