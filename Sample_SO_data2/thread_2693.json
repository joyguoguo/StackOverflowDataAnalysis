{
  "question" : {
    "question_id" : 79605945,
    "title" : "Java SSLSocket Bad Performance (How to optimize)",
    "body" : "<p>I have been trying to make a custom networking library for a game engine in Java using SSLSockets with TLS</p>\n<p><strong>Explanation of Problem</strong>:</p>\n<p>Anyways as I have ran some tests, I noticed that performance was very bad, the test connects 100 clients to the server (server backlog: 100), and they all then send messages at a rate of 5000/s in total (50/s per client) and this continues for 30s</p>\n<p><strong>Structure</strong>:</p>\n<p>The networking model uses Java Virtual Threads and Event listeners</p>\n<p>Basically, you create a Dispatcher which will poll for messages and based of the opcode, will call the corrosponding listener to handle it</p>\n<p>heavy listeners also recieve their own virtual thread to avoid blocking</p>\n<p><strong>Performance</strong></p>\n<p><strong>1. TEST</strong>:</p>\n<pre><code>--- Test Results ---\nDuration: 35,01 seconds\nClients: 100, Msg Rate/Client: 50/s\nTarget Total Send Rate: 5000/s\nActual Total Messages Sent (Client): 105272 (3007,03/s)\nTotal Messages Received (Server): 105272 (3007,03/s)\nClient PONGs Received: 84182\nClient HEAVY_RESP Received: 21090\n\n--- Latency (Round Trip Nanos) ---\nSamples: 84182\nMin Latency: 73 801 ns (0,074 ms)\nMax Latency: 122 189 501 ns (122,190 ms)\nAvg Latency: 1 460 886 ns (1,461 ms)\n--------------------\n</code></pre>\n<p><strong>2. TEST</strong>:</p>\n<pre><code>--- Test Results ---\nDuration: 35,01 seconds\nClients: 100, Msg Rate/Client: 50/s\nTarget Total Send Rate: 5000/s\nActual Total Messages Sent (Client): 109337 (3123,38/s)\nTotal Messages Received (Server): 109337 (3123,38/s)\nClient PONGs Received: 87428\nClient HEAVY_RESP Received: 21896\n\n--- Latency (Round Trip Nanos) ---\nSamples: 87428\nMin Latency: 73 999 ns (0,074 ms)\nMax Latency: 109 425 701 ns (109,426 ms)\nAvg Latency: 1 857 526 ns (1,858 ms)\n--------------------\n</code></pre>\n<p><strong>3. TEST</strong>:</p>\n<pre><code>--- Test Results ---\nDuration: 35,00 seconds\nClients: 100, Msg Rate/Client: 50/s\nTarget Total Send Rate: 5000/s\nActual Total Messages Sent (Client): 103965 (2970,20/s)\nTotal Messages Received (Server): 103965 (2970,20/s)\nClient PONGs Received: 83126\nClient HEAVY_RESP Received: 20809\n\n--- Latency (Round Trip Nanos) ---\nSamples: 83126\nMin Latency: 75 200 ns (0,075 ms)\nMax Latency: 62 947 500 ns (62,948 ms)\nAvg Latency: 1 635 833 ns (1,636 ms)\n--------------------\n</code></pre>\n<p><strong>Code</strong>\n<strong>LWJG.net.Dispatcher</strong></p>\n<pre><code>package LWJG.net;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.Socket;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport static LWJG.net.util.bin.ByteWizard.toBytes;\nimport static LWJG.net.util.bin.ByteWizard.toInteger;\n\nimport javax.net.ssl.SSLSocket;\n\n/**\n * Dispatcher Object to abstract sending and recieving\n * {@link #listeners} Includes a basic listener Map that lets utilities easiely interface with Client requests to the Server\n * &lt;br&gt;&lt;b&gt;WARNING: Only 256 Possible Opcodes for now!&lt;/b&gt;\n * @author Lithax\n * @version 2025-05-03T1:28\n */\npublic class Dispatcher implements Runnable {\n    private final SSLSocket socket;\n    private final byte[] buffer;\n    private volatile boolean running;\n\n    private final Map&lt;Byte, List&lt;IOEventListener&gt;&gt; listeners = new ConcurrentHashMap&lt;&gt;();\n\n    private static final ExecutorService backgroundTaskExecutor = Executors.newVirtualThreadPerTaskExecutor();\n\n    public Dispatcher(SSLSocket socket, int bufsize) {\n        this.running = true;\n        this.buffer = new byte[bufsize];\n        this.socket = socket;\n    }\n\n    /**\n     * Add new Event Listener\n     * @param opcode Opcode to be invoked by\n     * @param l Listener\n     */\n    public void addEventListener(byte opcode, IOEventListener l) {\n        listeners\n          .computeIfAbsent(opcode, k -&gt; new CopyOnWriteArrayList&lt;&gt;())\n          .add(l);\n    }\n\n    /**\n     * Remove a existing Event Listener\n     * @param opcode Opcode to be invoked by\n     * @param l Listener\n     */\n    public void removeEventListener(byte opcode, IOEventListener l) {\n        List&lt;IOEventListener&gt; lst = listeners.get(opcode);\n        if (lst != null) lst.remove(l);\n    }\n\n    @Override\n    public void run() {\n        int payloadLen;\n        byte code;\n        int chunkLen;\n        int readSoFar;\n        int toRead;\n        int r;\n        try (InputStream in = socket.getInputStream()) {\n            int len;\n            while ((len = in.read(buffer)) != -1 &amp;&amp; running) {\n                if (len &lt; 5) continue;\n                code = buffer[0];\n                payloadLen = toInteger(new byte[]{buffer[1], buffer[2], buffer[3], buffer[4]});\n\n                ByteArrayOutputStream stream = new ByteArrayOutputStream(payloadLen);\n\n                chunkLen = len - 5;\n                if (chunkLen &gt; 0) {\n                    stream.write(buffer, 5, chunkLen);\n                }\n\n                readSoFar = chunkLen;\n                while (readSoFar &lt; payloadLen) {\n                    toRead = Math.min(buffer.length, payloadLen - readSoFar);\n                    r = in.read(buffer, 0, toRead);\n                    if (r == -1) throw new IOException(&quot;Stream closed prematurely&quot;);\n                    stream.write(buffer, 0, r); // only writes actual read instead of entire buffer\n                    readSoFar += r;\n                }\n\n                final byte[] payload = stream.toByteArray();\n\n                List&lt;IOEventListener&gt; lst = listeners.get(code);\n\n                if (lst != null) \n                    for (IOEventListener l : lst) \n                        if(l.isHeavyTask())\n                            backgroundTaskExecutor.submit(() -&gt; {\n                                try { l.onEvent(this, payload); } catch (Exception e) { /* handle */ }\n                            });\n                        else l.onEvent(this, payload);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            close();\n        }\n    }\n\n    /**\n     * Send a payload to Client\n     * @param b payload\n     * @param opcode opcode\n     */\n    public void send(byte opcode, byte[] b) {\n        byte[] tmp = new byte[b.length+5];\n        tmp[0] = opcode;\n        byte[] len = toBytes(b.length);\n        tmp[1] = len[0];\n        tmp[2] = len[1];\n        tmp[3] = len[2];\n        tmp[4] = len[3];\n        for(int i = 0; i &lt; b.length; i++) tmp[5+i] = b[i];\n        send(tmp);\n    }\n\n    /**\n     * Send raw bytes to Client\n     * WARNING: Does not account for opcode or len\n     * @param b Bytes to be send\n     */\n    public void send(byte[] b) {\n        try {\n            socket.getOutputStream().write(b);\n            socket.getOutputStream().flush();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * Get Client Socket\n     * @return Socket\n     */\n    public Socket getSocket() {\n        return socket;\n    }\n\n    /**\n     * &lt;b&gt;Close Client&lt;/b&gt;\n     * Warning: After close, Client Object should be removed, as it is now unusable\n     */\n    public void close() {\n        if(!running) return;\n        try {\n            running = false;\n            if(socket.isClosed()) socket.close();\n        } catch (IOException e) {\n            System.out.println(&quot;Error Closing Client: &quot;+e.getMessage());\n        }\n    }\n}\n</code></pre>\n<p><strong>LWJG.net.Client</strong></p>\n<pre><code>package LWJG.net;\n\nimport javax.net.ssl.SSLSocket;\n\n/**\n * Server Client Object, abstracts client sockets for easier handling\n * {@link #listeners} Includes a basic listener Map that lets utilities easiely interface with Client requests to the Server\n * &lt;br&gt;&lt;b&gt;WARNING: Only 256 Possible Opcodes for now!&lt;/b&gt;\n * @author Lithax\n * @version 2025-05-03T1:28\n * @side Server\n */\npublic class Client extends Dispatcher {\n    private ClientPermission permission;\n\n    public Client(SSLSocket socket, ClientPermission perm, int bufsize) {\n        super(socket, bufsize);\n        this.permission = perm;\n    }\n\n    /**\n     * Get Permissions\n     * @return Permissions\n     */\n    public ClientPermission getPermission() {\n        return permission;\n    }\n\n    /**\n     * Set Permissions\n     * @param permission New Permission\n     */\n    public void setPermission(ClientPermission permission) {\n        this.permission = permission;\n    }\n}\n</code></pre>\n<p><strong>LWJG.net.ClientManager</strong></p>\n<pre><code>package LWJG.net;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.net.ssl.SSLSocket;\n\n/**\n * Client Manager Class to manage all current Clients connected to the Server\n * {@link #clients} All currently connected clients\n * {@link #blacklist} All currently blacklisted clients (aborted upon connection attempt)\n * {@link #defaultPerm} The default permission all clients should recieve\n * {@link #clientConnectedListeners} All Event Listeners that will be invoked once a new client has connected\n * @author Lithax\n * @version 2025-05-03T3:58\n * @side Server\n */\npublic class ClientManager {\n    private List&lt;Client&gt; clients;\n    private List&lt;String&gt; blacklist;\n    private ClientPermission defaultPerm;\n\n    private final List&lt;ClientConnectedListener&gt; clientConnectedListeners = new ArrayList&lt;&gt;();\n\n    public ClientManager(ClientPermission permission) {\n        this.clients = new ArrayList&lt;&gt;();\n        this.blacklist = new ArrayList&lt;&gt;();\n        this.defaultPerm = permission;\n    }\n\n    /**\n     * Adds a new Client Connected Listener\n     * @param listener Listener\n     */\n    public void addClientConnectedListener(ClientConnectedListener listener) {\n        clientConnectedListeners.add(listener);\n    }\n\n    /**\n     * Removes a new Client Connected Listener\n     * @param listener Listener\n     */\n    public void removeClientConnectedListener(ClientConnectedListener listener) {\n        clientConnectedListeners.remove(listener);\n    }\n\n    /**\n     * Get current Clients\n     * @return List&lt;Client&gt; clients\n     */\n    public List&lt;Client&gt; getClients() {\n        return clients;\n    }\n\n    public Client add(SSLSocket c) {\n        if(true || !clients.stream().anyMatch(client -&gt; client.getSocket().getInetAddress().getHostAddress().equals(c.getInetAddress().getHostAddress()))) {\n            Client client = new Client(c, defaultPerm, 1024);\n            clients.add(client);\n            for (ClientConnectedListener listener : clientConnectedListeners) {\n                listener.onClientConnected(client);\n            }\n            return client;\n        }\n        return null;\n    }\n\n    /**\n     * Broadcast raw bytes to all Clients\n     * @param opcode Listener Opcode\n     * @param b Bytes\n     */\n    public void broadcast(byte opcode, byte[] b) {\n        for (Client c : clients) {\n            c.send(opcode, b);\n        }\n    }\n\n    /**\n     * Get Client by String ip representation\n     * @param ip IP, e.g. 192.168.178.1\n     * @return Client\n     */\n    public Client get(String ip) {\n        for(Client c : clients)\n            if(c.getSocket().getInetAddress().getHostAddress().equals(ip)) {\n                return c;\n            }\n        return null;\n    }\n\n    /**\n     * Close Client by IP\n     * @param ip IP, e.g. 192.168.178.1\n     * @return Closing Sucessful\n     */\n    public boolean close(String ip) {\n        Client c = get(ip);\n        if(c != null) { c.close(); clients.remove(c); return true; } return false;\n    }\n\n    /**\n     * Checks if a client is blacklisted\n     * @param ip Client ip\n     * @return Is blocked\n     */\n    public boolean isBlocked(String ip) {\n        return blacklist.contains(ip);\n    }\n\n    /**\n     * Add Client to blacklist\n     * @param ip\n     */\n    public void block(String ip) {\n        if(!blacklist.contains(ip)) blacklist.add(ip);\n    }\n\n    /**\n     * Remove Client from blacklist\n     * @param ip\n     */\n    public void unblock(String ip) {\n        if(blacklist.contains(ip)) blacklist.remove(ip);\n    }\n\n    /**\n     * Close all clients\n     */\n    public void closeAllClients() {\n        for(Client c : clients) c.close();\n    }\n}\n</code></pre>\n<p><strong>LWJG.net.RemoteServer</strong></p>\n<pre><code>package LWJG.net;\n\nimport java.io.IOException;\n\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.SSLSocketFactory;\n\n/**\n * Client side of the Client Server interaction\n * {@link #listeners} Includes a basic listener Map that lets utilities easiely interface with Client requests to the Server\n * &lt;br&gt;&lt;b&gt;WARNING: Only 256 Possible Opcodes for now!&lt;/b&gt;\n * @author Lithax\n * @version 2025-05-03T1:28\n * @side Client\n */\npublic class RemoteServer extends Dispatcher {\n    private final int port;\n    private final String ip;\n\n    public RemoteServer(String ip, int port, int bufsize) throws IOException {\n        super(createSocket(ip, port), bufsize);\n        this.port = port;\n        this.ip = ip;\n    }\n\n    private static SSLSocket createSocket(String ip, int port) throws IOException {\n        SSLSocket s = (SSLSocket) SSLSocketFactory.getDefault().createSocket(ip, port);\n        s.setEnabledProtocols(new String[] { &quot;TLSv1.3&quot;, &quot;TLSv1.2&quot; });\n        return s;\n    }\n\n    public String getIP() {\n        return ip;\n    }\n\n    public int getPort() {\n        return port;\n    }\n}\n</code></pre>\n<p><strong>LWJG.net.ServerHandler</strong></p>\n<pre><code>package LWJG.net;\n\nimport java.io.IOException;\n\nimport javax.net.ssl.SSLServerSocket;\nimport javax.net.ssl.SSLServerSocketFactory;\nimport javax.net.ssl.SSLSocket;\n\n/**\n * Utility Class for easy creation of a server with Clientmanager integretation\n * @author Lithax\n * @version 2025-05-03T4:03\n * @side Server\n */\npublic class ServerHandler extends Thread {\n    private final int port;\n    private final int backlog;\n    private volatile boolean running;\n    private ClientManager mn;\n    private SSLServerSocket serverSocket;\n\n    static {\n        System.setProperty(&quot;javax.net.ssl.keyStore&quot;, &quot;server.keystore&quot;);\n        System.setProperty(&quot;javax.net.ssl.keyStorePassword&quot;, &quot;server.password&quot;);\n    }\n\n    public ServerHandler(int port, int backlog, ClientPermission defaultPermission) {\n        this.port = port;\n        this.backlog = backlog;\n        this.running = true;\n        mn = new ClientManager(defaultPermission);\n    }\n\n    @Override\n    public void run() {\n        try {\n            serverSocket = (SSLServerSocket) SSLServerSocketFactory.getDefault().createServerSocket(port, backlog);\n            serverSocket.setEnabledProtocols(new String[] { &quot;TLSv1.3&quot;, &quot;TLSv1.2&quot; });\n            while(running) {\n                SSLSocket client = (SSLSocket) serverSocket.accept();\n                if(!mn.isBlocked(client.getInetAddress().getHostAddress())) {\n                    Client newClient = mn.add(client);\n                    if (newClient != null) {\n                        Thread.startVirtualThread(newClient);\n                        System.out.println(&quot;Started virtual thread for client&quot;);\n                    } else {\n                        System.out.println(&quot;Failed to add client (duplicate or error&quot;);\n                        if (!client.isClosed()) try { client.close(); } catch (IOException e) { /* ignore */ }\n                    }\n                } else System.out.println(&quot;Client connection was blocked.&quot;);\n            }\n            serverSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        finally {\n            close();\n        }\n    }\n\n    public void close() {\n        running = false;\n        if (serverSocket != null &amp;&amp; !serverSocket.isClosed()) {\n            try {\n                serverSocket.close();\n            } catch (IOException e) {\n                System.err.println(&quot;Error closing server socket: &quot; + e.getMessage());\n            }\n        }\n        mn.closeAllClients();\n    }\n\n    public ClientManager getClientManager() {\n        return mn;\n    }\n}\n</code></pre>\n<p><strong>LWJG.net.IOEventListener</strong>\n<strong>LWJG.net.ClientConnectedListener</strong>\n<strong>TEST CLASS</strong>\nNot enough characters for post, I put the rest on my github: <a href=\"https://github.com/Lithax/lwjg\" rel=\"nofollow noreferrer\">https://github.com/Lithax/lwjg</a></p>\n<p>If you know a way to make this faster, I would be very interested, I'm trying to get the maximum performance possible</p>\n",
    "tags" : [ "java", "performance", "sockets", "network-programming", "optimization" ],
    "owner" : {
      "account_id" : 35172147,
      "reputation" : 11,
      "user_id" : 27027955,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/bb47ddf4d45bcd90a15b361a0706efcd?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Lithax",
      "link" : "https://stackoverflow.com/users/27027955/lithax"
    },
    "is_answered" : false,
    "view_count" : 100,
    "answer_count" : 0,
    "score" : 1,
    "last_activity_date" : 1746384785,
    "creation_date" : 1746383939,
    "link" : "https://stackoverflow.com/questions/79605945/java-sslsocket-bad-performance-how-to-optimize",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140396687,
    "post_id" : 79605945,
    "body" : "Did you profile it? You didn&#39;t say what is slow. It could be the TLS connection establishment if the client doesn&#39;t remember TLS session tickets/sid (if it can&#39;t resume). It could be the overhead of flushing at every message, because there could be padding inflating the size of tls record over TCP. You think you send 10kB/s but it could be 100kB/s, suddenly way off the bandwidth available. If not profiling, you could still measure systemnanotime at key moments and every 100 messages and record them in a long[], then print at the end to see if it warms up and get better or if it is constant.",
    "score" : 0,
    "owner" : {
      "account_id" : 2303891,
      "reputation" : 2171,
      "user_id" : 2023577,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/b4ahpbUr.png?s=256",
      "display_name" : "user2023577",
      "link" : "https://stackoverflow.com/users/2023577/user2023577"
    },
    "creation_date" : 1746445566,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140395320,
    "post_id" : 79605945,
    "body" : "5,000 per second seems like an arbitrary goal, whereas 3,000 per second seems pretty fast to me.  Why do you expect it to be 5,000?  Do other applications (including non-Java applications) achieve 5,000 per second for similar tasks?  Do you see better rates if you temporarily comment out the <code>for (IOEventListener…)</code> loop?  I can see some places where optimization might help you, particularly the use of <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/io/InputStream.html#readNBytes(int)\" rel=\"nofollow noreferrer\">readNBytes</a>.",
    "score" : 0,
    "owner" : {
      "account_id" : 2053598,
      "reputation" : 44991,
      "user_id" : 1831987,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/38b1c37530189ec4471a43a618e33f67?s=256&d=identicon&r=PG",
      "display_name" : "VGR",
      "link" : "https://stackoverflow.com/users/1831987/vgr"
    },
    "creation_date" : 1746393861,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140395133,
    "post_id" : 79605945,
    "body" : "I&#39;d replace list with hashset",
    "score" : 0,
    "owner" : {
      "account_id" : 3415144,
      "reputation" : 24365,
      "user_id" : 2864275,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f1f73deb5983ac46af2a74732752292e?s=256&d=identicon&r=PG",
      "display_name" : "Iłya Bursov",
      "link" : "https://stackoverflow.com/users/2864275/i%c5%82ya-bursov"
    },
    "creation_date" : 1746386818,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}