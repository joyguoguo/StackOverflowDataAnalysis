{
  "question" : {
    "question_id" : 79565803,
    "title" : "How to make sure that MapStruct uses method annotated with @ObjectFactory",
    "body" : "<p>I want to standardize my mapping processes to follow a particular scheme. Therefore I introduced a few generic interfaces that helps to reduce effort when writing new mappers for new types. Here is the interface for types:</p>\n<pre><code>import lombok.NonNull;\n\npublic interface MappableCyclic&lt;IN extends MappableCyclic&lt;IN&gt;&gt;\n{\n    void beforeMapping(@NonNull IN in, @NonNull ReferenceCycleTracking context);\n    void  afterMapping(@NonNull IN in, @NonNull ReferenceCycleTracking context);\n}\n</code></pre>\n<p><code>ReferenceCycleTracking</code> is a typical implementation for a mapstruct context to avoid infinite recursion when mapping objects with cyclic dependencies. In addition to that there is a generic super interface for mappers:</p>\n<pre><code>public interface MappableCyclicMapper&lt;IN extends MappableCyclic&lt;IN, OUT&gt;, OUT extends MappableCyclic&lt;OUT, IN&gt;&gt;\n{\n    @NonNull OUT map(@NonNull IN in, @NonNull @Context ReferenceCycleTracking context);\n\n    @BeforeMapping default void beforeMapping(\n            @NonNull                IN                     in,\n            @NonNull @MappingTarget OUT                    out,\n            @NonNull @Context       ReferenceCycleTracking context)\n    {\n        out.beforeMapping(out, in, context);\n    }\n\n    @AfterMapping default void afterMapping(\n            @NonNull                IN               in,\n            @NonNull @MappingTarget OUT              out,\n            @NonNull @Context ReferenceCycleTracking context)\n    {\n        out.afterMapping(out, in, context);\n    }\n\n    @NonNull Class&lt;OUT&gt; outType();\n    @NonNull OUT        create(IN in);\n\n    /**\n     * object factory should be called by mapstruct during generated {@link #map(MappableCyclic, ReferenceCycleTracking)}\n     * implementation\n     */\n    @ObjectFactory default @NonNull OUT lookupOrCreate(@NonNull IN in, @NonNull ReferenceCycleTracking context)\n    {\n        OUT out = context.get(in, outType());\n        if (out == null)\n        {\n            out = create(in);\n            context.put(in, out);\n        }\n        return out;\n    }\n}\n</code></pre>\n<p>And finally here is the mapper interface for two of my mappable types:</p>\n<pre><code>@Mapper interface Map_TaskGroup_EntityDTO_EntityJPA extends MappableCyclicMapper&lt;TaskGroupEntityDTO, TaskGroupEntityJPA&gt;\n{\n    Map_TaskGroup_EntityDTO_EntityJPA INSTANCE = Mappers.getMapper(Map_TaskGroup_EntityDTO_EntityJPA.class);\n\n    @NonNull TaskGroupEntityJPA map(@NonNull TaskGroupEntityDTO input, @NonNull @Context ReferenceCycleTracking context);\n\n    @Override default @NonNull Class&lt;TaskGroupEntityJPA&gt; outType() { return TaskGroupEntityJPA.class; }\n\n    @Override default @NonNull TaskGroupEntityJPA create(TaskGroupEntityDTO in) { return new TaskGroupEntityJPA(in.name()); }\n\n    @ObjectFactory\n    @Override default @NonNull TaskGroupEntityJPA lookupOrCreate(\n            @NonNull TaskGroupEntityDTO taskGroupEntityDTO, @NonNull ReferenceCycleTracking context)\n    {\n        return MappableCyclicMapper.super.lookupOrCreate(taskGroupEntityDTO, context);\n    }\n}\n</code></pre>\n<p>I expected that mapstruct would use the <code>@ObjectFactory</code> method provided in the super interface but it doesnÂ´t, so I tried to help mapstruct with an additional object factory method in the sub interface above. However the implementation for that interface generated by mapstruct ignores my object factory methods:</p>\n<pre><code>    @Override\n    public TaskGroupEntityJPA map(TaskGroupEntityDTO input, ReferenceCycleTracking context) {\n        TaskGroupEntityJPA target = context.get( input, TaskGroupEntityJPA.class );\n        if ( target != null ) {\n            return target;\n        }\n\n        if ( input == null ) {\n            return null;\n        }\n\n        String name = null;\n\n        TaskGroupEntityJPA taskGroupEntityJPA = new TaskGroupEntityJPA( name );\n\n        context.put( input, taskGroupEntityJPA );\n        beforeMapping( input, taskGroupEntityJPA, context );\n\n        afterMapping( input, taskGroupEntityJPA, context );\n\n        return taskGroupEntityJPA;\n    }\n</code></pre>\n<p>How can I make sure that my object factory methods are not ignored any longer?</p>\n",
    "tags" : [ "java", "generics", "mapstruct", "objectfactory" ],
    "owner" : {
      "account_id" : 8737131,
      "reputation" : 647,
      "user_id" : 6535384,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/a28b2c633bb377b977717a287b9fe7cc?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "r-uu",
      "link" : "https://stackoverflow.com/users/6535384/r-uu"
    },
    "is_answered" : true,
    "view_count" : 253,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1744540944,
    "creation_date" : 1744263717,
    "link" : "https://stackoverflow.com/questions/79565803/how-to-make-sure-that-mapstruct-uses-method-annotated-with-objectfactory",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79570281,
    "question_id" : 79565803,
    "body" : "<p>The reason why the object factory method is not taken into account is not because it is a <code>default</code> method in an interface. Rather, the <code>ReferenceCycleTracking</code> parameter is missing the annotation <code>@Context</code> in my example.</p>\n",
    "score" : 0,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 8737131,
      "reputation" : 647,
      "user_id" : 6535384,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/a28b2c633bb377b977717a287b9fe7cc?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "r-uu",
      "link" : "https://stackoverflow.com/users/6535384/r-uu"
    },
    "creation_date" : 1744451544,
    "last_activity_date" : 1744540944,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140319744,
    "post_id" : 79565803,
    "body" : "And as I pointed out -&gt; <b>Java doesn&#39;t inherit annotations on interfaces</b> . That is by design. I also stated that MapStruct probably doesn&#39;t do additional work for the <code>@ObjectFactory</code> which it does for the other ones. I would also suggest to try <b>without</b> Lombok annotations. Lombok is IMHO already a PITA combined with MapStruct it makes things even worse (I assume you have the proper configuration for that setup in the compiler plugin?).",
    "score" : 0,
    "owner" : {
      "account_id" : 3192259,
      "reputation" : 126826,
      "user_id" : 2696260,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/qHEzx.png?s=256",
      "display_name" : "M. Deinum",
      "link" : "https://stackoverflow.com/users/2696260/m-deinum"
    },
    "creation_date" : 1744278387,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140319728,
    "post_id" : 79565803,
    "body" : "In my comment I confirm your assumption that the <code>@BeforeMapping</code> and <code>@AfterMapping</code> annotations in super interfaces are taken into account by mapstruct. This is not the case with the <code>@OjectFactory</code> annotation (why?). Apart from that, I pointed out that it is not taken into account even if I place it directly in the mapper interface. At the next opportunity I will try to replace the interface with an abstract class, even if this is not necessary or even unattractive in my case. Whether it helps remains to be seen.",
    "score" : 0,
    "owner" : {
      "account_id" : 8737131,
      "reputation" : 647,
      "user_id" : 6535384,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/a28b2c633bb377b977717a287b9fe7cc?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "r-uu",
      "link" : "https://stackoverflow.com/users/6535384/r-uu"
    },
    "creation_date" : 1744278035,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140319524,
    "post_id" : 79565803,
    "body" : "Did you read my comment? Java doesn&#39;t inherit annotations on interfaces, so MapStruct must do additional work to detect those annotations. As I mentioned in my initial comment I suspect that additional work isn&#39;t done for the <code>@ObjectFactory</code> annotation. Hence my suggestion to use an <code>abstract</code> class instead of an interface to determine if that is indeed the case. Another thing is your class/interface is a bit of a annotation galore and includes Lombok, not sure if Lombok hides/destroys visibility here as well (wouldn&#39;t be the first time it did).",
    "score" : 0,
    "owner" : {
      "account_id" : 3192259,
      "reputation" : 126826,
      "user_id" : 2696260,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/qHEzx.png?s=256",
      "display_name" : "M. Deinum",
      "link" : "https://stackoverflow.com/users/2696260/m-deinum"
    },
    "creation_date" : 1744274943,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140319490,
    "post_id" : 79565803,
    "body" : "<code>@BeforeMapping</code> and <code>@AfterMapping</code> in super interfaces seems to be taken into  account in the generated mapper as desired, but <code>@ObjectFactory</code> isn&#39;t as the example from above shows. But even the <code>@ObjectFactory</code> annotated method in the <code>@Mapper</code> anntotated interface itself is ignored. So what am I missing? Is there any official description about this behaviour out there?",
    "score" : 0,
    "owner" : {
      "account_id" : 8737131,
      "reputation" : 647,
      "user_id" : 6535384,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/a28b2c633bb377b977717a287b9fe7cc?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "r-uu",
      "link" : "https://stackoverflow.com/users/6535384/r-uu"
    },
    "creation_date" : 1744274236,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140319049,
    "post_id" : 79565803,
    "body" : "Annotations on interfaces aren&#39;t inherited so the actual implementations so I suspect that is lost. I suspect that MapStruct does some additional work for the <code>@BeforeMapping</code> and <code>@AfterMapping</code> that is ignored for the <code>@ObjectFactory</code>. I suspect that it will work when using an <code>abstract</code> class instead of an interface.",
    "score" : 0,
    "owner" : {
      "account_id" : 3192259,
      "reputation" : 126826,
      "user_id" : 2696260,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/qHEzx.png?s=256",
      "display_name" : "M. Deinum",
      "link" : "https://stackoverflow.com/users/2696260/m-deinum"
    },
    "creation_date" : 1744266576,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}