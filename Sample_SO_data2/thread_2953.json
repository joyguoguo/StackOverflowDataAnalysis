{
  "question" : {
    "question_id" : 79585584,
    "title" : "403 Forbidden When Using @Async and DelegatingSecurityContextAsyncTaskExecutor despite SecurityContext Inheritance",
    "body" : "<p>I'm working on a Spring Boot application with a secured API using custom X-API-KEY authentication and method-level async execution for certain operations.</p>\n<p>I'm trying to confirm a payment intent via a secured endpoint (/api/payments/intents/{id}/confirm). The controller method returns a CompletableFuture, and internally it calls a service method annotated with @Async, which leverages a DelegatingSecurityContextAsyncTaskExecutor to preserve security context. Despite this setup, I'm consistently receiving a 403 Forbidden error when calling the endpoint. The authentication principal appears to be lost in the async flow.</p>\n<pre><code>{\n    &quot;timestamp&quot;: &quot;2025-04-22T01:33:05.355+00:00&quot;,\n    &quot;status&quot;: 403,\n    &quot;error&quot;: &quot;Forbidden&quot;,\n    &quot;path&quot;: &quot;/api/payments/intents/pi_bb6021bb-e32e-4afb-b80d-e8d38b9b5bc5/confirm&quot;\n}\n</code></pre>\n<pre><code>  @PatchMapping(&quot;/api/payments/intents/{id}/confirm&quot;)\n    public CompletableFuture&lt;EntityResponse&lt;PaymentIntentDto&gt;&gt; confirmPaymentIntent(@PathVariable String id, @RequestBody @Valid ConfirmPaymentIntent confirmPaymentIntent, @AuthenticationPrincipal CurrentAuth currentAuth) throws Exception {\n        log.info(&quot;Inside the @aa logic: {}&quot;, SecurityContextHolder.getContext().getAuthentication());\n\n        CompletableFuture&lt;EntityResponse&lt;PaymentIntentDto&gt;&gt; future = paymentCommandService.confirmPayment(new ConfirmPaymentCommand(id, confirmPaymentIntent.getPaymentMethodId(), currentAuth.merchantReferenceNumber()));\n        log.info(&quot;Inside the @aa2 logic: {}&quot;, SecurityContextHolder.getContext().getAuthentication());\n\n        return future;\n    }\n</code></pre>\n<pre><code>  @Async(&quot;delegatingSecurityContextAsyncTaskExecutor&quot;)\n    public CompletableFuture&lt;EntityResponse&lt;PaymentIntentDto&gt;&gt; confirmPayment(final ConfirmPaymentCommand confirmPaymentCommand) {\n\n        log.info(&quot;[Start] Confirming payment intent {}&quot;, confirmPaymentCommand.paymentIntentReferenceNumber());\n        log.info(&quot;Inside the @Async logic: {}&quot;, SecurityContextHolder.getContext().getAuthentication());\n\n\n\n    var merchantFuture =\n        CompletableFuture.supplyAsync(\n                        getMerchant(confirmPaymentCommand))\n            .thenCompose(merchantOpt -&gt; fromOptional(merchantOpt, MerchantNotFoundException::new));\n\n    var paymentIntentFuture =\n        merchantFuture\n            .thenCompose(\n                merchant -&gt;\n                    CompletableFuture.supplyAsync(\n                        getPaymentIntent(confirmPaymentCommand, merchant)))\n            .thenCompose(\n                paymentIntentOpt -&gt; fromOptional(paymentIntentOpt, PaymentIntentNotFound::new));\n\n    var paymentMethodFuture =\n        merchantFuture\n            .thenCompose(\n                merchant -&gt;\n                    CompletableFuture.supplyAsync(\n                        getPaymentMethod(confirmPaymentCommand, merchant)))\n            .thenCompose(\n                paymentMethodOpt -&gt; fromOptional(paymentMethodOpt, PaymentMethodNotFound::new));\n\n        // Combine paymentIntent and paymentMethod futures\n        return paymentIntentFuture.thenCombineAsync(paymentMethodFuture, (paymentIntent, paymentMethod) -&gt; {\n            // Validate and process paymentIntent\n            log.info(&quot;Inside the @Async2 logic: {}&quot;, SecurityContextHolder.getContext().getAuthentication());\n\n            paymentIntent.validate(paymentMethod);\n\n            PaymentStrategy paymentStrategy = paymentMethod.getPaymentStrategy(paymentFacade, paymentMethod.getPaymentGateway().name());\n\n                    NextAction nextAction = null;\n                    try {\n                        nextAction = paymentStrategy.nextAction(paymentIntent, paymentMethod, merchantFuture.join());\n                    } catch (Exception e) {\n                        throw new RuntimeException(e);\n                    }\n\n                    ConfirmedPayment confirmedPayment = paymentIntent.requiresAction(paymentMethod.getReferenceNumber());\n\n\n            PaymentIntent saved = paymentFacade.getPaymentIntentCommandRepository().save(paymentIntent);\n//\n//\n//            rabbitTemplate.convertAndSend(\n//                    confirmedPayment.getExchange(),\n//                    confirmedPayment.getRoutingKey(),\n//                    confirmedPayment\n//            );\n\n\n            PaymentIntentDto paymentIntentDto = buildDto(saved, nextAction);\n\n            log.info(&quot;[End] Confirmed payment intent {}&quot;, confirmPaymentCommand.paymentIntentReferenceNumber());\n\n            return new EntityResponse&lt;&gt;(\n                    saved.getReferenceNumber(),\n                    PAYMENT_INTENT,\n                    paymentIntentDto\n            );\n        },delegatingSecurityContextAsyncTaskExecutor)\n               ;\n    }\n</code></pre>\n<p>I have enabled the async configuration as seen below.</p>\n<pre><code>@EnableAsync\n@Configuration\npublic class ThreadPoolConfiguration {\n\n    @Bean\n    public InitializingBean initializingBean() {\n        return () -&gt; SecurityContextHolder.setStrategyName(\n                SecurityContextHolder.MODE_INHERITABLETHREADLOCAL);\n    }\n\n    @Bean\n    public ThreadPoolTaskExecutor confirmPaymentExecutor() {\n        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n        executor.setCorePoolSize(27);\n        executor.setMaxPoolSize(50);\n        executor.setQueueCapacity(100);\n        executor.setThreadNamePrefix(&quot;confirm-payment-&quot;);\n\n        return executor;\n    }\n\n    @Bean\n    public DelegatingSecurityContextAsyncTaskExecutor delegatingSecurityContextAsyncTaskExecutor(ThreadPoolTaskExecutor confirmPaymentExecutor) {\n        return new DelegatingSecurityContextAsyncTaskExecutor(confirmPaymentExecutor);\n    }\n\n}\n</code></pre>\n<p>Security Config</p>\n<pre><code>@Bean\n    @Order(1)\n    public SecurityFilterChain apiSecurityFilterChain(HttpSecurity http) throws Exception {\n\n        http\n                .formLogin(AbstractHttpConfigurer::disable)\n                .httpBasic(AbstractHttpConfigurer::disable)\n                .csrf(AbstractHttpConfigurer::disable)\n                .cors(Customizer.withDefaults())\n                .sessionManagement(session -&gt; session\n                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n                .headers(headers -&gt;\n                        headers.frameOptions(HeadersConfigurer.FrameOptionsConfig::disable) //needed for h2\n                )\n                .securityMatcher(&quot;/api/**&quot;)\n                .authorizeHttpRequests(registry -&gt; registry\n                        .requestMatchers(&quot;/api/**&quot;).hasAnyAuthority(&quot;API_ADMIN&quot;, &quot;API_MERCHANT&quot;)\n                )\n                .addFilterBefore(new ApiKeyFilter(merchantKeyCommandRepository), UsernamePasswordAuthenticationFilter.class);\n        return http.build();\n    }\n</code></pre>\n<p>API Key Filter</p>\n<pre><code>public class ApiKeyFilter extends OncePerRequestFilter {\n\n    private static final Logger log = LoggerFactory.getLogger(ApiKeyFilter.class);\n\n    private final MerchantKeyCommandRepository merchantKeyCommandRepository;\n\n\n    public ApiKeyFilter(MerchantKeyCommandRepository merchantKeyCommandRepository) {\n        this.merchantKeyCommandRepository = merchantKeyCommandRepository;\n    }\n\n    @Override\n    protected void doFilterInternal(\n        final HttpServletRequest request,\n        final HttpServletResponse response,\n        final FilterChain filterChain\n    ) throws ServletException, IOException {\n\n        try {\n\n            log.info(&quot;[Start] Filtering by api key {}&quot;,Thread.currentThread().getName());\n\n            String apiKey = request.getHeader(&quot;X-API-KEY&quot;);\n            if (apiKey == null) {\n                throw new BadCredentialsException(&quot;No X-API-KEY header found&quot;);\n            }\n\n            Optional&lt;MerchantKey&gt; merchantKeyOpt = merchantKeyCommandRepository.findByApiKey(apiKey);\n\n            if(merchantKeyOpt.isEmpty()){\n                throw new BadCredentialsException(&quot;Invalid API Key&quot;);\n            }\n\n            else if(!merchantKeyOpt.get().isEnabled()){\n                throw new MerchantKeyDisabledException();\n            }\n\n            final MerchantKey key = merchantKeyOpt.get();\n\n            Authentication authentication = new ApiKeyAuthenticationToken(\n                new CurrentAuth(\n                    key.getApiKey(),\n                    key.getSecretKey(),\n                    key.getMerchant().getReferenceNumber()\n                ),\n                key.getMerchantKeyPermissions()\n                    .stream()\n                    .map(permission -&gt; new SimpleGrantedAuthority(permission.name()))\n                    .toList()\n            );\n\n            SecurityContext context = SecurityContextHolder.createEmptyContext();\n            context.setAuthentication(authentication);\n\n            SecurityContextHolder.setContext(context);\n            filterChain.doFilter(request, response);\n\n        } catch (BadCredentialsException | MerchantKeyDisabledException exp) {\n            respondWithUnauthorized(request, response, exp);\n        }\n\n    }\n</code></pre>\n",
    "tags" : [ "java", "spring-boot", "spring-security" ],
    "owner" : {
      "account_id" : 11899514,
      "reputation" : 95,
      "user_id" : 8707914,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/3ced8d83a1ca2fd17d1638644affe541?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "fragilepriCe",
      "link" : "https://stackoverflow.com/users/8707914/fragileprice"
    },
    "is_answered" : false,
    "view_count" : 64,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1745286562,
    "creation_date" : 1745286562,
    "link" : "https://stackoverflow.com/questions/79585584/403-forbidden-when-using-async-and-delegatingsecuritycontextasynctaskexecutor-d",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140362502,
    "post_id" : 79585584,
    "body" : "read what i wrote... you most likely have the credentials, its just that the credentials might not be allowed to do what it is you want to do",
    "score" : 0,
    "owner" : {
      "account_id" : 2064278,
      "reputation" : 15107,
      "user_id" : 1840146,
      "user_type" : "registered",
      "accept_rate" : 86,
      "profile_image" : "https://i.sstatic.net/JXdxm.png?s=256",
      "display_name" : "Toerktumlare",
      "link" : "https://stackoverflow.com/users/1840146/toerktumlare"
    },
    "creation_date" : 1745429687,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140361039,
    "post_id" : 79585584,
    "body" : "The authentication should have been propagated to the async threads. I am not sure why i get 403",
    "score" : 0,
    "owner" : {
      "account_id" : 11899514,
      "reputation" : 95,
      "user_id" : 8707914,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/3ced8d83a1ca2fd17d1638644affe541?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "fragilepriCe",
      "link" : "https://stackoverflow.com/users/8707914/fragileprice"
    },
    "creation_date" : 1745405242,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140359160,
    "post_id" : 79585584,
    "body" : "403 usually means that you have presented some sort of credentials, but what you are doing is outside of the permission range of what your credentials allowes",
    "score" : 0,
    "owner" : {
      "account_id" : 2064278,
      "reputation" : 15107,
      "user_id" : 1840146,
      "user_type" : "registered",
      "accept_rate" : 86,
      "profile_image" : "https://i.sstatic.net/JXdxm.png?s=256",
      "display_name" : "Toerktumlare",
      "link" : "https://stackoverflow.com/users/1840146/toerktumlare"
    },
    "creation_date" : 1745352016,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}