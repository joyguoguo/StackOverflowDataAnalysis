{
  "question" : {
    "question_id" : 79772895,
    "title" : "Why does Java give a warning for casting Collection&lt;? extends Number&gt; to List&lt;Number&gt; but an error for assignment?",
    "body" : "<p>I’m trying to understand the difference between assignment and casting in Java generics. Consider the following examples:</p>\n<pre><code>List&lt;Integer&gt; ints = new ArrayList&lt;&gt;();\nList&lt;Number&gt; nums = ints; //Compile-time error\n</code></pre>\n<p>Even if the list contains only integers, the compiler throws an error. I understand this is because List&lt; Integer&gt; is not a subtype of List&lt; Number&gt;.</p>\n<pre><code>Collection&lt;? extends Number&gt; numbers = new ArrayList&lt;Integer&gt;();\nList&lt;Number&gt; nums = (List&lt;Number&gt;) numbers; //warning\n</code></pre>\n<p>Here, the compiler only gives a warning (unchecked cast), even though this cast could also lead to runtime errors if I try to add a Double to the list.</p>\n<p>Why does Java allow the cast with a warning but forbid the direct assignment with a compile-time error, even though both could be unsafe at runtime?</p>\n<p>What exactly is the difference in how the compiler treats assignments versus casts in the context of generics?</p>\n",
    "tags" : [ "java", "generics" ],
    "owner" : {
      "account_id" : 23624871,
      "reputation" : 450,
      "user_id" : 17657568,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/dca1bff50a3af1c3421aae288870e281?s=256&d=identicon&r=PG",
      "display_name" : "AMZ",
      "link" : "https://stackoverflow.com/users/17657568/amz"
    },
    "is_answered" : true,
    "view_count" : 194,
    "answer_count" : 3,
    "score" : 2,
    "last_activity_date" : 1759160174,
    "creation_date" : 1758647518,
    "link" : "https://stackoverflow.com/questions/79772895/why-does-java-give-a-warning-for-casting-collection-extends-number-to-listnu",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79773275,
    "question_id" : 79772895,
    "body" : "<p>The assignment fails because Java is <a href=\"https://en.wikipedia.org/wiki/Type_system#Static_type_checking\" rel=\"nofollow noreferrer\">statically typed</a>. The compiler will only allow assignments that are <em>guaranteed</em> to be type-safe.</p>\n<p>That said, casting is a way to tell the compiler you believe, rightfully or not, that you know more than it does. It is a clear indication to the compiler that you want to do something it can't guarantee is type-safe. Without a cast, the usual static type checking applies; if a type is not assignable to another type then the compiler won't allow it. With a cast, some of that static type checking is disabled.</p>\n<p>If the compiler cannot <em>statically</em> prove a specific cast will never succeed then it will allow the cast. If you're wrong about the cast then a <code>ClassCastException</code> will be thrown at run-time (via a <code>checkcast</code> instruction). That exception will be thrown <em>right when the cast occurs</em>. This means that even though the compiler could not catch the error, at least the run-time knows something is wrong immediately.</p>\n<p>However, generics complicate things. An instance of a generic class does not know its parameterization at run-time. For example, an <code>ArrayList&lt;String&gt;</code> <em>object</em> does not know it was parameterized with <code>String</code>. It only knows it's an <code>ArrayList</code>. This is known as &quot;type erasure&quot;. Yet casting is still a way to &quot;override&quot; the compiler's usual static type checking, therefore even with generics involved the compiler will still allow a cast it cannot statically prove is impossible. But type erasure makes it impossible to insert a <code>checkcast</code> instruction for the generics, so now the compiler may allow a cast that <em>won't</em> fail at run-time despite incompatible generics.</p>\n<p>This can lead to errors occurring elsewhere in the code, even code far removed from the root of the problem. Hence the compiler emits an unchecked cast warning basically saying, &quot;<em>I, the compiler, accept that you are overriding my usual static type checking but in this case not even the run-time is guaranteed to know if you're wrong. Please be cautious.</em>&quot;</p>\n<p>Note sometimes the compiler can statically prove a cast involving generics is fully compatible and thus will be type-safe assuming the cast between the raw types succeeds at run-time. In those cases the compiler will <em>not</em> emit an unchecked cast warning.</p>\n<hr />\n<p>In your example:</p>\n<blockquote>\n<pre class=\"lang-java prettyprint-override\"><code>Collection&lt;? extends Number&gt; numbers = new ArrayList&lt;Integer&gt;();\nList&lt;Number&gt; nums = (List&lt;Number&gt;) numbers; //warning\n</code></pre>\n</blockquote>\n<p>The compiler doesn't care (or really &quot;know&quot;) about the <code>new ArrayList&lt;Integer&gt;()</code> side when checking the <code>(List&lt;Number&gt;) numbers</code> cast. It only cares about the fact that the static type of <code>numbers</code> is <code>Collection&lt;? extends Number&gt;</code>. Since a cast from <code>Collection&lt;? extends Number&gt;</code> to <code>List&lt;Number&gt;</code> may be safe, the compiler allows you to do it (with a warning) on the assumption you know what you're doing.</p>\n",
    "score" : 2,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49904,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1758689694,
    "last_activity_date" : 1758696208,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79773033,
    "question_id" : 79772895,
    "body" : "<h2>Generics</h2>\n<p>I would recommend reading <a href=\"https://stackoverflow.com/questions/27606449/how-exactly-do-generics-work\">How exactly do Generics work?</a>. In a nut shell,  generics only exist at compile time and are erased in the final bytecode.</p>\n<p>Take the following code, for example:</p>\n<pre><code>List&lt;String&gt; list = new ArrayList&lt;String&gt;();\nlist.add(&quot;foo&quot;);\nString item = list.get(0);\n</code></pre>\n<p>When compiled to bytecode, it looks like this:</p>\n<pre><code>L0 {\n    new java/util/ArrayList\n    dup\n    invokespecial java/util/ArrayList.&lt;init&gt;()V\n    astore 1\n}\nL1 {\n    aload 1\n    ldc &quot;foo&quot; (java.lang.String)\n    invokeinterface java/util/List.add(Ljava/lang/Object;)Z\n    pop\n}\nL2 {\n    aload 1\n    iconst_0\n    invokeinterface java/util/List.get(I)Ljava/lang/Object;\n    checkcast java/lang/String\n    astore 2\n}\n</code></pre>\n<p>Notice how there are no generic types anywhere in this bytecode. Instead, the compiler has replaced all instances of generic types with the <code>Object</code> type. Take, for example, the call to <code>list.get(0)</code>, which returns <code>java/lang/Object</code> instead of <code>java/lang/String</code>. Since the generic types are known the compiler, it has added an extra operation to cast the Object to a String:</p>\n<pre><code>checkcast java/lang/String\n</code></pre>\n<p>So if we were to use a decompiler to reverse engineer this bytecode, we would get the following:</p>\n<pre><code>String item = (String) list.get(0);\n// notice the cast ^ which was not present in the original source code\n</code></pre>\n<p>This clearly demonstrates how generics really only serve as a syntactically pleasing methods of implicit casting that <em>prevent</em> you from shooting yourself in the foot, but do not stop you from doing so (if you decide to use explicit casts or reflection).</p>\n<h2>Your Code</h2>\n<p>Since generics ultimately become Objects when compiled, we can, with a slight modification, get your code to compile and run. All you have to do is mask those generic types to the compiler with a cast to <code>Object</code> and then cast back to your desired generically-typed list:</p>\n<pre><code>List&lt;Integer&gt; ints = new ArrayList&lt;&gt;();\nList&lt;Number&gt; nums = (List&lt;Number&gt;) (Object) ints;\n// Mask the generic types with a cast ^ to object\n</code></pre>\n<p>The compiler is still smart enough to raise an &quot;unchecked cast&quot; warning, but it will not stop you from compiling this code. The reason it raised an error with your original code is because you didn't cast at all. My guess is that this lack of a cast made the compiler identify your assignment operation as an unintentional oversight.</p>\n<p>As for the example of casting from <code>Collection&lt;? extends Number&gt;</code> to <code>List&lt;Number&gt;</code>, I'm honestly not sure what is going on behind the scenes here. I usually have a pretty good understanding of what source code is actually doing when compiled to bytecode, but I'm not as well versed on what happens in the compiler itself. I will let someone else answer this facet of your question :^)</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 7421543,
      "reputation" : 3594,
      "user_id" : 5645656,
      "user_type" : "registered",
      "accept_rate" : 100,
      "profile_image" : "https://i.sstatic.net/cWJZKa1g.png?s=256",
      "display_name" : "Cardinal System",
      "link" : "https://stackoverflow.com/users/5645656/cardinal-system"
    },
    "creation_date" : 1758658112,
    "last_activity_date" : 1758658588,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79773220,
    "question_id" : 79772895,
    "body" : "<p>Without your feedback, I'm not going to address the casting because I feel that might not be what is causing confusion (but could certainly be wrong).  The way I read your question is that you believe your second bit of code to be the solution to the first and you're wondering why.</p>\n<p>If I'm correct, I would point out that the following modification to your first example works:</p>\n<pre><code>List&lt;Integer&gt; ints = new ArrayList&lt;&gt;();\nints.add(1);\nList&lt;? extends Number&gt; nums = ints; // No compile-time error\n</code></pre>\n<p>I'm pointing this out because you state &quot;<code>List&lt;Integer&gt;</code> is not a subtype of <code>List&lt;Number&gt;</code>&quot; which is correct but seems to imply that you expect it to be.  Rather, it is simply because <code>Integer</code> is not the same class as <code>Number</code> and the compiler is telling you that have defined your lists to only contain those things and they are not equal.</p>\n<p>In my code above, you're telling the compiler &quot;In the second list, go ahead and allow objects whose class extends Number&quot; - it happily complies.</p>\n<p>Let me know if I'm on the right track or not and I will amend/append my answer appropriately.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 5584785,
      "reputation" : 139,
      "user_id" : 4425544,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/946c068ad6ee30c5814968803f2cab91?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "kansasSamurai",
      "link" : "https://stackoverflow.com/users/4425544/kansassamurai"
    },
    "creation_date" : 1758680840,
    "last_activity_date" : 1759160174,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140755303,
    "post_id" : 79772895,
    "body" : "&quot;<i>this cast could also lead to runtime errors if I try to add a Double to the list.</i>&quot; -- well no, at least not directly.  Java&#39;s implementation of generics employs type erasure.  The JVM does not know at runtime that the <code>List</code> was declared as a <code>List&lt;Integer&gt;</code>.  It will accept any <code>Object</code> that is presented to it.  Substantially all the magic of generics happens in the compiler.  What <i>could</i> happen is that you add a <code>Double</code> via the <code>nums</code> reference, and then run into trouble by retrieving it via the <code>ints</code> reference into code that (therefore) assumes it can only be an <code>Integer</code>.",
    "score" : 2,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1758650552,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140755256,
    "post_id" : 79772895,
    "body" : "If the compiler knows the full type of the list if <code>List&lt;Integer&gt;</code>, there is no possibility that it can be <code>List&lt;Number&gt;</code>, so that assignment generates an error.  However, <code>Collection&lt;? extends Number&gt;</code> means “I don’t know what the exact type is;  it might be Number or Integer or Double etc.”  So it is <i>possible</i> that the exact type of the collection is in fact <code>Collection&lt;Number&gt;</code>.  Since the compiler can’t know for certain if it’s an error, the compiler generates a warning instead.",
    "score" : 3,
    "owner" : {
      "account_id" : 2053598,
      "reputation" : 44991,
      "user_id" : 1831987,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/38b1c37530189ec4471a43a618e33f67?s=256&d=identicon&r=PG",
      "display_name" : "VGR",
      "link" : "https://stackoverflow.com/users/1831987/vgr"
    },
    "creation_date" : 1758649432,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140755232,
    "post_id" : 79772895,
    "body" : "A cast indicates you are consciously accepting the risk, explicitly choosing the unsafe conversion.  An assignment could just be because you think it&#39;s safe.",
    "score" : 6,
    "owner" : {
      "account_id" : 465573,
      "reputation" : 200423,
      "user_id" : 869736,
      "user_type" : "registered",
      "accept_rate" : 82,
      "profile_image" : "https://www.gravatar.com/avatar/ae7bb06b9a23a4dd7eea69e853d47d12?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Louis Wasserman",
      "link" : "https://stackoverflow.com/users/869736/louis-wasserman"
    },
    "creation_date" : 1758648969,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79773220" : [ {
      "comment_id" : 140764378,
      "post_id" : 79773220,
      "body" : "&quot;&quot;List&lt;Integer&gt; is not a subtype of List&lt;Number&gt;&quot; which is incorrect&quot; It is correct.",
      "score" : 2,
      "owner" : {
        "account_id" : 31622,
        "reputation" : 123161,
        "user_id" : 86989,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/4bd262de5d82a235eeb64f71e4058198?s=256&d=identicon&r=PG",
        "display_name" : "newacct",
        "link" : "https://stackoverflow.com/users/86989/newacct"
      },
      "creation_date" : 1759027271,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79773275" : [ {
      "comment_id" : 140764850,
      "post_id" : 79773275,
      "body" : "@Slaw Thanks. Now I understand that you pointed to this in your earlier comments. Please add these details to your accepted answer so that others can use it.",
      "score" : 0,
      "owner" : {
        "account_id" : 23624871,
        "reputation" : 450,
        "user_id" : 17657568,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/dca1bff50a3af1c3421aae288870e281?s=256&d=identicon&r=PG",
        "display_name" : "AMZ",
        "link" : "https://stackoverflow.com/users/17657568/amz"
      },
      "creation_date" : 1759067207,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140764382,
      "post_id" : 79773275,
      "body" : "@AMZ We cannot cast <code>List&lt;Number&gt;</code> to <code>List&lt;Integer&gt;</code> (or vice versa) because nothing can be both a <code>List&lt;Number&gt;</code> and a <code>List&lt;Integer&gt;</code> at the same time. Each <code>List</code> object has, in principle, a specific type argument, and a generic type of one specific type argument is not a subtype of a generic type of a different specific type argument. So this cast is provably wrong at compile time. On the other hand, a cast from <code>List&lt;? extends Number&gt;</code> to <code>List&lt;Integer&gt;</code> is not provably wrong, because it&#39;s possible for something to be both a <code>List&lt;? extends Number&gt;</code> and a <code>List&lt;Integer&gt;</code> (e.g `List&lt;Integ",
      "score" : 1,
      "owner" : {
        "account_id" : 31622,
        "reputation" : 123161,
        "user_id" : 86989,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/4bd262de5d82a235eeb64f71e4058198?s=256&d=identicon&r=PG",
        "display_name" : "newacct",
        "link" : "https://stackoverflow.com/users/86989/newacct"
      },
      "creation_date" : 1759027858,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140764122,
      "post_id" : 79773275,
      "body" : "...that says it&#39;s a list of numbers. This can lead to problems down the road. Yet casting <code>numbers</code> to a <code>List&lt;Integer&gt;</code> is still fully type-safe in this case. That&#39;s why the compiler allows the cast but with a warning. The cast <i>may</i> be type-safe but neither the compiler nor the run-time can <i>guarantee</i> it.",
      "score" : 1,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49904,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1759004701,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140764119,
      "post_id" : 79773275,
      "body" : "Casting <code>numbers</code> to a <code>List&lt;Integer&gt;</code> will be allowed by the compiler, succeed at run-time, and ultimately be type-safe. While the compiler only cares about the reference types, this example may be confusing things slightly. Say you have <code>List&lt;Integer&gt; integers = new ArrayList&lt;&gt;();</code> and <code>Collection&lt;? extends Number&gt; numbers = integers;</code>. You now have two references to the same object, and that object is being treated as a list of integers. It&#39;s type-safe code. But you can cast <code>numbers</code> to a <code>List&lt;Number&gt;</code> and now have a reference to the object that says it&#39;s a list of integers and another...",
      "score" : 1,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49904,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1759004588,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140764115,
      "post_id" : 79773275,
      "body" : "@AMZ Using your example: <code>Collection&lt;? extends Number&gt; numbers = new ArrayList&lt;Integer&gt;();</code>. Casting <code>numbers</code> to <code>Set&lt;Number&gt;</code> will be allowed by the compiler but fail at run-time with a <code>ClassCastException</code> because an <code>ArrayList</code> is not a <code>Set</code>. In constrast, casting it to <code>List&lt;Number&gt;</code> will be allowed by the compiler <i>and will succeed at run-time</i> because an <code>ArrayList</code> is a <code>List</code>. Despite the cast succeeding you now have broken code; the run-time can&#39;t distinguish between the <i>object</i> being an <code>ArrayList&lt;Integer&gt;</code> versus an <code>ArrayList&lt;Number&gt;</code>. That&#39;s why the compiler emits a warning.",
      "score" : 1,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49904,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1759004357,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140763517,
      "post_id" : 79773275,
      "body" : "@Slaw Thanks, but what I mean is that because the compiler only looks at the reference type and sees it as Collection&lt;? extends Number&gt;, it assumes that the type could be Number or any of its subclasses. If it’s one of the subclasses, then the cast will definitely be unsafe and rejected at runtime. But if it’s actually Number itself, then we can safely cast a Collection&lt;Number&gt; to List&lt;Number&gt;. Because of this, the compiler assumes: “Maybe this collection is a List&lt;Number&gt;, so I can’t forbid the cast, but I’ll warn you that it might instead be a List&lt;Integer&gt; or List&lt;Double&gt;, so be careful.”",
      "score" : 0,
      "owner" : {
        "account_id" : 23624871,
        "reputation" : 450,
        "user_id" : 17657568,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/dca1bff50a3af1c3421aae288870e281?s=256&d=identicon&r=PG",
        "display_name" : "AMZ",
        "link" : "https://stackoverflow.com/users/17657568/amz"
      },
      "creation_date" : 1758973649,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140760441,
      "post_id" : 79773275,
      "body" : "But since that can&#39;t be fully checked at run-time, the compiler emits a warning. Keep in mind that non-wildcard generic type arguments are invariant in Java. Wildcards introduce <a href=\"https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\" rel=\"nofollow noreferrer\">variance</a>. Also note that Java only has use-site variance for generics; it doesn&#39;t have declaration-site variance (other languages, such as Kotlin, have both).",
      "score" : 0,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49904,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1758831337,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140760431,
      "post_id" : 79773275,
      "body" : "@AMZ Mostly correct, if I understand you correctly. But to clarify, a <code>List&lt;? extends Number&gt;</code> does not mean the list is a list of any and all <code>Number</code> types (that&#39;s what <code>List&lt;Number&gt;</code> means). It means the list is a list of a <b><i>specific</b> but unknown</i> element type that is at least &quot;compatible&quot; with <code>Number</code>. In other words, the &quot;real list&quot; could be <code>List&lt;Number&gt;</code>, <code>List&lt;Integer&gt;</code>, <code>List&lt;Double&gt;</code>, and so on (that&#39;s why you can&#39;t <i>add</i> elements to such a list). So, you can cast <code>List&lt;? extends Number&gt;</code> to <code>List&lt;Integer&gt;</code> because it may actually be a <code>List&lt;Integer&gt;</code>.",
      "score" : 2,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49904,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1758830973,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140759478,
      "post_id" : 79773275,
      "body" : "So to summarize your answer, we cannot cast &#39;List &lt;Number&gt;&#39; to &#39;List&lt;integer&gt;&#39; because it may contain any data type other than Integer, but &#39;List&lt;? extends Number&gt;&#39; can be cast, not because Integer is allowed here, but because &#39;?&#39; may be of the Number type itself. That is why it warns, otherwise if we remove Number from these types and only include subclasses of Number, then definitely casting will not work and will give an error.",
      "score" : 0,
      "owner" : {
        "account_id" : 23624871,
        "reputation" : 450,
        "user_id" : 17657568,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/dca1bff50a3af1c3421aae288870e281?s=256&d=identicon&r=PG",
        "display_name" : "AMZ",
        "link" : "https://stackoverflow.com/users/17657568/amz"
      },
      "creation_date" : 1758805848,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140756145,
      "post_id" : 79773275,
      "body" : "(although I am only talking about casting in the context of Java where it&#39;s always just a &quot;hint&quot; to the compiler, with some run-time checks, that you want to treat the object as a different type; analogous to C++&#39;s <code>dynamic_cast</code> if I&#39;m not mistaken)",
      "score" : 1,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49904,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1758696566,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140756121,
      "post_id" : 79773275,
      "body" : "True, but at that point why use a statically typed language at all? The point I&#39;m trying to make in my answer is that casting is for <i>explicitly</i> side-stepping some of the static type checking done by the compiler. That should also explain, or at least imply, why the assignment fails. Without a cast, the compiler only allows fully guaranteed type-safe assignments, as that&#39;s just how statically typed languages work. And I wanted to answer at a more conceptual level, so I avoided referencing the JLS.",
      "score" : 3,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49904,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1758695778,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140756116,
      "post_id" : 79773275,
      "body" : "but the compiler could also assume &quot;<i>you know what you&#39;re doing</i>&quot; for the assignment (part of the question was why <i>the assignment is forbidden</i>)",
      "score" : 1,
      "owner" : {
        "account_id" : 31180,
        "reputation" : 29752,
        "user_id" : 85421,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/kKvXH.gif?s=256",
        "display_name" : "user85421",
        "link" : "https://stackoverflow.com/users/85421/user85421"
      },
      "creation_date" : 1758695481,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}