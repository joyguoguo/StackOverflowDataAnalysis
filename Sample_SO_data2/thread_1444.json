{
  "question" : {
    "question_id" : 79709515,
    "title" : "Quarkus Mutiny and Vertx Thread blocking while calling multiple API concurrency on a GCP Cloudrun",
    "body" : "<p>I developped a small application to reproduce and try to fix a big performance issue on a big project.\nOn my project, I need to do a fire-and-forget webservice that will consume a String, parse it, and retrieve information from 2 differents remote API so I can use them on a Mapstruct mapper.</p>\n<p>This is my simple controller</p>\n<pre><code>import io.smallrye.mutiny.Uni;\nimport jakarta.inject.Inject;\nimport jakarta.ws.rs.Consumes;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.core.MediaType;\nimport jakarta.ws.rs.core.Response;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.io.IOException;\nimport java.util.UUID;\n\n...\n\n@POST\n@Path(&quot;/test&quot;)\n@Consumes(MediaType.APPLICATION_JSON)\npublic Uni&lt;Response&gt; sendInfologOrderReleaseTest(Apin2Request message) throws InterruptedException {\n\n    infologOrderReleaseService.test(message.getContent())\n            .subscribe()\n            .with(\n                    result -&gt; {\n                    }, // ignore\n                    failure -&gt; log.error(&quot;Fire-and-forget failed&quot;, failure)\n            );\n    return Uni.createFrom().item(Response.accepted().build());\n}\n</code></pre>\n<p>it callings a service</p>\n<pre><code>import io.smallrye.mutiny.Uni;\nimport jakarta.ws.rs.core.Response;\nimport lombok.extern.slf4j.Slf4j;\n\nimport java.util.ArrayList;\nimport java.util.List;\n...\n    public Uni&lt;OrderReleaseDto&gt; test(String content) {\n    log.info(&quot;starting test&quot;);\n    Uni&lt;List&lt;SiteDTO&gt;&gt; sourceSiteUni = testClient.getFilteredRdoSiteTransco();\n    Uni&lt;List&lt;SiteDTO&gt;&gt; destinationSiteUni = testClient.getFilteredRdoSiteTransco();\n    return Uni.combine().all().unis(sourceSiteUni, destinationSiteUni)\n            .with((source, destination) -&gt; {\n                log.info(&quot;starting mapping for source: {}, destination: {}&quot;, source.size(), destination.size());\n                log.info(&quot;end mapping&quot;);\n                return OrderReleaseDto.builder().build();\n            });\n\n}\n</code></pre>\n<p>which itself call the same webservice (for test purpose)</p>\n<pre><code>import io.smallrye.mutiny.Uni;\nimport jakarta.enterprise.inject.Default;\nimport jakarta.ws.rs.GET;\nimport org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n\nimport java.util.List;\n\n@Default\n@RegisterRestClient(configKey = &quot;rdo-site-transco&quot;)\npublic interface TestClient {\n\n    @GET\n    Uni&lt;List&lt;SiteDTO&gt;&gt; getFilteredRdoSiteTransco();\n}\n</code></pre>\n<p>On Intellij, i encounter no issues, it retrieve perfectly and instantly the responses, and I can proceed how I want. But as soon as it is deployed on a Google Cloud Run, i encounter some kind of thread leaking, and I got a Vertx Thread blocked warning</p>\n<pre><code>2025-07-21 20:28:46.382 HAEC\n2025-07-21 18:28:46,182 WARN [io.ver.cor.imp.BlockedThreadChecker] (vertx-blocked-thread-checker) Thread Thread[vert.x-eventloop-thread-1,5,main] has been blocked for 10594 ms, time limit is 2000 ms: io.vertx.core.VertxException: Thread blocked\n2025-07-21 20:28:46.383 HAEC\nat java.base/java.io.RandomAccessFile.readBytes0(Native Method)\n2025-07-21 20:28:46.383 HAEC\nat java.base/java.io.RandomAccessFile.readBytes(RandomAccessFile.java:400)\n2025-07-21 20:28:46.383 HAEC\nat java.base/java.io.RandomAccessFile.read(RandomAccessFile.java:434)\n2025-07-21 20:28:46.383 HAEC\nat java.base/java.io.RandomAccessFile.readFully(RandomAccessFile.java:498)\n2025-07-21 20:28:46.383 HAEC\nat java.base/java.util.zip.ZipFile$Source.readFullyAt(ZipFile.java:1528)\n2025-07-21 20:28:46.383 HAEC\nat java.base/java.util.zip.ZipFile$ZipFileInputStream.initDataOffset(ZipFile.java:930)\n2025-07-21 20:28:46.383 HAEC\nat java.base/java.util.zip.ZipFile$ZipFileInputStream.read(ZipFile.java:946)\n2025-07-21 20:28:46.383 HAEC\nat java.base/java.util.zip.ZipFile$ZipFileInflaterInputStream.fill(ZipFile.java:463)\n2025-07-21 20:28:46.383 HAEC\nat java.base/java.util.zip.InflaterInputStream.read(InflaterInputStream.java:175)\n2025-07-21 20:28:46.383 HAEC\nat io.quarkus.bootstrap.runner.JarResource$JarResourceDataProvider.apply(JarResource.java:73)\n2025-07-21 20:28:46.383 HAEC\nat io.quarkus.bootstrap.runner.JarResource$JarResourceDataProvider.apply(JarResource.java:59)\n2025-07-21 20:28:46.383 HAEC\nat io.quarkus.bootstrap.runner.JarFileReference.consumeSharedJarFile(JarFileReference.java:169)\n2025-07-21 20:28:46.383 HAEC\nat io.quarkus.bootstrap.runner.JarFileReference.withJarFile(JarFileReference.java:135)\n2025-07-21 20:28:46.383 HAEC\nat io.quarkus.bootstrap.runner.JarResource.getResourceData(JarResource.java:56)\n2025-07-21 20:28:46.383 HAEC\nat io.quarkus.bootstrap.runner.RunnerClassLoader.loadClass(RunnerClassLoader.java:106)\n2025-07-21 20:28:46.383 HAEC\nat io.quarkus.bootstrap.runner.RunnerClassLoader.loadClass(RunnerClassLoader.java:72)\n2025-07-21 20:28:46.383 HAEC\nat io.netty.handler.ssl.SslHandler$SslEngineType.forEngine(SslHandler.java:360)\n2025-07-21 20:28:46.383 HAEC\nat io.netty.handler.ssl.SslHandler.&lt;init&gt;(SslHandler.java:480)\n2025-07-21 20:28:46.383 HAEC\nat io.netty.handler.ssl.SslContext.newHandler(SslContext.java:1076)\n2025-07-21 20:28:46.383 HAEC\nat io.netty.handler.ssl.DelegatingSslContext.newHandler(DelegatingSslContext.java:100)\n2025-07-21 20:28:46.383 HAEC\nat io.netty.handler.ssl.SslContext.newHandler(SslContext.java:1071)\n2025-07-21 20:28:46.383 HAEC\nat io.vertx.core.net.impl.SslChannelProvider.createClientSslHandler(SslChannelProvider.java:141)\n2025-07-21 20:28:46.383 HAEC\nat io.vertx.core.net.impl.ChannelProvider.initSSL(ChannelProvider.java:109)\n2025-07-21 20:28:46.383 HAEC\nat io.vertx.core.net.impl.ChannelProvider.access$200(ChannelProvider.java:41)\n</code></pre>\n<p>It is not a connection issue because I tried on two differents environment (enterprise and personal environment), and this issue is a reproduction of an enterprise project.\nI tried optimising cloud run specs, or thread management with runOnSubscribtion for blocking task, but nothing let me go through.</p>\n<p>I also tried with @Blocking or @NonBlocking, with WebClient from mutiny.vertx with vertx injection. I am lost and I have no more idea to beat that.</p>\n<p>I use latest version of quarkus and JDK 21.\nEverthing is up-to-date.</p>\n<p>Any help please ? Thank !</p>\n",
    "tags" : [ "java", "quarkus", "google-cloud-run", "vert.x", "mutiny" ],
    "owner" : {
      "account_id" : 14832147,
      "reputation" : 452,
      "user_id" : 10711346,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/BleVD.jpg?s=256",
      "display_name" : "Robyn.D",
      "link" : "https://stackoverflow.com/users/10711346/robyn-d"
    },
    "is_answered" : false,
    "view_count" : 169,
    "answer_count" : 1,
    "score" : 1,
    "last_activity_date" : 1753224945,
    "creation_date" : 1753123463,
    "link" : "https://stackoverflow.com/questions/79709515/quarkus-mutiny-and-vertx-thread-blocking-while-calling-multiple-api-concurrency",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79711133,
    "question_id" : 79709515,
    "body" : "<p>When a thread is blocked, it means it cannot continue its execution. This issue can occur for various reasons, such as synchronization problems, resource contention, deadlock situations, or even a known <a href=\"https://docs.quarkiverse.io/quarkus-cxf/dev/release-notes/3.17.0.html#_bugfixes_in_quarkus_cxf\" rel=\"nofollow noreferrer\">bug</a> in <strong>Quarkus</strong>. Additionally, there might be a blocking API call somewhere in your <code>OrderReleaseDto.builder().build()</code> method or elsewhere.</p>\n<p>I came across this <a href=\"https://vertx.io/docs/vertx-core/java/#golden_rule\" rel=\"nofollow noreferrer\">article</a> from Vert.x about a golden rule, maybe it will help. It also mentions that you can turn off those warnings or adjust the settings. See also this <a href=\"https://github.com/quarkusio/quarkus/issues/17631\" rel=\"nofollow noreferrer\">discussion</a> from GitHub.</p>\n<p>You mentioned that it works in IntelliJ (local environment) possibly because it has more CPU cores and experiences less contention than your Cloud Run service.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 34448633,
      "reputation" : 676,
      "user_id" : 26575637,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/itZdNU2j.webp?s=256",
      "display_name" : "HerPat",
      "link" : "https://stackoverflow.com/users/26575637/herpat"
    },
    "creation_date" : 1753224945,
    "last_activity_date" : 1753224945,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79711133" : [ {
      "comment_id" : 140613140,
      "post_id" : 79711133,
      "body" : "The OrderReleaseDto builder is just here to return something. It is a lombok builder, nothing too fancy.  I found a solution to my problem, which is not THE response to my main issue, but i was compiling my application with JVM and then in a docker image, then deploying in a GCP cloud run.   Now I am building in native with GraalVM and it works great.   I will open an issue on the github page of quarkus, there might be an issue with thread management in a coud contexte.",
      "score" : 0,
      "owner" : {
        "account_id" : 14832147,
        "reputation" : 452,
        "user_id" : 10711346,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/BleVD.jpg?s=256",
        "display_name" : "Robyn.D",
        "link" : "https://stackoverflow.com/users/10711346/robyn-d"
      },
      "creation_date" : 1753300238,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}