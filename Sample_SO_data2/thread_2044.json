{
  "question" : {
    "question_id" : 79655641,
    "title" : "Why can&#39;t I affect List&lt;ConcreteClass&gt; to a variable of type List&lt;Interface&gt;?",
    "body" : "<p>I have an interface I which is implemented by two classes C1 and C2.</p>\n<p>I have that code, and I don't understand why some don't:</p>\n<pre><code>// works, of course\nList&lt;C1&gt; list = List.of(new C1());\nList&lt;C1&gt; list = List.of(new C1()).stream().toList();\n\n// works, too, but why, considering the ones below that don't?\nList&lt;I&gt; list = List.of(new C1());\n\n// doesn't compile, why?\nList&lt;I&gt; list = List.of(new C1()).stream().toList();\nList&lt;I&gt; list = List.of(new C2()).stream().toList();\n\n// but this works, why?\nList&lt;I&gt; list = List.of(new C2()).stream().collect(Collectors.toList());\n\n// works, again why?\nList&lt;I&gt; list = new ArrayList&lt;&gt;();\nList.of(new C1()).stream().forEach(c1 -&gt; list.add(c1)).toList();\n\n// works\nList&lt;I&gt; list = List.of(new C1(), new C2()).stream().toList();\n</code></pre>\n<p>I don't understand why the lines 4, 5 don't compile while the 3, 6, 7 do. Both should compile, or none should.</p>\n<p>It seems the compiler realizes that I have only C1 instances and forces me to use <code>List&lt;C1&gt;</code>, which is understandable, but then why does it not forces the same for line 3, 6, 7?</p>\n<p>I have similar behavior with Stream instead of List, but it's inconsistent. for example:</p>\n<pre><code>private Stream&lt;I&gt; aa() {\n  return Stream.of(new C1()); // works\n  return List.of(new C1()).stream() // doesn't\n  return List.of(new C1()).stream().map(a-&gt;a) // works, why?\n}\n</code></pre>\n<p>If I change the return type to <code>Stream&lt;C1&gt;</code>, the compiler is fine, so it does understand that I actually return only C1 in my stream, but sometimes it forces me to, and others it doesn't. Why?</p>\n",
    "tags" : [ "java", "inheritance" ],
    "owner" : {
      "account_id" : 16478911,
      "reputation" : 413,
      "user_id" : 11906121,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/c6320114c699f06d4038d99c1a9273f6?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "elcye",
      "link" : "https://stackoverflow.com/users/11906121/elcye"
    },
    "is_answered" : true,
    "view_count" : 112,
    "answer_count" : 1,
    "score" : 2,
    "last_activity_date" : 1749202152,
    "creation_date" : 1749199489,
    "link" : "https://stackoverflow.com/questions/79655641/why-cant-i-affect-listconcreteclass-to-a-variable-of-type-listinterface",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79655705,
    "question_id" : 79655641,
    "body" : "<p>In both cases, the result is a <code>Stream&lt;C1&gt;</code>.<br /><br />\n<strong>But:</strong></p>\n<ul>\n<li><code>Stream.of(new C1())</code> can be interpreted as <code>Stream&lt;I&gt;</code> because the method is generic and the compiler can infer the type parameter as <code>I</code> if needed.</li>\n<li><code>List.of(new C1()).stream()</code> always returns a <code>Stream&lt;C1&gt;</code>, and you cannot assign a <code>Stream&lt;C1&gt;</code> to a <code>Stream&lt;I&gt;</code> variable or return type.\n<br /></li>\n</ul>\n<p>In other words:</p>\n<ul>\n<li><code>Stream.of(new C1())</code> can be interpreted as <code>Stream.of&lt;I&gt;(new C1())</code> due to type inference.</li>\n<li><code>List.of(new C1()).stream()</code> returns a <code>Stream&lt;C1&gt;</code>, and you cannot assign a <code>Stream&lt;String&gt;</code> to a <code>Stream&lt;Object&gt;</code>.</li>\n</ul>\n<p>As for the last return row:</p>\n<ul>\n<li>The <code>.map(a -&gt; a)</code> can be interpreted as mapping from <code>C1</code> to <code>I</code> (since every <code>C1</code> is an <code>I</code>).</li>\n<li>The compiler sees that the expected return type is <code>Stream&lt;I&gt;</code>, so it infers the lambda as <code>Function&lt;C1, I&gt;</code>.</li>\n<li>Therefore, the resulting stream is a <code>Stream&lt;I&gt;</code>.</li>\n</ul>\n",
    "score" : 4,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 14331879,
      "reputation" : 346,
      "user_id" : 10352428,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/619aa63a0625944a2aa2fd0fdacb95cb?s=256&d=identicon&r=PG",
      "display_name" : "萝莉w",
      "link" : "https://stackoverflow.com/users/10352428/%e8%90%9d%e8%8e%89w"
    },
    "creation_date" : 1749202020,
    "last_activity_date" : 1749202020,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140492834,
    "post_id" : 79655641,
    "body" : "(counter)example for the question in the title: a basket of apples is not a basket of fruits - you cannot add oranges to the first, while it is OK for the second - if it were allowed to assign the first to the second, you could add the orange to it, and, since it is still the same instance, the first would also contain the added orange",
    "score" : 0,
    "owner" : {
      "account_id" : 31180,
      "reputation" : 29752,
      "user_id" : 85421,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/kKvXH.gif?s=256",
      "display_name" : "user85421",
      "link" : "https://stackoverflow.com/users/85421/user85421"
    },
    "creation_date" : 1749205306,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140492740,
    "post_id" : 79655641,
    "body" : "Compare to <a href=\"https://stackoverflow.com/questions/40500280/comparing-and-thencomparing-gives-compile-error\">comparing and thenComparing gives compile error</a>",
    "score" : 1,
    "owner" : {
      "account_id" : 7612423,
      "reputation" : 87409,
      "user_id" : 5772882,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/8283c64511fa80afed5259d10850168f?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Anonymous",
      "link" : "https://stackoverflow.com/users/5772882/anonymous"
    },
    "creation_date" : 1749203621,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140492726,
    "post_id" : 79655641,
    "body" : "Java’s generic type inference is complicated, and I don’t expect to understand all of it ever. Java applies information from the left side of an assignment when inferring types on the right side (this is why you can use the diamond operator, <code>&lt;&gt;</code>, when the type is already given on the left side). So in <code>List&lt;I&gt; list = List.of(new C1());</code>, from <code>&lt;I&gt;</code> Java can assume <code>List.&lt;I&gt;of()</code>, and since <code>C1</code> is an <code>I</code>, it works. With the stream operation this no longer works: Java can only use <code>C1</code> to infer the element type of the list.",
    "score" : 0,
    "owner" : {
      "account_id" : 7612423,
      "reputation" : 87409,
      "user_id" : 5772882,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/8283c64511fa80afed5259d10850168f?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Anonymous",
      "link" : "https://stackoverflow.com/users/5772882/anonymous"
    },
    "creation_date" : 1749203480,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140492705,
    "post_id" : 79655641,
    "body" : "Related: <a href=\"https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super\">What is PECS (Producer Extends Consumer Super)?</a>",
    "score" : 0,
    "owner" : {
      "account_id" : 7612423,
      "reputation" : 87409,
      "user_id" : 5772882,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/8283c64511fa80afed5259d10850168f?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Anonymous",
      "link" : "https://stackoverflow.com/users/5772882/anonymous"
    },
    "creation_date" : 1749203184,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140492613,
    "post_id" : 79655641,
    "body" : "I&#39;ve read it, and reread it. It explains why some cases don&#39;t work, but not why similar cases do work when, by the same logic, they shouldn&#39;t. Why does <code>Stream&lt;I&gt; = List.of(new C1()).stream().map(Function.identity())</code> work when <code>.stream()</code> alone doesn&#39;t ? The compiler understands it&#39;s a <code>Stream&lt;C1&gt;</code> since <code>Stream&lt;C1&gt; = List.of(new C1()).stream().map(Function.identity())</code> also works.",
    "score" : 0,
    "owner" : {
      "account_id" : 16478911,
      "reputation" : 413,
      "user_id" : 11906121,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/c6320114c699f06d4038d99c1a9273f6?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "elcye",
      "link" : "https://stackoverflow.com/users/11906121/elcye"
    },
    "creation_date" : 1749200833,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140492552,
    "post_id" : 79655641,
    "body" : "See also <a href=\"https://stackoverflow.com/questions/2745265/is-listdog-a-subclass-of-listanimal-why-are-java-generics-not-implicitly-po\">Is List&lt;Dog&gt; a subclass of List&lt;Animal&gt;?</a>",
    "score" : 3,
    "owner" : {
      "account_id" : 4819600,
      "reputation" : 59711,
      "user_id" : 3890632,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/hNkgF.png?s=256",
      "display_name" : "khelwood",
      "link" : "https://stackoverflow.com/users/3890632/khelwood"
    },
    "creation_date" : 1749199610,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}