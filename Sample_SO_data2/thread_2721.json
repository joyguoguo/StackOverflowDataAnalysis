{
  "question" : {
    "question_id" : 79602763,
    "title" : "Does this DFS approach for detecting cycles in a directed graph work correctly, or are there hidden issues?",
    "body" : "<p>I'm trying to detect cycles in a directed graph using a DFS-based approach in Java. I implemented a solution that uses a visited[] array and builds map from the input edge list. It seems to work correctly across all the test cases I wrote — even for disconnected graphs and graphs with multiple branches.</p>\n<p>However, I’m wondering if there are any edge cases where this approach may fail or produce incorrect results. I want to be sure that my logic is solid, and if there’s a flaw, I’d like to understand it better.</p>\n<pre><code>public static boolean hasCycle(List&lt;List&lt;Integer&gt;&gt; edges, int v) {\n    boolean[] visited = new boolean[v];\n    Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();\n\n    for (List&lt;Integer&gt; list : edges) {\n        int parent = list.get(0);\n        List&lt;Integer&gt; l = map.getOrDefault(parent, new ArrayList&lt;&gt;());\n        l.add(list.get(1));\n        map.put(parent, l);\n    }\n\n    for (int i = 0; i &lt; v; i++) {\n        if (!visited[i] &amp;&amp; dfs(map, visited, i)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nprivate static boolean dfs(Map&lt;Integer, List&lt;Integer&gt;&gt; map, boolean[] visited, int currentNode) {\n    if (visited[currentNode]) {\n        return true;\n    }\n\n    visited[currentNode] = true;\n\n    if (map.containsKey(currentNode)) {\n        for (Integer node : map.get(currentNode)) {\n            if (dfs(map, visited, node)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n</code></pre>\n<p>Example Test Case</p>\n<pre><code>    // Test Case 1 (should return true)\n    int v1 = 4;\n    List&lt;List&lt;Integer&gt;&gt; edges1 = Arrays.asList(\n        Arrays.asList(0, 1),\n        Arrays.asList(0, 2),\n        Arrays.asList(1, 2),\n        Arrays.asList(2, 0),\n        Arrays.asList(2, 3)\n    );\n    System.out.println(&quot;Case 1: &quot; + hasCycle(edges1, v1)); // true\n    \n    // Test Case 2 (should return false)\n    int v2 = 4;\n    List&lt;List&lt;Integer&gt;&gt; edges2 = Arrays.asList(\n        Arrays.asList(0, 1),\n        Arrays.asList(0, 2),\n        Arrays.asList(1, 2),\n        Arrays.asList(2, 3)\n    );\n    System.out.println(&quot;Case 2: &quot; + hasCycle(edges2, v2)); // false\n\n    int v3 = 5;\n    List&lt;List&lt;Integer&gt;&gt; edges3 = List.of(\n        List.of(0, 1),\n        List.of(1, 2),\n        List.of(2, 0), // Cycle 1: 0 → 1 → 2 → 0\n        List.of(2, 3),\n        List.of(3, 4),\n        List.of(4, 2)  // Cycle 2: 2 → 3 → 4 → 2\n    );\n\n    System.out.println(&quot;Case 2: &quot; + hasCycle(edges3, v3)); // true\n\n    int v4 = 4;\n    List&lt;List&lt;Integer&gt;&gt; edges4 = Arrays.asList(\n        Arrays.asList(0, 1),\n        Arrays.asList(1, 2),\n        Arrays.asList(2, 3)\n    );\n    System.out.println(&quot;Case 4: &quot; + hasCycle(edges4, v4)); // false\n\n    int v5 = 6;\n    List&lt;List&lt;Integer&gt;&gt; edges5 = Arrays.asList(\n        Arrays.asList(0, 1),\n        Arrays.asList(1, 2),\n        Arrays.asList(3, 4),\n        Arrays.asList(4, 5),\n        Arrays.asList(5, 3)\n    );\n    System.out.println(&quot;Case 5: &quot; + hasCycle(edges5,    v5)); // true\n\n    int v6 = 3;\n    List&lt;List&lt;Integer&gt;&gt; edges6 = Arrays.asList(\n        Arrays.asList(0, 1),\n        Arrays.asList(1, 2),\n        Arrays.asList(0, 2)\n    );\n    System.out.println(&quot;Case 6: &quot; + hasCycle(edges6,    v6)); // false\n\n    int v7 = 4;\n    // Graph: 0 → 1, 0 → 2, 1 → 3, 2 → 3 — no cycle\n    List&lt;List&lt;Integer&gt;&gt; edges7 = Arrays.asList(\n        Arrays.asList(0, 1),\n        Arrays.asList(0, 2),\n        Arrays.asList(1, 3),\n        Arrays.asList(2, 3)\n    );\n    System.out.println(&quot;Case 7 (no cycle, should be false): &quot; + hasCycle(edges7, v7)); // false\n</code></pre>\n<p>I wrote the code on my own and manually created various test cases — including graphs with cycles, without cycles, disconnected graphs, and graphs with multiple paths to the same node. In all cases, the output matched my expectations.</p>\n<p>But I realized that my DFS uses a simple visited[] flag for cycle detection, and I started wondering: maybe it falsely detects cycles in some valid graphs? I expected it to detect cycles correctly, but now I want to confirm with the community — is this method truly reliable for directed graphs? If not, can someone provide a counterexample?</p>\n",
    "tags" : [ "java", "graph", "depth-first-search", "directed-graph", "cycle-detection" ],
    "owner" : {
      "account_id" : 20622806,
      "reputation" : 1,
      "user_id" : 15139425,
      "user_type" : "registered",
      "profile_image" : "https://graph.facebook.com/1088280148310930/picture?type=large",
      "display_name" : "Игорь Райский",
      "link" : "https://stackoverflow.com/users/15139425/%d0%98%d0%b3%d0%be%d1%80%d1%8c-%d0%a0%d0%b0%d0%b9%d1%81%d0%ba%d0%b8%d0%b9"
    },
    "is_answered" : false,
    "view_count" : 81,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1746193594,
    "creation_date" : 1746154960,
    "link" : "https://stackoverflow.com/questions/79602763/does-this-dfs-approach-for-detecting-cycles-in-a-directed-graph-work-correctly",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79603505,
    "question_id" : 79602763,
    "body" : "<p>I was trying to implement cycle detection in a directed graph using DFS. At first, I thought my solution was correct, but it kept returning <code>true</code> (indicating a cycle) in cases where there was clearly no cycle.</p>\n<p>After debugging, I realized the issue was in my <code>dfs</code> function. I was only using a <code>visited[]</code> array to track visited nodes, but I wasn't keeping track of the nodes in the <strong>current DFS path</strong>. This caused false positives — if a node was visited in a <em>different</em> DFS path, my code wrongly assumed that was a cycle.</p>\n<p>What I was missing was a second boolean array (often called <code>recStack[]</code>) to track the recursion stack — basically, which nodes are part of the <strong>current active DFS call chain</strong>.</p>\n<p>This was wrong because it returned <code>true</code> whenever a node was visited — even if that node had already finished its DFS and was not part of the current path.</p>\n<hr />\n<h3>The fix was to add a second array <code>recStack[]</code>:</h3>\n<pre><code>private static boolean dfs(Map&lt;Integer, List&lt;Integer&gt;&gt; map, boolean[] visited, boolean[] recStack, int currentNode) {\n    visited[currentNode] = true;\n    recStack[currentNode] = true;\n\n    if (map.containsKey(currentNode)) {\n        for (Integer neighbor : map.get(currentNode)) {\n            if (!visited[neighbor] &amp;&amp; dfs(map, visited, recStack, neighbor)) {\n                return true;\n            } else if (recStack[neighbor]) {\n                return true;\n            }\n        }\n    }\n\n    recStack[currentNode] = false;\n    return false;\n}\n</code></pre>\n<p>And I updated my main <code>hasCycle()</code> function to use both arrays:</p>\n<pre><code>for (int i = 0; i &lt; v; i++) {\n    if (!visited[i]) {\n        if (dfs(map, visited, recStack, i)) {\n            return true;\n        }\n    }\n}\n</code></pre>\n<hr />\n<h3>Example test case that was failing before:</h3>\n<p>This test case was giving me <code>true</code> even though there’s no cycle:</p>\n<pre><code>int v8 = 5;\nList&lt;List&lt;Integer&gt;&gt; edges8 = Arrays.asList(\n    Arrays.asList(0, 3),\n    Arrays.asList(1, 0),\n    Arrays.asList(1, 2),\n    Arrays.asList(2, 3),\n    Arrays.asList(3, 4)\n);\nSystem.out.println(&quot;Case 8 (no cycle, should be false): &quot; + hasCycle(edges8, v8)); // Expected: false\n</code></pre>\n<p>That was because node <code>3</code> was visited through two different paths (<code>0 → 3</code> and <code>2 → 3</code>), and my original code wrongly detected that as a cycle.</p>\n<p>Maybe this will help someone else who was stuck like I was — all because I forgot to track nodes in the current DFS path using a recursion stack.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 20622806,
      "reputation" : 1,
      "user_id" : 15139425,
      "user_type" : "registered",
      "profile_image" : "https://graph.facebook.com/1088280148310930/picture?type=large",
      "display_name" : "Игорь Райский",
      "link" : "https://stackoverflow.com/users/15139425/%d0%98%d0%b3%d0%be%d1%80%d1%8c-%d0%a0%d0%b0%d0%b9%d1%81%d0%ba%d0%b8%d0%b9"
    },
    "creation_date" : 1746193594,
    "last_activity_date" : 1746193594,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140388877,
    "post_id" : 79602763,
    "body" : "This sounds like it might be better suited to <a href=\"https://codereview.stackexchange.com/?tags=java\">codereview.stackeachange</a>, in that it&#39;s questioning reliability, logic and test coverage, rather than how to resolve a reproducible problem.",
    "score" : 2,
    "owner" : {
      "account_id" : 29509195,
      "reputation" : 750,
      "user_id" : 22614603,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/9eccb09504844a83f9c0449754c98aaf?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "SmellyCat",
      "link" : "https://stackoverflow.com/users/22614603/smellycat"
    },
    "creation_date" : 1746159375,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}