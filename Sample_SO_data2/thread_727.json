{
  "question" : {
    "question_id" : 79772043,
    "title" : "How to handle lifecycle of cameraX?",
    "body" : "<p>I am trying to make a cameraX plugin which I plan to use inside unity. The camera seems to start ( having some problems while setting resolution as well), but when I put the app in the background, the camera is supposed to stop and it does but with this error</p>\n<pre><code>2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession Session 0: Exception while stopping repeating: \n2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession android.hardware.camera2.CameraAccessException: CAMERA_ERROR (3): The camera device has encountered a serious error\n2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession  at android.hardware.camera2.impl.CameraDeviceImpl.checkIfCameraClosedOrInError(CameraDeviceImpl.java:2612)\n2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession  at android.hardware.camera2.impl.CameraDeviceImpl.stopRepeating(CameraDeviceImpl.java:1469)\n2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession  at android.hardware.camera2.impl.CameraCaptureSessionImpl.close(CameraCaptureSessionImpl.java:579)\n2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession  at androidx.camera.camera2.internal.SynchronizedCaptureSessionBaseImpl.close(SynchronizedCaptureSessionBaseImpl.java:476)\n2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession  at androidx.camera.camera2.internal.CaptureSession.release(CaptureSession.java:526)\n2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession  at androidx.camera.camera2.internal.Camera2CameraImpl.releaseSession(Camera2CameraImpl.java:555)\n2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession  at androidx.camera.camera2.internal.Camera2CameraImpl.resetCaptureSession(Camera2CameraImpl.java:1329)\n2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession  at androidx.camera.camera2.internal.Camera2CameraImpl.closeCamera(Camera2CameraImpl.java:468)\n2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession  at androidx.camera.camera2.internal.Camera2CameraImpl$StateCallback.handleErrorOnOpen(Camera2CameraImpl.java:1798)\n2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession  at androidx.camera.camera2.internal.Camera2CameraImpl$StateCallback.onError(Camera2CameraImpl.java:1754)\n2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession  at androidx.camera.camera2.internal.CameraDeviceStateCallbacks$ComboDeviceStateCallback.onError(CameraDeviceStateCallbacks.java:121)\n2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession  at android.hardware.camera2.impl.CameraDeviceImpl$ClientStateCallback$4.run(CameraDeviceImpl.java:338)\n2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession  at androidx.camera.core.impl.utils.executor.SequentialExecutor$1.run(SequentialExecutor.java:111)\n2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession  at androidx.camera.core.impl.utils.executor.SequentialExecutor$QueueWorker.workOnQueue(SequentialExecutor.java:231)\n2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession  at androidx.camera.core.impl.utils.executor.SequentialExecutor$QueueWorker.run(SequentialExecutor.java:173)\n2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:644)\n&gt; 2025-09-22 16:17:29.347 30471 30594 Error CameraCaptureSession    at java.lang.Thread.run(Thread.java:1012)\n</code></pre>\n<p>Here's my code</p>\n<pre><code>package com.android.cameraplugin;\n\nimport android.Manifest;\nimport android.app.Activity;\nimport android.content.Context;\nimport android.content.pm.PackageManager;\nimport android.graphics.ImageFormat;\nimport android.os.Handler;\nimport android.os.Looper;\nimport android.util.Log;\nimport android.util.Size;\n\nimport androidx.annotation.NonNull;\nimport androidx.camera.core.AspectRatio;\nimport androidx.camera.core.Camera;\nimport androidx.camera.core.CameraSelector;\nimport androidx.camera.core.ImageAnalysis;\nimport androidx.camera.core.ImageProxy;\nimport androidx.camera.lifecycle.ProcessCameraProvider;\nimport androidx.core.app.ActivityCompat;\nimport androidx.core.content.ContextCompat;\nimport androidx.lifecycle.Lifecycle;\nimport androidx.lifecycle.LifecycleOwner;\nimport androidx.lifecycle.LifecycleRegistry;\n\nimport com.google.common.util.concurrent.ListenableFuture;\n\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class CameraPlugin {\n    private static final String TAG = &quot;CameraPlugin&quot;;\n    private static CameraPlugin instance;\n\n    private final Activity activity;\n    private final Context context;\n\n    // CameraX components\n    private ProcessCameraProvider cameraProvider;\n    private Camera camera;\n    private ImageAnalysis imageAnalysis;\n    private CameraSelector cameraSelector;\n\n    // Threading\n    private final ExecutorService cameraExecutor;\n    private final Handler mainHandler = new Handler(Looper.getMainLooper());\n\n    // Our explicit lifecycle for CameraX\n    private final CustomLifecycle camLifecycle = new CustomLifecycle();\n\n    // Camera state\n    private boolean isCameraStarted = false;\n    private boolean isFrontCamera = false;\n    private int targetWidth = 1280;\n    private int targetHeight = 720;\n\n    // Rapid-cycling detection (kept from your original)\n    private long lastBackgroundTime = 0;\n    private int backgroundCount = 0;\n    private static final long BACKGROUND_DETECTION_WINDOW = 5000; // 5 seconds\n    private boolean isRapidCyclingMode = false;\n    private long rapidCyclingStartTime = 0;\n    private static final long RAPID_CYCLING_COOLDOWN = 10000; // 10 seconds\n\n    // RGB data storage\n    private volatile byte[] latestRGBData;\n    private volatile int frameWidth = 640;\n    private volatile int frameHeight = 480;\n\n    // Image analysis callback (YUV_420_888 guaranteed)\n    private final ImageAnalysis.Analyzer imageAnalyzer = new ImageAnalysis.Analyzer() {\n        private long lastProcessTime = 0;\n        private static final long MIN_PROCESS_INTERVAL = 50; // ~20 FPS max\n        private int frameSkipCounter = 0;\n        private static final int FRAME_SKIP_RATIO = 2; // Process every 2nd frame\n\n        @Override\n        public void analyze(@NonNull ImageProxy image) {\n            try {\n                // Log first few frames to debug\n                if (frameSkipCounter &lt; 5) {\n                    Log.d(TAG, &quot;ImageAnalyzer received frame #&quot; + frameSkipCounter + \n                          &quot; - format: &quot; + image.getFormat() + \n                          &quot;, size: &quot; + image.getWidth() + &quot;x&quot; + image.getHeight());\n                }\n                \n                // Throttle/skip for CPU budget\n                frameSkipCounter++;\n                if (frameSkipCounter % FRAME_SKIP_RATIO != 0) return;\n\n                long now = System.currentTimeMillis();\n                if (now - lastProcessTime &lt; MIN_PROCESS_INTERVAL) return;\n                lastProcessTime = now;\n\n                if (image.getFormat() != ImageFormat.YUV_420_888) {\n                    Log.w(TAG, &quot;Unexpected format: &quot; + image.getFormat() + &quot; (expected YUV_420_888)&quot;);\n                }\n\n                byte[] rgb = yuv420888ToRgb(image);\n                if (rgb != null) {\n                    latestRGBData = rgb;\n                    frameWidth = image.getWidth();\n                    frameHeight = image.getHeight();\n                    Log.v(TAG, &quot;Frame &quot; + frameWidth + &quot;x&quot; + frameHeight + &quot; -&gt; RGB bytes=&quot; + rgb.length);\n                }\n            } catch (Throwable t) {\n                Log.e(TAG, &quot;analyze error: &quot; + t.getMessage(), t);\n            } finally {\n                image.close();\n            }\n        }\n    };\n\n    private CameraPlugin(Activity activity) {\n        this.activity = activity;\n        this.context = activity.getApplicationContext();\n        this.cameraExecutor = Executors.newSingleThreadExecutor();\n        \n        // Initialize CustomLifecycle on main thread\n        if (Looper.myLooper() == Looper.getMainLooper()) {\n            camLifecycle.initialize();\n        } else {\n            mainHandler.post(camLifecycle::initialize);\n        }\n        \n        initializeCameraProvider();\n    }\n\n    public static CameraPlugin getInstance(Activity activity) {\n        if (instance == null) {\n            instance = new CameraPlugin(activity);\n        }\n        return instance;\n    }\n\n    private void initializeCameraProvider() {\n        ListenableFuture&lt;ProcessCameraProvider&gt; cameraProviderFuture =\n                ProcessCameraProvider.getInstance(context);\n\n        cameraProviderFuture.addListener(() -&gt; {\n            try {\n                cameraProvider = cameraProviderFuture.get();\n                Log.d(TAG, &quot;CameraX provider initialized&quot;);\n                try {\n                    var infos = cameraProvider.getAvailableCameraInfos();\n                    Log.d(TAG, &quot;Available cameras: &quot; + infos.size());\n                    for (int i = 0; i &lt; infos.size(); i++) {\n                        Log.d(TAG, &quot;Camera &quot; + i + &quot;: &quot; + infos.get(i));\n                    }\n                } catch (Exception e) {\n                    Log.w(TAG, &quot;Could not list camera infos: &quot; + e.getMessage());\n                }\n            } catch (ExecutionException | InterruptedException e) {\n                Log.e(TAG, &quot;Failed to init CameraX provider: &quot; + e.getMessage(), e);\n            }\n        }, ContextCompat.getMainExecutor(context));\n    }\n\n    public boolean checkCameraPermission() {\n        return ContextCompat.checkSelfPermission(context, Manifest.permission.CAMERA)\n                == PackageManager.PERMISSION_GRANTED;\n    }\n\n    public void requestCameraPermission() {\n        if (!checkCameraPermission()) {\n            ActivityCompat.requestPermissions(activity,\n                    new String[]{Manifest.permission.CAMERA}, 100);\n        }\n    }\n\n    public boolean startCamera() {\n        return startCamera(targetWidth, targetHeight);\n    }\n\n    public boolean startCamera(int targetWidth, int targetHeight) {\n        Log.d(TAG, &quot;Starting CameraX with &quot; + targetWidth + &quot;x&quot; + targetHeight);\n\n        if (isRapidCyclingMode) {\n            Log.w(TAG, &quot;Blocked: rapid cycling mode&quot;);\n            return false;\n        }\n        if (!checkCameraPermission()) {\n            Log.e(TAG, &quot;Camera permission not granted&quot;);\n            return false;\n        }\n        if (cameraProvider == null) {\n            Log.e(TAG, &quot;Camera provider not ready&quot;);\n            return false;\n        }\n        if (isCameraStarted) {\n            Log.d(TAG, &quot;Camera already started&quot;);\n            return true;\n        }\n\n        if (Looper.myLooper() != Looper.getMainLooper()) {\n            mainHandler.post(() -&gt; startCameraOnMainThread(targetWidth, targetHeight));\n            return true;\n        } else {\n            return startCameraOnMainThread(targetWidth, targetHeight);\n        }\n    }\n\n    private boolean startCameraOnMainThread(int targetWidth, int targetHeight) {\n        try {\n            this.targetWidth = targetWidth;\n            this.targetHeight = targetHeight;\n            \n            Log.d(TAG, &quot;Requesting camera resolution: &quot; + targetWidth + &quot;x&quot; + targetHeight);\n\n            cameraSelector = new CameraSelector.Builder()\n                    .requireLensFacing(isFrontCamera ? CameraSelector.LENS_FACING_FRONT\n                                                     : CameraSelector.LENS_FACING_BACK)\n                    .build();\n\n            // Force a standard resolution that's commonly supported\n            // Use 1280x720 (HD) which is almost universally supported\n            Size targetSize = new Size(1280, 720);\n            Log.d(TAG, &quot;Forcing target size to: &quot; + targetSize + &quot; (ignoring requested &quot; + targetWidth + &quot;x&quot; + targetHeight + &quot;)&quot;);\n            \n            imageAnalysis = new ImageAnalysis.Builder()\n                    .setTargetResolution(targetSize)\n                    .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)\n                    // Force YUV_420_888 output to the analyzer\n                    .setOutputImageFormat(ImageAnalysis.OUTPUT_IMAGE_FORMAT_YUV_420_888)\n                    .build();\n            imageAnalysis.setAnalyzer(cameraExecutor, imageAnalyzer);\n\n            cameraProvider.unbindAll();\n\n            try {\n                camera = cameraProvider.bindToLifecycle(\n                        camLifecycle,\n                        cameraSelector,\n                        imageAnalysis\n                );\n\n                // Move custom lifecycle to RESUMED state to actually start the camera\n                mainHandler.post(camLifecycle::toResumed);\n\n                isCameraStarted = true;\n                Log.d(TAG, &quot;CameraX started (YUV_420_888, analysis only)&quot;);\n                return true;\n            } catch (Exception bindingError) {\n                Log.e(TAG, &quot;Failed to bind camera to lifecycle: &quot; + bindingError.getMessage(), bindingError);\n                // Clean up on binding failure\n                if (cameraProvider != null) {\n                    try {\n                        cameraProvider.unbindAll();\n                    } catch (Exception cleanupError) {\n                        Log.e(TAG, &quot;Cleanup error after binding failure: &quot; + cleanupError.getMessage());\n                    }\n                }\n                return false;\n            }\n\n        } catch (Exception e) {\n            Log.e(TAG, &quot;Failed to start CameraX: &quot; + e.getMessage(), e);\n            return false;\n        }\n    }\n\n    public void stopCamera() {\n        Log.d(TAG, &quot;Stopping CameraX&quot;);\n        if (Looper.myLooper() != Looper.getMainLooper()) {\n            mainHandler.post(this::stopCameraOnMainThread);\n        } else {\n            stopCameraOnMainThread();\n        }\n    }\n\n    private void stopCameraOnMainThread() {\n    Log.d(TAG, &quot;Stopping CameraX (sync)&quot;);\n\n    // 0) Prevent new analyze callbacks while tearing down\n    try {\n        if (imageAnalysis != null) imageAnalysis.clearAnalyzer();\n    } catch (Exception ignore) {}\n\n    // 1) Unbind all use cases NOW (not posted)\n    if (cameraProvider != null) {\n        try { cameraProvider.unbindAll(); } catch (Exception e) {\n            Log.e(TAG, &quot;unbindAll error: &quot; + e.getMessage(), e);\n        }\n    }\n\n    // 2) Drive lifecycle down NOW (not posted)\n    try { camLifecycle.toCreated(); } catch (Exception e) {\n        Log.e(TAG, &quot;Error setting lifecycle to CREATED: &quot; + e.getMessage());\n    }\n\n    // 3) Null state\n    isCameraStarted = false;\n    camera = null;\n    imageAnalysis = null;\n\n    Log.d(TAG, &quot;CameraX stopped&quot;);\n}\n\n\n    private void stopCameraImmediately() {\n        Log.d(TAG, &quot;Immediate stop (break rapid cycling)&quot;);\n        if (cameraProvider != null) {\n            try {\n                Log.d(TAG, &quot;Immediate stop - unbinding all use cases&quot;);\n                cameraProvider.unbindAll();\n            } catch (Exception e) {\n                Log.e(TAG, &quot;Immediate unbindAll error: &quot; + e.getMessage(), e);\n            }\n        }\n        \n        // Move custom lifecycle to CREATED state immediately\n        try {\n            if (Looper.myLooper() == Looper.getMainLooper()) {\n                camLifecycle.toCreated();\n            } else {\n                mainHandler.post(camLifecycle::toCreated);\n            }\n        } catch (Exception e) {\n            Log.e(TAG, &quot;Error setting lifecycle to CREATED (immediate): &quot; + e.getMessage());\n        }\n        \n        isCameraStarted = false;\n        camera = null;\n        imageAnalysis = null;\n    }\n\n    public void pauseCamera() { Log.d(TAG, &quot;pauseCamera (lifecycle-driven)&quot;); }\n    public void resumeCamera() { Log.d(TAG, &quot;resumeCamera (lifecycle-driven)&quot;); }\n\n    public void switchCamera() {\n        Log.d(TAG, &quot;Switching camera&quot;);\n        if (isCameraStarted) {\n            stopCamera();\n            isFrontCamera = !isFrontCamera;\n            startCamera();\n        } else {\n            isFrontCamera = !isFrontCamera;\n        }\n    }\n\n    public boolean isUsingFrontCamera() { return isFrontCamera; }\n    public boolean isCameraRunning() { return isCameraStarted &amp;&amp; camera != null; }\n\n    // Unity-facing frame accessors\n    public boolean hasNewFrame() { return latestRGBData != null; }\n    public byte[] getLatestFrameData() { return latestRGBData; }\n    public byte[] getLatestRGBFrame() { return latestRGBData; }\n    public int getFrameWidth() { return frameWidth; }\n    public int getFrameHeight() { return frameHeight; }\n    public void clearFrameData() { latestRGBData = null; }\n\n    public boolean isCameraInitialized() { return isCameraStarted; }\n    public boolean isCameraReady() { return isCameraStarted &amp;&amp; camera != null &amp;&amp; latestRGBData != null; }\n\n    public void setTargetResolution(int width, int height) {\n        this.targetWidth = width;\n        this.targetHeight = height;\n    }\n    public int getTargetWidth() { return targetWidth; }\n    public int getTargetHeight() { return targetHeight; }\n\n    public void setZoom(float zoomLevel) {\n        Log.d(TAG, &quot;setZoom called with: &quot; + zoomLevel);\n        // Implement via CameraControl if/when needed\n    }\n\n    public void switchCamera(String direction) {\n        Log.d(TAG, &quot;switchCamera(direction=&quot; + direction + &quot;)&quot;);\n        switchCamera();\n    }\n\n    public void breakRapidCycling() {\n        Log.d(TAG, &quot;breakRapidCycling called&quot;);\n        backgroundCount = 0;\n        lastBackgroundTime = 0;\n        isRapidCyclingMode = false;\n        rapidCyclingStartTime = 0;\n        if (isCameraStarted) stopCameraImmediately();\n    }\n\n    public boolean isInRapidCycling() { return isRapidCyclingMode; }\n\n    // Manual camera control methods\n    public void startCameraManually() {\n        Log.d(TAG, &quot;Manually starting camera via custom lifecycle&quot;);\n        if (!isRapidCyclingMode) {\n            mainHandler.post(camLifecycle::toResumed);\n        }\n    }\n\n    public void stopCameraManually() {\n        Log.d(TAG, &quot;Manually stopping camera via custom lifecycle&quot;);\n        mainHandler.post(camLifecycle::toStarted);\n    }\n\n    // Handle camera errors and recovery\n    public void handleCameraError() {\n        Log.e(TAG, &quot;Handling camera error - stopping and resetting&quot;);\n        \n        // Stop camera immediately\n        stopCameraImmediately();\n        \n        // Reset rapid cycling mode\n        isRapidCyclingMode = false;\n        backgroundCount = 0;\n        lastBackgroundTime = 0;\n        rapidCyclingStartTime = 0;\n        \n        // Wait a bit before allowing restart\n        mainHandler.postDelayed(() -&gt; {\n            Log.d(TAG, &quot;Camera error recovery - ready for restart&quot;);\n        }, 2000); // 2 second delay\n    }\n\n    // --------- YUV_420_888 -&gt; RGB (interleaved) WITHOUT JPEG ----------\n    // Handles arbitrary row/pixel strides for Y, U, V planes.\n    private static byte[] yuv420888ToRgb(ImageProxy image) {\n        final int width = image.getWidth();\n        final int height = image.getHeight();\n\n        ImageProxy.PlaneProxy yPlane = image.getPlanes()[0];\n        ImageProxy.PlaneProxy uPlane = image.getPlanes()[1];\n        ImageProxy.PlaneProxy vPlane = image.getPlanes()[2];\n\n        ByteBuffer yBuf = yPlane.getBuffer();\n        ByteBuffer uBuf = uPlane.getBuffer();\n        ByteBuffer vBuf = vPlane.getBuffer();\n\n        int yRowStride = yPlane.getRowStride();\n        int yPixStride = yPlane.getPixelStride(); // usually 1\n\n        int uRowStride = uPlane.getRowStride();\n        int uPixStride = uPlane.getPixelStride(); // usually 2\n\n        int vRowStride = vPlane.getRowStride();\n        int vPixStride = vPlane.getPixelStride(); // usually 2\n\n        byte[] out = new byte[width * height * 3];\n\n        // Standard BT.601 full-range conversion\n        // R = 1.164*(Y-16) + 1.596*(V-128)\n        // G = 1.164*(Y-16) - 0.392*(U-128) - 0.813*(V-128)\n        // B = 1.164*(Y-16) + 2.017*(U-128)\n        //\n        // Use integer math approximation for speed:\n        // C = Y - 16; D = U - 128; E = V - 128;\n        // R = (298*C + 409*E + 128) &gt;&gt; 8\n        // G = (298*C - 100*D - 208*E + 128) &gt;&gt; 8\n        // B = (298*C + 516*D + 128) &gt;&gt; 8\n\n        for (int y = 0; y &lt; height; y++) {\n            int yRowStart = yRowStride * y;\n            int uvRow = (y &gt;&gt; 1); // /2\n            int uRowStart = uRowStride * uvRow;\n            int vRowStart = vRowStride * uvRow;\n\n            for (int x = 0; x &lt; width; x++) {\n                int yCol = yRowStart + x * yPixStride;\n\n                int uvCol = (x &gt;&gt; 1); // /2\n                int uIndex = uRowStart + uvCol * uPixStride;\n                int vIndex = vRowStart + uvCol * vPixStride;\n\n                int Y = (yBuf.get(yCol) &amp; 0xFF);\n                int U = (uBuf.get(uIndex) &amp; 0xFF);\n                int V = (vBuf.get(vIndex) &amp; 0xFF);\n\n                int C = Y - 16;\n                int D = U - 128;\n                int E = V - 128;\n\n                if (C &lt; 0) C = 0;\n\n                int R = (298 * C + 409 * E + 128) &gt;&gt; 8;\n                int G = (298 * C - 100 * D - 208 * E + 128) &gt;&gt; 8;\n                int B = (298 * C + 516 * D + 128) &gt;&gt; 8;\n\n                if (R &lt; 0) R = 0; else if (R &gt; 255) R = 255;\n                if (G &lt; 0) G = 0; else if (G &gt; 255) G = 255;\n                if (B &lt; 0) B = 0; else if (B &gt; 255) B = 255;\n\n                int outIdx = (y * width + x) * 3;\n                out[outIdx]     = (byte) R;\n                out[outIdx + 1] = (byte) G;\n                out[outIdx + 2] = (byte) B;\n            }\n        }\n\n        return out;\n    }\n\n    // ---- Forward these from your Activity/Unity bridge ----\n\n    public void onCreate() {\n        Log.d(TAG, &quot;CameraPlugin onCreate&quot;);\n        // CustomLifecycle starts at CREATED\n        // Don't automatically move to RESUMED - let startCamera() handle it\n    }\n\n    public void onResume() {\n        Log.d(TAG, &quot;CameraPlugin onResume - restarting camera for foreground&quot;);\n        long now = System.currentTimeMillis();\n        if (isRapidCyclingMode &amp;&amp; (now - rapidCyclingStartTime) &lt; RAPID_CYCLING_COOLDOWN) {\n            Log.d(TAG, &quot;In cooldown; skip resume transition&quot;);\n            return;\n        }\n        \n        // Restart camera when app comes to foreground\n        Log.d(TAG, &quot;Moving camera to RESUMED state (started) for foreground&quot;);\n        mainHandler.post(camLifecycle::toResumed);\n    }\n\n    public void onPause() {\n    Log.d(TAG, &quot;CameraPlugin onPause - stopping camera for background&quot;);\n    // Donâ€™t post just a lifecycle bump; actually stop now.\n    if (Looper.myLooper() == Looper.getMainLooper()) {\n        stopCameraOnMainThread();\n    } else {\n        mainHandler.post(this::stopCameraOnMainThread);\n    }\n}\n\n\n    public void onStop() {\n        Log.d(TAG, &quot;CameraPlugin onStop&quot;);\n        mainHandler.post(camLifecycle::toCreated);\n    }\n\n    public void onDestroy() {\n        Log.d(TAG, &quot;CameraPlugin onDestroy&quot;);\n        stopCamera();\n        if (cameraExecutor != null) cameraExecutor.shutdown();\n        mainHandler.post(camLifecycle::toDestroyed);\n    }\n}\n\n// Explicit lifecycle you control from Unity/Activity\nclass CustomLifecycle implements LifecycleOwner {\n    private final LifecycleRegistry lifecycleRegistry;\n    private final Handler mainHandler = new Handler(Looper.getMainLooper());\n\n    public CustomLifecycle() {\n        lifecycleRegistry = new LifecycleRegistry(this);\n        // Don't set state in constructor - do it on main thread\n    }\n\n    // Initialize on main thread\n    public void initialize() {\n        if (Looper.myLooper() == Looper.getMainLooper()) {\n            lifecycleRegistry.setCurrentState(Lifecycle.State.CREATED);\n        } else {\n            mainHandler.post(() -&gt; lifecycleRegistry.setCurrentState(Lifecycle.State.CREATED));\n        }\n    }\n\n    public void toResumed() { \n        if (Looper.myLooper() == Looper.getMainLooper()) {\n            Log.d(&quot;CustomLifecycle&quot;, &quot;Setting state to RESUMED&quot;);\n            lifecycleRegistry.setCurrentState(Lifecycle.State.RESUMED); \n        } else {\n            mainHandler.post(() -&gt; {\n                Log.d(&quot;CustomLifecycle&quot;, &quot;Setting state to RESUMED (posted)&quot;);\n                lifecycleRegistry.setCurrentState(Lifecycle.State.RESUMED);\n            });\n        }\n    }\n    \n    public void toStarted() { \n        if (Looper.myLooper() == Looper.getMainLooper()) {\n            lifecycleRegistry.setCurrentState(Lifecycle.State.STARTED); \n        } else {\n            mainHandler.post(() -&gt; lifecycleRegistry.setCurrentState(Lifecycle.State.STARTED));\n        }\n    }\n    \n    public void toCreated() { \n        if (Looper.myLooper() == Looper.getMainLooper()) {\n            lifecycleRegistry.setCurrentState(Lifecycle.State.CREATED); \n        } else {\n            mainHandler.post(() -&gt; lifecycleRegistry.setCurrentState(Lifecycle.State.CREATED));\n        }\n    }\n    \n    public void toDestroyed() { \n        if (Looper.myLooper() == Looper.getMainLooper()) {\n            lifecycleRegistry.setCurrentState(Lifecycle.State.DESTROYED); \n        } else {\n            mainHandler.post(() -&gt; lifecycleRegistry.setCurrentState(Lifecycle.State.DESTROYED));\n        }\n    }\n\n    @Override\n    public Lifecycle getLifecycle() {\n        return lifecycleRegistry;\n    }\n}\n\n\n</code></pre>\n<p>Is there any documentation to look into? Or does anyone know what am I doing wrong here?</p>\n",
    "tags" : [ "java", "android", "unity-game-engine", "android-camerax" ],
    "owner" : {
      "account_id" : 44045500,
      "reputation" : 1,
      "user_id" : 31547131,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/c4bcbead2704e0dfead8bcf4c226a3ed?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Khushal Nirmal Jain",
      "link" : "https://stackoverflow.com/users/31547131/khushal-nirmal-jain"
    },
    "is_answered" : false,
    "view_count" : 52,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1758574252,
    "creation_date" : 1758574252,
    "link" : "https://stackoverflow.com/questions/79772043/how-to-handle-lifecycle-of-camerax",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140760181,
    "post_id" : 79772043,
    "body" : "Here&#39;s hoping it actually gives you the reason!",
    "score" : 0,
    "owner" : {
      "account_id" : 5251730,
      "reputation" : 311,
      "user_id" : 4195783,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/a5d372bc5e4b3a665276eb1f1b19a260?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "NPatch",
      "link" : "https://stackoverflow.com/users/4195783/npatch"
    },
    "creation_date" : 1758821896,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140759438,
    "post_id" : 79772043,
    "body" : "@NPatch Thank you so much for this link. This probably might solve my problem.",
    "score" : 0,
    "owner" : {
      "account_id" : 44045500,
      "reputation" : 1,
      "user_id" : 31547131,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/c4bcbead2704e0dfead8bcf4c226a3ed?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Khushal Nirmal Jain",
      "link" : "https://stackoverflow.com/users/31547131/khushal-nirmal-jain"
    },
    "creation_date" : 1758804903,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140759061,
    "post_id" : 79772043,
    "body" : "No exp with this but docs on <a href=\"https://developer.android.com/reference/android/hardware/camera2/CameraAccessException#CAMERA_ERROR\" rel=\"nofollow noreferrer\">camera error 3</a> say the camera is in an error state and to check CameraDevice.StateCallback.onError for the nature of the error. It might help you figure it out.",
    "score" : 0,
    "owner" : {
      "account_id" : 5251730,
      "reputation" : 311,
      "user_id" : 4195783,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/a5d372bc5e4b3a665276eb1f1b19a260?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "NPatch",
      "link" : "https://stackoverflow.com/users/4195783/npatch"
    },
    "creation_date" : 1758796481,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}