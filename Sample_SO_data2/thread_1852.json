{
  "question" : {
    "question_id" : 79672506,
    "title" : "What is an efficient alternative to creating dozens of ActionListener implementations in Java?",
    "body" : "<p>I'm designing a P2P messaging application using Swing, and have been running into serious issues when it comes to organizing my GUI component <code>ActionListener</code>s. Each <code>JButton</code> and <code>JTextField</code> almost always needs its own <code>ActionListener</code> implementation designed, because each component naturally has a different effect on the application than the others. My immediate thought was to just use lambdas to define an <code>actionPerformed()</code> call for each unique component, but this becomes even more problematic, because lambdas cannot be passed any parameters from the caller (as far as I know) since we don't have any constructor to use as a passer. In short, it seems I have to choose between two options:</p>\n<ol>\n<li>Create a new class implementing <code>ActionListener</code> for each component requiring unique action logic, cluttering my codebase to a preposterous degree (BUT allowing for parameter passing via said class's constructor/native methods).</li>\n<li>Use an <code>actionPerformed()</code> lambda for each component requiring unique action logic, streamlining my codebase while requiring a complete redesign of said logic's details due to the loss of parameter passing.</li>\n</ol>\n<p>I would be stunned, however, if this bad choice road is the reality of the situation. Is there an alternative to these poor options? Maybe a programming paradigm I've entirely overlooked?</p>\n",
    "tags" : [ "java", "swing", "lambda", "actionlistener" ],
    "owner" : {
      "account_id" : 42453136,
      "reputation" : 31,
      "user_id" : 30759710,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/M6u3J1Vp.png?s=256",
      "display_name" : "jinzōningen",
      "link" : "https://stackoverflow.com/users/30759710/jinz%c5%8dningen"
    },
    "is_answered" : true,
    "view_count" : 120,
    "answer_count" : 1,
    "score" : 2,
    "last_activity_date" : 1751122014,
    "creation_date" : 1750358466,
    "link" : "https://stackoverflow.com/questions/79672506/what-is-an-efficient-alternative-to-creating-dozens-of-actionlistener-implementa",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79672694,
    "question_id" : 79672506,
    "body" : "<p>There's no problem with using lambdas. Here's an example of adding some behaviour to a menu item:</p>\n<pre class=\"lang-java prettyprint-override\"><code>cutMenuItem.addActionListener( e -&gt; textComponent.cut() );\n</code></pre>\n<p>Notice that the lambda can refer to <code>textComponent</code> from the scope in which the lambda is created. It happens that in this case that component was passed to a method that constructs a menu for it. The thing a lambda can't refer to is a non-final variable, and the compiler will do its best to make variables final for you if you use them in lambdas (they become &quot;effectively final&quot;).</p>\n<p>You expressed concern with cluttering your code with listener implementations. Lambdas don't prevent you having to define a lot of listeners, but they are a concise way of defining them.</p>\n",
    "score" : 5,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 15660756,
      "reputation" : 344,
      "user_id" : 11299770,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/IxD7x.png?s=256",
      "display_name" : "J Banana",
      "link" : "https://stackoverflow.com/users/11299770/j-banana"
    },
    "creation_date" : 1750371233,
    "last_activity_date" : 1750371233,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140528010,
    "post_id" : 79672506,
    "body" : "@Slaw and this was what I was looking for. Codebase is now far prettier AND more functional, something I hadn&#39;t even dared to hope for. Thanks for the help!",
    "score" : 0,
    "owner" : {
      "account_id" : 42453136,
      "reputation" : 31,
      "user_id" : 30759710,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/M6u3J1Vp.png?s=256",
      "display_name" : "jinzōningen",
      "link" : "https://stackoverflow.com/users/30759710/jinz%c5%8dningen"
    },
    "creation_date" : 1750368131,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140528003,
    "post_id" : 79672506,
    "body" : "@JorgeCampos looks like it&#39;s time to check back in with the Gang of Four lol. Thanks for the recommendations!",
    "score" : 1,
    "owner" : {
      "account_id" : 42453136,
      "reputation" : 31,
      "user_id" : 30759710,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/M6u3J1Vp.png?s=256",
      "display_name" : "jinzōningen",
      "link" : "https://stackoverflow.com/users/30759710/jinz%c5%8dningen"
    },
    "creation_date" : 1750368038,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140527832,
    "post_id" : 79672506,
    "body" : "Example: <code>String str = &quot;Hi&quot;; Runnable r = () -&gt; System.out.println(str);</code>. The lambda has captured the object referenced by <code>str</code> (i.e., <code>&quot;Hi&quot;</code>). This is essentially the same as passing <code>str</code> to a named class implementation of <code>Runnable</code> via a constructor.",
    "score" : 1,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49904,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1750362857,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140527830,
    "post_id" : 79672506,
    "body" : "Lambdas can reference local variables outside the lambda as long as they&#39;re final or <i>effectively final</i> (and are in scope, obviously). An effectively final variable is simply a variable that can be marked <code>final</code> without issue. Lambdas can also reference fields, which don&#39;t have to be (effectively) final. When an outside local variable or field is referenced inside a lambda, the lambda implementation captures the object. For instance fields, the captured object is the enclosing <code>this</code>. For static fields, the lambda implementation just queries the field directly (no capturing).",
    "score" : 5,
    "owner" : {
      "account_id" : 8532578,
      "reputation" : 49904,
      "user_id" : 6395627,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Slaw",
      "link" : "https://stackoverflow.com/users/6395627/slaw"
    },
    "creation_date" : 1750362827,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140527677,
    "post_id" : 79672506,
    "body" : "You might benefit of reading and eventually applying some design patterns as solutions. First, you can pass parameters to lambdas, as long as they are <code>final</code>. Here are a list of patterns that comes to mind and might help: Command, Strategy, Observer, Action/Input Map, Mediator and Factory. You can apply all or some it depends on your implementation details, which you left out of your question.",
    "score" : 5,
    "owner" : {
      "account_id" : 209503,
      "reputation" : 23867,
      "user_id" : 460557,
      "user_type" : "registered",
      "accept_rate" : 100,
      "profile_image" : "https://www.gravatar.com/avatar/b4565f97815833390c9c880e9e8522e4?s=256&d=identicon&r=PG",
      "display_name" : "Jorge Campos",
      "link" : "https://stackoverflow.com/users/460557/jorge-campos"
    },
    "creation_date" : 1750359697,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79672694" : [ {
      "comment_id" : 140549571,
      "post_id" : 79672694,
      "body" : "For more info, see <a href=\"https://www.baeldung.com/java-effectively-final\" rel=\"nofollow noreferrer\"><i>Final vs Effectively Final in Java</i></a> and <a href=\"https://stackoverflow.com/q/20938095/642706\"><i>Difference between final and effectively final</i></a>",
      "score" : 0,
      "owner" : {
        "account_id" : 322981,
        "reputation" : 347089,
        "user_id" : 642706,
        "user_type" : "registered",
        "accept_rate" : 58,
        "profile_image" : "https://i.sstatic.net/ZWEI3.jpg?s=256",
        "display_name" : "Basil Bourque",
        "link" : "https://stackoverflow.com/users/642706/basil-bourque"
      },
      "creation_date" : 1751122167,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140528220,
      "post_id" : 79672694,
      "body" : "Thank you! I feel really dumb for forgetting about the effectively final thing. And the clutter I was worried about was simply the full class definitions, so the lambda concision is exactly what I&#39;m looking for.",
      "score" : 1,
      "owner" : {
        "account_id" : 42453136,
        "reputation" : 31,
        "user_id" : 30759710,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/M6u3J1Vp.png?s=256",
        "display_name" : "jinzōningen",
        "link" : "https://stackoverflow.com/users/30759710/jinz%c5%8dningen"
      },
      "creation_date" : 1750377276,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}