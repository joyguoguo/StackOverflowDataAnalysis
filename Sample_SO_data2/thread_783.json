{
  "question" : {
    "question_id" : 79767499,
    "title" : "Java multithreading happens-before collection when passing a collection",
    "body" : "<p>When we pass a collection from thread 1 to thread 2, and it will be used only for reading in thread 2, do we need to sync the collection? To force happens - before relationship</p>\n<pre class=\"lang-java prettyprint-override\"><code>List a = new ArrayList() ;\na.add(&quot;val&quot;)\n\nmethodToRunNewThread (a) ;\n</code></pre>\n<p>Is it guaranteed that the new thread will see values inside (a) collection?</p>\n<p>And if yes, why, how happens before relationship is executed here?</p>\n",
    "tags" : [ "java", "multithreading" ],
    "owner" : {
      "account_id" : 101412,
      "reputation" : 5235,
      "user_id" : 272869,
      "user_type" : "registered",
      "accept_rate" : 96,
      "profile_image" : "https://www.gravatar.com/avatar/83680b12d53f53f073a3fbe504695733?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "VextoR",
      "link" : "https://stackoverflow.com/users/272869/vextor"
    },
    "is_answered" : true,
    "view_count" : 125,
    "answer_count" : 2,
    "score" : 0,
    "last_activity_date" : 1758182983,
    "creation_date" : 1758121210,
    "link" : "https://stackoverflow.com/questions/79767499/java-multithreading-happens-before-collection-when-passing-a-collection",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79767517,
    "question_id" : 79767499,
    "body" : "<blockquote>\n<p>When we pass a collection from thread 1 to thread 2, and it will be used only for reading in thread 2, do we need to sync the collection?</p>\n</blockquote>\n<p>Yes you do.  (It depends on what you <em>precisely</em> mean by &quot;sync the collection&quot;.  Your code doesn't show us what you are doing in that respect.)</p>\n<blockquote>\n<p>So is it guarantee that the new thread will see values inside (a) collection?</p>\n</blockquote>\n<p>If there is a happens-before relation chain from the last write to the collection in thread 1 to the first read by thread 2, then thread 2 will see all of the writes to the collection made by thread 1 ... up to the last write.</p>\n<blockquote>\n<p>And if yes, why, how happens before relationship is executed here?</p>\n</blockquote>\n<p>A happens-before relation will exist if certain events occur.  These include <em>appropriate</em> use of a <code>synchronized</code> block or method, completion of a constructor (for <code>final</code> fields), creating a thread, joining a thread and using various Java concurrent classes.</p>\n<p>Not all of these will be relevant to your use-case.  It will depend on how the collection is passed from thread 1 to thread 2.</p>\n<hr />\n<blockquote>\n<p>What if thread 1 created the collection and will not anymore add values there and then pass to thread 2, do we need still the synchronization?</p>\n</blockquote>\n<p>You still need to synchronize appropriately.  Please read what I wrote in my 2nd paragraph.</p>\n",
    "score" : 4,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 47283,
      "reputation" : 723399,
      "user_id" : 139985,
      "user_type" : "registered",
      "accept_rate" : 69,
      "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
      "display_name" : "Stephen C",
      "link" : "https://stackoverflow.com/users/139985/stephen-c"
    },
    "creation_date" : 1758122165,
    "last_activity_date" : 1758179842,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79767529,
    "question_id" : 79767499,
    "body" : "<blockquote>\n<p>what if thread 1 created the collection and will not anymore add values there and then pass to thread 2, do we need still the synchronization? –\nVextoR</p>\n</blockquote>\n<p>Yes, as Stephan mentions, you still need a happens-before edge. If you truly do not write after a certain point, then you only need one such edge (such as writing a reference to the object to a volatile variable).</p>\n<p>Example:</p>\n<pre><code>class Example {\n\n  private volatile List&lt;String&gt; list;\n\n  public Example() {\n    List&lt;String&gt; tempList = new List&lt;&gt;();\n    tempList.add(&quot;a&quot;);\n    list = tempList;  // note: init first, then write to volatile\n  }\n\n  public boolean isPresent(String x) {\n    return list.contains(x);  // volatile provides happens-before\n  }\n}\n</code></pre>\n",
    "score" : 3,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2709823,
      "reputation" : 11069,
      "user_id" : 2338547,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/QT3fG.png?s=256",
      "display_name" : "markspace",
      "link" : "https://stackoverflow.com/users/2338547/markspace"
    },
    "creation_date" : 1758122935,
    "last_activity_date" : 1758144814,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140744262,
    "post_id" : 79767499,
    "body" : "Does <code>methodToRunNewThread</code> start a new thread? If so, that already establishes a happens-before, and no additional synchronisation is needed.",
    "score" : 1,
    "owner" : {
      "account_id" : 213468,
      "reputation" : 110282,
      "user_id" : 466862,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d873f397779db38cd510d9ee5416fd43?s=256&d=identicon&r=PG",
      "display_name" : "Mark Rotteveel",
      "link" : "https://stackoverflow.com/users/466862/mark-rotteveel"
    },
    "creation_date" : 1758183025,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140743779,
    "post_id" : 79767499,
    "body" : "@BasilBourque I gotta disagree with your comment on passing collections (or other objects) from thread to thread.  <a href=\"https://stackoverflow.com/questions/801993/java-multi-threading-safe-publication\">Check out &quot;Safe Publication&quot;</a> (a pattern) in Java Concurrency in Practice.  To me this is very much codifying &quot;passing a value from thread to thread&quot; in a pattern.  I think it&#39;s a good idea to think in this way.",
    "score" : 2,
    "owner" : {
      "account_id" : 2709823,
      "reputation" : 11069,
      "user_id" : 2338547,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/QT3fG.png?s=256",
      "display_name" : "markspace",
      "link" : "https://stackoverflow.com/users/2338547/markspace"
    },
    "creation_date" : 1758166532,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140743264,
    "post_id" : 79767499,
    "body" : "does it mean when I write something to volatile - java will sync thread local to main java memory for ALL existing threads? And if yes, that means when we write to volatile this triggers happens-before for every write - and java will constantly flush memory. ..",
    "score" : 0,
    "owner" : {
      "account_id" : 101412,
      "reputation" : 5235,
      "user_id" : 272869,
      "user_type" : "registered",
      "accept_rate" : 96,
      "profile_image" : "https://www.gravatar.com/avatar/83680b12d53f53f073a3fbe504695733?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "VextoR",
      "link" : "https://stackoverflow.com/users/272869/vextor"
    },
    "creation_date" : 1758137573,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140743002,
    "post_id" : 79767499,
    "body" : "By the way, you do not really “pass a collection from thread 1 to thread 2”. All threads have the same access to the same stuff except for <code>ThreadLocal</code> and <a href=\"https://openjdk.org/jeps/506\" rel=\"nofollow noreferrer\">Scoped Values</a> (Java 25+). You are merely passing between methods, not threads technically.",
    "score" : 0,
    "owner" : {
      "account_id" : 322981,
      "reputation" : 346842,
      "user_id" : 642706,
      "user_type" : "registered",
      "accept_rate" : 58,
      "profile_image" : "https://i.sstatic.net/ZWEI3.jpg?s=256",
      "display_name" : "Basil Bourque",
      "link" : "https://stackoverflow.com/users/642706/basil-bourque"
    },
    "creation_date" : 1758129734,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140742742,
    "post_id" : 79767499,
    "body" : "Yes, as Stephan mentions below, you still need a happens-before edge.  If you truly do not write after a certain point, then you only need one such edge (such as writing a reference to the object to a <code>volatile</code> variable.",
    "score" : 0,
    "owner" : {
      "account_id" : 2709823,
      "reputation" : 11069,
      "user_id" : 2338547,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/QT3fG.png?s=256",
      "display_name" : "markspace",
      "link" : "https://stackoverflow.com/users/2338547/markspace"
    },
    "creation_date" : 1758122685,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140742738,
    "post_id" : 79767499,
    "body" : "what if thread 1 created the collection and will not anymore add values there and then pass to thread 2, do we need still the synchronization?",
    "score" : 0,
    "owner" : {
      "account_id" : 101412,
      "reputation" : 5235,
      "user_id" : 272869,
      "user_type" : "registered",
      "accept_rate" : 96,
      "profile_image" : "https://www.gravatar.com/avatar/83680b12d53f53f073a3fbe504695733?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "VextoR",
      "link" : "https://stackoverflow.com/users/272869/vextor"
    },
    "creation_date" : 1758122569,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140742734,
    "post_id" : 79767499,
    "body" : "Tooting my own horn here: <a href=\"https://stackoverflow.com/questions/27120914/do-i-need-to-add-some-locks-or-synchronization-if-there-is-only-one-thread-writi\" title=\"do i need to add some locks or synchronization if there is only one thread writi\">stackoverflow.com/questions/27120914/&hellip;</a>",
    "score" : 0,
    "owner" : {
      "account_id" : 2709823,
      "reputation" : 11069,
      "user_id" : 2338547,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/QT3fG.png?s=256",
      "display_name" : "markspace",
      "link" : "https://stackoverflow.com/users/2338547/markspace"
    },
    "creation_date" : 1758122438,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140742716,
    "post_id" : 79767499,
    "body" : "<code>do we need to sync the collection?</code> Yes.  There must be a happens-before edge before reads take place, or visibility is not guaranteed.  Usually starting a thread does this, but if you&#39;re not then you do need to make sure that an edge of some sort is present.  Read the spec!",
    "score" : 3,
    "owner" : {
      "account_id" : 2709823,
      "reputation" : 11069,
      "user_id" : 2338547,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/QT3fG.png?s=256",
      "display_name" : "markspace",
      "link" : "https://stackoverflow.com/users/2338547/markspace"
    },
    "creation_date" : 1758122022,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79767529" : [ {
      "comment_id" : 140744626,
      "post_id" : 79767529,
      "body" : "Actually, no. Letting aside that “memory flushing” is the wrong mindset, the costs of one thread leaving a <code>synchronized</code> block and another one entering it are on par with one volatile write followed by another thread’s read. The differences come into play when multiple threads want to write.",
      "score" : 2,
      "owner" : {
        "account_id" : 3211603,
        "reputation" : 300941,
        "user_id" : 2711488,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/t2hoD.jpg?s=256",
        "display_name" : "Holger",
        "link" : "https://stackoverflow.com/users/2711488/holger"
      },
      "creation_date" : 1758193344,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140743461,
      "post_id" : 79767529,
      "body" : "@Slaw <code>final</code> would work the same here, but only because I happened to initialize the field in a constructor.  <code>volatile</code> will work for ordinary methods too.",
      "score" : 0,
      "owner" : {
        "account_id" : 2709823,
        "reputation" : 11069,
        "user_id" : 2338547,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/QT3fG.png?s=256",
        "display_name" : "markspace",
        "link" : "https://stackoverflow.com/users/2338547/markspace"
      },
      "creation_date" : 1758144977,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140743456,
      "post_id" : 79767529,
      "body" : "@BasilBourque Yup, thanks....",
      "score" : 0,
      "owner" : {
        "account_id" : 2709823,
        "reputation" : 11069,
        "user_id" : 2338547,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/QT3fG.png?s=256",
        "display_name" : "markspace",
        "link" : "https://stackoverflow.com/users/2338547/markspace"
      },
      "creation_date" : 1758144830,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140743453,
      "post_id" : 79767529,
      "body" : "@VextoR Not all threads -- <code>volatile</code> requires a write of the <code>volatile</code> field followed by a read of the same field.  Only the threads that do one or the other are affected by <i>happens-before</i>.  In general, <code>volatile</code> will do less memory flushing than <code>synchronized</code> will, I think.",
      "score" : 0,
      "owner" : {
        "account_id" : 2709823,
        "reputation" : 11069,
        "user_id" : 2338547,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/QT3fG.png?s=256",
        "display_name" : "markspace",
        "link" : "https://stackoverflow.com/users/2338547/markspace"
      },
      "creation_date" : 1758144779,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140743259,
      "post_id" : 79767529,
      "body" : "does it mean when I write something to volatile - java will sync thread local to main java memory for ALL existing threads? And if yes, that means when we write to volatile this triggers happens-before for every write - and java will constantly flush memory. ..",
      "score" : 0,
      "owner" : {
        "account_id" : 101412,
        "reputation" : 5235,
        "user_id" : 272869,
        "user_type" : "registered",
        "accept_rate" : 96,
        "profile_image" : "https://www.gravatar.com/avatar/83680b12d53f53f073a3fbe504695733?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "VextoR",
        "link" : "https://stackoverflow.com/users/272869/vextor"
      },
      "creation_date" : 1758137266,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140743088,
      "post_id" : 79767529,
      "body" : "@Basil In that case, as long as you use <code>listRef.set(tempList)</code> instead of <code>listRef = new AtomicReference&lt;&gt;(tempList)</code> then I think you&#39;ll be okay. Though <code>listRef</code> may need to be <code>final</code>. It&#39;s a little confusing with the given example because the field is only written to in the constructor of <code>Example</code>. And since the constructor is single-threaded, initializing the instance should <i>happen-before</i> passing it to another thread. Assuming appropriate synchronization when passing the <code>Example</code> instance to another thread, I don&#39;t think either <code>volatile</code> or <code>final</code> are necessarily <i>required</i> here.",
      "score" : 0,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49884,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1758131836,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140743066,
      "post_id" : 79767529,
      "body" : "@Slaw Yes, I did mean to populate on declaration to avoid that problem: <code>private AtomicReference &lt; List &lt; String &gt; &gt; listRef = new AtomicReference &lt;&gt; ( List.of() ) ;</code>",
      "score" : 0,
      "owner" : {
        "account_id" : 322981,
        "reputation" : 346842,
        "user_id" : 642706,
        "user_type" : "registered",
        "accept_rate" : 58,
        "profile_image" : "https://i.sstatic.net/ZWEI3.jpg?s=256",
        "display_name" : "Basil Bourque",
        "link" : "https://stackoverflow.com/users/642706/basil-bourque"
      },
      "creation_date" : 1758131328,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140743064,
      "post_id" : 79767529,
      "body" : "With the current design of <code>Example</code>, I believe making <code>list</code> (Basil: or <code>listRef</code>) <code>final</code> instead of <code>volatile</code> would also work. At least since Java 8, I think.",
      "score" : 1,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49884,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1758131322,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140743039,
      "post_id" : 79767529,
      "body" : "@BasilBourque The <code>AtomicReference</code> itself would not be published correctly without appropriate synchronization, such as by making <code>listRef</code> volatile. This could lead to other threads seeing <code>null</code> (or an old atomic reference if the field is written to more than once). But the value held by the atomic reference would be thread-safe, assuming the appropriate methods of <code>AtomicReference</code> are used (e.g., <code>get</code> and <code>set</code> have volatile semantics).",
      "score" : 0,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49884,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1758130754,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140742993,
      "post_id" : 79767529,
      "body" : "I wonder… Would we effectively get the same result if we replaced the <code>volatile</code> member field with an <code>AtomicReference</code>, like this: <code>private AtomicReference &lt; List &lt; String &gt; &gt; listRef ;</code>?",
      "score" : 0,
      "owner" : {
        "account_id" : 322981,
        "reputation" : 346842,
        "user_id" : 642706,
        "user_type" : "registered",
        "accept_rate" : 58,
        "profile_image" : "https://i.sstatic.net/ZWEI3.jpg?s=256",
        "display_name" : "Basil Bourque",
        "link" : "https://stackoverflow.com/users/642706/basil-bourque"
      },
      "creation_date" : 1758129549,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140742863,
      "post_id" : 79767529,
      "body" : "@VextoR Yes, <code>volatile</code> helps an entire object.  The language spec says &quot;all actions&quot; including writes are made visible.  That includes all writes inside an object, plus writes that happen elsewhere, as long as those writes happen (in program order) before the write to <code>volatile</code>.  Brian Goetz in his book <i>Java Concurrency in Practice</i> calls this &quot;piggy backing,&quot; where other writes can be made visible along with the write to <code>volatile</code>.",
      "score" : 1,
      "owner" : {
        "account_id" : 2709823,
        "reputation" : 11069,
        "user_id" : 2338547,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/QT3fG.png?s=256",
        "display_name" : "markspace",
        "link" : "https://stackoverflow.com/users/2338547/markspace"
      },
      "creation_date" : 1758125516,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140742804,
      "post_id" : 79767529,
      "body" : "Will volatile help even for an object? I mean will volatile trigger happens before even for elements which are inside collection?",
      "score" : 0,
      "owner" : {
        "account_id" : 101412,
        "reputation" : 5235,
        "user_id" : 272869,
        "user_type" : "registered",
        "accept_rate" : 96,
        "profile_image" : "https://www.gravatar.com/avatar/83680b12d53f53f073a3fbe504695733?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "VextoR",
        "link" : "https://stackoverflow.com/users/272869/vextor"
      },
      "creation_date" : 1758124143,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79767517" : [ {
      "comment_id" : 140746115,
      "post_id" : 79767517,
      "body" : "@BasilBourque Yea.  But I&#39;m not inclined to elaborate, given how sketchy the question is.  In both senses of that word!  Now ... if the OP could be bothered to clarify the question ...",
      "score" : 0,
      "owner" : {
        "account_id" : 47283,
        "reputation" : 723399,
        "user_id" : 139985,
        "user_type" : "registered",
        "accept_rate" : 69,
        "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
        "display_name" : "Stephen C",
        "link" : "https://stackoverflow.com/users/139985/stephen-c"
      },
      "creation_date" : 1758241920,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140746112,
      "post_id" : 79767517,
      "body" : "@StephenC I was thinking that assigning an object to the <code>final</code> member field <i>while inside a constructor</i> would make reading that field foolproof thread-safe given that Java guarantees an object is not accessible until after construction.",
      "score" : 0,
      "owner" : {
        "account_id" : 322981,
        "reputation" : 346842,
        "user_id" : 642706,
        "user_type" : "registered",
        "accept_rate" : 58,
        "profile_image" : "https://i.sstatic.net/ZWEI3.jpg?s=256",
        "display_name" : "Basil Bourque",
        "link" : "https://stackoverflow.com/users/642706/basil-bourque"
      },
      "creation_date" : 1758241737,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140744071,
      "post_id" : 79767517,
      "body" : "@BasilBourque Maybe.  But the <code>final</code> <i>happens-before</i> is a bit different.  As the JLS states: <i>&quot;This happens-before ordering does not transitively close with other happens-before orderings.&quot;</i>.",
      "score" : 1,
      "owner" : {
        "account_id" : 47283,
        "reputation" : 723399,
        "user_id" : 139985,
        "user_type" : "registered",
        "accept_rate" : 69,
        "profile_image" : "https://www.gravatar.com/avatar/147c5a9cc1feec049c50da791ac7d144?s=256&d=identicon&r=PG",
        "display_name" : "Stephen C",
        "link" : "https://stackoverflow.com/users/139985/stephen-c"
      },
      "creation_date" : 1758178385,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140743540,
      "post_id" : 79767517,
      "body" : "Would it be correct to add “completion of the constructor” to your list of certain events that cause a happens-before? If a <code>final</code> member field <code>List</code> is assigned a <code>List</code> object in the containing class’ constructor, would accessing the reference to that list be thread-safe without needing to be <code>volatile</code>?",
      "score" : 0,
      "owner" : {
        "account_id" : 322981,
        "reputation" : 346842,
        "user_id" : 642706,
        "user_type" : "registered",
        "accept_rate" : 58,
        "profile_image" : "https://i.sstatic.net/ZWEI3.jpg?s=256",
        "display_name" : "Basil Bourque",
        "link" : "https://stackoverflow.com/users/642706/basil-bourque"
      },
      "creation_date" : 1758148662,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140743050,
      "post_id" : 79767517,
      "body" : "@VextoR See <a href=\"https://docs.oracle.com/en/java/javase/24/docs/api/java.base/java/util/concurrent/package-summary.html#MemoryVisibility\" rel=\"nofollow noreferrer\">this documentation</a>. Particularly, &quot;<i>Each action in a thread happens-before every action in that thread that comes later in the program&#39;s order</i>&quot;, and, &quot;<i>A call to <code>start</code> on a thread happens-before any action in the started thread.</i>&quot;",
      "score" : 0,
      "owner" : {
        "account_id" : 8532578,
        "reputation" : 49884,
        "user_id" : 6395627,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/af0f9bfe593f36642a032cd7ea611e7d?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "Slaw",
        "link" : "https://stackoverflow.com/users/6395627/slaw"
      },
      "creation_date" : 1758130978,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140742751,
      "post_id" : 79767517,
      "body" : "@VextoR Stephen is telling you that you must properly synchronize the act of passing the reference from thread 1 to thread 2, but then, if thread 1 does not make any changes to the collection after it was passed, you will not need any <i>additional</i> synchronization when thread 2 subsequently uses the collection.",
      "score" : 0,
      "owner" : {
        "account_id" : 14247365,
        "reputation" : 453,
        "user_id" : 10291999,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/1yd1F.png?s=256",
        "display_name" : "Ohm&#39;s Lawman",
        "link" : "https://stackoverflow.com/users/10291999/ohms-lawman"
      },
      "creation_date" : 1758122851,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140742736,
      "post_id" : 79767517,
      "body" : "Thank you, what if thread 1 created the collection and will not anymore add values there and then pass to thread 2, do we need still the synchronization?",
      "score" : 0,
      "owner" : {
        "account_id" : 101412,
        "reputation" : 5235,
        "user_id" : 272869,
        "user_type" : "registered",
        "accept_rate" : 96,
        "profile_image" : "https://www.gravatar.com/avatar/83680b12d53f53f073a3fbe504695733?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "VextoR",
        "link" : "https://stackoverflow.com/users/272869/vextor"
      },
      "creation_date" : 1758122505,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}