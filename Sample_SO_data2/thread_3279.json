{
  "question" : {
    "question_id" : 79562445,
    "title" : "DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS doesn&#39;t preserve scale",
    "body" : "<p>When I deserialize a JSON number to a <code>BigDecimal</code> using <code>readTree</code>, the results don't preserve the scale, i.e. it treats <code>0.10</code> as <code>0.1</code>. On the other hand, if I deserialize using <code>readValue</code>, it <em>does</em> preserve scale, returning a <code>BigDecimal</code> with the correct scale of 2:</p>\n<pre><code>    ObjectMapper objectMapper = new ObjectMapper();\n    objectMapper.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\n    JsonNode jsonNode = objectMapper.readTree(&quot;0.10&quot;);\n    BigDecimal numberFromReadTree = ((DecimalNode)jsonNode).decimalValue();\n    BigDecimal numberFromReadValue = objectMapper.readValue(&quot;0.10&quot;, BigDecimal.class);\n\n    System.out.println(numberFromReadTree); // Prints 0.1, i.e. scale = 1\n    System.out.println(numberFromReadValue); // Prints 0.10, i.e. scale = 2\n</code></pre>\n<p>Is there a reason for this apparent inconsistency, and is there an option I can set to keep the scale the same as the input (i.e. to be consistent with <code>readValue</code>)?</p>\n",
    "tags" : [ "java", "jackson", "jackson-databind" ],
    "owner" : {
      "account_id" : 319988,
      "reputation" : 11876,
      "user_id" : 638028,
      "user_type" : "registered",
      "accept_rate" : 91,
      "profile_image" : "https://i.sstatic.net/xj2Hg.png?s=256",
      "display_name" : "Klitos Kyriacou",
      "link" : "https://stackoverflow.com/users/638028/klitos-kyriacou"
    },
    "is_answered" : true,
    "view_count" : 177,
    "answer_count" : 1,
    "score" : 4,
    "last_activity_date" : 1744178202,
    "creation_date" : 1744125296,
    "link" : "https://stackoverflow.com/questions/79562445/deserializationfeature-use-big-decimal-for-floats-doesnt-preserve-scale",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79563027,
    "question_id" : 79562445,
    "body" : "<blockquote>\n<p>Is there a reason for this apparent inconsistency, and is there an option I can set to keep the scale the same as the input (i.e. to be consistent with <code>readValue</code>)?</p>\n</blockquote>\n<p>As you pointed the reason for this inconsistency stands in an option that can be set for <code>JSonNode</code> nodes that will be created:</p>\n<pre><code>JsonNodeFactory factory = new JsonNodeFactory(true);\nObjectMapper objectMapper = new ObjectMapper();\nobjectMapper.setNodeFactory(factory);\nobjectMapper.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\nJsonNode jsonNode = objectMapper.readTree(&quot;0.10&quot;);\nSystem.out.println(jsonNode); // Prints 0.10, i.e. scale = 2\n</code></pre>\n<p>Basically the <code>ObjectMapper</code> mapper has to set its <code>JSonNodeFactory</code> attribute passing a new <code>JsonNodeFactory</code> object created by the  <a href=\"https://fasterxml.github.io/jackson-databind/javadoc/2.14/com/fasterxml/jackson/databind/node/JsonNodeFactory.html#JsonNodeFactory-boolean-\" rel=\"nofollow noreferrer\"><code>JsonNodeFactory#JsonNodeFactory-boolean</code></a> constructor using the <code>true</code> value indicating that DecimalNode instances must be built with exact representations of BigDecimal instances, while the std <code>ObjectMapper</code> constructor owns a <code>JsonNodeFactory</code> object created by the no-arg constructor (and the default instance) with a default <code>false</code> value as an argument.</p>\n<p>In the second case that uses a <code>ObjectMapper</code> mapper without touching the <code>JSonNodeFactory</code> attribute:</p>\n<pre><code>ObjectMapper objectMapper = new ObjectMapper();\nobjectMapper.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\nBigDecimal numberFromReadValue = objectMapper.readValue(&quot;0.10&quot;, BigDecimal.class);\nSystem.out.println(numberFromReadValue); // Prints 0.10, i.e. scale = 2\n</code></pre>\n<p>It works because in the <code>BigDecimal</code> class the <a href=\"https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html#BigDecimal-java.lang.String-\" rel=\"nofollow noreferrer\"><code>BigDecimal.html#BigDecimal-java.lang.String</code></a> constructor is present and directly used by the <code>ObjectMapper</code> mapper giving the expected result.</p>\n",
    "score" : 1,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 16211352,
      "reputation" : 4677,
      "user_id" : 11713777,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/2d0a11098b79513b0ec2cacb62a0cc59?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "dariosicily",
      "link" : "https://stackoverflow.com/users/11713777/dariosicily"
    },
    "creation_date" : 1744145073,
    "last_activity_date" : 1744178202,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140312871,
    "post_id" : 79562445,
    "body" : "The discrepancy seems surprising to me.  However, it looks like either treatment you observe, considered separately, would be consistent with JSON, which does not seem to specify any particular significance for trailing zeroes with place-value less than 1.  If you want to preserve scale when conveying decimal numbers via JSON then your best bet is probably to convey them as JSON strings (e.g. <code>&quot;\\&quot;1.0\\&quot;&quot;</code>) and convert to <code>BigDecimal</code> after deserialization.",
    "score" : 1,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1744131766,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79563027" : [ {
      "comment_id" : 140315170,
      "post_id" : 79563027,
      "body" : "Glad to have helped :)  @KlitosKyriacou. Even if it  still appears in the doc, I found that the static method has been annotated as deprecated in the <a href=\"https://github.com/FasterXML/jackson-databind/blob/2.19/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\" rel=\"nofollow noreferrer\">last version</a> of the <code>JNodeNodeFactory</code> class.",
      "score" : 1,
      "owner" : {
        "account_id" : 16211352,
        "reputation" : 4677,
        "user_id" : 11713777,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/2d0a11098b79513b0ec2cacb62a0cc59?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "dariosicily",
        "link" : "https://stackoverflow.com/users/11713777/dariosicily"
      },
      "creation_date" : 1744188305,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140315029,
      "post_id" : 79563027,
      "body" : "Thanks for the detailed answer! Looking at the documentation you linked, I think that, instead of calling the <code>new JsonNodeFactory(true)</code> constructor, it makes it much clearer to use the static function: <code>JsonNodeFactory factory = JsonNodeFactory.withExactBigDecimals(true);</code>.",
      "score" : 1,
      "owner" : {
        "account_id" : 319988,
        "reputation" : 11876,
        "user_id" : 638028,
        "user_type" : "registered",
        "accept_rate" : 91,
        "profile_image" : "https://i.sstatic.net/xj2Hg.png?s=256",
        "display_name" : "Klitos Kyriacou",
        "link" : "https://stackoverflow.com/users/638028/klitos-kyriacou"
      },
      "creation_date" : 1744186429,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}