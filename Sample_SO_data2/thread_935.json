{
  "question" : {
    "question_id" : 79762105,
    "title" : "How to separate a pure domain object from its JPA implementation in a microservice architecture?",
    "body" : "<p>I’m refactoring a microservice and I need to move one of my domain objects into an external shared dependency (library).</p>\n<p>Currently, this domain object is annotated with JPA (@Entity, @Id, etc.).\nHowever, I don’t want any technical details (like persistence annotations) to leak into my shared dependency — it should contain only pure, generic domain objects.</p>\n<p>I want:</p>\n<ul>\n<li>Define a pure domain object (without JPA annotations) in the external dependency.</li>\n<li>Inside my microservice, map or extend this object into a JPA entity to handle persistence.</li>\n</ul>\n<p>This way, the external dependency stays framework-agnostic, while my microservice can still persist the object.</p>\n<p>What is the recommended approach or best practice for achieving this separation?</p>\n<p>Domain object:</p>\n<pre><code>@Entity\n@Table(name = &quot;my_domain_obj&quot;,schema = &quot;domain_obj&quot;)\npublic class MyDomainObj implements Serializable {\n\n    @Id\n    public Integer id;\n\n    @Column(name = &quot;name&quot;)\n    public String name;\n</code></pre>\n",
    "tags" : [ "java", "spring-boot", "jpa", "microservices", "separation-of-concerns" ],
    "owner" : {
      "account_id" : 8056132,
      "reputation" : 403,
      "user_id" : 6073219,
      "user_type" : "registered",
      "accept_rate" : 80,
      "profile_image" : "https://www.gravatar.com/avatar/e746f335363b80c443a3b206851f4970?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Ryley38",
      "link" : "https://stackoverflow.com/users/6073219/ryley38"
    },
    "is_answered" : false,
    "view_count" : 111,
    "answer_count" : 2,
    "score" : 1,
    "last_activity_date" : 1758700286,
    "creation_date" : 1757604000,
    "link" : "https://stackoverflow.com/questions/79762105/how-to-separate-a-pure-domain-object-from-its-jpa-implementation-in-a-microservi",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79773423,
    "question_id" : 79762105,
    "body" : "<p>Adopt hexagonal architecture, its purpose is to solve this.</p>\n<p>In your domain logic, define pure object and specify the interface of the repository.</p>\n<p>Then provide an implementation of the repository interface. If you use JPA, you will have to convert the domain objects into JPA entities. You will be able to change of technology later without any impact on your domain logic and domain objects.</p>\n<p>When you instantiate the domain logic, pass it the implementation of the repository.</p>\n<p>The hexagonal architecture is all about that : the domain logic defines the repository interface for its domain objects and is provided an implementation of this repository, so the domain logic is not tainted with any implementation details like the JPA annotations.</p>\n<pre class=\"lang-java prettyprint-override\"><code>// Pure domain object\npublic class MyDomainObj {\n    public Integer id;\n    public String name;\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>// Pure domain repository\npublic interface MyDomainObjRepository {\n    public List&lt;MyDomainObj&gt; getObjects();\n    public void saveObject(MyDomainObj object) throws Exception;\n}\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>// JPA entity\n@Entity\n@Table(name = &quot;my_domain_obj&quot;,schema = &quot;domain_obj&quot;)\npublic class JPAObj implements Serializable {\n    @Id\n    public Integer id;\n    @Column(name = &quot;name&quot;)\n    public String name;\n</code></pre>\n<pre class=\"lang-java prettyprint-override\"><code>// JPA Repository\npublic class JPAObjRepository implements MyDomainObjRepository {\n    public List&lt;MyDomainObj&gt; getObjects() {\n        // retrieve entity objects, convert them into domain objects and return them\n    }\n    public void saveObject(MyDomainObj object) throws Exception {\n        // convert into entity object and persist the entity object\n    }\n}\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2296191,
      "reputation" : 2891,
      "user_id" : 2017567,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/rJame.jpg?s=256",
      "display_name" : "Christophe Quintard",
      "link" : "https://stackoverflow.com/users/2017567/christophe-quintard"
    },
    "creation_date" : 1758700286,
    "last_activity_date" : 1758700286,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79762202,
    "question_id" : 79762105,
    "body" : "<p>Put the annotations in an abstract parent class in another package? You will need one per Domain Object.</p>\n",
    "score" : -1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1880361,
      "reputation" : 253,
      "user_id" : 1700716,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d0ab8e4b4c98406ac61b0a317be9747a?s=256&d=identicon&r=PG",
      "display_name" : "Nikolaj Hansen",
      "link" : "https://stackoverflow.com/users/1700716/nikolaj-hansen"
    },
    "creation_date" : 1757609364,
    "last_activity_date" : 1757609364,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140731664,
    "post_id" : 79762105,
    "body" : "Some providers though allow completely ignoring entity properties and only using what is defined in the orm.xml: EclipseLink has its own eclipselink-orm.xml extension that allows specifying xml-mapping-metadata-complete, which will cause it to not use any mappings not within that file - so new properties won&#39;t automatically have default mappings applied if the entity class changes. Most providers will allow building mappings dynamically outside of the JPA annotation way, or have their own native mapping solutions outside of JPA entities which would have the same effect",
    "score" : 0,
    "owner" : {
      "account_id" : 231721,
      "reputation" : 21335,
      "user_id" : 496099,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/efa7510cf47d7bd79e80486246e7e39e?s=256&d=identicon&r=PG",
      "display_name" : "Chris",
      "link" : "https://stackoverflow.com/users/496099/chris"
    },
    "creation_date" : 1757683465,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140731651,
    "post_id" : 79762105,
    "body" : "You don&#39;t need any annotations if using an orm.xml mapping file. If your issue is about changing entities in a shared external library.. that is a problem for every application; how does the storage of the serialized view of the previous version map to the latest library your &#39;other&#39; apps might have on hand? There are no great solutions for that except versioning your libraries and ensuring your apps are updated and tested before migrating to the latest.",
    "score" : 0,
    "owner" : {
      "account_id" : 231721,
      "reputation" : 21335,
      "user_id" : 496099,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/efa7510cf47d7bd79e80486246e7e39e?s=256&d=identicon&r=PG",
      "display_name" : "Chris",
      "link" : "https://stackoverflow.com/users/496099/chris"
    },
    "creation_date" : 1757683257,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140731035,
    "post_id" : 79762105,
    "body" : "@Chris I’m not sure I fully understand your point. Could you clarify what you mean by persisting information using ORM.xml? The issue I’m facing is that with all the solutions I’ve found so far, I still need to update the microservices that import the shared package whenever a property in the domain object changes.",
    "score" : 0,
    "owner" : {
      "account_id" : 8056132,
      "reputation" : 403,
      "user_id" : 6073219,
      "user_type" : "registered",
      "accept_rate" : 80,
      "profile_image" : "https://www.gravatar.com/avatar/e746f335363b80c443a3b206851f4970?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "Ryley38",
      "link" : "https://stackoverflow.com/users/6073219/ryley38"
    },
    "creation_date" : 1757662745,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140729694,
    "post_id" : 79762105,
    "body" : "Annotations within the entity are just a convenience, albeit one that everyone comes to expect as the go to place to store mapping data. You can map any object from anywhere with persistence information using an ORM.xml and is the approach I&#39;d use rather than create a duplicate object just to hold mapping data. This also allows different persistence units to use the same java classes in slightly different ways - great to account for mapping differences in maybe a test or stage environment",
    "score" : 1,
    "owner" : {
      "account_id" : 231721,
      "reputation" : 21335,
      "user_id" : 496099,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/efa7510cf47d7bd79e80486246e7e39e?s=256&d=identicon&r=PG",
      "display_name" : "Chris",
      "link" : "https://stackoverflow.com/users/496099/chris"
    },
    "creation_date" : 1757605925,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}