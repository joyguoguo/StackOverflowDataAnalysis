{
  "question" : {
    "question_id" : 79826692,
    "title" : "&quot;DefaultJpaDialect does not support custom isolation levels&quot; when upgrading to spring batch 5",
    "body" : "<p>I am upgrading an app to newest Spring Boot 3, and because of that Spring Batch is upgraded to 5.2.3 (from 4.3.10).</p>\n<p>The application did not persist batch states previously, it was using the &quot;map based&quot; job repository.</p>\n<p>Since that map based repository completely removed in v5, I have to change to a JDBC table based repo. I have read the migration guide ( <a href=\"https://github.com/spring-projects/spring-batch/wiki/Spring-Batch-5.0-Migration-Guide\" rel=\"nofollow noreferrer\">https://github.com/spring-projects/spring-batch/wiki/Spring-Batch-5.0-Migration-Guide</a> ) and according to that I changed the following part of the application:</p>\n<pre><code>        return new StepBuilder(&quot;cnyProcessStep&quot;, jobRepository) //\n                .allowStartIfComplete(true)//\n                .&lt;ChangeDataHolder&lt;CnyPushChangeData&gt;, CnyPushAcknowledgementHolder&gt; chunk(1)\n                .reader(cnyPushItemReader) //\n                .processor(compositeProcessor) //\n                .writer(cnyPushItemWriter) //\n                .faultTolerant()\n                .skipPolicy((t, skipCount) -&gt; true) //\n                .listener(defaultBatchListener) //\n                .transactionAttribute(new DefaultTransactionAttribute(TransactionDefinition.PROPAGATION_NEVER))\n                .build();\n</code></pre>\n<p>to this:</p>\n<pre><code>...\n    @Autowired\n    private PlatformTransactionManager transactionManager;\n...\n\n        return new StepBuilder(&quot;cnyProcessStep&quot;, jobRepository) //\n                .allowStartIfComplete(true)//\n                .&lt;ChangeDataHolder&lt;CnyPushChangeData&gt;, CnyPushAcknowledgementHolder&gt; chunk(1, transactionManager)\n                .reader(cnyPushItemReader) //\n                .processor(compositeProcessor) //\n                .writer(cnyPushItemWriter) //\n                .faultTolerant()\n                .skipPolicy((t, skipCount) -&gt; true) //\n                .listener(defaultBatchListener) //\n                .transactionAttribute(new DefaultTransactionAttribute(TransactionDefinition.PROPAGATION_NEVER))\n                .build();\n</code></pre>\n<p>Basically I added the platform tx manager as a second parameter to the chunk(...) method.</p>\n<p>I also created the required tables and sequences to the database schema ( schema-oracle.sql from the batch core artifact ).</p>\n<p>After these changes, the job throws the following excpetion on execution:</p>\n<pre><code>...\nCaused by: org.springframework.transaction.InvalidIsolationLevelException: DefaultJpaDialect does not support custom isolation levels due to limitations in standard JPA. Specific arrangements may be implemented in custom JpaDialect variants.\n    at org.springframework.orm.jpa.DefaultJpaDialect.beginTransaction(DefaultJpaDialect.java:64)\n    at org.springframework.orm.jpa.JpaTransactionManager.doBegin(JpaTransactionManager.java:421)\n    at org.springframework.transaction.support.AbstractPlatformTransactionManager.startTransaction(AbstractPlatformTransactionManager.java:532)\n    at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:405)\n    at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:639)\n    at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:374)\n    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:119)\n    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:184)\n    at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:223)\n    at jdk.proxy2/jdk.proxy2.$Proxy375.getLastJobExecution(Unknown Source)\n    at org.springframework.batch.core.launch.support.TaskExecutorJobLauncher.run(TaskExecutorJobLauncher.java:109)\n</code></pre>\n<p>What's my mistake?</p>\n<hr />\n<h2>1st idea: configure HibernateJpaDialect</h2>\n<p>This is a JPA project, and the tx manager in Spring was set up to be an instance of JpaTransactionManager.\nThat JpaTransactionManager is by default uses a DefaultJpaDialect instance, and the &quot;.beginTransaction&quot;\nmethod there throws the &quot;DefaultJpaDialect does not support custom isolation levels...&quot; exception.</p>\n<p>Since we use Hibernate as the JPA implementation in the project, my first thought was to specify\nHibernateJpaDialect (instead of the default) in our db config like this:</p>\n<pre><code>    @Bean\n    public PlatformTransactionManager transactionManager() {\n        JpaTransactionManager transactionManager = new JpaTransactionManager();\n        transactionManager.setEntityManagerFactory(entityManagerFactory());\n        transactionManager.setDataSource(dataSource);\n        transactionManager.setJpaDialect(new HibernateJpaDialect());\n        return transactionManager;\n    }\n</code></pre>\n<p>Unfortunately, after that I still got an other kind of exception:</p>\n<pre><code>Caused by: org.springframework.transaction.InvalidIsolationLevelException: HibernateJpaDialect is not allowed to support custom isolation levels: make sure that its 'prepareConnection' flag is on (the default) and that the Hibernate connection release mode is set to ON_CLOSE.\n    at org.springframework.orm.jpa.vendor.HibernateJpaDialect.beginTransaction(HibernateJpaDialect.java:168)\n    at org.springframework.orm.jpa.JpaTransactionManager.doBegin(JpaTransactionManager.java:421)\n\n</code></pre>\n<p>I gave it a try and completed my entityManagerFactory with the hibernate.connection.release_mode&quot;, &quot;on_close&quot;\nsetting</p>\n<pre><code>    @Bean\n    public EntityManagerFactory entityManagerFactory() {\n        LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();\n        factoryBean.setDataSource(dataSource);\n        factoryBean.setPackagesToScan(\n                ...\n                );\n        factoryBean.setPersistenceProviderClass(HibernatePersistenceProvider.class);\n        Properties properties = new Properties();\n        ...\n        properties.put(&quot;hibernate.connection.release_mode&quot;, &quot;on_close&quot;);\n        factoryBean.setJpaProperties(properties);\n        factoryBean.afterPropertiesSet();\n        return factoryBean.getObject();\n    }\n</code></pre>\n<p>and completed the hibernateJpaDialect with the &quot;setPrepareConnection(true)&quot; settings</p>\n<pre><code>    @Bean\n    public PlatformTransactionManager transactionManager() {\n        JpaTransactionManager transactionManager = new JpaTransactionManager();\n        transactionManager.setEntityManagerFactory(entityManagerFactory());\n        transactionManager.setDataSource(dataSource);\n        transactionManager.setDefaultTimeout(txTimeoutInSeconds);\n        HibernateJpaDialect hibernateJpaDialect = new HibernateJpaDialect();\n        hibernateJpaDialect.setPrepareConnection(true);\n        transactionManager.setJpaDialect(hibernateJpaDialect);\n        return transactionManager;\n    }\n</code></pre>\n<p>But still got the same &quot;HibernateJpaDialect is not allowed to support custom isolation levels...&quot;\nexception.</p>\n<hr />\n<h2>2nd try: configure Batch via @EnableBatchProcessing(transactionManagerRef = &quot;...&quot;)</h2>\n<p>After that I tried to configure a separate tx manager for the Spring Batch via the\n@EnableBatchProcessing(transactionManagerRef = &quot;someOtherTxManRef&quot;) annotation:</p>\n<pre><code>@Configuration\n@EnableBatchProcessing(transactionManagerRef = &quot;batchTransactionManager&quot;)\npublic class BatchConfig {\n    @Bean(defaultCandidate = false, name = &quot;batchTransactionManager&quot;)\n    public DataSourceTransactionManager batchTransactionManager(DataSource ds) {\n        return new DataSourceTransactionManager(ds);\n    }\n}\n</code></pre>\n<p>With that DataSourceTransactionManager instance the Spring-Batch jobs\nstarted working.</p>\n<p>So It seems that I have a working solution.</p>\n<p>It would be reassuring to have some feedback if this is indeed a proper\nsolution or not ?</p>\n<p>Also I am a bit worried that I use two different TransactionManager\n(a JpaTransactionManager for the application and a DataSourceTransactionManager\nfor Spring-Batch) with <em>ONE</em> datasource.</p>\n<p>Is it safe? Or should I configure a separate DataSource for the\nDataSourceTransactionManager?</p>\n",
    "tags" : [ "java", "oracle-database", "spring-boot", "jpa", "spring-batch" ],
    "owner" : {
      "account_id" : 4639875,
      "reputation" : 1839,
      "user_id" : 3760049,
      "user_type" : "registered",
      "accept_rate" : 86,
      "profile_image" : "https://www.gravatar.com/avatar/69ed405cd4036cdf27e003ca372c6d1c?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "riskop",
      "link" : "https://stackoverflow.com/users/3760049/riskop"
    },
    "is_answered" : false,
    "view_count" : 60,
    "answer_count" : 0,
    "score" : 0,
    "last_activity_date" : 1764086019,
    "creation_date" : 1763739169,
    "link" : "https://stackoverflow.com/questions/79826692/defaultjpadialect-does-not-support-custom-isolation-levels-when-upgrading-to-s",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ ],
  "answer_comments" : { }
}