{
  "question" : {
    "question_id" : 79809902,
    "title" : "Java 21+ container support: active processor count",
    "body" : "<p>In containers running Java 21+, I would like to have the active processor count reflect the actual available hardware cores, regardless of configured CPU shares.</p>\n<p>CSR <a href=\"https://bugs.openjdk.org/browse/JDK-8281571\" rel=\"nofollow noreferrer\">JDK-8281571</a> &quot;Do not use CPU Shares to compute active processor count&quot; explains the problem with using Docker/Kubernetes CPU resource limits to determine the active processor count with <code>-XX:+UseContainerSupport</code> and I understand it to have changed this.</p>\n<p>In Java 21 however, the deprecated flags controlling this (<code>UseContainerCpuShares</code> and <code>PreferContainerQuotaForCPUCount</code>) are gone, and I cannot find documentation on what the situation is supposed to be wrt container CPU limits.</p>\n<p>The behavior in Kubernetes, with resource limits like this:</p>\n<pre><code>   resources:\n      limits:\n         cpu: 1000m\n</code></pre>\n<p>is that the active processor count is limited to <code>1</code> with all the problems described in JDK-8281571 (<code>Runtime.getRuntime().availableProcessors()</code> returns <code>1</code>).</p>\n<p>I could override this explicitly with <code>-XX:ActiveProcessorCount=n</code>, but this requires explicitly configuring the concrete processor count, which might change with node updates and tends to be missed during updates.</p>\n<p>I tried setting <code>-XX:ActiveProcessorCount=-1</code>, however this does not do anything.</p>\n",
    "tags" : [ "java", "kubernetes", "jvm" ],
    "owner" : {
      "account_id" : 1181771,
      "reputation" : 1288,
      "user_id" : 1156561,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/cfa23205cce07923a8c4e3f4b0824389?s=256&d=identicon&r=PG",
      "display_name" : "Carsten",
      "link" : "https://stackoverflow.com/users/1156561/carsten"
    },
    "is_answered" : false,
    "view_count" : 126,
    "answer_count" : 0,
    "score" : 1,
    "last_activity_date" : 1762337876,
    "creation_date" : 1762337876,
    "link" : "https://stackoverflow.com/questions/79809902/java-21-container-support-active-processor-count",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ ],
  "question_comments" : [ {
    "comment_id" : 140839555,
    "post_id" : 79809902,
    "body" : "I agree with you, on the other hand, telling Java there are a lot of CPUs while you have relatively low limits compared to the total CPU availability might lead to other problems due to throttling. But yes, I wonder how many applications are out there that don&#39;t run as well as they could because they assume a single CPU, and thus have small thread pools (which especially with virtual threads can be either a bottleneck, or even an issue if there is pinning).",
    "score" : 0,
    "owner" : {
      "account_id" : 213468,
      "reputation" : 110282,
      "user_id" : 466862,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d873f397779db38cd510d9ee5416fd43?s=256&d=identicon&r=PG",
      "display_name" : "Mark Rotteveel",
      "link" : "https://stackoverflow.com/users/466862/mark-rotteveel"
    },
    "creation_date" : 1762421173,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140837779,
    "post_id" : 79809902,
    "body" : "The main question remains, however: Is there a simple way to make the JVM ignore the limit without setting a fixed core number manually (and without losing the other non-cpu UseContainerSupport comforts)?",
    "score" : 0,
    "owner" : {
      "account_id" : 1181771,
      "reputation" : 1288,
      "user_id" : 1156561,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/cfa23205cce07923a8c4e3f4b0824389?s=256&d=identicon&r=PG",
      "display_name" : "Carsten",
      "link" : "https://stackoverflow.com/users/1156561/carsten"
    },
    "creation_date" : 1762346756,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140837775,
    "post_id" : 79809902,
    "body" : "@MarkRotteveel rereading, I can see that interpretation. I might have read too much into the discussion about how those limits are actually applied in the container runtime, and sentences like &quot;After this CSR, the JVM may use as much CPU as given by the OS&quot;. I still find it strange - to put mildly - to derive a core count from a cpu time quota. Those are categorically different things. But I guess that&#39;s a different question.",
    "score" : 0,
    "owner" : {
      "account_id" : 1181771,
      "reputation" : 1288,
      "user_id" : 1156561,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/cfa23205cce07923a8c4e3f4b0824389?s=256&d=identicon&r=PG",
      "display_name" : "Carsten",
      "link" : "https://stackoverflow.com/users/1156561/carsten"
    },
    "creation_date" : 1762346670,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140837570,
    "post_id" : 79809902,
    "body" : "As far as I can tell, the ticket you link describes the problem of using requests, not limits to determine the CPU count.",
    "score" : 0,
    "owner" : {
      "account_id" : 213468,
      "reputation" : 110282,
      "user_id" : 466862,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/d873f397779db38cd510d9ee5416fd43?s=256&d=identicon&r=PG",
      "display_name" : "Mark Rotteveel",
      "link" : "https://stackoverflow.com/users/466862/mark-rotteveel"
    },
    "creation_date" : 1762339421,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}