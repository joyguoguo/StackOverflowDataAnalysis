{
  "question" : {
    "question_id" : 79625563,
    "title" : "JPA Optimistic lock for associations",
    "body" : "<p>I'm trying to solve a problem with optimistic locks in jpa and hibernate for parent entity with associations. I need to increment the version of parent when child entity is changed or a new child entity is saved. I can't use OPTIMISTIC_FORCE_INCREMENT as in that transaction the parent entity also could be changed so the version will increment twice.</p>\n<pre><code>Parent {\n    \n    // The version of parent should be incremented if children list or children entity is modified\n    @OneToMany(\n        mappedBy = &quot;parent&quot;,\n        cascade = CascadeType.ALL\n    )\n    List&lt;Child&gt; children;\n    ...\n\n    @Version\n    Long version;\n\n}\n\nChild {\n    \n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = &quot;parent_id&quot;, nullable = false)\n    private Parent parent;\n    ...\n\n}\n</code></pre>\n<p>How can I achieve incrementing the parent version once if children or children list is changed or only parent is changed or both?\nI've read this article <a href=\"https://vladmihalcea.com/how-to-increment-the-parent-entity-version-whenever-a-child-entity-gets-modified-with-jpa-and-hibernate/\" rel=\"nofollow noreferrer\">vlad example</a> but can't implement his approach with RootAware interface. Ideal solution for me would be to check whether the parent has changed and if not to use force version increment lock otherwise not to lock the parent as it is already changed.</p>\n<p>Update:\nAlso I found out such a strange situation.\nIf I have a bidirectional relation between child and parent(like in the example above), when I change the children list the Parent's version is not incremented:D. The solution for that case for incrementing is to use @OptimisticLock(excluded = false) above the children field.\nBut if I have a unidirectional link with @JoinColumn on the Parent side in the same situation the Parent's version gets incremented. Is it normal behavior?</p>\n",
    "tags" : [ "java", "hibernate", "jpa", "optimistic-locking" ],
    "owner" : {
      "account_id" : 29075771,
      "reputation" : 143,
      "user_id" : 22272977,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/AAcHTte84Ivji8PRE1ZJ4PbrT8hScfiqYc2zV3zX5YpeaOwC=k-s256",
      "display_name" : "Роман Григорьев",
      "link" : "https://stackoverflow.com/users/22272977/%d0%a0%d0%be%d0%bc%d0%b0%d0%bd-%d0%93%d1%80%d0%b8%d0%b3%d0%be%d1%80%d1%8c%d0%b5%d0%b2"
    },
    "is_answered" : false,
    "view_count" : 146,
    "answer_count" : 1,
    "score" : 2,
    "last_activity_date" : 1747567811,
    "creation_date" : 1747411527,
    "link" : "https://stackoverflow.com/questions/79625563/jpa-optimistic-lock-for-associations",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79627362,
    "question_id" : 79625563,
    "body" : "<h1>Conditions</h1>\n<p>As far as I understand, you have the following conditions:</p>\n<ul>\n<li>if no changes are made, version remains still;</li>\n<li>if a parent is changed, version is incremented by one;</li>\n<li>if a child is changed, version is incremented by one;</li>\n<li>if both parent and child are changed, version is still incremented by one.</li>\n</ul>\n<p>This custom logic requires writing a simple <code>PreUpdateEventListener</code> for Hibernate.</p>\n<blockquote>\n<p>The main idea is, Hibernate needs to know whether an entity is dirty or not to update its <code>@Version</code>-annotated <code>version</code>. When try to set the <code>version</code> field manually, the entity would be marked dirty and it would be considered for flushing later.</p>\n</blockquote>\n<blockquote>\n<p>It is tricky, because according to Jakarta Persistence 3.2 (<a href=\"https://jakarta.ee/specifications/persistence/3.2/jakarta-persistence-spec-3.2#a2060\" rel=\"nofollow noreferrer\">source</a>), it is not possible to override <code>version</code> manually. Instead, we just  make a dummy change only to mark the <code>Parent</code> dirty, which would still increment the <code>@Version</code>, but only on Hibernate's behalf, ignoring our <code>version</code> changes.</p>\n</blockquote>\n<h1><code>Parent</code> setup</h1>\n<p>First, we need to add a <code>transient</code> field to the <code>Parent</code> entity to track whether increment has been done before.</p>\n<blockquote>\n<p>This step is not required. The main goal with a transient field is, to show programatically later that we would change <code>version</code> only once for clarity reasons. See the note above about Jakarta EE specification.</p>\n</blockquote>\n<p>Updated <code>Parent</code> entity:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Getter\n@Setter\npublic class Parent {\n  // ...\n  \n  @Version  \n  private Long version;  \n  \n  private transient Long tempVersion;\n\n  @PostLoad  \n  private void saveTempVersion() {  \n    tempVersion = version;  \n  }\n}\n</code></pre>\n<h1><code>PreUpdateEventListener</code></h1>\n<p>After that, we should write an external pre-update listener, which can track changes between old and new <code>Child</code> state and mark <code>Parent</code> as dirty accordingly.</p>\n<blockquote>\n<p>As stated above, client-defined <code>version</code> is not actually persisted as is, we just change its value to make the entity dirty, which Hibernate would increment on flush.</p>\n</blockquote>\n<blockquote>\n<p>This listener might be simplified to some extent, as the main point is, to make <code>Parent</code> dirty.</p>\n</blockquote>\n<pre class=\"lang-java prettyprint-override\"><code>public class ParentPreUpdateEventListener implements PreUpdateEventListener {  \n  @Override  \n  public boolean onPreUpdate(PreUpdateEvent event) {  \n    if (event.getEntity() instanceof Child child) {  \n      var parent = child.getParent();  \n      incrementParentVersionOnce(parent);  \n    }\n  \n    return false;  \n  }  \n  \n  private void incrementParentVersionOnce(Parent parent) {  \n    if (!hasVersionBeenIncrementedBefore(parent)) {  \n      parent.setVersion(parent.getVersion() + 1);  \n    }  \n  }  \n  \n  private boolean hasVersionBeenIncrementedBefore(Parent parent) {  \n    return !parent.getTempVersion().equals(parent.getVersion());  \n  }  \n}\n</code></pre>\n<h1><code>Integrator</code></h1>\n<p>Next, we need to add this listener in a custom <code>Integrator</code>:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class HibernateEventListenerIntegrator implements Integrator {  \n  @Override  \n  public void integrate(Metadata metadata, BootstrapContext bootstrapContext,  \n      SessionFactoryImplementor sessionFactory) {  \n    var serviceRegistry = sessionFactory.getSessionFactory().getServiceRegistry();  \n    var eventListenerRegistry = serviceRegistry.getService(EventListenerRegistry.class);  \n  \n    var parentEventListener = new ParentPreUpdateEventListener();  \n    eventListenerRegistry.appendListeners(EventType.PRE_UPDATE, parentEventListener);  \n  }  \n}\n</code></pre>\n<h1><code>IntegratorProvider</code></h1>\n<p>As an additional step, this <code>Integrator</code> needs to be provided in a <code>IntegratorProvider</code>:</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class HibernateEventListenerIntegratorProvider implements IntegratorProvider {  \n  @Override  \n  public List&lt;Integrator&gt; getIntegrators() {  \n    return List.of(new HibernateEventListenerIntegrator());  \n  }  \n}\n</code></pre>\n<p>Now let this <code>IntegratorProvider</code> be registered with Hibernate. Add to your <code>application.properties</code> the following line (it is assumed this class is located at <code>com.example</code> package):</p>\n<pre><code>hibernate.integrator_provider=com.example.HibernateEventListenerIntegratorProvider\n</code></pre>\n<p>If you use Spring Boot, use the following line:</p>\n<pre><code>spring.jpa.properties.hibernate.integrator_provider=com.example.HibernateEventListenerIntegratorProvider\n</code></pre>\n<hr />\n<h1>Integration test</h1>\n<p>I have written an integration unit test that proves this approach works. I use Spring Boot's <code>@DataJpaTest</code> with dependency injection to simplify setting up the test environment, but the main idea with Hibernate stays the same.</p>\n<p>Integration test code:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@DataJpaTest\npublic class ParentChildTest {\n  @Autowired\n  private EntityManager entityManager;\n\n  @BeforeEach\n  void setUp() {\n    var parent = Parent.builder()\n        .id(&quot;1&quot;)\n        .name(&quot;name 1&quot;)\n        .build();\n    entityManager.persist(parent);\n\n    var child = Child.builder()\n        .id(&quot;123&quot;)\n        .name(&quot;name 1&quot;)\n        .parent(parent)\n        .build();\n    entityManager.persist(child);\n\n    entityManager.flush();\n    entityManager.clear();\n  }\n\n  @Test\n  void whenChangeOnlyParent_thenVersionIsIncrementedByOne() {\n    var parent = findParentById(&quot;1&quot;);\n    var initialVersion = parent.getVersion();\n\n    parent.setName(&quot;new parent name&quot;);\n    entityManager.merge(parent);\n    entityManager.flush();\n\n    assertThat(parent.getVersion()).isEqualTo(initialVersion + 1);\n  }\n\n  @Test\n  void whenChangeOnlyChild_thenVersionIsIncrementedByOne() {\n    var parent = findParentById(&quot;1&quot;);\n    var initialVersion = parent.getVersion();\n    var child = parent.getChildren().getFirst();\n\n    child.setName(&quot;new child name&quot;);\n    entityManager.merge(child);\n    entityManager.flush();\n\n    assertThat(parent.getVersion()).isEqualTo(initialVersion + 1);\n  }\n\n  @Test\n  void whenChangeBothParentAndChild_thenVersionIsStillIncrementedByOne() {\n    var parent = findParentById(&quot;1&quot;);\n    var initialVersion = parent.getVersion();\n    var child = parent.getChildren().getFirst();\n\n    child.setName(&quot;new child name&quot;);\n    parent.setName(&quot;new parent name&quot;);\n    entityManager.merge(parent);\n    entityManager.flush();\n\n    assertThat(parent.getVersion()).isEqualTo(initialVersion + 1);\n  }\n\n  private Parent findParentById(String id) {\n    var query = entityManager.createQuery(&quot;select p from Parent p where p.id = :id&quot;, Parent.class);\n    query.setParameter(&quot;id&quot;, id);\n\n    return query.getSingleResult();\n  }\n}\n</code></pre>\n<p>Sources:</p>\n<ul>\n<li><a href=\"https://jakarta.ee/specifications/persistence/3.2/jakarta-persistence-spec-3.2#a2060\" rel=\"nofollow noreferrer\">https://jakarta.ee/specifications/persistence/3.2/jakarta-persistence-spec-3.2#a2060</a></li>\n<li><a href=\"https://docs.jboss.org/hibernate/orm/6.6/javadocs/org/hibernate/integrator/spi/Integrator.html\" rel=\"nofollow noreferrer\">https://docs.jboss.org/hibernate/orm/6.6/javadocs/org/hibernate/integrator/spi/Integrator.html</a></li>\n<li><a href=\"https://docs.jboss.org/hibernate/orm/6.6/javadocs/org/hibernate/event/spi/PreUpdateEventListener.html\" rel=\"nofollow noreferrer\">https://docs.jboss.org/hibernate/orm/6.6/javadocs/org/hibernate/event/spi/PreUpdateEventListener.html</a></li>\n<li><a href=\"https://docs.jboss.org/hibernate/orm/6.6/javadocs/org/hibernate/jpa/boot/spi/IntegratorProvider.html\" rel=\"nofollow noreferrer\">https://docs.jboss.org/hibernate/orm/6.6/javadocs/org/hibernate/jpa/boot/spi/IntegratorProvider.html</a></li>\n</ul>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 40864244,
      "reputation" : 632,
      "user_id" : 30001713,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/f59ea01a76709335047f0cee269d788e?s=256&d=identicon&r=PG",
      "display_name" : "biggujo",
      "link" : "https://stackoverflow.com/users/30001713/biggujo"
    },
    "creation_date" : 1747564573,
    "last_activity_date" : 1747567811,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140433243,
    "post_id" : 79625563,
    "body" : "@JohnBollinger I have a general entity in my project. So almost all other entities are linked to this. When a request comes in for update I need to prevent lost updates. For example user wants to replace old children with new. They should know whether there were such updates or not",
    "score" : 0,
    "owner" : {
      "account_id" : 29075771,
      "reputation" : 143,
      "user_id" : 22272977,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a/AAcHTte84Ivji8PRE1ZJ4PbrT8hScfiqYc2zV3zX5YpeaOwC=k-s256",
      "display_name" : "Роман Григорьев",
      "link" : "https://stackoverflow.com/users/22272977/%d0%a0%d0%be%d0%bc%d0%b0%d0%bd-%d0%93%d1%80%d0%b8%d0%b3%d0%be%d1%80%d1%8c%d0%b5%d0%b2"
    },
    "creation_date" : 1747414425,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140433229,
    "post_id" : 79625563,
    "body" : "Can you say something about <i>why</i> you want this? JPA optimistic locking is designed to protect against concurrent modification on the individual entity level.  Updates to relationships mapped by other entities are not intended to factor in.  There may be a better alternative for whatever you&#39;re trying to do than to piggyback on that, especially if it&#39;s not already doing what you want by default.",
    "score" : 0,
    "owner" : {
      "account_id" : 2792262,
      "reputation" : 190832,
      "user_id" : 2402272,
      "user_type" : "registered",
      "accept_rate" : 85,
      "profile_image" : "https://www.gravatar.com/avatar/1182b1d5518a596d4e8cfe0567a65c4d?s=256&d=identicon&r=PG",
      "display_name" : "John Bollinger",
      "link" : "https://stackoverflow.com/users/2402272/john-bollinger"
    },
    "creation_date" : 1747413977,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140433142,
    "post_id" : 79625563,
    "body" : "You&#39;ve tagged this Hibernate, so this might not help, but this is something that is provider specific (outside of JPA). EclipseLink has support here: <a href=\"https://stackoverflow.com/questions/13721354/version-of-parent-object-is-not-incremented-if-one-to-many-relationship-of-the-p\" title=\"version of parent object is not incremented if one to many relationship of the p\">stackoverflow.com/questions/13721354/&hellip;</a>",
    "score" : 0,
    "owner" : {
      "account_id" : 231721,
      "reputation" : 21335,
      "user_id" : 496099,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/efa7510cf47d7bd79e80486246e7e39e?s=256&d=identicon&r=PG",
      "display_name" : "Chris",
      "link" : "https://stackoverflow.com/users/496099/chris"
    },
    "creation_date" : 1747412090,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : { }
}