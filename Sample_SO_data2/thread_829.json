{
  "question" : {
    "question_id" : 79762624,
    "title" : "Deserialize XML with Jackson polymorphically also using an external element",
    "body" : "<p>I need to deserialize XML into polymorphic Java classes where the subtype is determined not just by a type attribute on <code>&lt;component&gt;</code>, but also by a sibling <code>&lt;version&gt;</code> element. For example, <code>&lt;component type=&quot;chair&quot;&gt;</code> with <code>&lt;version&gt;2</code> should map to <code>Chair2</code>, while with <code>&lt;version&gt;3</code> it should map to <code>Chair3</code>. Standard Jackson annotations like <code>@JsonTypeInfo</code> and custom <code>TypeIdResolver</code> donâ€™t directly support combining multiple properties for type resolution. Is there a clean way (ideally with annotations, avoiding a giant switch statement) to make Jackson handle this two-key polymorphic deserialization?</p>\n<hr />\n<h2>Specifics</h2>\n<p>I have XMLs with a polymorphic <code>&lt;component&gt;</code> that has a <code>type=</code> <strong>and</strong> a sibling <code>&lt;version&gt;</code>-Element, which <strong>in combination</strong> decide which subtype of <code>Component</code> I have to deserialize into.</p>\n<pre class=\"lang-xml prettyprint-override\"><code>&lt;desk&gt;\n  &lt;version&gt;3&lt;/version&gt;\n  &lt;component type=&quot;chair&quot;&gt;\n    &lt;seat&gt;...&lt;/seat&gt;\n  &lt;/component&gt;\n&lt;/desk&gt;\n</code></pre>\n<pre class=\"lang-xml prettyprint-override\"><code>&lt;desk&gt;\n  &lt;version&gt;2&lt;/version&gt;\n  &lt;component type=&quot;chair&quot;&gt;\n    &lt;backrest&gt;...&lt;/backrest&gt;\n  &lt;/component&gt;\n&lt;/desk&gt;\n</code></pre>\n<pre class=\"lang-xml prettyprint-override\"><code>&lt;desk&gt;\n  &lt;version&gt;2&lt;/version&gt;\n  &lt;component type=&quot;table&quot;&gt;\n    &lt;leg&gt;...&lt;/leg&gt;\n  &lt;/component&gt;\n&lt;/desk&gt;\n</code></pre>\n<p>And in Java something like this:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Data\npublic abstract class Component {\n   @JacksonXmlProperty(isAttribute = true) \n   private String type;\n}\n@Data public class Chair3 extends Component { String seat; }     // type=chair &lt;version&gt;3\n@Data public class Chair2 extends Component { String backrest; } // type=chair &lt;version&gt;2\n@Data public class Table  extends Component { String leg; }      // type=table &lt;version&gt;*\n\n@Data\npublic class Desk {\n   private String version;\n\n   @JacksonXmlElementWrapper(useWrapping = false)\n   private List&lt;Component&gt; component;\n}\n</code></pre>\n<p>I did experiment with</p>\n<pre class=\"lang-java prettyprint-override\"><code>@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = &quot;type&quot;)\n@JsonSubTypes({\n    @JsonSubTypes.Type(value = Chair3.class, name = &quot;chair&quot;), // version ???\n    @JsonSubTypes.Type(value = Table.class, name = &quot;table&quot;)\n})\n</code></pre>\n<p>as well as a custom <code>TypeIdResolver</code> using the <code>EXTERNAL_PROPERTY</code>. But that one does not work for types, so it didn't work. Also, I need to combine <code>version</code> and <code>type</code> somehow.</p>\n<p>I thought if I can inject the <code>version</code> element into the <code>DeserializationContext</code> somehow via <code>setAttribute(&quot;version&quot;, version)</code> I could possibly access that when deserializing the <code>Component</code>, but I could not bring that together.</p>\n<p>And also, it would require a huge <code>switch</code> statement.</p>\n<p>The optimal solution would be to craft a custom annotation, like:</p>\n<pre><code>@MyComponent(version=&quot;3&quot;, type=&quot;chair&quot;)\npublic class Char3 { ... }\n</code></pre>\n<p>that could be evaluated during deseriliazation?</p>\n",
    "tags" : [ "java", "xml", "jackson", "jackson-databind", "jackson-dataformat-xml" ],
    "owner" : {
      "account_id" : 216793,
      "reputation" : 22471,
      "user_id" : 472245,
      "user_type" : "registered",
      "accept_rate" : 83,
      "profile_image" : "https://www.gravatar.com/avatar/395b65e986e8aca7c1af4643d162012e?s=256&d=identicon&r=PG",
      "display_name" : "towi",
      "link" : "https://stackoverflow.com/users/472245/towi"
    },
    "is_answered" : false,
    "view_count" : 104,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1757936489,
    "creation_date" : 1757661501,
    "link" : "https://stackoverflow.com/questions/79762624/deserialize-xml-with-jackson-polymorphically-also-using-an-external-element",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79762844,
    "question_id" : 79762624,
    "body" : "<p>Step 1: Define @MyComponent Annotation</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface MyComponent {\n    String type();\n    String version();\n}\n</code></pre>\n<p>Step 2: Annotate Your Subtypes</p>\n<pre class=\"lang-java prettyprint-override\"><code>@MyComponent(type = &quot;chair&quot;, version = &quot;2&quot;)\n@Data\npublic class Chair2 extends Component {\n    private String backrest;\n}\n\n@MyComponent(type = &quot;chair&quot;, version = &quot;3&quot;)\n@Data\npublic class Chair3 extends Component {\n    private String seat;\n}\n\n@MyComponent(type = &quot;table&quot;, version = &quot;*&quot;)\n@Data\npublic class Table extends Component {\n    private String leg;\n}\n</code></pre>\n<p>Step 3: Create a Registry to Lookup by (type, version)</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class ComponentRegistry {\n    private final Map&lt;String, Class&lt;? extends Component&gt;&gt; registry = new HashMap&lt;&gt;();\n\n    public void register(Class&lt;? extends Component&gt; type) {\n        MyComponent ann = type.getAnnotation(MyComponent.class);\n        if (ann == null) throw new RuntimeException(type.getName() + &quot; not annotated with @MyComponent&quot;);\n        registry.put(createKey(ann.type(), ann.version()), type);\n    }\n\n    public Class&lt;? extends Component&gt; get(String type, String version) {\n        Class&lt;? extends Component&gt; clazz = registry.get(createKey(type, version));\n\n        // Fallback to wildcard version if exact match not found\n        if (clazz == null) {\n            clazz = registry.get(createKey(type, &quot;*&quot;));\n        }\n        return clazz;\n    }\n\n    protected String createKey(String type, String version) {\n        return type + &quot;#&quot; + version;\n    }\n}\n</code></pre>\n<p>Step 4: Implement a Custom JsonDeserializer</p>\n<pre class=\"lang-java prettyprint-override\"><code>public class ComponentDeserializer extends StdDeserializer&lt;Component&gt; {\n    private static final List&lt;Class&lt;? extends Component&gt;&gt; COMPONENT_TYPES = List.of(Chair2.class, Chair3.class, Table.class);\n    private final ComponentRegistry componentRegistry;\n\n    public ComponentDeserializer() {\n        super(Component.class);\n        componentRegistry = new ComponentRegistry();\n        COMPONENT_TYPES.forEach(componentRegistry::register);\n    }\n\n    @Override\n    public Component deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {\n        ObjectCodec codec = p.getCodec();\n        JsonNode componentNode = codec.readTree(p);\n\n        // Get parent node to access sibling &lt;version&gt;\n        JsonStreamContext parentContext = p.getParsingContext().getParent();\n        JsonParser rootParser = p;\n\n        while (parentContext.getParent() != null) {\n            parentContext = parentContext.getParent();\n        }\n\n        JsonNode rootNode = codec.readTree(rootParser);\n        String version = rootNode.get(&quot;version&quot;).asText();  // assumes &lt;version&gt; is on same level as &lt;component&gt;\n\n        String type = componentNode.get(&quot;@type&quot;).asText();  // Jackson maps XML attributes as &quot;@attrname&quot;\n\n        Class&lt;? extends Component&gt; clazz = componentRegistry.get(type, version);\n        if (clazz == null) {\n            throw new IllegalStateException(&quot;Unknown Component type: &quot; + type + &quot; with version: &quot; + version);\n        }\n\n        return codec.treeToValue(componentNode, clazz);\n    }\n}\n</code></pre>\n<p>Step 5: Annotate the component Field in Desk</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Data\npublic class Desk {\n    private String version;\n\n    @JacksonXmlElementWrapper(useWrapping = false)\n    @JsonDeserialize(contentUsing = ComponentDeserializer.class)\n    private List&lt;Component&gt; component;\n}\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1096470,
      "reputation" : 29415,
      "user_id" : 1089967,
      "user_type" : "registered",
      "accept_rate" : 59,
      "profile_image" : "https://www.gravatar.com/avatar/1f256b904ff621d678598d8fa49f86c5?s=256&d=identicon&r=PG",
      "display_name" : "lance-java",
      "link" : "https://stackoverflow.com/users/1089967/lance-java"
    },
    "creation_date" : 1757674615,
    "last_activity_date" : 1757936489,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140732249,
    "post_id" : 79762624,
    "body" : "I&#39;ve seen exactly this problem in a consultancy assignment I did. They started with a POJO approach and the XML gradually became more and more complex, and the Java gradually became more and more unwieldy, to the point where it was too big to compile, and eventually they had to throw the whole thing away and start from scratch.",
    "score" : 0,
    "owner" : {
      "account_id" : 529122,
      "reputation" : 164963,
      "user_id" : 415448,
      "user_type" : "registered",
      "accept_rate" : 33,
      "profile_image" : "https://i.sstatic.net/P2vVZ.png?s=256",
      "display_name" : "Michael Kay",
      "link" : "https://stackoverflow.com/users/415448/michael-kay"
    },
    "creation_date" : 1757697760,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140731171,
    "post_id" : 79762624,
    "body" : "@MichaelKay Good point and good idea. But the rest of the application will work a lot on the POJOs, which I do not want to put into XQuery and XSLT language -- not good languages for complex business logic. The XML is given, and alas lacking an XSD, hence the code-first approach. Putting an XSLT lay in front of it just for that one technical difficulty seems over-engineered, there must be a simper way. Currently it&#39;s a big switch-stamement that I am trying to avoid.",
    "score" : 0,
    "owner" : {
      "account_id" : 216793,
      "reputation" : 22471,
      "user_id" : 472245,
      "user_type" : "registered",
      "accept_rate" : 83,
      "profile_image" : "https://www.gravatar.com/avatar/395b65e986e8aca7c1af4643d162012e?s=256&d=identicon&r=PG",
      "display_name" : "towi",
      "link" : "https://stackoverflow.com/users/472245/towi"
    },
    "creation_date" : 1757666846,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "comment_id" : 140731077,
    "post_id" : 79762624,
    "body" : "You&#39;re pursuing a data-binding approach to XML processing, but the more flexible your XML becomes, the less value you get from this approach. Data binding works well when the XML structure is regular, predictable, and unchanging. When it becomes more varied, you&#39;re much better off avoiding it and using XML-specific languages such as XQuery and XSLT instead.",
    "score" : 2,
    "owner" : {
      "account_id" : 529122,
      "reputation" : 164963,
      "user_id" : 415448,
      "user_type" : "registered",
      "accept_rate" : 33,
      "profile_image" : "https://i.sstatic.net/P2vVZ.png?s=256",
      "display_name" : "Michael Kay",
      "link" : "https://stackoverflow.com/users/415448/michael-kay"
    },
    "creation_date" : 1757664051,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79762844" : [ {
      "comment_id" : 140737329,
      "post_id" : 79762844,
      "body" : "Alas, the call <code>codec.readTree(rootParser)</code> returns <code>null</code>. After the while loop to get to the root the debugger shows me a <code>parentContext</code> that has only <code>null</code> fields (except <code>_child</code>). It seems that for elements, like <code>&lt;component&gt;</code> is, one does not have access to the parent node. The documentation mentions something like that, that this might only work for attributes?",
      "score" : 0,
      "owner" : {
        "account_id" : 216793,
        "reputation" : 22471,
        "user_id" : 472245,
        "user_type" : "registered",
        "accept_rate" : 83,
        "profile_image" : "https://www.gravatar.com/avatar/395b65e986e8aca7c1af4643d162012e?s=256&d=identicon&r=PG",
        "display_name" : "towi",
        "link" : "https://stackoverflow.com/users/472245/towi"
      },
      "creation_date" : 1757949059,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}