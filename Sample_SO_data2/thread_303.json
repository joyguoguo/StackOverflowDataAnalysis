{
  "question" : {
    "question_id" : 79822583,
    "title" : "Prevent multiple subscriptions of same topic in HiveMQ MQTT client",
    "body" : "<p>I'm struggling with my MQTT clients to subscribe to a topic without having the topic subscribed multiple times after the client runs for a while. (I also have an issue with the clients not processing incoming messages on some topics any longer after the client runs for a while (maybe because the broker forgets the subscriptions), but that's another topic to be asked in another question. But that was the reason why I changed from persistent sessions to <code>cleanStart(true)</code> + <code>sessionExpiryInterval(0)</code> in combination with setting the subscriptions in the <code>addConnectedListener</code>. (It didn't help.))</p>\n<p>I'm new to MQTT and the HiveMQ client so there might be some misunderstanding on my side. Any ideas to improvements or alternative approaches for my code are also welcome.</p>\n<p>I'm using the Mosquitto 2.0.22 message broker on Windows Server 2019 (I would prefer Linux but at the moment I'm bound to Windows). Broker configuration:</p>\n<pre><code>max_queued_messages 8000\nallow_anonymous true\n\npersistence true\npersistence_location &lt;...&gt;\nautosave_on_changes true\nautosave_interval 60\n\nsys_interval 10\nlog_type all\nlog_dest file &lt;...&gt;\nlog_dest topic\n</code></pre>\n<p>I use MQTT 5. For the clients I use the HiveMQ Java client 1.3.10 with Spring Boot and Kotlin. Most clients are running on several Raspberry Pi and one client runs on the Windowns machine on which the broker runs.</p>\n<p>I'm using <code>cleanStart(true)</code> and <code>sessionExpiryInterval(0)</code> because as far as I know this ensures that all subscriptions are cancelled on any new connects or reconnects. Then I add all necessary subscriptions during connect via a ConnectedListener.</p>\n<p>This is how I connect to the broker:</p>\n<pre><code>    val mqtt: Mqtt5BlockingClient by lazy {\n        Mqtt5Client.builder()\n            .identifier(mqttClientId)\n            .serverHost(brokerHost)\n            .serverPort(brokerPort)\n            .automaticReconnectWithDefaultConfig()\n            .addConnectedListener { connectContext -&gt;\n                log.info(&quot;MQTT connectComplete(${connectContext.clientConfig}) → $brokerHost:$brokerPort&quot;)\n                sendOnlineStatusMessage(true)\n                taskExecutor.execute {\n                    mqttOfflineBuffer.flush { mqttMessage -&gt;\n                        mqtt.publishWith()\n                            .topic(mqttMessage.topic)\n                            .payload(mqttMessage.payload.toByteArray())\n                            .retain(mqttMessage.retainSeconds &gt; 0)\n                            .messageExpiryInterval(mqttMessage.retainSeconds)\n                            .qos(MqttQos.AT_LEAST_ONCE)\n                            .send()\n                    }\n                }\n                onConnectedHandlers.forEach { it.invoke() }  // for adding all subscriptions on re-connect\n            }\n            .addDisconnectedListener { connectContext -&gt;\n                ... # Code for logging disconnects and disconnect reasons\n                onDisconnectedHandlers.forEach { it.invoke() }\n            }\n            .willPublish()\n                ... # Code to send offline message\n                .applyWillPublish()\n            .buildBlocking()\n    }\n</code></pre>\n<pre><code>    override fun open() {\n        if (mqtt.state.isConnected) {\n            log.warn (&quot;Connection to MQTT message broker is already established.&quot;)\n            return\n        }\n\n        log.trace(&quot;Connecting to MQTT message broker '$brokerHost:$brokerPort' ...&quot;)\n        try {\n            val connAck = mqtt.connectWith()\n                .cleanStart(true)\n                .sessionExpiryInterval(0)  // Session ends immediately when disconnected\n                .send()\n            val notString = if (connAck.isSessionPresent) &quot;&quot; else &quot;NOT &quot;\n            log.info(&quot;MQTT connection established (with client ID '$mqttClientId'). Old session ${notString}re-established.\\n&quot; +\n                    &quot;ConnAck restrictions:\\n{}&quot;, connAck.restrictions)\n        } catch (e: Exception) {\n            log.error(&quot;Connection to MQTT message broker failed:&quot;, e)\n        }\n    }\n</code></pre>\n<p>When the client is started, it automatically runs</p>\n<pre><code>    private val areSubscriptionsDone = AtomicBoolean(false)\n\n    override fun run(vararg args: String) {\n        log.info(&quot;Initiating MQTT connection ...&quot;)\n        myMqttClient.registerOnConnectedHandler {\n            if (areSubscriptionsDone.compareAndSet(false, true)) {\n                subscribeToTopics()\n            } else {\n                log.debug(&quot;Subscriptions for this connection already installed.&quot;)\n            }\n        }\n        myMqttClient.registerOnDisconnectedHandler {\n            areSubscriptionsDone.set(false)\n        }\n\n        if (!myMqttClient.isConnected()) {\n            myMqttClient.open()\n            ...\n        }\n    }\n\n    private fun subscribeToTopics() {\n        myMqttClient.subscribeAndHandle(pingTopic) { _, _, _ -&gt;\n            log.info(&quot;→ Received ping message.&quot;)\n            myMqttClient.publishMessage(pongTopic, ...)\n        }\n        ...\n    }\n</code></pre>\n<p>And this is how I subscribe to the topics:</p>\n<pre><code>    override fun subscribeAndHandle(topicFilter: String, handler: (topic: String, payload: String, isFromRetainedStore: Boolean) -&gt; Unit) {\n        if (!mqtt.state.isConnected) throwOfflineException()\n\n        mqtt.toAsync()\n            .subscribeWith()\n            .topicFilter(topicFilter)\n            .retainHandling(Mqtt5RetainHandling.SEND)  // default\n            .retainAsPublished(false)  // default; ensures live forwards arrive with retain=false\n            .callback { publish -&gt;\n                val topic = publish.topic.toString()\n                val payload = publish.payloadAsBytes.toString(Charsets.UTF_8)\n                val isFromRetainedStore = publish.isRetain\n                handler(topic, payload, isFromRetainedStore)\n            }\n            .send()\n            .whenComplete { subAck, throwable -&gt;\n                ... // logging\n            }\n    }\n</code></pre>\n<p>In the log files of the clients I see that the reception of an MQTT message is logged several times (e.g. &quot;→ Received ping message&quot;, and this logging is triggered by the topic handler) when I sent a single message. In the log file of the broker I can see that there is only one message sent, so I presume that the broker holds only one subscription of that topic for that client.</p>\n<p>All clients have unique client IDs. Topics have the form &quot;devices/[device-ID]/subtopic&quot;. A restart of the client resets the number of logged receptions for one message (only one reception per message). But when I restart the broker, it increases by one.</p>\n",
    "tags" : [ "java", "kotlin", "mqtt", "hivemq" ],
    "owner" : {
      "account_id" : 5644060,
      "reputation" : 303,
      "user_id" : 4466828,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/7c4c245e1450068ec443125f60e43671?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "waldrabe",
      "link" : "https://stackoverflow.com/users/4466828/waldrabe"
    },
    "is_answered" : false,
    "view_count" : 73,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1763481407,
    "creation_date" : 1763399876,
    "link" : "https://stackoverflow.com/questions/79822583/prevent-multiple-subscriptions-of-same-topic-in-hivemq-mqtt-client",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79823567,
    "question_id" : 79822583,
    "body" : "<p>I found out that the combination of <code>.cleanstart(true)</code> and putting the subscriptions in <code>.addConnectedListener</code> is not working as I expected. The callbacks for incoming messages are saved in the client and stay there as long as the program runs. Each reconnect adds a new callback to the same topic when the subscription is included in the <code>.addConnectedListener</code>.</p>\n<p>One solution would be to guard against multiple subscriptions / callbacks.</p>\n<p>The other solution, which I chose, is to use persistent sessions (<code>.cleanstart(false)</code> + <code>.sessionExpiryInterval(POSITIVE_VALUE)</code> and subscribe to topics only once when the connection is made and not in the <code>.addConnectedListener</code>.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 5644060,
      "reputation" : 303,
      "user_id" : 4466828,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/7c4c245e1450068ec443125f60e43671?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "waldrabe",
      "link" : "https://stackoverflow.com/users/4466828/waldrabe"
    },
    "creation_date" : 1763481407,
    "last_activity_date" : 1763481407,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79823567" : [ {
      "comment_id" : 140861134,
      "post_id" : 79823567,
      "body" : "Another alternative is to seperate the <a href=\"https://github.com/hivemq/hivemq-mqtt-client#consume-messages-1\" rel=\"nofollow noreferrer\">subscription and consumption</a> of messages.",
      "score" : 0,
      "owner" : {
        "account_id" : 16352957,
        "reputation" : 18885,
        "user_id" : 11810946,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/3Oz9s.jpg?s=256",
        "display_name" : "Brits",
        "link" : "https://stackoverflow.com/users/11810946/brits"
      },
      "creation_date" : 1763499924,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}