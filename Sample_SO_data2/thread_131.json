{
  "question" : {
    "question_id" : 79837783,
    "title" : "Disable Button as click is still processed",
    "body" : "<p>Suppose a click on a JavaFX button is processed for some period of time (e.g. it performs some IO). How do you block interaction with that button while a click is still being processed? Say, it is processed for one second, and during that second no clicks made by the user should be processed.</p>\n<p>I feel there's a better way than to manually manipulate the <code>disable</code> property.</p>\n<p>Java 8, JavaFX 8.</p>\n<pre class=\"lang-java prettyprint-override\"><code>    private Button createOkButton() {\n        Button ok = new Button(&quot;OK&quot;);\n        ok.setOnAction(e -&gt; onOk());\n    }\n\n    private void onOk() {\n        ok.setDisable(true);\n        doSomething();\n        ok.setDisable(false);\n    }\n</code></pre>\n",
    "tags" : [ "java", "javafx" ],
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2683,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "is_answered" : true,
    "view_count" : 107,
    "answer_count" : 7,
    "score" : 1,
    "last_activity_date" : 1764859131,
    "creation_date" : 1764842953,
    "link" : "https://stackoverflow.com/questions/79837783/disable-button-as-click-is-still-processed",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79837875,
    "question_id" : 79837783,
    "body" : "<p>See: <a href=\"https://stackoverflow.com/questions/20556945/changing-cursor-in-javafx-application-for-long-operations/20561965#20561965\">Changing cursor in JavaFX application for long operations</a>.  The solution also shows how to disable portions of the UI or a button while the operation is being processed.</p>\n",
    "score" : 3,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1180113,
      "reputation" : 160487,
      "user_id" : 1155209,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/5192e7cbcf2f72a847d6fb0d1552f049?s=256&d=identicon&r=PG",
      "display_name" : "jewelsea",
      "link" : "https://stackoverflow.com/users/1155209/jewelsea"
    },
    "creation_date" : 1764848796,
    "last_activity_date" : 1764848796,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79838016,
    "question_id" : 79837783,
    "body" : "<h2>Issues with the posted code</h2>\n<p>The code in the original post</p>\n<pre><code>    private void onOk() {\n        ok.setDisable(true);\n        doSomething();\n        ok.setDisable(false);\n    }\n</code></pre>\n<p>will not work as desired.</p>\n<p>The UI cannot be re-rendered until <code>onOk()</code> completes execution. By the time the UI is re-rendered, the button will be enabled again, and so the button will never be rendered in a disabled state.</p>\n<p>If <code>doSomething()</code> runs synchronously, the UI thread will be blocked while <code>doSomething()</code> is processing, and no rendering happens at all while the long-running process takes place. If <code>doSomething()</code> runs asynchronously, then <code>ok.setDisable(false)</code> is called essentially immediately after <code>ok.setDisable(true)</code>, and again the button is never rendered in a disabled state.</p>\n<h2>Strategy for the desired result</h2>\n<p>To achieve the desired result, the long-running process <em>must</em> be executed asynchronously, and the call to re-enable the button must somehow be scheduled to happen <em>after</em> the long-running process completes. The call to re-enable the button must also be executed on the FX Application Thread (not on the background thread).</p>\n<h2>Best practices</h2>\n<p>The best practice for scenarios like this is to use the <a href=\"https://openjfx.io/javadoc/25/javafx.graphics/javafx/concurrent/Task.html\" rel=\"nofollow noreferrer\">JavaFX <code>Task</code> API</a>.</p>\n<p>Specifically:</p>\n<ol>\n<li><p>Encapsulate the long-running process as a <code>Task</code> implementation.</p>\n</li>\n<li><p>When the task needs to be run, execute it in the background using an appropriate <a href=\"https://docs.oracle.com/en/java/javase/25/docs/api/java.base/java/util/concurrent/Executors.html\" rel=\"nofollow noreferrer\"><code>Executor</code></a>.</p>\n</li>\n<li><p>Either:</p>\n<ol>\n<li>use the <code>onSucceeded</code>, <code>onFailed</code>, and <code>onRunning</code> handlers (which are executed on the FX application thread),</li>\n</ol>\n<p>or</p>\n<ol start=\"2\">\n<li>register listeners with the <a href=\"https://openjfx.io/javadoc/25/javafx.graphics/javafx/concurrent/Task.html#stateProperty()\" rel=\"nofollow noreferrer\"><code>stateProperty</code></a> to update the UI as the task changes state. This can be used, e.g. to disable a button when the task starts running and to enable it again when the task completes.</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>I feel there's a better way than to manually manipulate the <code>disable</code> property.</p>\n</blockquote>\n<p>Ultimately, if you want to change the disabled state of the button, you have to change the value of the <code>disable</code> property somewhere. The binding (second) implementation in the following example may be the implementation you feel you should be using here. In my opinion the choice between the two implementations is mostly just a matter of programmer preference.</p>\n<p>For more complex scenarios, it may also be worth investigating the <a href=\"https://openjfx.io/javadoc/25/javafx.graphics/javafx/concurrent/Service.html\" rel=\"nofollow noreferrer\">JavaFX <code>Service</code> API</a>. The <a href=\"https://stackoverflow.com/questions/20556945/changing-cursor-in-javafx-application-for-long-operations/20561965#20561965\">question and answer</a> linked <a href=\"https://stackoverflow.com/a/79837875/2189127\">above by @jewelsea</a> contains an example of this.</p>\n<p>Here is a minimal example:</p>\n<pre><code>import javafx.concurrent.Task;\n\npublic class BackgroundProcess extends Task&lt;Void&gt; {\n\n    @Override\n    protected Void call() throws Exception {\n\n        // simulate long-running process:\n        Thread.sleep(3000);\n        return null;\n    }\n}\n</code></pre>\n<p>and the UI:</p>\n<pre><code>import javafx.application.Application;\nimport javafx.geometry.Pos;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Button;\nimport javafx.scene.control.Label;\nimport javafx.scene.layout.VBox;\nimport javafx.stage.Stage;\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class HelloApplication extends Application {\n\n    private final ExecutorService exec = Executors.newCachedThreadPool(\n            // An executor which creates daemon threads\n            runnable -&gt; {\n                Thread thread = new Thread(runnable);\n                thread.setDaemon(true);\n                return thread;\n            }\n    );\n\n    private Button button;\n    private Label statusLabel;\n\n    @Override\n    public void start(Stage stage)  {\n        button = new Button(&quot;Start process&quot;);\n        statusLabel = new Label(&quot;Waiting&quot;);\n\n        button.setOnAction(_ -&gt; runBackgroundProcess());\n\n        VBox root = new VBox(20, statusLabel, button);\n        root.setAlignment(Pos.CENTER);\n        Scene scene = new Scene(root, 320, 250);\n        stage.setScene(scene);\n        stage.show();\n    }\n\n    private void runBackgroundProcess() {\n        BackgroundProcess process = new BackgroundProcess();\n        process.setOnRunning( _ -&gt; {\n            button.setDisable(true);\n            statusLabel.setText(&quot;Running&quot;);\n        });\n        process.setOnSucceeded( _ -&gt; {\n            button.setDisable(false);\n            statusLabel.setText(&quot;Completed&quot;);\n        });\n        process.setOnFailed(event -&gt; {\n            button.setDisable(false);\n            statusLabel.setText(&quot;An error occurred&quot;);\n            // In real life handle the exception more appropriately,\n            // this just shows you can get access to informataion about\n            // what went wrong.\n            process.getException().printStackTrace();\n        });\n        exec.submit(process);\n    }\n}\n</code></pre>\n<p>Here is an alternative implementation using the <code>stateProperty</code> and bindings:</p>\n<pre><code>    private void runBackgroundProcess() {\n        BackgroundProcess process = new BackgroundProcess();\n        button.disableProperty().bind(process.runningProperty());\n        statusLabel.textProperty().bind(\n                process.stateProperty().map(state -&gt; switch(state) {\n                    case Worker.State.RUNNING -&gt; &quot;Running&quot;;\n                    case Worker.State.SUCCEEDED -&gt; &quot;Completed&quot;;\n                    case Worker.State.FAILED -&gt; &quot;An error occurred&quot;;\n                    default -&gt; &quot;Waiting&quot;;\n                })\n        );\n        exec.submit(process);\n    }\n</code></pre>\n",
    "score" : 3,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2518243,
      "reputation" : 210916,
      "user_id" : 2189127,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/e8e6e627b4b90ec816c5c7aa04cbcc26?s=256&d=identicon&r=PG",
      "display_name" : "James_D",
      "link" : "https://stackoverflow.com/users/2189127/james-d"
    },
    "creation_date" : 1764857686,
    "last_activity_date" : 1764859131,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79837874,
    "question_id" : 79837783,
    "body" : "<p><em><strong>Did you not see the reply from [Google] Gemini?</strong></em></p>\n<p>To block user gestures (input events) in JavaFX while a background task executes, you should utilize a combination of concurrency utilities (like <code>Task</code> or <code>Service</code>) and UI manipulation on the JavaFX Application Thread. The core principle is to run the long operation in a background thread and visually disable the relevant UI components or show an overlay on the JavaFX Application Thread.</p>\n<h4>Recommended Approach: Use a Progress Overlay and Disable UI</h4>\n<p>The most user-friendly way to block gestures is to disable the main content and display an overlay (like a progress indicator or loading message) with a transparent but solid background to intercept all mouse events.\nHere is a step-by-step guide and an example:</p>\n<ol>\n<li><strong>Implement the Background Task using <code>Task</code></strong><br />\nUse the <code>javafx.concurrent.Task</code> class to perform your long-running work on a separate thread. The <code>call()</code> method runs in the background, while UI updates must use <code>Platform.runLater()</code> or the built-in <code>updateMessage()</code>/<code>updateProgress()</code> methods.</li>\n</ol>\n<pre class=\"lang-java prettyprint-override\"><code>import javafx.concurrent.Task;\n\npublic class LongRunningTask extends Task&lt;Void&gt; {\n\n    @Override\n    protected Void call() throws Exception {\n        // This runs on a background thread\n        for (int i = 0; i &lt; 100; i++) {\n            if (isCancelled()) {\n                break;\n            }\n            // Perform a chunk of work (e.g., I/O, heavy computation)\n            Thread.sleep(50); // Simulate work\n            updateProgress(i + 1, 100);\n            updateMessage(&quot;Processing: &quot; + (i + 1) + &quot;%&quot;);\n        }\n        return null;\n    }\n}\n</code></pre>\n<ol start=\"2\">\n<li><strong>Create an Overlay to Intercept Events</strong><br />\nA simple <code>StackPane</code> can layer the main content and a progress overlay. The overlay should have a background color (even semi-transparent) and a mouse filter to consume all mouse events.</li>\n<li><strong>Manage UI State</strong><br />\nWhen the task starts, disable the main UI and show the overlay. When it succeeds or fails, re-enable the UI and hide the overlay.</li>\n</ol>\n<pre class=\"lang-java prettyprint-override\"><code>import javafx.application.Application;\nimport javafx.scene.Scene;\nimport javafx.scene.control.*;\nimport javafx.scene.layout.StackPane;\nimport javafx.scene.layout.VBox;\nimport javafx.stage.Stage;\n\npublic class BlockingApp extends Application {\n\n    @Override\n    public void start(Stage primaryStage) {\n        // Main UI Content\n        VBox mainContent = new VBox(10);\n        Button startButton = new Button(&quot;Start Long Task&quot;);\n        Label statusLabel = new Label(&quot;Status: Ready&quot;);\n        mainContent.getChildren().addAll(startButton, statusLabel);\n\n        // Overlay Content\n        VBox overlay = new VBox(10);\n        ProgressIndicator indicator = new ProgressIndicator();\n        Label progressText = new Label(&quot;Working...&quot;);\n        overlay.getChildren().addAll(indicator, progressText);\n        // Style the overlay to cover the whole area and intercept clicks\n        overlay.setStyle(&quot;-fx-background-color: rgba(0, 0, 0, 0.3); -fx-alignment: center;&quot;);\n        // Add a mouse filter to consume all clicks in the overlay\n        overlay.setOnMouseClicked(event -&gt; event.consume());\n        overlay.setVisible(false); // Initially hidden\n\n        // Main layout using StackPane to layer content\n        StackPane root = new StackPane();\n        root.getChildren().addAll(mainContent, overlay);\n\n        startButton.setOnAction(event -&gt; {\n            LongRunningTask task = new LongRunningTask();\n\n            // Bind progress properties\n            indicator.progressProperty().bind(task.progressProperty());\n            progressText.textProperty().bind(task.messageProperty());\n\n            // Set up UI state changes\n            task.setOnRunning(e -&gt; {\n                overlay.setVisible(true);\n                startButton.setDisable(true);\n                statusLabel.setText(&quot;Status: Running&quot;);\n            });\n            task.setOnSucceeded(e -&gt; {\n                overlay.setVisible(false);\n                startButton.setDisable(false);\n                statusLabel.setText(&quot;Status: Complete&quot;);\n            });\n            task.setOnCancelled(e -&gt; {\n                overlay.setVisible(false);\n                startButton.setDisable(false);\n                statusLabel.setText(&quot;Status: Cancelled&quot;);\n            });\n            task.setOnFailed(e -&gt; {\n                overlay.setVisible(false);\n                startButton.setDisable(false);\n                statusLabel.setText(&quot;Status: Failed&quot;);\n            });\n\n            // Run the task in a background thread\n            new Thread(task).start();\n        });\n\n        Scene scene = new Scene(root, 300, 250);\n        primaryStage.setScene(scene);\n        primaryStage.setTitle(&quot;Block Gestures Example&quot;);\n        primaryStage.show();\n    }\n\n    public static void main(String[] args) {\n        launch(args);\n    }\n}\n</code></pre>\n<p>This method ensures the main JavaFX Application Thread remains responsive for rendering the overlay and progress updates, while preventing interaction with the underlying components.</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2485939,
      "reputation" : 20969,
      "user_id" : 2164365,
      "user_type" : "registered",
      "accept_rate" : 40,
      "profile_image" : "https://i.sstatic.net/RKSgV.png?s=256",
      "display_name" : "Abra",
      "link" : "https://stackoverflow.com/users/2164365/abra"
    },
    "creation_date" : 1764848725,
    "last_activity_date" : 1764848725,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79837793,
    "question_id" : 79837783,
    "body" : "<p>Do you <a href=\"https://www.google.com/search?q=javafx+block+user+gestures+while+background+task+executes\" rel=\"nofollow noreferrer\">search</a> before posting questions?</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2485939,
      "reputation" : 20969,
      "user_id" : 2164365,
      "user_type" : "registered",
      "accept_rate" : 40,
      "profile_image" : "https://i.sstatic.net/RKSgV.png?s=256",
      "display_name" : "Abra",
      "link" : "https://stackoverflow.com/users/2164365/abra"
    },
    "creation_date" : 1764843465,
    "last_activity_date" : 1764843465,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79837809,
    "question_id" : 79837783,
    "body" : "<p>@Abra follow-up question, do you examine your search results before referencing them? None of the pages returned for your request actually answer what I asked (which is not how to put IO in the background)</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2683,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "creation_date" : 1764844403,
    "last_activity_date" : 1764844403,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79837891,
    "question_id" : 79837783,
    "body" : "<p>@Abra I never mentioned any progress indicators or overlays. I simply want the button to be disabled while the task (asynchronous or otherwise) is running</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 10187542,
      "reputation" : 2683,
      "user_id" : 20692967,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/NZSXm.jpg?s=256",
      "display_name" : "Sergey Zolotarev",
      "link" : "https://stackoverflow.com/users/20692967/sergey-zolotarev"
    },
    "creation_date" : 1764849874,
    "last_activity_date" : 1764849874,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79837915,
    "question_id" : 79837783,
    "body" : "<p>Disabling just the button does not prevent the user from interacting with other <code>Node</code>s in the GUI. Is that OK? I assumed that it is not, hence the <code>StackPane</code> to prevent the user from interacting with the GUI at all. The progress bar helps to show the user that the application is working (and not frozen) but is, of-course, not essential. You say that the duration of the processing performed when the button is activated is one second. Could there not be an exceptional situation where the processing takes ten seconds? If so, then in that case the user may believe that the application is stuck and try to interact with other <code>Node</code>s in the GUI. Hence a <code>StackPane</code> and progress bar will avoid that happening.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 2485939,
      "reputation" : 20969,
      "user_id" : 2164365,
      "user_type" : "registered",
      "accept_rate" : 40,
      "profile_image" : "https://i.sstatic.net/RKSgV.png?s=256",
      "display_name" : "Abra",
      "link" : "https://stackoverflow.com/users/2164365/abra"
    },
    "creation_date" : 1764851236,
    "last_activity_date" : 1764851236,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}