{
  "question" : {
    "question_id" : 79619072,
    "title" : "what needs to be done so that in exceptionHandling in class securityConfig the HttpServletResponse code is returned depending on the error",
    "body" : "<p>How can I return different <code>HttpServletResponse</code> status codes based on the type of error, not just <code>SC_UNAUTHORIZED</code>? For example, return <code>SC_UNAUTHORIZED</code> for token-related errors and <code>SC_SERVICE_UNAVAILABLE</code> for other types of errors</p>\n<pre><code>@Configuration\n@EnableWebSecurity\n@RequiredArgsConstructor\npublic class SecurityConfig{\n\n    private final JwtTokenFilter jwtTokenFilter;\n    private final CustomAuthenticationEntryPoint customAuthenticationEntryPoint;\n\n    @Bean\n    protected SecurityFilterChain configure(HttpSecurity http) throws Exception {\n        return http\n            .csrf(AbstractHttpConfigurer::disable)\n            .authorizeHttpRequests(auth -&gt; auth\n                .requestMatchers(antMatcher(&quot;/**/actuator/**&quot;)).permitAll()\n                .requestMatchers(antMatcher(&quot;/**/check/**&quot;)).permitAll()\n                .anyRequest().hasAuthority(&quot;PERMISSION&quot;)\n            )\n            .sessionManagement(\n                config -&gt; config.sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            )\n            .exceptionHandling(exception -&gt;\n                exception.authenticationEntryPoint((request, response, ex) -&gt;\n                    response.sendError(HttpServletResponse.SC_UNAUTHORIZED, ex.getMessage())//so that, depending on the error, different HttpServletResponse are returned, not only SC_UNAUTHORIZED, but also SC_SERVICE_UNAVAILABLE, how do I do this? \n                ))\n            .addFilterBefore(jwtTokenFilter, UsernamePasswordAuthenticationFilter.class)\n            .build();\n    }\n}\n</code></pre>\n<p>here is the class that works with the token:</p>\n<pre><code>@Component\n@Slf4j\n@RequiredArgsConstructor\npublic class JwtTokenFilter extends OncePerRequestFilter {\n\n    private final JwtTokenParser jwtTokenParser;\n\n    @Value(&quot;${sppi.security.enabled}&quot;)\n    private boolean securityEnabled;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException {\n        String token = getTokenFromHeader(request);\n\n        if (Objects.isNull(token) &amp;&amp; securityEnabled) {\n            chain.doFilter(request, response);\n            return;\n        }\n\n        try {\n            UserDetails userDetails = getUsernameFromTokenAndAddHeaderIfExpired(token, response);\n            if (Objects.isNull(userDetails)) {\n                chain.doFilter(request, response);\n                return;\n            }\n\n\n            response.setHeader(&quot;username&quot;, userDetails.getUsername());\n            chain.doFilter(request, response);\n\n        } catch (RestClientException e) {\n            e.printStackTrace();\n            response.sendError(HttpServletResponse.SC_BAD_GATEWAY);\n        }\n    }\n\n    private String getTokenFromHeader(HttpServletRequest request) {\n        String header = request.getHeader(HttpHeaders.AUTHORIZATION);\n        if (Objects.isNull(header) || !header.startsWith(&quot;Bearer &quot;))\n            return null;\n        else {\n            return header.split(&quot; &quot;)[1].trim();\n        }\n    }\n\n    public UserDetails getUsernameFromTokenAndAddHeaderIfExpired(String token, HttpServletResponse response) {\n        UserDetails userDetails = null;\n        try {\n            userDetails = jwtTokenParser.getUserFromToken(token);\n        } catch (SignatureException ex) {\n            log.info(&quot;Invalid JWT signature - {}&quot;, ex.getMessage());\n        } catch (MalformedJwtException ex) {\n            log.info(&quot;Invalid JWT token - {}&quot;, ex.getMessage());\n        } catch (ExpiredJwtException ex) {\n            log.info(&quot;Expired JWT token - {}&quot;, ex.getMessage());\n            response.setHeader(&quot;is-token-expired&quot;, String.valueOf(true));\n        } catch (UnsupportedJwtException ex) {\n            log.info(&quot;Unsupported JWT token - {}&quot;, ex.getMessage());\n        } catch (IllegalArgumentException ex) {\n            log.info(&quot;JWT claims string is empty - {}&quot;, ex.getMessage());\n        } catch (CertificateException ex) {\n            log.info(&quot;Certificate factory not available - {}&quot;, ex.getMessage());\n        }\n\n        return userDetails;\n    }\n}\n</code></pre>\n",
    "tags" : [ "java", "spring", "spring-boot", "spring-security" ],
    "owner" : {
      "account_id" : 29335954,
      "reputation" : 1,
      "user_id" : 22476332,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/5ArPz.jpg?s=256",
      "display_name" : "Progress",
      "link" : "https://stackoverflow.com/users/22476332/progress"
    },
    "is_answered" : false,
    "view_count" : 66,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1747673525,
    "creation_date" : 1747118173,
    "link" : "https://stackoverflow.com/questions/79619072/what-needs-to-be-done-so-that-in-exceptionhandling-in-class-securityconfig-the-h",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79629174,
    "question_id" : 79619072,
    "body" : "<p>have you tried writing your own custom AuthenticationEntryPoint implemention..i mean...you can inheirt and inspect the cause by using instanceOf method  and as per the exception you can send the required response...</p>\n<p>here's what i am talking about...</p>\n<pre><code>@Component\npublic class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint {\n\n    @Override\n    public void commence(HttpServletRequest request,\n                         HttpServletResponse response,\n                         AuthenticationException authException) throws IOException {\n\n        // Example: distinguish exceptions\n        Throwable cause = authException.getCause();\n\n        if (cause instanceof SignatureException) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, &quot;Authentication service down&quot;);\n        } else if (authException instanceof InsufficientAuthenticationException) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN, &quot;Access denied: insufficient auth&quot;);\n//...and so on,you get the idea.Just remember that authException would let you catch your custom exception and cause would help you inspect whjat was the real 'cause' of your custom exception\n        } \n\n    }\n</code></pre>\n<p>and then in your config class you can create a bean of this and use it in your filter as below..</p>\n<pre><code>.exceptionHandling(exception -&gt;\n    exception.authenticationEntryPoint(customAuthenticationEntryPoint)\n)\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 15307173,
      "reputation" : 1,
      "user_id" : 19680253,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/1adc8e0338e3a713b1c42f1328119f6d?s=256&d=identicon&r=PG",
      "display_name" : "Raj11",
      "link" : "https://stackoverflow.com/users/19680253/raj11"
    },
    "creation_date" : 1747673525,
    "last_activity_date" : 1747673525,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : { }
}