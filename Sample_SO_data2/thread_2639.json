{
  "question" : {
    "question_id" : 79609312,
    "title" : "Spring security 403 forbidden in login via roles",
    "body" : "<p>im quite new in spring jwt, i get the 403 forbidden when i login, i succesfully register all my users. this is </p>\n<pre><code>package org.example.gestionrendezvousmedic.configs;\n\nimport jakarta.servlet.Filter;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;\nimport org.springframework.security.web.SecurityFilterChain;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.dao.DaoAuthenticationProvider;\nimport org.springframework.security.authentication.ProviderManager;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.example.gestionrendezvousmedic.security.JwtAuthFilter;\n@EnableMethodSecurity\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n    private final UserDetailsService userDetailsService;\n    private final JwtAuthFilter jwtAuthFilter;\n\n    public SecurityConfig(UserDetailsService userDetailsService, JwtAuthFilter jwtAuthFilter) {\n        this.userDetailsService = userDetailsService;\n        this.jwtAuthFilter = jwtAuthFilter;\n    }\n\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        http\n                .csrf(AbstractHttpConfigurer::disable)\n                .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))\n                .authorizeHttpRequests(auth -&gt; auth\n                        .requestMatchers(&quot;/api/auth/signup/**&quot;).permitAll()\n                        .requestMatchers(&quot;/api/auth/login&quot;).permitAll()\n                        .requestMatchers(&quot;/api/auth/**&quot;).permitAll()\n                      //  .requestMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)\n                     //   .requestMatchers(&quot;/medecin/**&quot;).hasRole(&quot;MEDECIN&quot;)\n                     //   .requestMatchers(&quot;/patient/**&quot;).hasRole(&quot;PATIENT&quot;)\n                        .anyRequest().authenticated()\n\n                )\n                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);\n\n        return http.build();\n    }\n\n\n\n\n}\n</code></pre>\n<p>and this is my logindto:</p>\n<pre><code>package org.example.gestionrendezvousmedic.dtos;\n\nimport lombok.Data;\nimport org.example.gestionrendezvousmedic.models.Role;\n\n@Data\npublic class LoginUserDto {\n    private String email;\n\n    private String password;\n    private Role role;\n\n\n}\n\n</code></pre>\n<p>and this is my jwt service</p>\n<pre><code>package org.example.gestionrendezvousmedic.services;\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\nimport io.jsonwebtoken.io.Decoders;\nimport io.jsonwebtoken.security.Keys;\nimport java.security.Key;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Function;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class JwtService {\n    @Value(&quot;${security.jwt.secret-key}&quot;)\n    private String secretKey;\n\n    @Value(&quot;${security.jwt.expiration-time}&quot;)\n    private long jwtExpiration;\n\n    public String extractUsername(String token) {\n        return extractClaim(token, Claims::getSubject);\n    }\n\n    public &lt;T&gt; T extractClaim(String token, Function&lt;Claims, T&gt; claimsResolver) {\n        final Claims claims = extractAllClaims(token);\n        return claimsResolver.apply(claims);\n    }\n\n    public String generateToken(UserDetails userDetails) {\n        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();\n        claims.put(&quot;role&quot;, userDetails.getAuthorities().stream()\n                .map(auth -&gt; auth.getAuthority())\n                .toList()\n        );\n        return generateToken(claims, userDetails);\n    }\n\n\n    public String generateToken(Map&lt;String, Object&gt; extraClaims, UserDetails userDetails) {\n        return buildToken(extraClaims, userDetails, jwtExpiration);\n    }\n\n    public long getExpirationTime() {\n        return jwtExpiration;\n    }\n\n    private String buildToken(\n            Map&lt;String, Object&gt; extraClaims,\n            UserDetails userDetails,\n            long expiration\n    ) {\n        return Jwts\n                .builder()\n                .setClaims(extraClaims)\n                .setSubject(userDetails.getUsername())\n                .setIssuedAt(new Date(System.currentTimeMillis()))\n                .setExpiration(new Date(System.currentTimeMillis() + 1000*60*24))\n                .signWith(getSignInKey(), SignatureAlgorithm.HS256)\n                .compact();\n    }\n\n    public boolean isTokenValid(String token, UserDetails userDetails) {\n        final String username = extractUsername(token);\n        return (username.equals(userDetails.getUsername())) &amp;&amp; !isTokenExpired(token);\n    }\n\n\n    private boolean isTokenExpired(String token) {\n        return extractExpiration(token).before(new Date());\n    }\n\n    private Date extractExpiration(String token) {\n        return extractClaim(token, Claims::getExpiration);\n    }\n\n    private Claims extractAllClaims(String token) {\n        return Jwts\n                .parserBuilder()\n                .setSigningKey(getSignInKey())\n                .build()\n                .parseClaimsJws(token)\n                .getBody();\n    }\n\n    private Key getSignInKey() {\n        byte[] keyBytes = Decoders.BASE64.decode(secretKey);\n        return Keys.hmacShaKeyFor(keyBytes);\n    }\n}\n</code></pre>\n<p>and this is my user class:</p>\n<pre><code>package org.example.gestionrendezvousmedic.models;\n\nimport jakarta.persistence.*;\nimport lombok.Builder;\nimport lombok.Data;\nimport org.hibernate.annotations.CreationTimestamp;\nimport org.hibernate.annotations.UpdateTimestamp;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.List;\n\n@Inheritance(strategy = InheritanceType.JOINED)\n@Data\n@Entity\n\npublic class User implements UserDetails {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String name;\n\n    private String email;\n\n    private String password;\n\n    @Enumerated(EnumType.STRING)\n    @Column(updatable = false, name =&quot;ROLE_&quot;)\n    private Role role;\n\n    @CreationTimestamp\n    @Column(updatable = false, name = &quot;created_at&quot;)\n    private Date createdAt;\n\n    @UpdateTimestamp\n    @Column(name = &quot;updated_at&quot;)\n    private Date updatedAt;\n\n    public User() {}\n\n    public User(String name, String email, Role role) {\n        this.name = name;\n        this.email = email;\n        this.role = role;\n    }\n\n    public User(Role role) {\n        this.role = role;\n    }\n\n    @Override\n    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {\n        return List.of(new SimpleGrantedAuthority(&quot;ROLE_&quot; + this.role.name()));\n    }\n\n    @Override\n    public String getUsername() {\n        return email; // Used by Spring Security\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n\n</code></pre>\n<p>and this is my authentification service:</p>\n<pre><code>package org.example.gestionrendezvousmedic.services;\n\nimport jakarta.transaction.Transactional;\nimport org.example.gestionrendezvousmedic.dtos.AuthenticationResponse;\nimport org.example.gestionrendezvousmedic.dtos.LoginUserDto;\nimport org.example.gestionrendezvousmedic.dtos.RegisterUserDto;\nimport org.example.gestionrendezvousmedic.models.*;\nimport org.example.gestionrendezvousmedic.repos.AdminRepository;\nimport org.example.gestionrendezvousmedic.repos.MedecinRepository;\nimport org.example.gestionrendezvousmedic.repos.PatientRepository;\nimport org.example.gestionrendezvousmedic.repos.UserRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.stereotype.Service;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Service\npublic class AuthenticationService {\n    private static final Logger logger = LoggerFactory.getLogger(AuthenticationService.class);\n    @Autowired\n    private JwtService jwtService;\n\n    @Autowired\n    private AdminRepository adminRepository;\n\n    @Autowired\n    private PatientRepository patientRepository;\n\n    @Autowired\n    private MedecinRepository medecinRepository;\n\n    private final UserRepository userRepository;\n    private final PasswordEncoder passwordEncoder;\n    private final AuthenticationManager authenticationManager;\n\n    @Autowired\n    public AuthenticationService(\n            UserRepository userRepository,\n            AuthenticationManager authenticationManager,\n            PasswordEncoder passwordEncoder\n    ) {\n        this.userRepository = userRepository;\n        this.authenticationManager = authenticationManager;\n        this.passwordEncoder = passwordEncoder;\n    }\n\n    // ------------------ PATIENT ------------------\n    public AuthenticationResponse signupPatient(RegisterUserDto input) {\n        Patient patient = new Patient();\n        patient.setName(input.getName());\n        patient.setEmail(input.getEmail());\n        patient.setPassword(passwordEncoder.encode(input.getPassword()));\n        patient.setRole(Role.PATIENT);\n\n         patientRepository.save(patient);\n        var jwt = jwtService.generateToken(patient);\n        return AuthenticationResponse.builder().token(jwt).build();\n    }\n\n    public AuthenticationResponse authenticatePatient(LoginUserDto input) {\n        authenticationManager.authenticate (new UsernamePasswordAuthenticationToken(input.getEmail(), input.getPassword()));\n\n        Patient patient = patientRepository.findByEmail(input.getEmail())\n                .orElseThrow(() -&gt; new UsernameNotFoundException(&quot;Patient not found&quot;));\n\n        String token = jwtService.generateToken(patient);\n        return new AuthenticationResponse(token);\n    }\n\n    // ------------------ MEDECIN ------------------\n    @Transactional\n    public Map&lt;String, Object&gt; signupMedecin(RegisterUserDto input) {\n        Medecin medecin = new Medecin();\n        medecin.setName(input.getName());\n        medecin.setEmail(input.getEmail());\n        medecin.setPassword(passwordEncoder.encode(input.getPassword()));\n        medecin.setRole(Role.MEDECIN);\n        medecin.setSpecialite(input.getSpecialite());\n\n        logger.info(&quot;Medecin before save: email={}, name={}, role={}, specialite={}&quot;,\n                medecin.getEmail(), medecin.getName(), medecin.getRole(), medecin.getSpecialite());\n\n        Medecin savedMedecin = medecinRepository.save(medecin);\n        logger.info(&quot;Saved Medecin: {}&quot;, savedMedecin); // extra debug log\n\n        String jwtToken = jwtService.generateToken(savedMedecin);\n\n        Map&lt;String, Object&gt; response = new HashMap&lt;&gt;();\n        response.put(&quot;message&quot;, &quot;Medecin registered successfully&quot;);\n        response.put(&quot;token&quot;, jwtToken);\n        response.put(&quot;user&quot;, Map.of(\n                &quot;id&quot;, savedMedecin.getId(),\n                &quot;name&quot;, savedMedecin.getName(),\n                &quot;email&quot;, savedMedecin.getEmail(),\n                &quot;role&quot;, savedMedecin.getRole().toString(),\n                &quot;specialite&quot;, savedMedecin.getSpecialite()\n        ));\n\n        return response;\n    }\n\n\n    public AuthenticationResponse authenticateMedecin(LoginUserDto input) {\n        authenticationManager.authenticate(\n                new UsernamePasswordAuthenticationToken(input.getEmail(), input.getPassword())\n        );\n\n        Medecin medecin = medecinRepository.findByEmail(input.getEmail())\n                .orElseThrow(() -&gt; new UsernameNotFoundException(&quot;Medecin not found&quot;));\n\n        String token = jwtService.generateToken(medecin);\n        System.out.println(&quot;User role: &quot; + medecin.getRole());\n\n        return new AuthenticationResponse(token);\n    }\n\n    // ------------------ ADMINISTRATEUR ------------------\n    public AuthenticationResponse signupAdmin(RegisterUserDto input) {\n        Administateur admin = new Administateur();\n        admin.setName(input.getName());\n        admin.setEmail(input.getEmail());\n        admin.setPassword(passwordEncoder.encode(input.getPassword()));\n        admin.setRole(Role.ADMIN);\n\n      adminRepository.save(admin);\n        var jwt = jwtService.generateToken(admin);\n        return AuthenticationResponse.builder().token(jwt).build();\n    }\n\n    public AuthenticationResponse authenticateAdmin(LoginUserDto input) {\n        authenticationManager.authenticate(\n                new UsernamePasswordAuthenticationToken(input.getEmail(), input.getPassword())\n        );\n\n        Administateur admin = adminRepository.findByEmail(input.getEmail())\n                .orElseThrow(() -&gt; new UsernameNotFoundException(&quot;Admin not found&quot;));\n\n        String token = jwtService.generateToken(admin);\n        return new AuthenticationResponse(token);\n    }\n\n\n\n\n\n\n\n}\n\n</code></pre>\n<p>Thanks in advance.</p>\n<p>Im expecting a jwt token but all I get is 403 error.\nthis is the log i get :</p>\n<pre><code>2025-05-06T19:38:34.790+01:00  INFO 25876 --- [gestion rendez-vousmedic] [nio-8787-exec-8] o.e.g.security.JwtAuthFilter             : Processing request: /api/auth/login\n2025-05-06T19:38:34.790+01:00  INFO 25876 --- [gestion rendez-vousmedic] [nio-8787-exec-8] o.e.g.security.JwtAuthFilter             : Skipping JWT filter for: /api/auth/login\nHibernate: select u1_0.id,case when u1_1.id is not null then 1 when u1_2.id is not null then 2 when u1_3.id is not null then 3 when u1_0.id is not null then 0 end,u1_0.created_at,u1_0.email,u1_0.name,u1_0.password,u1_0.role_,u1_0.updated_at,u1_2.specialite from user u1_0 left join administateur u1_1 on u1_0.id=u1_1.id left join medecin u1_2 on u1_0.id=u1_2.id left join patient u1_3 on u1_0.id=u1_3.id where u1_0.email=?\n\n</code></pre>\n",
    "tags" : [ "java", "spring-boot", "error-handling", "jwt", "backend" ],
    "owner" : {
      "account_id" : 41822063,
      "reputation" : 11,
      "user_id" : 30465325,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/5b43d2b150f96b92da4451a7cae3c533?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "user30465325",
      "link" : "https://stackoverflow.com/users/30465325/user30465325"
    },
    "is_answered" : true,
    "view_count" : 35,
    "answer_count" : 1,
    "score" : 0,
    "last_activity_date" : 1746558977,
    "creation_date" : 1746557252,
    "link" : "https://stackoverflow.com/questions/79609312/spring-security-403-forbidden-in-login-via-roles",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79609352,
    "question_id" : 79609312,
    "body" : "<p>SOLVED-the query returnes multiple users thats why lol</p>\n",
    "score" : 1,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 41822063,
      "reputation" : 11,
      "user_id" : 30465325,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/5b43d2b150f96b92da4451a7cae3c533?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "user30465325",
      "link" : "https://stackoverflow.com/users/30465325/user30465325"
    },
    "creation_date" : 1746558977,
    "last_activity_date" : 1746558977,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79609352" : [ {
      "comment_id" : 140401761,
      "post_id" : 79609352,
      "body" : "Consider using unique constraints (email or username) to prevent multiple users. Unique constraints ensure that the data in a column or combination of columns is unique for each row.",
      "score" : 0,
      "owner" : {
        "account_id" : 10822550,
        "reputation" : 121,
        "user_id" : 7959547,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/2af8a2d3ebf8d28c19609e1ac8c8a1f0?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "elvirt",
        "link" : "https://stackoverflow.com/users/7959547/elvirt"
      },
      "creation_date" : 1746562052,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}