{
  "question" : {
    "question_id" : 79690262,
    "title" : "Spring Boot JWT Auth Fails With &quot;Another algorithm expected, or no matching key(s) found&quot; Despite Matching HS512 Config",
    "body" : "<p>I'm building a Spring Boot microservices application where an auth-service generates JWTs and a user-service validates them. I'm consistently getting a 401 Unauthorized error in the user-service when I make a request with a valid token generated by the auth-service.The specific error from the user-service logs is: An error occurred while attempting to decode the Jwt: Signed JWT rejected: Another algorithm expected, or no matching key(s) foundThis is very confusing because I have meticulously configured both services to use the HS512 algorithm and the exact same secret key.</p>\n<p>My Setup1. auth-service - Token Generation (JwtService.java)This service creates the token using the io.jsonwebtoken (jjwt) library and signs it with SignatureAlgorithm.HS512.</p>\n<pre><code>        package com.grambasket.authservice.security;\n    \n    import io.jsonwebtoken.Jwts;\n    import io.jsonwebtoken.SignatureAlgorithm;\n    import io.jsonwebtoken.security.Keys;\n    import jakarta.annotation.PostConstruct;\n    import lombok.extern.slf4j.Slf4j;\n    import org.springframework.beans.factory.annotation.Value;\n    import org.springframework.stereotype.Service;\n    import java.nio.charset.StandardCharsets;\n    import java.security.Key;\n    import java.util.Date;\n    import java.util.Map;\n    \n    @Service\n    @Slf4j\n    public class JwtService {\n    \n        @Value(&quot;${spring.security.oauth2.resourceserver.jwt.secret-key}&quot;)\n        private String jwtSecret;\n    \n        private Key signInKey;\n    \n        @PostConstruct\n        public void init() {\n            this.signInKey = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));\n            log.info(&quot;JWT signing key initialized for use with HS512 algorithm.&quot;);\n        }\n    \n        private String buildToken(Map&lt;String, Object&gt; extraClaims, UserDetails userDetails, long expiration) {\n            // ...\n            return Jwts.builder()\n                    // ... other claims (subject, issuer, etc.)\n                    .signWith(signInKey, SignatureAlgorithm.HS512) // Explicitly using HS512\n                    .compact();\n        }\n        // ... rest of the class\n    }\n</code></pre>\n<ol start=\"2\">\n<li>user-service - Token Validation (SecurityConfig.java)This service is an OAuth2 Resource Server. It uses NimbusJwtDecoder to validate the token, also specifying HmacSHA512.</li>\n</ol>\n<pre><code>package com.grambasket.userservice.security;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.oauth2.jwt.JwtDecoder;\nimport org.springframework.security.oauth2.jwt.NimbusJwtDecoder;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.nio.charset.StandardCharsets;\n\n@Configuration\n@EnableWebSecurity\n@Slf4j\npublic class SecurityConfig {\n\n    @Value(&quot;${spring.security.oauth2.resourceserver.jwt.secret-key}&quot;)\n    private String jwtSecret;\n\n    // ... other beans and configs\n\n    @Bean\n    public JwtDecoder jwtDecoder() {\n        // Expecting HmacSHA512\n        SecretKeySpec secretKey = new SecretKeySpec(jwtSecret.getBytes(StandardCharsets.UTF_8), &quot;HmacSHA512&quot;);\n        log.info(&quot;Configuring JwtDecoder with HmacSHA512 algorithm.&quot;);\n        return NimbusJwtDecoder.withSecretKey(secretKey).build();\n    }\n}\n</code></pre>\n<ol start=\"3\">\n<li>Shared Configuration (application.yml)Both services use the exact same secret key. I've tried both a simple key and a long, Base64-encoded key to ensure it meets the length requirements for HS512. The error is the same in both cases.â€¢auth-service/application.yml:</li>\n</ol>\n<pre><code>      security:\n        oauth2:\n          resourceserver:\n            jwt:\n              secret-key: &quot;mysupersecretkeymysupersecretkey12&quot;\n    ````\n\nuser-service/application.yml:\n\n</code></pre>\n<pre><code>spring:\n  security:\n    oauth2:\n      resourceserver:\n        jwt:\n          secret-key: &quot;mysupersecretkeymysupersecretkey12&quot;\n</code></pre>\n<pre><code>\n\nWhat I Have Tried\n1.Algorithm Alignment: \nI have triple-checked that both the signing (SignatureAlgorithm.HS512) and decoding (&quot;HmacSHA512&quot;) configurations match.\n2.Secret Key Verification: The secret key is identical in both services. I've copy-pasted it to be sure.\n3.Key Length: I replaced an initial shorter key with a longer one (&gt; 64 bytes) to satisfy the length requirement for HS512, but the error persists.\n4.Clean Build: I have run mvn clean install -U and manually deleted my .m2 repository folders to rule out caching issues.\n5.Public Endpoint Test: I created a public /ping endpoint in the user-service which works perfectly. The 401 error only occurs when the Authorization: Bearer &lt;token&gt; header is present, which isolates the problem to JWT validation.\n\n\nGiven that the algorithms and secret keys appear to be perfectly matched, what could be the underlying cause for the JwtAuthenticationProvider to fail with Another algorithm expected, or no matching key(s) found?Could there be a subtle conflict between the io.jsonwebtoken library used for signing and the com.nimbusds library used by Spring for decoding? Or could the non-GA dependency versions in my pom.xml be causing this unpredictable behavior?Any insight would be greatly appreciated.\n</code></pre>\n",
    "tags" : [ "java", "spring", "spring-boot", "spring-mvc", "jwt" ],
    "owner" : {
      "account_id" : 7019742,
      "reputation" : 68,
      "user_id" : 7645532,
      "user_type" : "registered",
      "profile_image" : "https://lh5.googleusercontent.com/-arfpNXcpl2s/AAAAAAAAAAI/AAAAAAAAAVY/Rtj6N053--M/s256-rj/photo.jpg",
      "display_name" : "Kiran Gavhane",
      "link" : "https://stackoverflow.com/users/7645532/kiran-gavhane"
    },
    "is_answered" : true,
    "view_count" : 225,
    "answer_count" : 2,
    "score" : 0,
    "last_activity_date" : 1751698683,
    "creation_date" : 1751635558,
    "link" : "https://stackoverflow.com/questions/79690262/spring-boot-jwt-auth-fails-with-another-algorithm-expected-or-no-matching-key",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79690663,
    "question_id" : 79690262,
    "body" : "<p>Configure your <code>user-service</code> correctly to expect HS512 tokens and use the provided 64-byte key for validation. Fix discrepancy between the required key length for HS512 algorithm and the key you're providing.</p>\n<h3>1. Generate proper secret key</h3>\n<p>You need a key that is at least 64 bytes long. The best practice is to use a cryptographically random string and then Base64-encode it. Use this generated key in the <code>application.yml</code> of both your <code>auth-service</code> and <code>user-service</code>.</p>\n<ul>\n<li><p>Update your <code>user-service/application.yml</code> with the new, 64-byte, Base64-encoded key and add <code>jws-algorithms</code> property to explicitly tell Spring Security which algorithm to use for validation:</p>\n<pre class=\"lang-yaml prettyprint-override\"><code>spring:\n  security:\n    oauth2:\n      resourceserver:\n        jwt:\n          secret-key: &quot;bU9YUGlFcGZBYW14dElzckQ5QklmVEdqVk1SU1hJc1RGNUZpSmxLcUZkM0d2UHpocVd4M3g2a0JtY0VvVlZUeA==&quot;\n          jws-algorithms: HS512\n</code></pre>\n</li>\n<li><p>Ensure your <code>auth-service/application.yml</code> uses the exact same new key:</p>\n<pre class=\"lang-yaml prettyprint-override\"><code>spring:\n  security:\n    oauth2:\n      resourceserver:\n        jwt:\n          secret-key: &quot;bU9YUGlFcGZBYW14dElzckQ5QklmVEdqVk1SU1hJc1RGNUZpSmxLcUZkM0d2UHpocVd4M3g2a0JtY0VvVlZUeA==&quot;\n</code></pre>\n</li>\n</ul>\n<h3>2: Leverage Spring Boot Autoconfiguration</h3>\n<p>Your <code>user-service</code> has a manual <code>JwtDecoder</code> bean. While this works you're fighting Spring Boot's auto-configuration. You can achieve the same result with zero custom code, which is the much more robust and reliable embedded auto-configuration mechanism.</p>\n<p>Spring Security's resource server can be configured entirely from <code>application.yml</code>. You just need to tell it which algorithm to expect.</p>\n<h3>3. Remove manual JwtDecoder</h3>\n<p>Since Spring Boot has all the information it needs, you can completely delete your <code>jwtDecoder</code> bean from your <code>SecurityConfig</code> in <code>user-service</code>. The framework will now automatically create correctly configured <code>NimbusJwtDecoder</code> for you. The best code is often the code you don't have to write. Just let the framework do its job by proper configuration.</p>\n<p>Your <code>SecurityConfig</code> can be simplified:</p>\n<pre class=\"lang-java prettyprint-override\"><code>@Configuration\n@EnableWebSecurity\n@Slf4j\npublic class SecurityConfig {\n    // No @Value for the secret is needed here anymore\n    // No jwtDecoder() bean is needed anymore!\n    \n    // ... other beans and security configs (for example SecurityFilterChain bean)\n}\n</code></pre>\n",
    "score" : 2,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 1207862,
      "reputation" : 4210,
      "user_id" : 1177031,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/79eaae35b3331731ecfb9e360bb8380b?s=256&d=identicon&r=PG",
      "display_name" : "kapandron",
      "link" : "https://stackoverflow.com/users/1177031/kapandron"
    },
    "creation_date" : 1751664051,
    "last_activity_date" : 1751664355,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79690846,
    "question_id" : 79690262,
    "body" : "<pre><code>    @Bean\n    public JwtDecoder jwtDecoder() {\n        byte[] keyBytes = jwtSecret.getBytes(StandardCharsets.UTF_8);\n        SecretKeySpec secretKey = new SecretKeySpec(keyBytes, &quot;HmacSHA512&quot;);\n        log.info(&quot;Configuring JwtDecoder with HmacSHA512 and explicitly setting HS512.&quot;);\n        return NimbusJwtDecoder.withSecretKey(secretKey)\n                .macAlgorithm(MacAlgorithm.HS512)\n                .build();\n    }\n</code></pre>\n<p>After research, I found that, nimbus doesn't reconize HS512 algorithm, so we explicitly needs to nimbus that it's HS512, so I have provided macAlgorithm(MacAlgorithm.HS512) which resolved the issue. Also I tried the answer from <a href=\"https://stackoverflow.com/users/1177031/kapandron\">kapandron</a>, which also solves the issue. So, only thing about this issue is that we explicitly need to add type of algorithm we are using.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 7019742,
      "reputation" : 68,
      "user_id" : 7645532,
      "user_type" : "registered",
      "profile_image" : "https://lh5.googleusercontent.com/-arfpNXcpl2s/AAAAAAAAAAI/AAAAAAAAAVY/Rtj6N053--M/s256-rj/photo.jpg",
      "display_name" : "Kiran Gavhane",
      "link" : "https://stackoverflow.com/users/7645532/kiran-gavhane"
    },
    "creation_date" : 1751698683,
    "last_activity_date" : 1751698683,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79690846" : [ {
      "comment_id" : 140566506,
      "post_id" : 79690846,
      "body" : "But in general you don&#39;t need to write custom code where you can solve the problem by simply configuring the framework you&#39;re using correctly",
      "score" : 1,
      "owner" : {
        "account_id" : 1207862,
        "reputation" : 4210,
        "user_id" : 1177031,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/79eaae35b3331731ecfb9e360bb8380b?s=256&d=identicon&r=PG",
        "display_name" : "kapandron",
        "link" : "https://stackoverflow.com/users/1177031/kapandron"
      },
      "creation_date" : 1751701044,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}