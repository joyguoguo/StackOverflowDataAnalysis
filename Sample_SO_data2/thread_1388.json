{
  "question" : {
    "question_id" : 79715510,
    "title" : "TypeCasting Math.pow(2,31) to int is not wrapping around as expected?",
    "body" : "<p>I was trying to check for wrap around property when the value is greater than the container that can hold it.</p>\n<pre><code>public class Main {\n    public static void main(String[] args) {\n        double value = Math.pow(2,31);\n        System.out.println(&quot;Raw double: &quot; + value);\n        System.out.println(&quot;After casting to int: &quot; + (int)value);\n        System.out.println(&quot;Integer.MAX_VALUE: &quot; + Integer.MAX_VALUE);\n    }\n}\n</code></pre>\n<p>I have done this in JShell -- Version 20.0.2, java 20.0.2 2023-07-18, and <a href=\"https://www.programiz.com/java-programming/online-compiler/\" rel=\"noreferrer\">programiz</a></p>\n<p>The output i was expecting since the value should wrap around :</p>\n<pre><code>Raw double: 2.147483648E9\nAfter casting to int: -2147483648\nInteger.MAX_VALUE: 2147483647\n</code></pre>\n<p>The output i got:</p>\n<pre><code>Raw double: 2.147483648E9\nAfter casting to int: 2147483647\nInteger.MAX_VALUE: 2147483647\n</code></pre>\n<p>I also tried shift operator <code>1L&lt;&lt;31</code> insted of <code>Math.pow(2,31)</code> since there can be lost in precision when using double (Math.pow() return type) but the result was same.</p>\n",
    "tags" : [ "java", "data-structures" ],
    "owner" : {
      "account_id" : 43233760,
      "reputation" : 53,
      "user_id" : 31148866,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/3bd1328a52b3d615e8bbda53c09be927?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "shajid",
      "link" : "https://stackoverflow.com/users/31148866/shajid"
    },
    "is_answered" : true,
    "view_count" : 269,
    "closed_date" : 1753582346,
    "answer_count" : 1,
    "score" : 5,
    "last_activity_date" : 1753520145,
    "creation_date" : 1753517078,
    "link" : "https://stackoverflow.com/questions/79715510/typecasting-math-pow2-31-to-int-is-not-wrapping-around-as-expected",
    "closed_reason" : "Duplicate"
  },
  "answers" : [ {
    "answer_id" : 79715515,
    "question_id" : 79715510,
    "body" : "<p>Firstly, skip the call to <code>Math.pow</code> - focus on the cast. You could just hard-code the <code>double</code> value in the first line, using a literal. You have &quot;a large <code>double</code>&quot; (slightly bigger than the biggest <code>int</code>) and you're casting to <code>int</code>. Now let's look at what that's specified to do in the Java language specification.</p>\n<p>This is a <em>narrowing primitive conversion</em> <a href=\"https://docs.oracle.com/javase/specs/jls/se24/html/jls-5.html#jls-5.1.3\" rel=\"noreferrer\">ยง5.1.3</a> which follows these rules:</p>\n<blockquote>\n<p>A narrowing conversion of a floating-point number to an integral type T takes two steps:</p>\n<ul>\n<li><p>In the first step, the floating-point number is converted either to a long, if T is long, or to an int, if T is byte, short, char, or int, as follows:</p>\n<ul>\n<li>If the floating-point number is NaN (ยง4.2.3), the result of the first step of the conversion is an int or long 0.</li>\n<li>Otherwise, if the floating-point number is not an infinity, the floating-point value is rounded to an integer value V using the round toward zero rounding policy (ยง4.2.4). Then there are two cases:\n<ul>\n<li>If T is long, and this integer value can be represented as a long, then the result of the first step is the long value V.</li>\n<li>Otherwise, if this integer value can be represented as an int, then the result of the first step is the int value V.</li>\n</ul>\n</li>\n<li>Otherwise, one of the following two cases must be true:\n<ul>\n<li>The value must be too small (a negative value of large magnitude or negative infinity), and the result of the first step is the smallest representable value of type int or long.</li>\n<li>The value must be too large (a positive value of large magnitude or positive infinity), and the result of the first step is the largest representable value of type int or long.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>In the second step:</p>\n<ul>\n<li><p>If T is int or long, the result of the conversion is the result of the first step.</p>\n</li>\n<li><p>If T is byte, char, or short, the result of the conversion is the result of a narrowing conversion to type T (ยง5.1.3) of the result of the first step.</p>\n</li>\n</ul>\n</blockquote>\n<p>So following those rules:</p>\n<ul>\n<li>The value isn't NaN</li>\n<li>The value isn't infinity</li>\n<li>The value can't be represented as an <code>int</code></li>\n<li>The value is too large - &quot;a positive value of large magnitude or positive infinity&quot; - therefore &quot;the result of the first step is the largest representable value of type <code>int</code> or <code>long</code>&quot;; this is the result of the first step</li>\n<li>The second step just says the result is the result of the first step, because we're casting to <code>int</code></li>\n</ul>\n<p>So it looks to me like the result of <code>Integer.MAX_VALUE</code> is entirely appropriate.</p>\n<p>If you still believe that the result should be negative, you should try to find a justification for that in the language specification.</p>\n<p>Note that other narrowing primitive conversions don't operate in the same way. From the same section:</p>\n<blockquote>\n<p>A narrowing conversion of a signed integer to an integral type T simply discards all but the n lowest order bits, where n is the number of bits used to represent type T. In addition to a possible loss of information about the magnitude of the numeric value, this may cause the sign of the resulting value to differ from the sign of the input value.</p>\n</blockquote>\n<p>Which means, for example:</p>\n<pre class=\"lang-java prettyprint-override\"><code>long x = 1L &lt;&lt; 31;\nSystem.out.println((int) x);\n</code></pre>\n<p>... prints -2147483648.</p>\n<p>In order to understand the results of operations - whether casting, or &quot;simple&quot; arithmetic operators like <code>+</code> and <code>-</code> - you need to be absolutely clear what the types are, because that affects the results.</p>\n",
    "score" : 12,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 11683,
      "reputation" : 1521090,
      "user_id" : 22656,
      "user_type" : "registered",
      "accept_rate" : 86,
      "profile_image" : "https://www.gravatar.com/avatar/6d8ebb117e8d83d74ea95fbdd0f87e13?s=256&d=identicon&r=PG",
      "display_name" : "Jon Skeet",
      "link" : "https://stackoverflow.com/users/22656/jon-skeet"
    },
    "creation_date" : 1753517498,
    "last_activity_date" : 1753520145,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140620091,
    "post_id" : 79715510,
    "body" : "<a href=\"https://stackoverflow.com/q/54557453/85421\">The specifics of casting to int, from double and long</a>",
    "score" : 1,
    "owner" : {
      "account_id" : 31180,
      "reputation" : 29752,
      "user_id" : 85421,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/kKvXH.gif?s=256",
      "display_name" : "user85421",
      "link" : "https://stackoverflow.com/users/85421/user85421"
    },
    "creation_date" : 1753531172,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79715515" : [ {
      "comment_id" : 140619884,
      "post_id" : 79715515,
      "body" : "@shajid For example, <code>long x = 1L &lt;&lt; 31; System.out.println((int) x);</code> will print -2147483648. But you need to be <i>really</i> precise about which operations you&#39;re doing.",
      "score" : 2,
      "owner" : {
        "account_id" : 11683,
        "reputation" : 1521090,
        "user_id" : 22656,
        "user_type" : "registered",
        "accept_rate" : 86,
        "profile_image" : "https://www.gravatar.com/avatar/6d8ebb117e8d83d74ea95fbdd0f87e13?s=256&d=identicon&r=PG",
        "display_name" : "Jon Skeet",
        "link" : "https://stackoverflow.com/users/22656/jon-skeet"
      },
      "creation_date" : 1753520090,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140619882,
      "post_id" : 79715515,
      "body" : "@shajid: No, when narrowing <i>from a floating point type</i> the sign won&#39;t change. But from the same section (linked in the answer): &quot;A narrowing conversion of a signed integer to an integral type T simply discards all but the n lowest order bits, where n is the number of bits used to represent type T. In addition to a possible loss of information about the magnitude of the numeric value, this may cause the sign of the resulting value to differ from the sign of the input value.&quot; So if you cast from a <code>long</code> value greater than <code>Integer.MAX_VALUE</code> to <code>int</code>, that can indeed be negative",
      "score" : 0,
      "owner" : {
        "account_id" : 11683,
        "reputation" : 1521090,
        "user_id" : 22656,
        "user_type" : "registered",
        "accept_rate" : 86,
        "profile_image" : "https://www.gravatar.com/avatar/6d8ebb117e8d83d74ea95fbdd0f87e13?s=256&d=identicon&r=PG",
        "display_name" : "Jon Skeet",
        "link" : "https://stackoverflow.com/users/22656/jon-skeet"
      },
      "creation_date" : 1753520012,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140619857,
      "post_id" : 79715515,
      "body" : "So it means when narrowing the wrap around method is not used. Right!",
      "score" : 0,
      "owner" : {
        "account_id" : 43233760,
        "reputation" : 53,
        "user_id" : 31148866,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/3bd1328a52b3d615e8bbda53c09be927?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "shajid",
        "link" : "https://stackoverflow.com/users/31148866/shajid"
      },
      "creation_date" : 1753518897,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140619843,
      "post_id" : 79715515,
      "body" : "@shajid 2^31+1 doesn&#39;t involve a narrowing primitive conversion (e.g., conversion from double to int)",
      "score" : 0,
      "owner" : {
        "account_id" : 1888781,
        "reputation" : 2498,
        "user_id" : 1707427,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/4d1a2608ee35e2df7d2400a02e62bb20?s=256&d=identicon&r=PG",
        "display_name" : "S&#246;ren",
        "link" : "https://stackoverflow.com/users/1707427/s%c3%b6ren"
      },
      "creation_date" : 1753518669,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140619841,
      "post_id" : 79715515,
      "body" : "@shajid: Is it though? When casting <i>from a double</i>? The context is important here. Note that it&#39;s very different if you already <i>have</i> a large <code>int</code> (max value) and add 1 to it, or if you cast from <code>long</code>. Those operations use different rules. Can you provide a concrete example where casting from a large <code>double</code> value to <code>int</code> results in a negative value?",
      "score" : 0,
      "owner" : {
        "account_id" : 11683,
        "reputation" : 1521090,
        "user_id" : 22656,
        "user_type" : "registered",
        "accept_rate" : 86,
        "profile_image" : "https://www.gravatar.com/avatar/6d8ebb117e8d83d74ea95fbdd0f87e13?s=256&d=identicon&r=PG",
        "display_name" : "Jon Skeet",
        "link" : "https://stackoverflow.com/users/22656/jon-skeet"
      },
      "creation_date" : 1753518628,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140619832,
      "post_id" : 79715515,
      "body" : "The value is too large - &quot;a positive value of large magnitude or positive infinity&quot; - therefore &quot;the result of the first step is the largest representable value of type int or long&quot;; this is the result of the first step..... According to this every number which is greater than the MAX value must be casted to MAX value on int but if you try it for 2^31+1 the result is -2^31",
      "score" : 0,
      "owner" : {
        "account_id" : 43233760,
        "reputation" : 53,
        "user_id" : 31148866,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/3bd1328a52b3d615e8bbda53c09be927?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "shajid",
        "link" : "https://stackoverflow.com/users/31148866/shajid"
      },
      "creation_date" : 1753517802,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}