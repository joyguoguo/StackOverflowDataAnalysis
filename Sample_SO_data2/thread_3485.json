{
  "question" : {
    "question_id" : 79548721,
    "title" : "Exception when using timeout on transaction",
    "body" : "<p>I use Spring Boot 3 with an Oracle database (JpaRepository and Hikari connection are used) and I have a strange behaviour when using timeout on @Transactional.\nWhat I want is to do a select but if the query is too long, then I want a timeout with an exception to catch to return a specific error to the front-end.</p>\n<p>I use this on the service method:</p>\n<pre><code>@Transactional(readOnly = true, timeout = 30)\n</code></pre>\n<p>When timeout occurs, I see these errors in logs:</p>\n<pre><code>ORA-01013: user requested cancel of current operation &lt;-- seems to be due to the timeout\n...\nERROR o.s.t.i.TransactionInterceptor - Application exception overridden by rollback exception\n...\nCaused by: oracle.jdbc.OracleDatabaseException: ORA-01013\n</code></pre>\n<p>In the controller, if I catch the Exception thrown by the service, I have a JPA exception (<code>org.springframework.orm.jpa.JpaSystemException: Unable to rollback against JDBC Connection</code>) due to the fact that a rollback cannot be done because the connection is closed:</p>\n<pre><code>org.springframework.orm.jpa.JpaSystemException: Unable to rollback against JDBC Connection\nat org.springframework.orm.jpa.vendor.HibernateJpaDialect.convertHibernateAccessException(HibernateJpaDialect.java:341)\nat org.springframework.orm.jpa.vendor.HibernateJpaDialect.translateExceptionIfPossible(HibernateJpaDialect.java:241)\nat org.springframework.orm.jpa.JpaTransactionManager.doRollback(JpaTransactionManager.java:593)\n...\nCaused by: org.hibernate.TransactionException: Unable to rollback against JDBC Connection\nat org.hibernate.resource.jdbc.internal.AbstractLogicalConnectionImplementor.rollback(AbstractLogicalConnectionImplementor.java:137)\nat org.hibernate.resource.transaction.backend.jdbc.internal.JdbcResourceLocalTransactionCoordinatorImpl$TransactionDriverControlImpl.rollback(JdbcResourceLocalTransactionCoordinatorImpl.java:289)\nat org.hibernate.engine.transaction.internal.TransactionImpl.rollback(TransactionImpl.java:142)\n...\nCaused by: java.sql.SQLException: Connection is closed\nat com.zaxxer.hikari.pool.ProxyConnection$ClosedConnection.lambda$getClosedConnection$0(ProxyConnection.java:503)\nat jdk.proxy3/jdk.proxy3.$Proxy144.rollback(Unknown Source)\nat com.zaxxer.hikari.pool.ProxyConnection.rollback(ProxyConnection.java:386)\nat com.zaxxer.hikari.pool.HikariProxyConnection.rollback(HikariProxyConnection.java)\n</code></pre>\n<p>I do not understand because my transaction is readOnly so I do not expect to have a commit or a rollback. Also, I do not expect to have an error due to a closed connection but just to have a TransactionTimedOutException or something like that to catch indicating that the error is due to timeout.</p>\n<p>I would like to catch an exception in my controller linked to the timeout like this if it is possible to be able to return a specific response to the front-end that there was a timeout:</p>\n<pre><code>try {\n  this.myService.doService();\n} catch(Exception e) { // An explicit exception indication that we had a timeout (ex: TransactionTimedOutException)\n  // return a specific error code to front-end\n}\n</code></pre>\n<p>For the moment, I have a <code>org.springframework.orm.jpa.JpaSystemException: Unable to rollback against JDBC Connection</code> due to the fact that the rollback cannot be done because the connection has been closed after a SQL exception (with ORA-01013 error). I am not able to have information about the original exception that is a SQLTimeoutException.</p>\n<p>Can you help me please?</p>\n",
    "tags" : [ "java", "spring", "spring-boot" ],
    "owner" : {
      "account_id" : 18936970,
      "reputation" : 341,
      "user_id" : 13817825,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/cbced2a5eafd2c2cec5f5dd41b288905?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "phildeg31",
      "link" : "https://stackoverflow.com/users/13817825/phildeg31"
    },
    "is_answered" : true,
    "view_count" : 241,
    "answer_count" : 3,
    "score" : 0,
    "last_activity_date" : 1745569056,
    "creation_date" : 1743512781,
    "link" : "https://stackoverflow.com/questions/79548721/exception-when-using-timeout-on-transaction",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79548770,
    "question_id" : 79548721,
    "body" : "<p>As far as I'm concern, any transational query is handled by Spring Boot's TransactionManager, which is the one doing the rollback that causes the exception, even if it is a readOnly operation.</p>\n<p>If you're only concerned about the actual read, maybe you could just use <code>@Query</code> or <code>@QueryTimeout</code> headers with setHint. Or even set the default read timeout to whichever value you need using <code>spring.datasource.hikari.dataSourceProperties: oracle.jdbc.ReadTimeout=XXX</code></p>\n<p>Hope this helps!</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 19328770,
      "reputation" : 1,
      "user_id" : 15019437,
      "user_type" : "registered",
      "profile_image" : "https://lh3.googleusercontent.com/a-/AOh14GguPbLDDQu_37vJY1mwC0vQMKJV8d-we4eQUSeHgA=k-s256",
      "display_name" : "Daniel Robledo",
      "link" : "https://stackoverflow.com/users/15019437/daniel-robledo"
    },
    "creation_date" : 1743513937,
    "last_activity_date" : 1743513937,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79549038,
    "question_id" : 79548721,
    "body" : "<p>I'm a little unsure I understand the question exactly but I'll put out a couple of leads to follow.  Maybe add more information to your question if these suggestions aren't helpful.</p>\n<ol>\n<li>&quot;Application exception overridden by rollback exception&quot; means that the exception you catch should have a &quot;suppressed&quot; exception connected to it.  That &quot;suppressed&quot; exception is the application error that prompted the rollback.  Inspecting the suppressed exception using <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html#getSuppressed--\" rel=\"nofollow noreferrer\">getSuppressed</a> might help you solve the root problem.</li>\n<li>If your connection is being closed before the timeout occurs, this should be fixable by tweaking your DB connection configuration details. Ensure that the connection timeout is higher than the timeout of any query.  (Check this configuration on the Oracle side as well since those Oracle setting supersede anything you do on your application side.)</li>\n</ol>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 273136,
      "reputation" : 1711,
      "user_id" : 564553,
      "user_type" : "registered",
      "accept_rate" : 92,
      "profile_image" : "https://www.gravatar.com/avatar/cca53f9b89c73e85539a7f599585c789?s=256&d=identicon&r=PG",
      "display_name" : "BPS",
      "link" : "https://stackoverflow.com/users/564553/bps"
    },
    "creation_date" : 1743536517,
    "last_activity_date" : 1743536517,
    "content_license" : "CC BY-SA 4.0"
  }, {
    "answer_id" : 79592099,
    "question_id" : 79548721,
    "body" : "<p>After putting the behaviour on the Github of the Spring team, a new version 6.2.6 of spring-jdbc dependency has been published.</p>\n<p>This is what you have to do to catch a org.springframework.dao.QueryTimeoutException using this new version:</p>\n<ul>\n<li>Use LazyConnectionDataSourceProxy where the change has been done (<a href=\"https://github.com/spring-projects/spring-framework/commit/cc5ae239156bb9553263b3a825fb34dfeb5f5265\" rel=\"nofollow noreferrer\">https://github.com/spring-projects/spring-framework/commit/cc5ae239156bb9553263b3a825fb34dfeb5f5265</a>):</li>\n</ul>\n<pre><code>@Configuration\npublic class DatabaseConfiguration {\n    @Bean\n    @ConfigurationProperties(prefix = &quot;spring.datasource.hikari&quot;)\n    public HikariDataSource hikariDataSource(DataSourceProperties properties) {\n        HikariDataSource hikariDataSource = createDataSource(properties, HikariDataSource.class);\n        if (StringUtils.hasText(properties.getName())) {\n            hikariDataSource.setPoolName(properties.getName());\n        }\n        return hikariDataSource;\n    }\n\n    protected static &lt;T&gt; T createDataSource(DataSourceProperties properties, Class&lt;? extends DataSource&gt; type) {\n        return (T) properties.initializeDataSourceBuilder().type(type).build();\n    }\n\n    @Primary\n    @Bean\n    public DataSource dataSource(HikariDataSource hikariDataSource) {\n        // Wrap hikariDataSource in a LazyConnectionDataSourceProxy\n        LazyConnectionDataSourceProxy lazyDataSource = new LazyConnectionDataSourceProxy();\n        lazyDataSource.setTargetDataSource(hikariDataSource);\n        return lazyDataSource;\n    }\n}\n</code></pre>\n<ul>\n<li>Disable DataSourceAutoConfiguration because of the previous specific configuration:</li>\n</ul>\n<pre><code>@EnableAutoConfiguration(exclude = { DataSourceAutoConfiguration.class })\n</code></pre>\n<ul>\n<li>catch org.springframework.dao.QueryTimeoutException in the controller because with the change this is now what we receive instead of an exception for the rollback that cannot be done because of a closed connection before.</li>\n</ul>\n<p>Thank you to the Spring team to do this fast change because I am now able to catch this exception related to the timeout of the transaction to return REQUEST_TIMEOUT error to the front-end.</p>\n",
    "score" : 0,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 18936970,
      "reputation" : 341,
      "user_id" : 13817825,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/cbced2a5eafd2c2cec5f5dd41b288905?s=256&d=identicon&r=PG&f=y&so-version=2",
      "display_name" : "phildeg31",
      "link" : "https://stackoverflow.com/users/13817825/phildeg31"
    },
    "creation_date" : 1745569056,
    "last_activity_date" : 1745569056,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ {
    "comment_id" : 140287887,
    "post_id" : 79548721,
    "body" : "Since spring JPARepository intercept database exceptions and replaces it with their own the correct approach for you is to write your own interceptor for it. Something that is discussed here: <a href=\"https://stackoverflow.com/q/69646662/460557\">stackoverflow.com/q/69646662/460557</a>",
    "score" : 0,
    "owner" : {
      "account_id" : 209503,
      "reputation" : 23867,
      "user_id" : 460557,
      "user_type" : "registered",
      "accept_rate" : 100,
      "profile_image" : "https://www.gravatar.com/avatar/b4565f97815833390c9c880e9e8522e4?s=256&d=identicon&r=PG",
      "display_name" : "Jorge Campos",
      "link" : "https://stackoverflow.com/users/460557/jorge-campos"
    },
    "creation_date" : 1743541912,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "answer_comments" : {
    "79549038" : [ {
      "comment_id" : 140293586,
      "post_id" : 79549038,
      "body" : "For &quot;Application exception overridden by rollback exception&quot;, it seems to be done by TransactionInterceptor. When the timeout occurs, there is a SQLException with code ORA-01013 and then I see this log. In my controller, if I catch exception thrown by my service, I have a JPA exception due to the fact that a rollback cannot be done and not an exception due to the timeout so I am not able to identify that the root cause is the timeout.",
      "score" : 0,
      "owner" : {
        "account_id" : 18936970,
        "reputation" : 341,
        "user_id" : 13817825,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/cbced2a5eafd2c2cec5f5dd41b288905?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "phildeg31",
        "link" : "https://stackoverflow.com/users/13817825/phildeg31"
      },
      "creation_date" : 1743666725,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140293530,
      "post_id" : 79549038,
      "body" : "Hi, I edited my question to clarify what I would like to have.",
      "score" : 0,
      "owner" : {
        "account_id" : 18936970,
        "reputation" : 341,
        "user_id" : 13817825,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/cbced2a5eafd2c2cec5f5dd41b288905?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "phildeg31",
        "link" : "https://stackoverflow.com/users/13817825/phildeg31"
      },
      "creation_date" : 1743665849,
      "content_license" : "CC BY-SA 4.0"
    } ],
    "79548770" : [ {
      "comment_id" : 140307572,
      "post_id" : 79548770,
      "body" : "I see, it seems that if you throw any exception, the rollback is executed by the TransantionalManager... Maybe you can try to catch the exception itself and just return a custom response, that way no rollback would get triggered?",
      "score" : 0,
      "owner" : {
        "account_id" : 19328770,
        "reputation" : 1,
        "user_id" : 15019437,
        "user_type" : "registered",
        "profile_image" : "https://lh3.googleusercontent.com/a-/AOh14GguPbLDDQu_37vJY1mwC0vQMKJV8d-we4eQUSeHgA=k-s256",
        "display_name" : "Daniel Robledo",
        "link" : "https://stackoverflow.com/users/15019437/daniel-robledo"
      },
      "creation_date" : 1744026449,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140293617,
      "post_id" : 79548770,
      "body" : "I thought that, when putting readOnly to true, the transaction would be optimized and no commit or rollback would be done. I edited my question. I hope my need is clearer",
      "score" : 0,
      "owner" : {
        "account_id" : 18936970,
        "reputation" : 341,
        "user_id" : 13817825,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/cbced2a5eafd2c2cec5f5dd41b288905?s=256&d=identicon&r=PG&f=y&so-version=2",
        "display_name" : "phildeg31",
        "link" : "https://stackoverflow.com/users/13817825/phildeg31"
      },
      "creation_date" : 1743667126,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}