{
  "question" : {
    "question_id" : 79557841,
    "title" : "Spring Boot Swagger throws &quot;Failed to load API definition. Response status is 500 /v3/api-docs&quot; after adding Exception Handlers",
    "body" : "<p>This is my first time asking a question here, so please bear with me if I miss anything.</p>\n<p>I’ve created a simple Spring Boot banking project with the following REST APIs:</p>\n<pre><code>/create\n/getAccount\n/deposit\n/withdraw\n/deleteAccount\n</code></pre>\n<p>Everything works perfectly:</p>\n<ol>\n<li>The APIs function correctly and update the database as expected</li>\n<li>Swagger UI shows all endpoints as intended</li>\n<li>Postman tests also work without any issues</li>\n</ol>\n<p>However, when I added custom exception handling using @ControllerAdvice, Swagger started throwing this error:</p>\n<p>Failed to load API definition. Response status is 500 /v3/api-docs</p>\n<p>Here’s the strange part: when I remove the exception classes, Swagger starts working again! So clearly, there’s something in the exception handling setup that’s causing this issue.</p>\n<p>Could someone help me figure out what’s going wrong?</p>\n<h2>ErrorResponse class:</h2>\n<pre><code>package com.bank.bankingApplication.exceptions;\n\nimport java.time.LocalDateTime;\n\npublic class ErrorResponse {\n    private String message;\n    private String timestamp;\n    private String path;\n\n    public ErrorResponse(String message, String path) {\n        this.message = message;\n        this.timestamp = LocalDateTime.now().toString();\n        this.path = path;\n    }\n\n    // Getters and Setters\n\n    public String getMessage() {\n        return message;\n    }\n\n    public void setMessage(String message) {\n        this.message = message;\n    }\n\n    public String getTimestamp() {\n        return timestamp;\n    }\n\n    public void setTimestamp(String timestamp) {\n        this.timestamp = timestamp;\n    }\n\n    public String getPath() {\n        return path;\n    }\n\n    public void setPath(String path) {\n        this.path = path;\n    }\n}\n\n</code></pre>\n<h2>GlobalExceptionHandler class:</h2>\n<pre><code>package com.bank.bankingApplication.exceptions;\n\n\nimport com.bank.bankingApplication.controller.BankController;\nimport jakarta.servlet.http.HttpServletRequest;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.MethodArgumentNotValidException;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;\n\n\n@ControllerAdvice\n@RestControllerAdvice(assignableTypes = {BankController.class})\npublic class GlobalExceptionHandler {\n\n//    @ExceptionHandler(Exception.class)\n//    public ResponseEntity&lt;ErrorResponse&gt; handleAllExceptions(Exception ex, HttpServletRequest request) {\n//        ErrorResponse error = new ErrorResponse(ex.getMessage(), request.getRequestURI());\n//        return new ResponseEntity&lt;&gt;(error, HttpStatus.INTERNAL_SERVER_ERROR);\n//    }\n\n    @ExceptionHandler(MethodArgumentTypeMismatchException.class)\n    public ResponseEntity&lt;ErrorResponse&gt; handleTypeMismatch(MethodArgumentTypeMismatchException ex, HttpServletRequest request) {\n        String msg = &quot;Invalid type for parameter: &quot; + ex.getName();\n        ErrorResponse error = new ErrorResponse(msg, request.getRequestURI());\n        return new ResponseEntity&lt;&gt;(error, HttpStatus.BAD_REQUEST);\n    }\n\n    @ExceptionHandler(IllegalArgumentException.class)\n    public ResponseEntity&lt;ErrorResponse&gt; handleIllegalArgs(IllegalArgumentException ex, HttpServletRequest request) {\n        ErrorResponse error = new ErrorResponse(ex.getMessage(), request.getRequestURI());\n        return new ResponseEntity&lt;&gt;(error, HttpStatus.BAD_REQUEST);\n    }\n\n    // You can add more specific ones like @ExceptionHandler(AccountNotFoundException.class) here.\n}\n\n</code></pre>\n<h2>Controller:</h2>\n<pre><code>package com.bank.bankingApplication.controller;\nimport io.swagger.v3.oas.annotations.Operation;\nimport io.swagger.v3.oas.annotations.tags.Tag;\nimport com.bank.bankingApplication.model.Account;\nimport com.bank.bankingApplication.repository.AccountRepository;\nimport com.bank.bankingApplication.service.AccountService;\nimport jakarta.servlet.http.HttpServletRequest;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Optional;\n\n@RestController\n@RequestMapping(&quot;/bank&quot;)\n@Tag(name = &quot;Bank Controller&quot;, description = &quot;Handles operations related to bank accounts&quot;)\npublic class BankController {\n    @Autowired\n    private AccountService accountService;\n\n    @Autowired\n    private AccountRepository accountRepository;\n\n    @Operation(\n            summary = &quot;Create a new bank account&quot;,\n            description = &quot;This endpoint is used to create a new bank account for a user.&quot;\n    )\n    @PostMapping(&quot;/create&quot;)\n    public Account createAccount(@RequestBody Account account){\n        return accountService.createAccount(account);\n    }\n\n    @Operation(\n            summary = &quot;Fetches the existing bank account&quot;,\n            description = &quot;This endpoint is used to fetch an existing bank account for a user.&quot;\n    )\n    @PostMapping(&quot;/getAccount&quot;)\n    public ResponseEntity&lt;?&gt; getAccountDetails(@RequestBody Account account) {\n        Long id = account.getId();\n        Optional&lt;Account&gt; accountOpt = accountRepository.findById(id);\n        if (accountOpt.isPresent()) {\n            return ResponseEntity.ok(accountOpt.get());\n        } else {\n            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(&quot;Account not found&quot;);\n        }\n    }\n\n    @Operation(\n            summary = &quot;Deposits the amount&quot;,\n            description = &quot;This endpoint is used to deposit amount for a user.&quot;\n    )\n    @PostMapping(&quot;/deposit&quot;)\n    public ResponseEntity&lt;DepositAndWithdrawResponse&gt; deposit(@RequestBody DepositAndWithdrawRequest request) {\n        Optional&lt;Account&gt; optionalAccount = accountRepository.findById(request.getId());\n        if (optionalAccount.isPresent()) {\n            Account account = optionalAccount.get();\n            account.setBalance(account.getBalance() + request.getAmount());\n            accountRepository.save(account);\n            DepositAndWithdrawResponse response = new DepositAndWithdrawResponse();\n            response.setId(account.getId());\n            response.setAccountHolder(account.getAccountHolder());\n            response.setBalance(account.getBalance());\n            response.setRemarks(&quot;Deposit successful. New balance: &quot; + account.getBalance());\n            return ResponseEntity.ok(response);\n        } else {\n            return ResponseEntity.notFound().build();\n        }\n    }\n\n    @Operation(\n            summary = &quot;withdraws the amount&quot;,\n            description = &quot;This endpoint is used to withdraw amount for a user.&quot;\n    )\n    @PostMapping(&quot;/withdraw&quot;)\n    public ResponseEntity&lt;DepositAndWithdrawResponse&gt; withdraw(@RequestBody DepositAndWithdrawRequest request) {\n        Optional&lt;Account&gt; optionalAccount = accountRepository.findById(request.getId());\n        if (optionalAccount.isPresent()) {\n            Account account = optionalAccount.get();\n            if(account.getBalance() &gt;= request.getAmount()){\n                account.setBalance(account.getBalance() - request.getAmount());\n                accountRepository.save(account);\n                DepositAndWithdrawResponse response = new DepositAndWithdrawResponse();\n                response.setId(account.getId());\n                response.setAccountHolder(account.getAccountHolder());\n                response.setBalance(account.getBalance());\n                response.setRemarks(&quot;Withdraw successful. New balance: &quot; + account.getBalance());\n                return ResponseEntity.ok(response);\n            }\n            else{\n                account.setBalance(account.getBalance());\n                accountRepository.save(account);\n                DepositAndWithdrawResponse response = new DepositAndWithdrawResponse();\n                response.setId(account.getId());\n                response.setAccountHolder(account.getAccountHolder());\n                response.setBalance(account.getBalance());\n                response.setRemarks(&quot;Withdraw unsuccessful because entered amount was greater than the current balance: &quot; + account.getBalance());\n                return ResponseEntity.ok(response);\n            }\n\n        } else {\n            return ResponseEntity.notFound().build();\n        }\n    }\n\n    @DeleteMapping(&quot;/deleteAccount&quot;)\n    @Operation(\n            summary = &quot;Deletes an existing bank account&quot;,\n            description = &quot;This endpoint is used to delete an existing bank account for a user.&quot;\n    )\n    public ResponseEntity&lt;String&gt; deleteAccountById(@RequestBody Map&lt;String, Long&gt; request) {\n        Long id = request.get(&quot;id&quot;);\n        Optional&lt;Account&gt; account = accountRepository.findById(id);\n        if (account.isPresent()) {\n            accountRepository.deleteById(id);\n            return ResponseEntity.ok(&quot;Account with ID &quot; + id + &quot; has been deleted successfully.&quot;);\n        } else {\n            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(&quot;Account with ID &quot; + id + &quot; not found.&quot;);\n        }\n    }\n\n}\n\n</code></pre>\n<h2>application.properties:</h2>\n<pre><code>spring.datasource.url=jdbc:mysql://localhost:3306/bank\nspring.datasource.username=root\nspring.datasource.password=MyPassword\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\nspring.jpa.database-platform=org.hibernate.dialect.MySQLDialect\nspring.jpa.hibernate.ddl-auto=update\nspring.jpa.show-sql=true\nspring.jpa.properties.hibernate.format_sql=true\n</code></pre>\n<h2>pom.xml:</h2>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;3.4.4&lt;/version&gt;\n        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;/parent&gt;\n    &lt;groupId&gt;com.bank&lt;/groupId&gt;\n    &lt;artifactId&gt;bankingApplication&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;bankingApplication&lt;/name&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n    &lt;url/&gt;\n    &lt;licenses&gt;\n        &lt;license/&gt;\n    &lt;/licenses&gt;\n    &lt;developers&gt;\n        &lt;developer/&gt;\n    &lt;/developers&gt;\n    &lt;scm&gt;\n        &lt;connection/&gt;\n        &lt;developerConnection/&gt;\n        &lt;tag/&gt;\n        &lt;url/&gt;\n    &lt;/scm&gt;\n    &lt;properties&gt;\n        &lt;java.version&gt;21&lt;/java.version&gt;\n    &lt;/properties&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;\n            &lt;scope&gt;runtime&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springdoc&lt;/groupId&gt;\n            &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;\n            &lt;version&gt;2.3.0&lt;/version&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n\n</code></pre>\n<p>I added @ControllerAdvice with custom exception classes to return structured error responses. I expected Swagger to continue working as it was earlier, but instead, I got a 500 error at /v3/api-docs. Removing the exception handler fixes Swagger, so I believe something is going wrong inside the exception handling layer. To troubleshoot, I commented out the generalized @ExceptionHandler(Exception.class) and kept only specific ones like MethodArgumentTypeMismatchException and IllegalArgumentException, assuming Swagger might rely on some built-in exception handling. But the result was still the same—Swagger fails to load with a 500 error, while Postman works fine.</p>\n",
    "tags" : [ "java", "spring", "spring-boot", "exception", "swagger-ui" ],
    "owner" : {
      "account_id" : 24098424,
      "reputation" : 13,
      "user_id" : 18070589,
      "user_type" : "registered",
      "profile_image" : "https://graph.facebook.com/489421932700465/picture?type=large",
      "display_name" : "Vijay Mohan Rangaraju",
      "link" : "https://stackoverflow.com/users/18070589/vijay-mohan-rangaraju"
    },
    "is_answered" : true,
    "view_count" : 1358,
    "answer_count" : 1,
    "score" : 1,
    "last_activity_date" : 1761885756,
    "creation_date" : 1743919124,
    "link" : "https://stackoverflow.com/questions/79557841/spring-boot-swagger-throws-failed-to-load-api-definition-response-status-is-50",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79558059,
    "question_id" : 79557841,
    "body" : "<p>You write, that removing the exception handler helps and Swagger starts working again. Perhaps, your <code>@ControllerAdvice</code> catches internal exceptions, possibly during <code>/v3/api-docs</code> generation.</p>\n<p>Try to remove <code>assignableTypes</code> and limit your <code>@RestControllerAdvice</code> with <code>basePackages</code>. Something like:</p>\n<pre><code>@RestControllerAdvice(basePackages = &quot;com.bank.bankingApplication.controller&quot;)\n</code></pre>\n",
    "score" : 0,
    "is_accepted" : true,
    "owner" : {
      "account_id" : 38931631,
      "reputation" : 671,
      "user_id" : 29023248,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/WxoZEuKw.png?s=256",
      "display_name" : "Aleksey Bykov",
      "link" : "https://stackoverflow.com/users/29023248/aleksey-bykov"
    },
    "creation_date" : 1743934245,
    "last_activity_date" : 1743934245,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79558059" : [ {
      "comment_id" : 140304670,
      "post_id" : 79558059,
      "body" : "Hey @user29023248, thanks a lot for your tip! I did try restricting RestControllerAdvice annotation using basePackages as you suggested — it was a solid direction. But even after that, Swagger still wasn’t loading properly. That’s when ChatGPT suggested using the Hidden annotation on our error handler methods to prevent Swagger from processing them. Once Idid that, everything worked perfectly. Your view on this helped me to solve this issue. Appreciate your input — it definitely helped me get on the right track!",
      "score" : 0,
      "owner" : {
        "account_id" : 24098424,
        "reputation" : 13,
        "user_id" : 18070589,
        "user_type" : "registered",
        "profile_image" : "https://graph.facebook.com/489421932700465/picture?type=large",
        "display_name" : "Vijay Mohan Rangaraju",
        "link" : "https://stackoverflow.com/users/18070589/vijay-mohan-rangaraju"
      },
      "creation_date" : 1743944050,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}