{
  "question" : {
    "question_id" : 79789569,
    "title" : "Gradle Configuration Cache in Spring Boot bootBuildImage with multiple Images",
    "body" : "<p>I have a modulith that produces several applications in one multimodule Gradle Build (Gradle 9.1)</p>\n<p>These applications are all spring boot apps and they are deployed as docker images using the bootBuildImage task from the gradle spring boot plugin.</p>\n<p>We're using continuous delivery, so every build should produce docker images for all applications with the version of the image being just the build number (which is produced by the pipeline and is unique for every pipeline run)</p>\n<p>My grade configuration looks like this:</p>\n<pre><code>\ntasks.named('bootBuildImage') {\n    \n    imageName = &quot;${System.getenv('BUILD_DOCKER_REGISTRY')}/${project.name}:${System.getenv('BUILD_DOCKER_TAG')}&quot;\n        \n    builder = &quot;paketobuildpacks/builder-jammy-java-tiny&quot;\n    buildpacks = [ /* ... */ ]\n\n    environment.putAll([ /* ... */ ])\n}\n</code></pre>\n<p>This all works fine, but it is not compatible with configuration cache. Gradle detects the env BUILD_DOCKER_TAG to change for every build and then invalidates configuration cache.</p>\n<p>This is painful for my team, as the configuration time in our project is comparatively large and the build logic rarely changes.</p>\n<p>Therefore, my question is: Is there a way to shift configuration of the image name from configuration time to build time, so that configuration cache stays intact? (I've tried providers, but what I've tried didn't do the trick, plus I could not really understand the documentation when describing the behaviour in regards to configuration cache)</p>\n<p>Things that will not work:</p>\n<ul>\n<li>Passing the image name as a build parameter: the build will produce multiple images that differ in name but have to have the same tag.</li>\n<li>optimizing or reviewing the project structure: The build is highly optimized, pretty much all tricks that can be pulled are pulled.</li>\n<li>any things that will take <em>longer</em> (e.g. multiple gradle builds instead of one - as the one gradle build is highly concurrent)</li>\n</ul>\n",
    "tags" : [ "java", "spring-boot", "gradle", "continuous-delivery", "spring-boot-gradle-plugin" ],
    "owner" : {
      "account_id" : 792027,
      "reputation" : 2875,
      "user_id" : 869368,
      "user_type" : "registered",
      "profile_image" : "https://www.gravatar.com/avatar/2fbecbc4c9b1c79fd9a903b48cac5dba?s=256&d=identicon&r=PG",
      "display_name" : "Matthias",
      "link" : "https://stackoverflow.com/users/869368/matthias"
    },
    "is_answered" : false,
    "view_count" : 93,
    "answer_count" : 1,
    "score" : 2,
    "last_activity_date" : 1760615383,
    "creation_date" : 1760381550,
    "link" : "https://stackoverflow.com/questions/79789569/gradle-configuration-cache-in-spring-boot-bootbuildimage-with-multiple-images",
    "content_license" : "CC BY-SA 4.0"
  },
  "answers" : [ {
    "answer_id" : 79792104,
    "question_id" : 79789569,
    "body" : "<p>Yes, it is possible to defer reading environment variables to execution time so they do not invalidate the configuration cache.</p>\n<p>The problem is the use of <code>System.getenv()</code> as this reads environment variables directly during configuration, and marks it as an input to the configuration. If a build input changes, the configuration cache entry becomes invalid and a new configuration phase needs to run.</p>\n<p>The <code>imageName</code> field in the <code>bootBuildImage</code> task is a type of <em>provider</em> that allows for lazy reads. There are also standard providers for accessing system and environment properties, and we can connect these togther. It could look something like this (Groovy DSL):</p>\n<pre><code>import org.springframework.boot.gradle.tasks.bundling.BootBuildImage\n\ntasks.named('bootBuildImage', BootBuildImage) {\n    String projectName = project.name // (1)\n    Provider&lt;String&gt; registryProvider = providers.environmentVariable('BUILD_DOCKER_REGISTRY')\n    Provider&lt;String&gt; tagProvider = providers.environmentVariable('BUILD_DOCKER_TAG').orElse('latest')\n\n    imageName = registryProvider.flatMap { registry -&gt;\n        tagProvider.map { tag -&gt;\n            &quot;$registry/$projectName:$tag&quot;.toString()\n        }\n    }\n\n    // ...\n}\n</code></pre>\n<p>(1): We cannot access the <code>project</code> object at execution time when the configuration cache is active, so this is why this value is extracted outside the lazy provider chain at configuration time.</p>\n<p>You could also try experimenting with <a href=\"https://docs.gradle.org/current/userguide/configuration_cache_enabling.html#config_cache:usage:parallel\" rel=\"nofollow noreferrer\">parallel configuration caching</a> or <a href=\"https://docs.gradle.org/current/userguide/configuration_cache_enabling.html#config_cache:usage:read_only\" rel=\"nofollow noreferrer\">read-only caches</a> for certain CI builds to see if that gives any performance improvements for this project.</p>\n",
    "score" : 0,
    "is_accepted" : false,
    "owner" : {
      "account_id" : 1884162,
      "reputation" : 7648,
      "user_id" : 1703730,
      "user_type" : "registered",
      "profile_image" : "https://i.sstatic.net/s4so1.jpg?s=256",
      "display_name" : "Bj&#248;rn Vester",
      "link" : "https://stackoverflow.com/users/1703730/bj%c3%b8rn-vester"
    },
    "creation_date" : 1760615383,
    "last_activity_date" : 1760615383,
    "content_license" : "CC BY-SA 4.0"
  } ],
  "question_comments" : [ ],
  "answer_comments" : {
    "79792104" : [ {
      "comment_id" : 140806647,
      "post_id" : 79792104,
      "body" : "@Matthias For me, when I run it a second time with a different environment variable for either the tag or the registry, it produces a new image with a name reflecting the new values of the environment variables. It also says &quot;reusing configuration cache&quot;. Maybe it is an issue with an older version of the Spring Boot plugin? I tested it with Gradle 9.1 and Spring Boot 3.5.6 on a minimal project made by Spring Initializr.",
      "score" : 0,
      "owner" : {
        "account_id" : 1884162,
        "reputation" : 7648,
        "user_id" : 1703730,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/s4so1.jpg?s=256",
        "display_name" : "Bj&#248;rn Vester",
        "link" : "https://stackoverflow.com/users/1703730/bj%c3%b8rn-vester"
      },
      "creation_date" : 1760973739,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140803934,
      "post_id" : 79792104,
      "body" : "Hey Bj&#246;rn, I tried exactly that. And it works. But only once. When you Run the build again with different environment variables however you will notice that the image name is cached (and therefore the same in every build, and not reflecting the actual build number...)",
      "score" : 0,
      "owner" : {
        "account_id" : 792027,
        "reputation" : 2875,
        "user_id" : 869368,
        "user_type" : "registered",
        "profile_image" : "https://www.gravatar.com/avatar/2fbecbc4c9b1c79fd9a903b48cac5dba?s=256&d=identicon&r=PG",
        "display_name" : "Matthias",
        "link" : "https://stackoverflow.com/users/869368/matthias"
      },
      "creation_date" : 1760807051,
      "content_license" : "CC BY-SA 4.0"
    }, {
      "comment_id" : 140799472,
      "post_id" : 79792104,
      "body" : "I just noticed now that you wrote that you already tried providers. The above worked for me so you may want to try to get a simple example working and then gradually expanding on it until the cache breaks to see what caused it.",
      "score" : 0,
      "owner" : {
        "account_id" : 1884162,
        "reputation" : 7648,
        "user_id" : 1703730,
        "user_type" : "registered",
        "profile_image" : "https://i.sstatic.net/s4so1.jpg?s=256",
        "display_name" : "Bj&#248;rn Vester",
        "link" : "https://stackoverflow.com/users/1703730/bj%c3%b8rn-vester"
      },
      "creation_date" : 1760616022,
      "content_license" : "CC BY-SA 4.0"
    } ]
  }
}