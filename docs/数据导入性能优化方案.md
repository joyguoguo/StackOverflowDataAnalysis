# 数据导入性能优化方案

## 当前问题分析

当前导入速度慢的主要原因：

1. **单个事务开销大**：每个 thread 一个事务，事务开销累积
2. **频繁的数据库查询**：每个用户、标签都需要查询数据库
3. **单个保存操作**：每个实体都单独调用 `save()`，没有批量操作
4. **重复查询**：相同用户/标签被重复查询

## 优化方案

### 方案 1：批量保存（推荐，已实现）

**实现文件**：`DataImportServiceOptimized.java`

**优化策略**：
1. **批量事务**：每批处理 50 个 threads（可配置），减少事务开销
2. **预加载缓存**：启动时预加载所有用户和标签到内存，避免重复查询
3. **批量保存**：使用 `saveAll()` 代替单个 `save()`
4. **内存映射**：使用 HashMap 缓存用户和标签，O(1) 查找

**预期性能提升**：
- 减少数据库查询：从 O(n*m) 降到 O(1)（n=threads, m=平均用户/标签数）
- 减少事务开销：从 n 个事务降到 n/50 个事务
- 批量插入：PostgreSQL 批量插入比单个插入快 10-50 倍

**使用方法**：
```java
// 在 DataImporterApplication 中替换服务
@Bean
public CommandLineRunner importRunner(DataImportServiceOptimized importService) {
    // ... 使用优化版服务
}
```

### 方案 2：JPA 批量插入配置

在 `application.properties` 中添加：

```properties
# JPA 批量插入优化
spring.jpa.properties.hibernate.jdbc.batch_size=50
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
spring.jpa.properties.hibernate.jdbc.batch_versioned_data=true
```

**说明**：
- `batch_size=50`：每批处理 50 条记录
- `order_inserts=true`：按插入顺序排序，提高批量效率
- `order_updates=true`：按更新顺序排序

### 方案 3：禁用不必要的级联和验证

在实体类中：
- 对于批量导入，可以临时禁用某些验证
- 使用 `@DynamicInsert` 和 `@DynamicUpdate`（Hibernate）

### 方案 4：使用原生 SQL 批量插入（最高性能）

如果数据量非常大（>10万条），可以考虑使用原生 SQL：

```java
@Modifying
@Query(value = "INSERT INTO users (account_id, user_id, display_name, ...) VALUES " +
       "(?1, ?2, ?3, ...) ON CONFLICT (account_id) DO NOTHING", 
       nativeQuery = true)
void batchInsertUsers(List<Object[]> users);
```

**优点**：性能最高
**缺点**：代码复杂，需要手动处理 SQL

### 方案 5：并行处理（多线程）

对于非常大的数据集，可以使用并行流：

```java
jsonFiles.parallelStream()
    .forEach(file -> {
        // 处理文件
    });
```

**注意**：需要确保线程安全，每个线程使用独立的事务

## 性能对比预估

| 方案 | 1000 threads | 10000 threads | 备注 |
|------|-------------|---------------|------|
| 当前方案 | ~5-10分钟 | ~50-100分钟 | 单个事务+单个保存 |
| 方案1（批量保存） | ~30秒-1分钟 | ~5-10分钟 | 推荐 |
| 方案1+方案2 | ~20-30秒 | ~3-5分钟 | 最佳组合 |
| 方案4（原生SQL） | ~10-20秒 | ~1-2分钟 | 最复杂 |

## 实施建议

1. **立即实施**：方案 1（批量保存）+ 方案 2（JPA 配置）
2. **如果还不够快**：考虑方案 4（原生 SQL）
3. **监控指标**：
   - 导入时间
   - 数据库连接数
   - 内存使用
   - CPU 使用率

## 注意事项

1. **内存使用**：预加载缓存会增加内存使用，确保有足够内存
2. **事务大小**：批次大小（BATCH_SIZE）需要根据数据量调整
3. **错误处理**：批量操作中一个失败会影响整批，需要适当的错误处理
4. **数据一致性**：确保批量操作不会导致数据不一致

## 测试建议

1. 先用小数据集（100 threads）测试
2. 逐步增加数据量
3. 监控性能指标
4. 对比优化前后的性能


