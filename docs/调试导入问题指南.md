# Comments表数据被覆盖问题 - 调试指南

## 问题描述

在导入数据时，如果下一个thread.json没有comments字段，会覆盖之前已导入的comments数据。

## 根本原因

1. **JPA的orphanRemoval机制**：`QuestionEntity`中的`comments`字段设置了`orphanRemoval = true`
2. **创建新实体而非更新**：每次导入都创建新的`QuestionEntity`对象，而不是检查是否已存在
3. **懒加载问题**：如果question已存在但comments未加载，JPA会认为要清空comments列表

## 已实施的修复

### 1. 检查并加载已有Question
```java
// 使用JOIN FETCH确保加载所有关联数据
Optional<QuestionEntity> existingQuestionOpt = 
    questionRepository.findByQuestionIdWithAssociations(questionId);
```

### 2. 只导入不存在的Comments
```java
// importComment方法会检查comment是否已存在
Optional<CommentEntity> existing = commentRepository.findByCommentId(comment.id());
if (existing.isPresent()) {
    return; // 已存在，跳过
}
```

### 3. 只导入不存在的Answers
```java
// 检查answer是否已存在
Optional<AnswerEntity> existingAnswerOpt = answerRepository.findByAnswerId(answer.id());
if (existingAnswerOpt.isPresent()) {
    // 使用已有answer，不创建新的
}
```

## 调试步骤

### 1. 启用详细日志

在`application.properties`中添加：
```properties
# 启用DEBUG级别日志
logging.level.cs209a.finalproject_demo.service.DataImportService=DEBUG
logging.level.cs209a.finalproject_demo.service.DataImportRunner=INFO

# 启用SQL日志（可选）
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
```

### 2. 检查日志输出

导入时应该看到：
```
DEBUG - Importing thread: question_id=79843504, title=...
INFO  - Updating existing question: question_id=79843504 (preserving 1 comments, 0 answers)
DEBUG - Importing 1 comments for question 79843504
TRACE - Comment 140897597 already exists, skipping
```

### 3. 验证数据库状态

在导入前后检查comments表：
```sql
-- 导入前
SELECT COUNT(*) FROM comments WHERE question_id = 79843504;

-- 导入后（应该保持不变或增加，不应该减少）
SELECT COUNT(*) FROM comments WHERE question_id = 79843504;
```

### 4. 断点调试位置

在以下位置设置断点：

1. **DataImportService.importThread()** - 第163行
   - 检查`isNewQuestion`的值
   - 检查`questionEntity.getComments().size()`

2. **DataImportService.importComment()** - 第327行
   - 检查`existing.isPresent()`
   - 确认是否跳过已存在的comment

3. **QuestionRepository.findByQuestionIdWithAssociations()**
   - 确认查询是否正确加载了关联数据

## 常见问题排查

### 问题1：Comments仍然被清空

**可能原因**：
- JOIN FETCH查询未正确执行
- 事务隔离级别问题

**解决方法**：
```java
// 在保存前强制刷新实体
questionRepository.flush();
questionEntity = questionRepository.findById(questionEntity.getQuestionId()).orElse(questionEntity);
```

### 问题2：导入速度变慢

**原因**：JOIN FETCH会加载所有关联数据

**解决方法**：
- 只在更新已有question时使用JOIN FETCH
- 新建question时使用普通查询

### 问题3：重复导入相同数据

**检查点**：
- `importComment`方法是否正确检查已存在
- `importComment`方法是否正确跳过已存在的comment

## 测试用例

### 测试场景1：导入有comments的thread
1. 导入`thread_06.json`（有1个question comment）
2. 检查comments表应该有1条记录
3. 再次导入`thread_06.json`
4. 检查comments表应该仍然只有1条记录（不重复）

### 测试场景2：导入无comments的thread
1. 导入`thread_06.json`（有comments）
2. 检查comments表应该有1条记录
3. 导入`thread_05.json`（无comments）
4. 检查comments表应该仍然有1条记录（不被清空）

### 测试场景3：混合导入
1. 导入多个有comments的thread
2. 导入一个无comments的thread
3. 检查所有comments都应该保留

## 监控指标

在导入过程中监控：
- 每个question的comments数量变化
- 导入前后的comments总数
- 跳过（已存在）的comments数量

## 如果问题仍然存在

1. 检查数据库事务隔离级别
2. 检查是否有其他代码在清空comments
3. 考虑禁用`orphanRemoval`，手动管理删除
4. 使用数据库触发器或约束保护数据

